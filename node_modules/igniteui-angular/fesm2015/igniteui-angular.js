import { style, animate, animation, keyframes, AnimationBuilder, useAnimation, trigger, transition } from '@angular/animations';
import { Injectable, Directive, Input, HostListener, NgModule, ɵɵdefineInjectable, ɵɵinject, PLATFORM_ID, Inject, Pipe, EventEmitter, Output, isDevMode, ElementRef, ComponentFactoryResolver, ApplicationRef, INJECTOR, NgZone, Injector, ChangeDetectorRef, Optional, HostBinding, InjectionToken, Component, ViewContainerRef, ViewChild, TemplateRef, IterableDiffers, ContentChild, ContentChildren, forwardRef, Self, Renderer2, LOCALE_ID, QueryList, ViewChildren, SecurityContext, Host, NgModuleRef, inject, SimpleChange, ChangeDetectionStrategy, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { NgModel, FormControlName, NG_VALUE_ACCESSOR, NG_VALIDATORS, CheckboxRequiredValidator, FormsModule, NgControl, ReactiveFormsModule } from '@angular/forms';
import { isPlatformBrowser, DOCUMENT, CommonModule, formatDate, FormatWidth, getLocaleDateFormat, DecimalPipe, DatePipe } from '@angular/common';
import { Observable, Subject, fromEvent, interval, animationFrameScheduler, merge as merge$1, Subscription, timer, pipe } from 'rxjs';
import { takeUntil, filter, throttleTime, first as first$1, take, throttle, debounce, tap, switchMap, skipLast, map, debounceTime } from 'rxjs/operators';
import ResizeObserver from 'resize-observer-polyfill';
import merge from 'lodash.merge';
import { __awaiter, __decorate } from 'tslib';
import * as JSZip from 'jszip';
import { DomSanitizer, HammerGestureConfig, HAMMER_GESTURE_CONFIG, ɵgetDOM } from '@angular/platform-browser';
import { addRow, addChild, pinLeft, unpinLeft, jumpDown, jumpUp, caseSensitive, editor } from '@igniteui/material-icons-extended';
import 'igniteui-trial-watermark';
import { v4 } from 'uuid';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/animations';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@angular/forms';
import * as ɵngcc4 from '@angular/platform-browser';

const _c0 = [[["igx-drop-down-item"]]];
const _c1 = ["igx-drop-down-item"];
const _c2 = ["*"];
const _c3 = ["display_container"];
function DisplayContainerComponent_ng_template_0_Template(rf, ctx) { }
const _c4 = ["horizontal_container"];
const _c5 = ["container"];
const _c6 = ["scrollContainer"];
function IgxDropDownComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function IgxInputGroupComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_div_0_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r16 = ɵngcc0.ɵɵreference(19);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r16);
} }
function IgxInputGroupComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 13);
} }
function IgxInputGroupComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1);
} }
function IgxInputGroupComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2);
} }
function IgxInputGroupComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3);
} }
function IgxInputGroupComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 4);
} }
function IgxInputGroupComponent_ng_template_12_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_12_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_12_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_12_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_12_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementStart(2, "div", 15);
    ɵngcc0.ɵɵtemplate(3, IgxInputGroupComponent_ng_template_12_ng_container_3_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵtemplate(4, IgxInputGroupComponent_ng_template_12_ng_container_4_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxInputGroupComponent_ng_template_12_ng_container_5_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r6 = ɵngcc0.ɵɵreference(9);
    const _r2 = ɵngcc0.ɵɵreference(5);
    const _r4 = ɵngcc0.ɵɵreference(7);
    const _r8 = ɵngcc0.ɵɵreference(11);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r8);
} }
function IgxInputGroupComponent_ng_template_14_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_14_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_14_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_14_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxInputGroupComponent_ng_template_14_ng_container_0_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementStart(1, "div", 14);
    ɵngcc0.ɵɵtemplate(2, IgxInputGroupComponent_ng_template_14_ng_container_2_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementStart(3, "div", 15);
    ɵngcc0.ɵɵtemplate(4, IgxInputGroupComponent_ng_template_14_ng_container_4_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxInputGroupComponent_ng_template_14_ng_container_5_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(5);
    const _r6 = ɵngcc0.ɵɵreference(9);
    const _r4 = ɵngcc0.ɵɵreference(7);
    const _r8 = ɵngcc0.ɵɵreference(11);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r8);
} }
function IgxInputGroupComponent_ng_template_16_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_16_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_16_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_16_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxInputGroupComponent_ng_template_16_ng_container_0_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementStart(1, "div", 14);
    ɵngcc0.ɵɵtemplate(2, IgxInputGroupComponent_ng_template_16_ng_container_2_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵtemplate(3, IgxInputGroupComponent_ng_template_16_ng_container_3_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵtemplate(4, IgxInputGroupComponent_ng_template_16_ng_container_4_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(5);
    const _r6 = ɵngcc0.ɵɵreference(9);
    const _r4 = ɵngcc0.ɵɵreference(7);
    const _r8 = ɵngcc0.ɵɵreference(11);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r8);
} }
function IgxInputGroupComponent_ng_template_18_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_18_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_18_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r14 = ɵngcc0.ɵɵreference(17);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r14);
} }
function IgxInputGroupComponent_ng_template_18_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_18_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_18_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r12 = ɵngcc0.ɵɵreference(15);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r12);
} }
function IgxInputGroupComponent_ng_template_18_ng_container_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_18_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_18_ng_container_3_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r12 = ɵngcc0.ɵɵreference(15);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r12);
} }
function IgxInputGroupComponent_ng_template_18_ng_container_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_18_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_18_ng_container_4_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r10 = ɵngcc0.ɵɵreference(13);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r10);
} }
function IgxInputGroupComponent_ng_template_18_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0, 16);
    ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_18_ng_container_1_Template, 2, 1, "ng-container", 17);
    ɵngcc0.ɵɵtemplate(2, IgxInputGroupComponent_ng_template_18_ng_container_2_Template, 2, 1, "ng-container", 17);
    ɵngcc0.ɵɵtemplate(3, IgxInputGroupComponent_ng_template_18_ng_container_3_Template, 2, 1, "ng-container", 17);
    ɵngcc0.ɵɵtemplate(4, IgxInputGroupComponent_ng_template_18_ng_container_4_Template, 2, 1, "ng-container", 18);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r17.theme);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "bootstrap");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "fluent");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "indigo-design");
} }
const _c7 = [[["igx-hint"], ["", "igxHint", ""]], [["", "igxLabel", ""]], [["", "igxInput", ""]], [["igx-prefix"], ["", "igxPrefix", ""]], [["igx-suffix"], ["", "igxSuffix", ""]]];
const _c8 = ["igx-hint, [igxHint]", "[igxLabel]", "[igxInput]", "igx-prefix, [igxPrefix]", "igx-suffix, [igxSuffix]"];
const _c9 = ["radio"];
const _c10 = ["nativeLabel"];
const _c11 = ["placeholderLabel"];
function IgxGridActionButtonComponent_ng_container_0_ng_container_1_igx_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("fontSet", ctx_r3.iconSet)("name", ctx_r3.iconName);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.iconName);
} }
function IgxGridActionButtonComponent_ng_container_0_ng_container_1_igx_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r4.iconName);
} }
function IgxGridActionButtonComponent_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 1);
    ɵngcc0.ɵɵlistener("click", function IgxGridActionButtonComponent_ng_container_0_ng_container_1_Template_button_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(2); return ctx_r5.handleClick($event); })("mousedown", function IgxGridActionButtonComponent_ng_container_0_ng_container_1_Template_button_mousedown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r7 = ɵngcc0.ɵɵnextContext(2); return ctx_r7.preventEvent($event); });
    ɵngcc0.ɵɵtemplate(2, IgxGridActionButtonComponent_ng_container_0_ng_container_1_igx_icon_2_Template, 2, 3, "igx-icon", 2);
    ɵngcc0.ɵɵtemplate(3, IgxGridActionButtonComponent_ng_container_0_ng_container_1_igx_icon_3_Template, 2, 1, "igx-icon", 0);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.iconSet);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.iconSet);
} }
function IgxGridActionButtonComponent_ng_container_0_ng_container_2_igx_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("fontSet", ctx_r9.iconSet)("name", ctx_r9.iconName);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r9.iconName);
} }
function IgxGridActionButtonComponent_ng_container_0_ng_container_2_igx_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r10.iconName);
} }
function IgxGridActionButtonComponent_ng_container_0_ng_container_2_label_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r11.labelText);
} }
function IgxGridActionButtonComponent_ng_container_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 4, 5);
    ɵngcc0.ɵɵtemplate(3, IgxGridActionButtonComponent_ng_container_0_ng_container_2_igx_icon_3_Template, 2, 3, "igx-icon", 2);
    ɵngcc0.ɵɵtemplate(4, IgxGridActionButtonComponent_ng_container_0_ng_container_2_igx_icon_4_Template, 2, 1, "igx-icon", 0);
    ɵngcc0.ɵɵtemplate(5, IgxGridActionButtonComponent_ng_container_0_ng_container_2_label_5_Template, 2, 1, "label", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("className", ctx_r2.containerClass);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.iconSet);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.iconSet);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.asMenuItem);
} }
function IgxGridActionButtonComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridActionButtonComponent_ng_container_0_ng_container_1_Template, 4, 2, "ng-container", 0);
    ɵngcc0.ɵɵtemplate(2, IgxGridActionButtonComponent_ng_container_0_ng_container_2_Template, 6, 4, "ng-container", 0);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.asMenuItem);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.asMenuItem);
} }
const _c12 = ["checkbox"];
const _c13 = ["label"];
const _c14 = ["igxDirRef"];
const _c15 = ["cell"];
function IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-grid-action-button", 5);
    ɵngcc0.ɵɵlistener("onActionClick", function IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_1_Template_igx_grid_action_button_onActionClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(2); return ctx_r5.startEdit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("asMenuItem", ctx_r1.asMenuItems)("labelText", ctx_r1.grid.resourceStrings.igx_grid_actions_edit_label);
} }
function IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-grid-action-button", 6);
    ɵngcc0.ɵɵlistener("onActionClick", function IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_2_Template_igx_grid_action_button_onActionClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(2); return ctx_r7.addRowHandler($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("asMenuItem", ctx_r2.asMenuItems)("labelText", ctx_r2.grid.resourceStrings.igx_grid_actions_add_label);
} }
function IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-grid-action-button", 7);
    ɵngcc0.ɵɵlistener("onActionClick", function IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_3_Template_igx_grid_action_button_onActionClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(2); return ctx_r9.addRowHandler($event, true); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("asMenuItem", ctx_r3.asMenuItems)("labelText", ctx_r3.grid.resourceStrings.igx_grid_actions_add_child_label);
} }
function IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-grid-action-button", 8);
    ɵngcc0.ɵɵlistener("onActionClick", function IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_4_Template_igx_grid_action_button_onActionClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(2); return ctx_r11.deleteRow($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("asMenuItem", ctx_r4.asMenuItems)("labelText", ctx_r4.grid.resourceStrings.igx_grid_actions_delete_label);
} }
function IgxGridEditingActionsComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_1_Template, 1, 2, "igx-grid-action-button", 1);
    ɵngcc0.ɵɵtemplate(2, IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_2_Template, 1, 2, "igx-grid-action-button", 2);
    ɵngcc0.ɵɵtemplate(3, IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_3_Template, 1, 2, "igx-grid-action-button", 3);
    ɵngcc0.ɵɵtemplate(4, IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_4_Template, 1, 2, "igx-grid-action-button", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.disabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.addRow && ctx_r0.isRootRow);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.addChild && ctx_r0.hasChildren);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.disabled);
} }
function IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-grid-action-button", 5);
    ɵngcc0.ɵɵlistener("onActionClick", function IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_1_Template_igx_grid_action_button_onActionClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(2); return ctx_r5.scrollToRow($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("asMenuItem", ctx_r1.asMenuItems)("labelText", ctx_r1.grid.resourceStrings.igx_grid_actions_jumpDown_label);
} }
function IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-grid-action-button", 6);
    ɵngcc0.ɵɵlistener("onActionClick", function IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_2_Template_igx_grid_action_button_onActionClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(2); return ctx_r7.scrollToRow($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("asMenuItem", ctx_r2.asMenuItems)("labelText", ctx_r2.grid.resourceStrings.igx_grid_actions_jumpUp_label);
} }
function IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-grid-action-button", 7);
    ɵngcc0.ɵɵlistener("onActionClick", function IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_3_Template_igx_grid_action_button_onActionClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(2); return ctx_r9.pin($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("asMenuItem", ctx_r3.asMenuItems)("labelText", ctx_r3.grid.resourceStrings.igx_grid_actions_pin_label);
} }
function IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-grid-action-button", 8);
    ɵngcc0.ɵɵlistener("onActionClick", function IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_4_Template_igx_grid_action_button_onActionClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(2); return ctx_r11.unpin($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("asMenuItem", ctx_r4.asMenuItems)("labelText", ctx_r4.grid.resourceStrings.igx_grid_actions_unpin_label);
} }
function IgxGridPinningActionsComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_1_Template, 1, 2, "igx-grid-action-button", 1);
    ɵngcc0.ɵɵtemplate(2, IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_2_Template, 1, 2, "igx-grid-action-button", 2);
    ɵngcc0.ɵɵtemplate(3, IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_3_Template, 1, 2, "igx-grid-action-button", 3);
    ɵngcc0.ɵɵtemplate(4, IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_4_Template, 1, 2, "igx-grid-action-button", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.inPinnedArea && ctx_r0.pinnedTop);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.inPinnedArea && !ctx_r0.pinnedTop);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.pinned);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.pinned);
} }
const _c16 = ["dropdown"];
function IgxActionStripComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 5);
    ɵngcc0.ɵɵlistener("click", function IgxActionStripComponent_ng_container_2_Template_button_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); return $event.stopPropagation(); });
    ɵngcc0.ɵɵelementStart(2, "igx-icon");
    ɵngcc0.ɵɵtext(3, "more_vert");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    const _r1 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxToggleAction", _r1)("overlaySettings", ctx_r0.menuOverlaySettings)("igxDropDownItemNavigation", _r1);
} }
function IgxActionStripComponent_igx_drop_down_item_5_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c17 = function (a0) { return { $implicit: a0 }; };
function IgxActionStripComponent_igx_drop_down_item_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-drop-down-item", 6);
    ɵngcc0.ɵɵelementStart(1, "div", 7);
    ɵngcc0.ɵɵtemplate(2, IgxActionStripComponent_igx_drop_down_item_5_ng_container_2_Template, 1, 0, "ng-container", 8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r5 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", item_r5.templateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, item_r5));
} }
const _c18 = ["noLigature"];
const _c19 = ["explicitLigature"];
const _c20 = ["svgImage"];
function IgxIconComponent_ng_template_0_Template(rf, ctx) { }
function IgxIconComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function IgxIconComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "svg");
    ɵngcc0.ɵɵelement(1, "use");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("href", ctx_r5.getSvgKey);
} }
function IgxIconComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c21 = ["image"];
const _c22 = ["defaultTemplate"];
const _c23 = ["imageTemplate"];
const _c24 = ["initialsTemplate"];
const _c25 = ["iconTemplate"];
function IgxAvatarComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function IgxAvatarComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 5, 6);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("background-image", ctx_r3.getSrcUrl());
} }
function IgxAvatarComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r5.initials.substring(0, 2));
} }
function IgxAvatarComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r7.icon);
} }
function IgxAvatarComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxBadgeComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.value);
} }
function IgxBadgeComponent_igx_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.icon);
} }
function IgxExpansionPanelHeaderComponent_ng_content_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "iconTemplate"]);
} }
function IgxExpansionPanelHeaderComponent_igx_icon_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.panel.collapsed ? "expand_more" : "expand_less", " ");
} }
const _c26 = [[["igx-expansion-panel-title"]], [["igx-expansion-panel-description"]], "*", [["igx-expansion-panel-icon"]]];
const _c27 = ["igx-expansion-panel-title", "igx-expansion-panel-description", "*", "igx-expansion-panel-icon"];
function IgxExpansionPanelComponent_ng_content_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1, ["*ngIf", "!collapsed"]);
} }
const _c28 = [[["igx-expansion-panel-header"]], [["igx-expansion-panel-body"]]];
const _c29 = ["igx-expansion-panel-header", "igx-expansion-panel-body"];
const _c30 = ["expansionPanel"];
function IgxBannerComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxBannerComponent_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 10);
    ɵngcc0.ɵɵlistener("click", function IgxBannerComponent_ng_container_10_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.close(); });
    ɵngcc0.ɵɵtext(2, " Dismiss ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} }
function IgxBannerComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1, 2);
    ɵngcc0.ɵɵelementContainerEnd();
} }
const _c31 = ["*", [["igx-icon"]], [["igx-banner-actions"]]];
const _c32 = ["*", "igx-icon", "igx-banner-actions"];
function IgxButtonGroupComponent_button_1_igx_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const button_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(button_r1.icon);
} }
function IgxButtonGroupComponent_button_1_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const button_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(button_r1.label);
} }
function IgxButtonGroupComponent_button_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtemplate(2, IgxButtonGroupComponent_button_1_igx_icon_2_Template, 2, 1, "igx-icon", 3);
    ɵngcc0.ɵɵtemplate(3, IgxButtonGroupComponent_button_1_span_3_Template, 2, 1, "span", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const button_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r0.displayDensity)("selected", button_r1.selected)("disabled", ctx_r0.disabled || button_r1.disabled)("igxButtonColor", button_r1.color)("igxButtonBackground", button_r1.bgcolor)("igxLabel", button_r1.label)("igxRipple", button_r1.ripple);
    ɵngcc0.ɵɵattribute("data-togglable", button_r1.togglable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("igx-button-group__item-content ", ctx_r0.itemContentCssClass, "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", button_r1.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", button_r1.label);
} }
const _c33 = ["yearsBtn"];
function IgxMonthsViewComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵlistener("onMonthSelection", function IgxMonthsViewComponent_div_2_Template_div_onMonthSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.selectMonth($event); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "titlecase");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const month_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxCalendarMonth", month_r1)("date", ctx_r0.date)("index", i_r2);
    ɵngcc0.ɵɵattribute("tabindex", ctx_r0.activeMonth === month_r1.getMonth() ? 0 : -1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind1(2, 5, ctx_r0.formattedMonth(month_r1)), " ");
} }
function IgxYearsViewComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵlistener("onYearSelection", function IgxYearsViewComponent_span_2_Template_span_onYearSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.selectYear($event); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const year_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxCalendarYear", year_r1)("date", ctx_r0.date);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.formattedYear(year_r1), " ");
} }
function IgxDaysViewComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2, "Wk");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function IgxDaysViewComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "titlecase");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const dayName_r3 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind1(2, 1, dayName_r3), " ");
} }
function IgxDaysViewComponent_div_3_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵelementStart(1, "span", 9);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const week_r4 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r7.getWeekNumber(week_r4[0].date), " ");
} }
function IgxDaysViewComponent_div_3_igx_day_item_2_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-day-item", 10);
    ɵngcc0.ɵɵlistener("focus", function IgxDaysViewComponent_div_3_igx_day_item_2_Template_igx_day_item_focus_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const day_r10 = ctx.$implicit; const ctx_r11 = ɵngcc0.ɵɵnextContext(2); return ctx_r11.activeDate = day_r10.date.toLocaleDateString(); })("onDateSelection", function IgxDaysViewComponent_div_3_igx_day_item_2_Template_igx_day_item_onDateSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r13 = ɵngcc0.ɵɵnextContext(2); return ctx_r13.selectDay($event); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const day_r10 = ctx.$implicit;
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("date", day_r10)("selection", ctx_r8.selection)("selected", ctx_r8.isSelected(day_r10))("isLastInRange", ctx_r8.isLastInRange(day_r10))("isFirstInRange", ctx_r8.isFirstInRange(day_r10))("isWithinRange", ctx_r8.isWithinRange(day_r10.date, true))("disabledDates", ctx_r8.disabledDates)("specialDates", ctx_r8.specialDates)("outOfRangeDates", ctx_r8.outOfRangeDates)("hideOutsideDays", ctx_r8.hideOutsideDays);
    ɵngcc0.ɵɵattribute("tabindex", ctx_r8.tabIndex(day_r10));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r8.formattedDate(day_r10.date), " ");
} }
function IgxDaysViewComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 0);
    ɵngcc0.ɵɵtemplate(1, IgxDaysViewComponent_div_3_div_1_Template, 3, 1, "div", 6);
    ɵngcc0.ɵɵtemplate(2, IgxDaysViewComponent_div_3_igx_day_item_2_Template, 2, 12, "igx-day-item", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const week_r4 = ctx.$implicit;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.showWeekNumbers);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", week_r4)("ngForTrackBy", ctx_r2.dateTracker);
} }
const _c34 = ["months"];
const _c35 = ["decade"];
const _c36 = ["days"];
const _c37 = ["prevMonthBtn"];
const _c38 = ["nextMonthBtn"];
const _c39 = ["monthsBtn"];
function IgxCalendarComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ctx_r1.getFormattedDate().weekday, ",\u00A0");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.getFormattedDate().monthday);
} }
function IgxCalendarComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r14 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 6, 7);
    ɵngcc0.ɵɵlistener("keydown", function IgxCalendarComponent_ng_template_2_Template_span_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r14); const obj_r10 = ctx.$implicit; const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onActiveViewYearKB(ctx_r13.getViewDate(obj_r10.index), $event, obj_r10.index); })("click", function IgxCalendarComponent_ng_template_2_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r14); const obj_r10 = ctx.$implicit; const ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.onActiveViewYear(ctx_r15.getViewDate(obj_r10.index), obj_r10.index, $event); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "span", 6, 8);
    ɵngcc0.ɵɵlistener("keydown", function IgxCalendarComponent_ng_template_2_Template_span_keydown_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r14); const obj_r10 = ctx.$implicit; const ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.onActiveViewDecadeKB($event, ctx_r16.getViewDate(obj_r10.index), obj_r10.index); })("click", function IgxCalendarComponent_ng_template_2_Template_span_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r14); const obj_r10 = ctx.$implicit; const ctx_r17 = ɵngcc0.ɵɵnextContext(); return ctx_r17.onActiveViewDecade(ctx_r17.getViewDate(obj_r10.index), obj_r10.index); });
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const obj_r10 = ctx.$implicit;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.formattedMonth(ctx_r3.getViewDate(obj_r10.index)), " ");
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.formattedYear(ctx_r3.getViewDate(obj_r10.index)), " ");
} }
function IgxCalendarComponent_div_4_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCalendarComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵelementStart(1, "h5", 10);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "h2", 11);
    ɵngcc0.ɵɵtemplate(4, IgxCalendarComponent_div_4_ng_container_4_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r4.formattedYear(ctx_r4.headerDate));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.headerTemplate ? ctx_r4.headerTemplate : _r0)("ngTemplateOutletContext", ctx_r4.headerContext);
} }
function IgxCalendarComponent_div_5_div_6_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCalendarComponent_div_5_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 23);
    ɵngcc0.ɵɵpipe(1, "IgxGetViewDate");
    ɵngcc0.ɵɵtemplate(2, IgxCalendarComponent_div_5_div_6_ng_container_2_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const i_r24 = ctx.index;
    const ctx_r20 = ɵngcc0.ɵɵnextContext(2);
    const _r2 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵstyleProp("width", 100 / ctx_r20.monthsViewNumber, "%");
    ɵngcc0.ɵɵattribute("data-month", ɵngcc0.ɵɵpipeBind3(1, 5, i_r24, ctx_r20.viewDate, false));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r20.subheaderTemplate ? ctx_r20.subheaderTemplate : _r2)("ngTemplateOutletContext", ctx_r20.getContext(i_r24));
} }
function IgxCalendarComponent_div_5_igx_days_view_13_Template(rf, ctx) { if (rf & 1) {
    const _r30 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-days-view", 24, 25);
    ɵngcc0.ɵɵlistener("activeDateChange", function IgxCalendarComponent_div_5_igx_days_view_13_Template_igx_days_view_activeDateChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r30); const ctx_r29 = ɵngcc0.ɵɵnextContext(2); return ctx_r29.activeDate = $event; })("onViewChanging", function IgxCalendarComponent_div_5_igx_days_view_13_Template_igx_days_view_onViewChanging_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r30); const ctx_r31 = ɵngcc0.ɵɵnextContext(2); return ctx_r31.viewChanging($event); })("onDateSelection", function IgxCalendarComponent_div_5_igx_days_view_13_Template_igx_days_view_onDateSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r30); const ctx_r32 = ɵngcc0.ɵɵnextContext(2); return ctx_r32.childClicked($event); })("monthsViewBlur", function IgxCalendarComponent_div_5_igx_days_view_13_Template_igx_days_view_monthsViewBlur_0_listener() { ɵngcc0.ɵɵrestoreView(_r30); const ctx_r33 = ɵngcc0.ɵɵnextContext(2); return ctx_r33.resetActiveDate(); });
    ɵngcc0.ɵɵpipe(2, "IgxGetViewDate");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const i_r27 = ctx.index;
    const ctx_r22 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("changeDaysView", true)("selection", ctx_r22.selection)("locale", ctx_r22.locale)("value", ctx_r22.value)("activeDate", ctx_r22.activeDate)("viewDate", ɵngcc0.ɵɵpipeBind2(2, 13, i_r27, ctx_r22.viewDate))("weekStart", ctx_r22.weekStart)("formatOptions", ctx_r22.formatOptions)("formatViews", ctx_r22.formatViews)("disabledDates", ctx_r22.disabledDates)("specialDates", ctx_r22.specialDates)("hideOutsideDays", ctx_r22.hideOutsideDays)("showWeekNumbers", ctx_r22.showWeekNumbers);
} }
const _c40 = function (a0) { return { "min-width.%": a0 }; };
function IgxCalendarComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    const _r35 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵlistener("@animateView.done", function IgxCalendarComponent_div_5_Template_div_animation_animateView_done_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r35); const ctx_r34 = ɵngcc0.ɵɵnextContext(); return ctx_r34.viewRendered($event); })("swiperight", function IgxCalendarComponent_div_5_Template_div_swiperight_0_listener() { ɵngcc0.ɵɵrestoreView(_r35); const ctx_r36 = ɵngcc0.ɵɵnextContext(); return ctx_r36.previousMonth(); })("swipeleft", function IgxCalendarComponent_div_5_Template_div_swipeleft_0_listener() { ɵngcc0.ɵɵrestoreView(_r35); const ctx_r37 = ɵngcc0.ɵɵnextContext(); return ctx_r37.nextMonth(); })("pointerdown", function IgxCalendarComponent_div_5_Template_div_pointerdown_0_listener() { ɵngcc0.ɵɵrestoreView(_r35); const ctx_r38 = ɵngcc0.ɵɵnextContext(); return ctx_r38.suppressBlur(); });
    ɵngcc0.ɵɵelementStart(1, "div", 14);
    ɵngcc0.ɵɵelementStart(2, "div", 15, 16);
    ɵngcc0.ɵɵelementStart(4, "igx-icon", 17);
    ɵngcc0.ɵɵtext(5, "keyboard_arrow_left");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, IgxCalendarComponent_div_5_div_6_Template, 3, 9, "div", 18);
    ɵngcc0.ɵɵpipe(7, "IgxMonthViewSlots");
    ɵngcc0.ɵɵelementStart(8, "div", 19, 20);
    ɵngcc0.ɵɵelementStart(10, "igx-icon", 17);
    ɵngcc0.ɵɵtext(11, "keyboard_arrow_right");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(12, "div", 21);
    ɵngcc0.ɵɵlistener("@animateChange.done", function IgxCalendarComponent_div_5_Template_div_animation_animateChange_done_12_listener($event) { ɵngcc0.ɵɵrestoreView(_r35); const ctx_r39 = ɵngcc0.ɵɵnextContext(); return ctx_r39.animationDone($event); });
    ɵngcc0.ɵɵtemplate(13, IgxCalendarComponent_div_5_igx_days_view_13_Template, 3, 16, "igx-days-view", 22);
    ɵngcc0.ɵɵpipe(14, "IgxMonthViewSlots");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animateView", ctx_r5.activeView);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("startScroll", ctx_r5.startPrevMonthScroll)("stopScroll", ctx_r5.stopMonthScroll)("ngStyle", ɵngcc0.ɵɵpureFunction1(14, _c40, 100 / (ctx_r5.monthsViewNumber * 7)));
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(7, 10, ctx_r5.monthsViewNumber));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("startScroll", ctx_r5.startNextMonthScroll)("stopScroll", ctx_r5.stopMonthScroll)("ngStyle", ɵngcc0.ɵɵpureFunction1(16, _c40, 100 / (ctx_r5.monthsViewNumber * 7)));
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("@animateChange", ctx_r5.animationAction);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(14, 12, ctx_r5.monthsViewNumber));
} }
function IgxCalendarComponent_igx_months_view_6_Template(rf, ctx) { if (rf & 1) {
    const _r42 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-months-view", 26, 27);
    ɵngcc0.ɵɵlistener("@animateView.done", function IgxCalendarComponent_igx_months_view_6_Template_igx_months_view_animation_animateView_done_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r42); const ctx_r41 = ɵngcc0.ɵɵnextContext(); return ctx_r41.viewRendered($event); })("onSelection", function IgxCalendarComponent_igx_months_view_6_Template_igx_months_view_onSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r42); const ctx_r43 = ɵngcc0.ɵɵnextContext(); return ctx_r43.changeMonth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animateView", ctx_r6.activeView)("date", ctx_r6.viewDate)("locale", ctx_r6.locale)("formatView", ctx_r6.formatViews.month)("monthFormat", ctx_r6.formatOptions.month);
} }
function IgxCalendarComponent_igx_years_view_7_Template(rf, ctx) { if (rf & 1) {
    const _r46 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-years-view", 28, 29);
    ɵngcc0.ɵɵlistener("@animateView.done", function IgxCalendarComponent_igx_years_view_7_Template_igx_years_view_animation_animateView_done_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r46); const ctx_r45 = ɵngcc0.ɵɵnextContext(); return ctx_r45.viewRendered($event); })("onSelection", function IgxCalendarComponent_igx_years_view_7_Template_igx_years_view_onSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r46); const ctx_r47 = ɵngcc0.ɵɵnextContext(); return ctx_r47.changeYear($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animateView", ctx_r7.activeView)("date", ctx_r7.viewDate)("locale", ctx_r7.locale)("formatView", ctx_r7.formatViews.year)("yearFormat", ctx_r7.formatOptions.year);
} }
const _c41 = function () { return { "min-width.%": 25, "left": 0 }; };
const _c42 = function () { return { "min-width.%": 25, "right": 0 }; };
function IgxMonthPickerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵlistener("@animateView.done", function IgxMonthPickerComponent_div_0_Template_div_animation_animateView_done_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.viewRendered($event); })("swiperight", function IgxMonthPickerComponent_div_0_Template_div_swiperight_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.previousYear(); })("swipeleft", function IgxMonthPickerComponent_div_0_Template_div_swipeleft_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.nextYear(); });
    ɵngcc0.ɵɵelementStart(1, "div", 3);
    ɵngcc0.ɵɵelementStart(2, "div", 4);
    ɵngcc0.ɵɵlistener("click", function IgxMonthPickerComponent_div_0_Template_div_click_2_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.previousYear(); })("keydown", function IgxMonthPickerComponent_div_0_Template_div_keydown_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.changeYearKB($event, false); });
    ɵngcc0.ɵɵelementStart(3, "igx-icon", 5);
    ɵngcc0.ɵɵtext(4, "keyboard_arrow_left");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "div");
    ɵngcc0.ɵɵelementStart(6, "span", 6, 7);
    ɵngcc0.ɵɵlistener("keydown", function IgxMonthPickerComponent_div_0_Template_span_keydown_6_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.activeViewDecadeKB($event); })("click", function IgxMonthPickerComponent_div_0_Template_span_click_6_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.activeViewDecade(); });
    ɵngcc0.ɵɵtext(8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "div", 8);
    ɵngcc0.ɵɵlistener("click", function IgxMonthPickerComponent_div_0_Template_div_click_9_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.nextYear(); })("keydown", function IgxMonthPickerComponent_div_0_Template_div_keydown_9_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.changeYearKB($event); });
    ɵngcc0.ɵɵelementStart(10, "igx-icon", 5);
    ɵngcc0.ɵɵtext(11, "keyboard_arrow_right");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(12, "igx-months-view", 9, 10);
    ɵngcc0.ɵɵlistener("@animateChange.done", function IgxMonthPickerComponent_div_0_Template_igx_months_view_animation_animateChange_done_12_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.animationDone($event); })("@animateView.done", function IgxMonthPickerComponent_div_0_Template_igx_months_view_animation_animateView_done_12_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.viewRendered($event); })("onSelection", function IgxMonthPickerComponent_div_0_Template_igx_months_view_onSelection_12_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.selectMonth($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animateView", ctx_r0.activeView);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction0(11, _c41));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵstyleProp("width", 100, "%");
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.formattedYear(ctx_r0.viewDate), " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction0(12, _c42));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("@animateChange", ctx_r0.yearAction)("date", ctx_r0.viewDate)("locale", ctx_r0.locale)("formatView", ctx_r0.formatViews.month)("monthFormat", ctx_r0.formatOptions.month);
} }
function IgxMonthPickerComponent_igx_years_view_1_Template(rf, ctx) { if (rf & 1) {
    const _r19 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-years-view", 11, 12);
    ɵngcc0.ɵɵlistener("@animateView.done", function IgxMonthPickerComponent_igx_years_view_1_Template_igx_years_view_animation_animateView_done_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.viewRendered($event); })("onSelection", function IgxMonthPickerComponent_igx_years_view_1_Template_igx_years_view_onSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r20 = ɵngcc0.ɵɵnextContext(); return ctx_r20.selectYear($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animateView", ctx_r1.activeView)("date", ctx_r1.viewDate)("locale", ctx_r1.locale)("formatView", ctx_r1.formatViews.year)("yearFormat", ctx_r1.formatOptions.year);
} }
const _c43 = [[["igx-avatar"], ["igx-card-media"], ["", "igxCardThumbnail", ""]], [["", "igxCardHeaderTitle", ""], ["", "igxCardHeaderSubtitle", ""], ["", 8, "igx-card-header__title"], ["", 8, "igx-card-header__subtitle"]], "*"];
const _c44 = ["igx-avatar, igx-card-media, [igxCardThumbnail]", "\n        [igxCardHeaderTitle],\n        [igxCardHeaderSubtitle],\n        .igx-card-header__title,\n        .igx-card-header__subtitle", "*"];
const _c45 = [[["igx-icon"], ["", "igxButton", "icon"]], [["", "igxButton", ""]], "*"];
const _c46 = ["igx-icon, [igxButton='icon']", "[igxButton]", "*"];
const _c47 = ["defaultIndicator"];
const _c48 = ["defaultNextButton"];
const _c49 = ["defaultPrevButton"];
function IgxCarouselComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 7);
} if (rf & 2) {
    const slide_r10 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("igx-nav-dot--active", slide_r10.active);
} }
function IgxCarouselComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 8);
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 9);
    ɵngcc0.ɵɵtext(2, "arrow_forward");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const disabled_r11 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("igx-nav-arrow--disabled", disabled_r11);
} }
function IgxCarouselComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 8);
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 9);
    ɵngcc0.ɵɵtext(2, "arrow_back");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const disabled_r12 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("igx-nav-arrow--disabled", disabled_r12);
} }
function IgxCarouselComponent_div_6_div_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCarouselComponent_div_6_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵlistener("click", function IgxCarouselComponent_div_6_div_1_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); const slide_r14 = ctx.$implicit; const ctx_r16 = ɵngcc0.ɵɵnextContext(2); return ctx_r16.select(slide_r14); });
    ɵngcc0.ɵɵtemplate(1, IgxCarouselComponent_div_6_div_1_ng_container_1_Template, 1, 0, "ng-container", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const slide_r14 = ctx.$implicit;
    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r13.setAriaLabel(slide_r14))("aria-selected", slide_r14.active);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r13.getIndicatorTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(4, _c17, slide_r14));
} }
function IgxCarouselComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵtemplate(1, IgxCarouselComponent_div_6_div_1_Template, 2, 6, "div", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r6.indicatorsOrientationClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r6.slides);
} }
function IgxCarouselComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵelementStart(1, "span", 14);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r7.indicatorsOrientationClass);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r7.getCarouselLabel);
} }
function IgxCarouselComponent_div_10_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCarouselComponent_div_10_Template(rf, ctx) { if (rf & 1) {
    const _r20 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵlistener("click", function IgxCarouselComponent_div_10_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r20); const ctx_r19 = ɵngcc0.ɵɵnextContext(); return ctx_r19.prev(); });
    ɵngcc0.ɵɵtemplate(1, IgxCarouselComponent_div_10_ng_container_1_Template, 1, 0, "ng-container", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r8.getPrevButtonTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, ctx_r8.prevButtonDisabled));
} }
function IgxCarouselComponent_div_11_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCarouselComponent_div_11_Template(rf, ctx) { if (rf & 1) {
    const _r23 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 16);
    ɵngcc0.ɵɵlistener("click", function IgxCarouselComponent_div_11_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r23); const ctx_r22 = ɵngcc0.ɵɵnextContext(); return ctx_r22.next(); });
    ɵngcc0.ɵɵtemplate(1, IgxCarouselComponent_div_11_ng_container_1_Template, 1, 0, "ng-container", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r9.getNextButtonTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, ctx_r9.nextButtonDisabled));
} }
const _c50 = ["chipArea"];
const _c51 = ["selectContainer"];
const _c52 = ["defaultRemoveIcon"];
const _c53 = ["defaultSelectIcon"];
function IgxChipComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxChipComponent_div_9_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxChipComponent_div_9_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵlistener("keydown", function IgxChipComponent_div_9_Template_div_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onRemoveBtnKeyDown($event); })("pointerdown", function IgxChipComponent_div_9_Template_div_pointerdown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onRemoveMouseDown($event); })("mousedown", function IgxChipComponent_div_9_Template_div_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onRemoveMouseDown($event); })("click", function IgxChipComponent_div_9_Template_div_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onRemoveClick($event); })("touchmove", function IgxChipComponent_div_9_Template_div_touchmove_0_listener() { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.onRemoveTouchMove(); })("touchend", function IgxChipComponent_div_9_Template_div_touchend_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.onRemoveTouchEnd($event); });
    ɵngcc0.ɵɵtemplate(1, IgxChipComponent_div_9_ng_container_1_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("tabIndex", ctx_r3.tabIndex);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.removeButtonTemplate);
} }
function IgxChipComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, "done");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxChipComponent_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, "cancel");
    ɵngcc0.ɵɵelementEnd();
} }
const _c54 = [[["igx-prefix"], ["", "igxPrefix", ""]], "*", [["igx-suffix"], ["", "igxSuffix", ""]]];
const _c55 = function (a0) { return { chip: a0 }; };
const _c56 = ["igx-prefix,[igxPrefix]", "*", "igx-suffix,[igxSuffix]"];
function IgxComboItemComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-checkbox", 2);
    ɵngcc0.ɵɵlistener("click", function IgxComboItemComponent_ng_container_0_Template_igx_checkbox_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.disableCheck($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("checked", ctx_r0.selected)("disableTransitions", ctx_r0.disableTransitions)("tabindex", -1);
} }
function IgxComboDropDownComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
const _c57 = ["searchInput"];
const _c58 = ["dropdownItemContainer"];
const _c59 = ["inputGroup"];
const _c60 = ["comboInput"];
const _c61 = ["primitive"];
const _c62 = ["complex"];
function IgxComboComponent_igx_suffix_12_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxComboComponent_igx_suffix_12_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_igx_suffix_12_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r22 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r22.clearIconTemplate);
} }
function IgxComboComponent_igx_suffix_12_igx_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 26);
    ɵngcc0.ɵɵtext(1, " clear ");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxComboComponent_igx_suffix_12_Template(rf, ctx) { if (rf & 1) {
    const _r26 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-suffix", 25);
    ɵngcc0.ɵɵlistener("click", function IgxComboComponent_igx_suffix_12_Template_igx_suffix_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r26); const ctx_r25 = ɵngcc0.ɵɵnextContext(); return ctx_r25.handleClearItems($event); });
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_igx_suffix_12_ng_container_1_Template, 2, 1, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(2, IgxComboComponent_igx_suffix_12_igx_icon_2_Template, 2, 0, "igx-icon", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.clearIconTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.clearIconTemplate);
} }
function IgxComboComponent_ng_container_14_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxComboComponent_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_ng_container_14_ng_container_1_Template, 1, 0, "ng-container", 27);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.toggleIconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, ctx_r3.collapsed));
} }
function IgxComboComponent_igx_icon_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 26);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r4.dropdown.collapsed ? "arrow_drop_down" : "arrow_drop_up", " ");
} }
function IgxComboComponent_igx_input_group_18_igx_suffix_3_Template(rf, ctx) { if (rf & 1) {
    const _r31 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-suffix");
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 31);
    ɵngcc0.ɵɵlistener("click", function IgxComboComponent_igx_input_group_18_igx_suffix_3_Template_igx_icon_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r31); const ctx_r30 = ɵngcc0.ɵɵnextContext(2); return ctx_r30.toggleCaseSensitive(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r29 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("isActive", ctx_r29.filteringOptions.caseSensitive);
} }
function IgxComboComponent_igx_input_group_18_Template(rf, ctx) { if (rf & 1) {
    const _r33 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 28);
    ɵngcc0.ɵɵelementStart(1, "input", 29, 30);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxComboComponent_igx_input_group_18_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r32 = ɵngcc0.ɵɵnextContext(); return ctx_r32.searchValue = $event; })("ngModelChange", function IgxComboComponent_igx_input_group_18_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r34 = ɵngcc0.ɵɵnextContext(); return ctx_r34.handleInputChange($event); })("keyup", function IgxComboComponent_igx_input_group_18_Template_input_keyup_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r35 = ɵngcc0.ɵɵnextContext(); return ctx_r35.handleKeyUp($event); })("keydown", function IgxComboComponent_igx_input_group_18_Template_input_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r36 = ɵngcc0.ɵɵnextContext(); return ctx_r36.handleKeyDown($event); })("focus", function IgxComboComponent_igx_input_group_18_Template_input_focus_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r37 = ɵngcc0.ɵɵnextContext(); return ctx_r37.dropdown.onBlur($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, IgxComboComponent_igx_input_group_18_igx_suffix_3_Template, 2, 1, "igx-suffix", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r6.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r6.searchValue);
    ɵngcc0.ɵɵattribute("placeholder", ctx_r6.searchPlaceholder)("aria-owns", ctx_r6.dropdown.id)("aria-labelledby", ctx_r6.ariaLabelledBy);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.showSearchCaseIcon);
} }
function IgxComboComponent_ng_container_19_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxComboComponent_igx_combo_item_22_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c63 = function (a0, a1, a2, a3, a4) { return { $implicit: a0, data: a1, valueKey: a2, groupKey: a3, displayKey: a4 }; };
function IgxComboComponent_igx_combo_item_22_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_igx_combo_item_22_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 27);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r38 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r40 = ɵngcc0.ɵɵnextContext();
    const _r20 = ɵngcc0.ɵɵreference(36);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r40.headerItemTemplate ? ctx_r40.headerItemTemplate : _r20)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction5(2, _c63, item_r38, ctx_r40.data, ctx_r40.valueKey, ctx_r40.groupKey, ctx_r40.displayKey));
} }
function IgxComboComponent_igx_combo_item_22_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, null, 33);
} }
const _c64 = function (a0, a1, a2, a3) { return { $implicit: a0, data: a1, valueKey: a2, displayKey: a3 }; };
function IgxComboComponent_igx_combo_item_22_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_igx_combo_item_22_ng_container_2_ng_container_1_Template, 2, 0, "ng-container", 27);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r38 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r41 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r41.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction4(2, _c64, item_r38, ctx_r41.data, ctx_r41.valueKey, ctx_r41.displayKey));
} }
function IgxComboComponent_igx_combo_item_22_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-combo-item", 32);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_igx_combo_item_22_ng_container_1_Template, 2, 8, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(2, IgxComboComponent_igx_combo_item_22_ng_container_2_Template, 2, 7, "ng-container", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r38 = ctx.$implicit;
    const rowIndex_r39 = ctx.index;
    const ctx_r9 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("itemHeight", ctx_r9.itemHeight)("value", item_r38)("isHeader", item_r38.isHeader)("index", rowIndex_r39);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", item_r38.isHeader);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r38.isHeader);
} }
function IgxComboComponent_div_25_div_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxComboComponent_div_25_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 37);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_div_25_div_1_ng_container_1_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r47 = ɵngcc0.ɵɵnextContext(2);
    const _r16 = ɵngcc0.ɵɵreference(32);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r47.emptyTemplate ? ctx_r47.emptyTemplate : _r16);
} }
function IgxComboComponent_div_25_igx_combo_add_item_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxComboComponent_div_25_igx_combo_add_item_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-combo-add-item", 38);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_div_25_igx_combo_add_item_2_ng_container_1_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r48 = ɵngcc0.ɵɵnextContext(2);
    const _r18 = ɵngcc0.ɵɵreference(34);
    ɵngcc0.ɵɵproperty("itemHeight", ctx_r48.itemHeight)("tabindex", ctx_r48.dropdown.collapsed ? -1 : ctx_r48.customValueFlag ? 1 : -1)("index", ctx_r48.virtualScrollContainer.igxForOf.length);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r48.addItemTemplate ? ctx_r48.addItemTemplate : _r18);
} }
function IgxComboComponent_div_25_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 34);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_div_25_div_1_Template, 2, 1, "div", 35);
    ɵngcc0.ɵɵtemplate(2, IgxComboComponent_div_25_igx_combo_add_item_2_Template, 2, 4, "igx-combo-add-item", 36);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r10.filteredData.length === 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r10.isAddButtonVisible());
} }
function IgxComboComponent_ng_container_26_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxComboComponent_ng_template_27_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const display_r51 = ctx.$implicit;
    const key_r53 = ctx.displayKey;
    ɵngcc0.ɵɵtextInterpolate1(" ", display_r51[key_r53], "\n");
} }
function IgxComboComponent_ng_template_29_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const display_r54 = ctx.$implicit;
    ɵngcc0.ɵɵtextInterpolate1(" ", display_r54, "\n");
} }
function IgxComboComponent_ng_template_31_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1, "The list is empty");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxComboComponent_ng_template_33_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 39);
    ɵngcc0.ɵɵtext(1, "Add item");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxComboComponent_ng_template_35_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const item_r56 = ctx.$implicit;
    const key_r57 = ctx.valueKey;
    ɵngcc0.ɵɵtextInterpolate1(" ", item_r56[key_r57], "\n");
} }
const _c65 = [[["", "igxLabel", ""]], [["igx-prefix"]], [["igx-hint"], ["", "igxHint", ""]], [["igx-suffix"]]];
const _c66 = function (a0, a1, a2, a3, a4) { return [a0, a1, a2, a3, a4]; };
const _c67 = ["[igxLabel]", "igx-prefix", "igx-hint, [igxHint]", "igx-suffix"];
const _c68 = ["calendar"];
function IgxCalendarContainerComponent_ng_template_0_div_0_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 6, 7);
    ɵngcc0.ɵɵlistener("click", function IgxCalendarContainerComponent_ng_template_0_div_0_button_1_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r8 = ɵngcc0.ɵɵnextContext(3); return ctx_r8.closeCalendar(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.cancelButtonLabel, " ");
} }
function IgxCalendarContainerComponent_ng_template_0_div_0_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 6, 8);
    ɵngcc0.ɵɵlistener("click", function IgxCalendarContainerComponent_ng_template_0_div_0_button_2_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(3); return ctx_r11.triggerTodaySelection(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r6.todayButtonLabel, " ");
} }
function IgxCalendarContainerComponent_ng_template_0_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵtemplate(1, IgxCalendarContainerComponent_ng_template_0_div_0_button_1_Template, 3, 1, "button", 5);
    ɵngcc0.ɵɵtemplate(2, IgxCalendarContainerComponent_ng_template_0_div_0_button_2_Template, 3, 1, "button", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.cancelButtonLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.todayButtonLabel);
} }
function IgxCalendarContainerComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxCalendarContainerComponent_ng_template_0_div_0_Template, 3, 2, "div", 3);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.cancelButtonLabel || ctx_r1.todayButtonLabel);
} }
function IgxCalendarContainerComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c69 = ["readOnlyDatePickerTemplate"];
const _c70 = ["editableDatePickerTemplate"];
function IgxDatePickerComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function IgxDatePickerComponent_ng_template_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 8);
} }
function IgxDatePickerComponent_ng_template_2_label_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r8.label);
} }
function IgxDatePickerComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 4);
    ɵngcc0.ɵɵlistener("click", function IgxDatePickerComponent_ng_template_2_Template_igx_input_group_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.openDialog(); });
    ɵngcc0.ɵɵtemplate(1, IgxDatePickerComponent_ng_template_2_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵelementStart(2, "igx-prefix");
    ɵngcc0.ɵɵelementStart(3, "igx-icon");
    ɵngcc0.ɵɵtext(4, "today");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxDatePickerComponent_ng_template_2_label_5_Template, 2, 1, "label", 6);
    ɵngcc0.ɵɵelementStart(6, "input", 7);
    ɵngcc0.ɵɵlistener("blur", function IgxDatePickerComponent_ng_template_2_Template_input_blur_6_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onBlur($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r0);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.labelVisibility && !ctx_r3._labelDirectiveUserTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r3.displayData || "")("disabled", ctx_r3.disabled)("tabindex", ctx_r3.editorTabIndex);
} }
function IgxDatePickerComponent_ng_template_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 8);
} }
function IgxDatePickerComponent_ng_template_4_label_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r14.label);
} }
function IgxDatePickerComponent_ng_template_4_igx_suffix_8_Template(rf, ctx) { if (rf & 1) {
    const _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-suffix", 4);
    ɵngcc0.ɵɵlistener("click", function IgxDatePickerComponent_ng_template_4_igx_suffix_8_Template_igx_suffix_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); const ctx_r16 = ɵngcc0.ɵɵnextContext(2); return ctx_r16.clear(); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon");
    ɵngcc0.ɵɵtext(2, "clear");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function IgxDatePickerComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    const _r19 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", null, 10);
    ɵngcc0.ɵɵtemplate(2, IgxDatePickerComponent_ng_template_4_ng_container_2_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵelementStart(3, "igx-prefix", 4);
    ɵngcc0.ɵɵlistener("click", function IgxDatePickerComponent_ng_template_4_Template_igx_prefix_click_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.onOpenClick($event); });
    ɵngcc0.ɵɵelementStart(4, "igx-icon");
    ɵngcc0.ɵɵtext(5, "today");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, IgxDatePickerComponent_ng_template_4_label_6_Template, 2, 1, "label", 6);
    ɵngcc0.ɵɵelementStart(7, "input", 11);
    ɵngcc0.ɵɵlistener("blur", function IgxDatePickerComponent_ng_template_4_Template_input_blur_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r20 = ɵngcc0.ɵɵnextContext(); return ctx_r20.onBlur($event); })("wheel", function IgxDatePickerComponent_ng_template_4_Template_input_wheel_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.onWheel($event); })("input", function IgxDatePickerComponent_ng_template_4_Template_input_input_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r22 = ɵngcc0.ɵɵnextContext(); return ctx_r22.onInput($event); })("focus", function IgxDatePickerComponent_ng_template_4_Template_input_focus_7_listener() { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r23 = ɵngcc0.ɵɵnextContext(); return ctx_r23.onFocus(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(8, IgxDatePickerComponent_ng_template_4_igx_suffix_8_Template, 3, 0, "igx-suffix", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r0);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.labelVisibility && !ctx_r5._labelDirectiveUserTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r5.transformedDate)("igxMask", ctx_r5.inputMask)("placeholder", ctx_r5.mask)("igxTextSelection", true)("disabled", ctx_r5.disabled)("displayValuePipe", ctx_r5.displayValuePipe)("focusedValuePipe", ctx_r5.inputValuePipe)("tabindex", ctx_r5.editorTabIndex);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r5.isEmpty);
} }
function IgxDatePickerComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c71 = [[["", "igxLabel", ""]]];
const _c72 = ["[igxLabel]"];
function IgxDialogComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("id", ctx_r2.titleId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r2.title, " ");
} }
function IgxDialogComponent_ng_content_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "!title"]);
} }
function IgxDialogComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r4.message);
} }
function IgxDialogComponent_ng_content_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1, ["*ngIf", "!message"]);
} }
function IgxDialogComponent_div_8_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 12);
    ɵngcc0.ɵɵlistener("click", function IgxDialogComponent_div_8_button_1_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.onInternalLeftButtonSelect($event); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵpropertyInterpolate("igxButton", ctx_r8.leftButtonType);
    ɵngcc0.ɵɵpropertyInterpolate("igxButtonColor", ctx_r8.leftButtonColor);
    ɵngcc0.ɵɵpropertyInterpolate("igxButtonBackground", ctx_r8.leftButtonBackgroundColor);
    ɵngcc0.ɵɵpropertyInterpolate("igxRipple", ctx_r8.leftButtonRipple);
    ɵngcc0.ɵɵproperty("igxFocus", ctx_r8.isOpen);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r8.leftButtonLabel, " ");
} }
function IgxDialogComponent_div_8_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 12);
    ɵngcc0.ɵɵlistener("click", function IgxDialogComponent_div_8_button_2_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); const ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onInternalRightButtonSelect($event); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵpropertyInterpolate("igxButton", ctx_r9.rightButtonType);
    ɵngcc0.ɵɵpropertyInterpolate("igxButtonColor", ctx_r9.rightButtonColor);
    ɵngcc0.ɵɵpropertyInterpolate("igxButtonBackground", ctx_r9.rightButtonBackgroundColor);
    ɵngcc0.ɵɵpropertyInterpolate("igxRipple", ctx_r9.rightButtonRipple);
    ɵngcc0.ɵɵproperty("igxFocus", ctx_r9.isOpen);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r9.rightButtonLabel, " ");
} }
function IgxDialogComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵtemplate(1, IgxDialogComponent_div_8_button_1_Template, 2, 6, "button", 11);
    ɵngcc0.ɵɵtemplate(2, IgxDialogComponent_div_8_button_2_Template, 2, 6, "button", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.leftButtonLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.rightButtonLabel);
} }
function IgxDialogComponent_ng_content_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "!leftButtonLabel && !rightButtonLabel"]);
} }
const _c73 = [[["igx-dialog-title"], ["", "igxDialogTitle", ""]], "*", [["igx-dialog-actions"], ["", "igxDialogActions", ""]]];
const _c74 = ["igx-dialog-title,[igxDialogTitle]", "*", "igx-dialog-actions,[igxDialogActions]"];
const _c75 = function (a0, a1, a2, a3, a4) { return { "igx-linear-bar__value--start": a0, "igx-linear-bar__value--center": a1, "igx-linear-bar__value--end": a2, "igx-linear-bar__value--top": a3, "igx-linear-bar__value--hidden": a4 }; };
const _c76 = ["circle"];
function IgxCircularProgressBarComponent__svg_text_5__svg_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCircularProgressBarComponent__svg_text_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 9);
    ɵngcc0.ɵɵtemplate(1, IgxCircularProgressBarComponent__svg_text_5__svg_ng_container_1_Template, 1, 0, "ng-container", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    const _r4 = ɵngcc0.ɵɵreference(9);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.textTemplate ? ctx_r2.textTemplate.template : _r4)("ngTemplateOutletContext", ctx_r2.context);
} }
function IgxCircularProgressBarComponent__svg_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCircularProgressBarComponent__svg_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "tspan", 10);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.textContent ? ctx_r5.textContent : ctx_r5.valueInPercent + "%", " ");
} }
function IgxCircularProgressBarComponent__svg_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "linearGradient", 11);
    ɵngcc0.ɵɵelement(1, "stop", 12);
    ɵngcc0.ɵɵelement(2, "stop", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r7.gradientId);
} }
const _c77 = ["input"];
function IgxSelectComponent_ng_container_11_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxSelectComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSelectComponent_ng_container_11_ng_container_1_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.toggleIconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, ctx_r2.collapsed));
} }
function IgxSelectComponent_igx_icon_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 16);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.collapsed ? "arrow_drop_down" : "arrow_drop_up");
} }
function IgxSelectComponent_div_16_ng_content_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 5, ["*ngTemplateOutlet", "headerTemplate"]);
} }
function IgxSelectComponent_div_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵtemplate(1, IgxSelectComponent_div_16_ng_content_1_Template, 1, 0, "ng-content", 18);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.headerTemplate);
} }
function IgxSelectComponent_div_20_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxSelectComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 19);
    ɵngcc0.ɵɵtemplate(1, IgxSelectComponent_div_20_ng_container_1_Template, 1, 0, "ng-container", 18);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r6.footerTemplate);
} }
const _c78 = [[["", "igxLabel", ""]], [["igx-prefix"], ["", "igxPrefix", ""]], [["igx-suffix"], ["", "igxSuffix", ""]], [["igx-hint"], ["", "igxHint", ""]], [["igx-select-item"], ["igx-select-item-group"]], "*"];
const _c79 = ["[igxLabel]", "igx-prefix,[igxPrefix]", "igx-suffix,[igxSuffix]", "igx-hint, [igxHint]", "igx-select-item, igx-select-item-group", "*"];
const _c80 = "[_nghost-%COMP%] {\n            display: block;\n        }";
const _c81 = [[["igx-select-item"]]];
const _c82 = ["igx-select-item"];
function IgxColumnActionsComponent_h4_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "h4", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("id", ctx_r0.titleID);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.title);
} }
function IgxColumnActionsComponent_igx_input_group_2_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 8);
    ɵngcc0.ɵɵelementStart(1, "input", 9);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxColumnActionsComponent_igx_input_group_2_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.filterCriteria = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r1.filterCriteria)("placeholder", ctx_r1.filterColumnsPrompt);
    ɵngcc0.ɵɵattribute("aria-describedby", ctx_r1.titleID);
} }
function IgxColumnActionsComponent_igx_checkbox_4_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-checkbox", 10);
    ɵngcc0.ɵɵlistener("change", function IgxColumnActionsComponent_igx_checkbox_4_Template_igx_checkbox_change_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const column_r5 = ctx.$implicit; const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.toggleColumn($event, column_r5); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r5 = ctx.$implicit;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("margin-left", column_r5.level * ctx_r2.indentation, "px");
    ɵngcc0.ɵɵproperty("checked", ctx_r2.actionsDirective.columnChecked(column_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", column_r5.header || column_r5.field, " ");
} }
const _c83 = ["columnHidingDropdown"];
const _c84 = ["columnHidingButton"];
const _c85 = ["exportDropdown"];
const _c86 = ["btnExport"];
const _c87 = ["columnPinningDropdown"];
const _c88 = ["columnPinningButton"];
function IgxGridToolbarComponent_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.getTitle(), "\n");
} }
function IgxGridToolbarComponent_div_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridToolbarComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtemplate(1, IgxGridToolbarComponent_div_1_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.customContentTemplate)("ngTemplateOutletContext", ctx_r1.context);
} }
function IgxGridToolbarComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelementStart(1, "button", 9, 10);
    ɵngcc0.ɵɵlistener("click", function IgxGridToolbarComponent_div_3_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.showAdvancedFilteringUI(); });
    ɵngcc0.ɵɵelementStart(3, "div", 11);
    ɵngcc0.ɵɵelementStart(4, "igx-icon");
    ɵngcc0.ɵɵtext(5, " filter_list ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "span");
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r2.grid.displayDensity)("ngClass", ctx_r2.grid.advancedFilteringExpressionsTree ? "igx-grid-toolbar__adv-filter--filtered" : "igx-grid-toolbar__adv-filter");
    ɵngcc0.ɵɵadvance(6);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.grid.resourceStrings.igx_grid_advanced_filter_title);
} }
function IgxGridToolbarComponent_div_4_igx_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, "visibility_off");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridToolbarComponent_div_4_igx_icon_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, "visibility");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridToolbarComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r16 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelementStart(1, "button", 12, 13);
    ɵngcc0.ɵɵlistener("click", function IgxGridToolbarComponent_div_4_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r16); const ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.toggleColumnHidingUI(); });
    ɵngcc0.ɵɵelementStart(3, "div", 11);
    ɵngcc0.ɵɵtemplate(4, IgxGridToolbarComponent_div_4_igx_icon_4_Template, 2, 0, "igx-icon", 3);
    ɵngcc0.ɵɵtemplate(5, IgxGridToolbarComponent_div_4_igx_icon_5_Template, 2, 0, "igx-icon", 3);
    ɵngcc0.ɵɵelementStart(6, "span");
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "span");
    ɵngcc0.ɵɵtext(9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(10, "igx-drop-down", 14, 15);
    ɵngcc0.ɵɵlistener("onClosing", function IgxGridToolbarComponent_div_4_Template_igx_drop_down_onClosing_10_listener($event) { ɵngcc0.ɵɵrestoreView(_r16); const ctx_r17 = ɵngcc0.ɵɵnextContext(); return ctx_r17.onClosingColumnHiding($event); });
    ɵngcc0.ɵɵelement(12, "igx-column-actions", 16);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r3.grid.displayDensity);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.grid.hiddenColumnsCount > 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.grid.hiddenColumnsCount === 0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.grid.hiddenColumnsCount);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.grid.hiddenColumnsText);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("grid", ctx_r3.grid)("title", ctx_r3.grid.columnHidingTitle)("filterColumnsPrompt", ctx_r3.filterColumnsPrompt)("columnsAreaMaxHeight", ctx_r3.defaultDropDownsMaxHeight);
} }
function IgxGridToolbarComponent_div_5_igx_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-icon", 23);
} }
function IgxGridToolbarComponent_div_5_igx_icon_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-icon", 24);
} }
function IgxGridToolbarComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    const _r23 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelementStart(1, "button", 17, 18);
    ɵngcc0.ɵɵlistener("click", function IgxGridToolbarComponent_div_5_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r23); const ctx_r22 = ɵngcc0.ɵɵnextContext(); return ctx_r22.toggleColumnPinningUI(); });
    ɵngcc0.ɵɵelementStart(3, "div", 11);
    ɵngcc0.ɵɵtemplate(4, IgxGridToolbarComponent_div_5_igx_icon_4_Template, 1, 0, "igx-icon", 19);
    ɵngcc0.ɵɵtemplate(5, IgxGridToolbarComponent_div_5_igx_icon_5_Template, 1, 0, "igx-icon", 20);
    ɵngcc0.ɵɵelementStart(6, "span");
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "span");
    ɵngcc0.ɵɵtext(9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(10, "span");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(11, "igx-drop-down", 14, 21);
    ɵngcc0.ɵɵlistener("onClosing", function IgxGridToolbarComponent_div_5_Template_igx_drop_down_onClosing_11_listener($event) { ɵngcc0.ɵɵrestoreView(_r23); const ctx_r24 = ɵngcc0.ɵɵnextContext(); return ctx_r24.onClosingColumnPinning($event); });
    ɵngcc0.ɵɵelement(13, "igx-column-actions", 22);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r4.grid.displayDensity);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.pinnedColumnsCount > 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.pinnedColumnsCount === 0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r4.pinnedColumnsCount);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r4.grid.pinnedColumnsText);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("grid", ctx_r4.grid)("title", ctx_r4.grid.columnPinningTitle)("filterColumnsPrompt", ctx_r4.filterColumnsPrompt)("columnsAreaMaxHeight", ctx_r4.defaultDropDownsMaxHeight);
} }
function IgxGridToolbarComponent_div_6_li_13_Template(rf, ctx) { if (rf & 1) {
    const _r30 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 33);
    ɵngcc0.ɵɵlistener("click", function IgxGridToolbarComponent_div_6_li_13_Template_li_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r30); const ctx_r29 = ɵngcc0.ɵɵnextContext(2); return ctx_r29.exportToExcelClicked(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r27 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r27.getExportExcelText());
} }
function IgxGridToolbarComponent_div_6_li_14_Template(rf, ctx) { if (rf & 1) {
    const _r32 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 34);
    ɵngcc0.ɵɵlistener("click", function IgxGridToolbarComponent_div_6_li_14_Template_li_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r32); const ctx_r31 = ɵngcc0.ɵɵnextContext(2); return ctx_r31.exportToCsvClicked(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r28 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r28.getExportCsvText());
} }
function IgxGridToolbarComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r34 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 25);
    ɵngcc0.ɵɵelementStart(1, "button", 26, 27);
    ɵngcc0.ɵɵlistener("click", function IgxGridToolbarComponent_div_6_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r34); const ctx_r33 = ɵngcc0.ɵɵnextContext(); return ctx_r33.exportClicked(); });
    ɵngcc0.ɵɵelementStart(3, "span", 11);
    ɵngcc0.ɵɵelementStart(4, "igx-icon", 28);
    ɵngcc0.ɵɵtext(5, "import_export");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "span");
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "igx-icon", 28);
    ɵngcc0.ɵɵtext(9, "arrow_drop_down");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(10, "igx-drop-down", null, 29);
    ɵngcc0.ɵɵelementStart(12, "ul", 30);
    ɵngcc0.ɵɵtemplate(13, IgxGridToolbarComponent_div_6_li_13_Template, 2, 1, "li", 31);
    ɵngcc0.ɵɵtemplate(14, IgxGridToolbarComponent_div_6_li_14_Template, 2, 1, "li", 32);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r5.grid.displayDensity)("disabled", ctx_r5.isExporting);
    ɵngcc0.ɵɵadvance(6);
    ɵngcc0.ɵɵtextInterpolate(ctx_r5.getExportText());
    ɵngcc0.ɵɵadvance(6);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.shouldShowExportExcelButton);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.shouldShowExportCsvButton);
} }
function IgxGridToolbarComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 35);
    ɵngcc0.ɵɵelement(1, "igx-linear-bar", 36);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
const _c89 = ["defaultExcelColumnOperations"];
const _c90 = ["defaultExcelFilterOperations"];
const _c91 = ["mainDropdown"];
function IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_sorting_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-excel-style-sorting");
} }
function IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_moving_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-excel-style-moving");
} }
function IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_pinning_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-excel-style-pinning");
} }
function IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_hiding_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-excel-style-hiding");
} }
function IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_selecting_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-excel-style-selecting");
} }
function IgxGridExcelStyleFilteringComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-excel-style-header", 5);
    ɵngcc0.ɵɵtemplate(1, IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_sorting_1_Template, 1, 0, "igx-excel-style-sorting", 6);
    ɵngcc0.ɵɵtemplate(2, IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_moving_2_Template, 1, 0, "igx-excel-style-moving", 6);
    ɵngcc0.ɵɵtemplate(3, IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_pinning_3_Template, 1, 0, "igx-excel-style-pinning", 6);
    ɵngcc0.ɵɵtemplate(4, IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_hiding_4_Template, 1, 0, "igx-excel-style-hiding", 6);
    ɵngcc0.ɵɵtemplate(5, IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_selecting_5_Template, 1, 0, "igx-excel-style-selecting", 6);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("showHiding", ctx_r1.displayDensity !== "comfortable" && !(ctx_r1.column == null ? null : ctx_r1.column.disableHiding))("showPinning", ctx_r1.displayDensity !== "comfortable" && !(ctx_r1.column == null ? null : ctx_r1.column.disablePinning))("showSelecting", ctx_r1.displayDensity !== "comfortable" && ctx_r1.columnSelectable());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.column == null ? null : ctx_r1.column.sortable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.column == null ? null : ctx_r1.column.movable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !(ctx_r1.column == null ? null : ctx_r1.column.disablePinning) && ctx_r1.displayDensity === "comfortable");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !(ctx_r1.column == null ? null : ctx_r1.column.disableHiding) && ctx_r1.displayDensity === "comfortable");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.columnSelectable() && ctx_r1.displayDensity === "comfortable");
} }
function IgxGridExcelStyleFilteringComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-excel-style-clear-filters");
    ɵngcc0.ɵɵelement(1, "igx-excel-style-conditional-filter");
    ɵngcc0.ɵɵelement(2, "igx-excel-style-search");
} }
function IgxGridExcelStyleFilteringComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function IgxGridExcelStyleFilteringComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
const _c92 = [[["igx-excel-style-column-operations"], ["", "igxExcelStyleColumnOperations", ""]], [["igx-excel-style-filter-operations"], ["", "igxExcelStyleFilterOperations", ""]]];
const _c93 = function (a0, a1) { return { "igx-excel-filter__menu--cosy": a0, "igx-excel-filter__menu--compact": a1 }; };
const _c94 = ["igx-excel-style-column-operations,[igxExcelStyleColumnOperations]", "igx-excel-style-filter-operations,[igxExcelStyleFilterOperations]"];
function IgxGridHeaderComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r1.columnTitle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.column.header || ctx_r1.column.field);
} }
function IgxGridHeaderComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridHeaderComponent_div_4_igx_icon_1_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 8);
    ɵngcc0.ɵɵlistener("click", function IgxGridHeaderComponent_div_4_igx_icon_1_Template_igx_icon_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(2); return ctx_r6.onSortingIconClick($event); });
    ɵngcc0.ɵɵpipe(1, "sortingIndex");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("draggable", false)("data-sortIndex", ɵngcc0.ɵɵpipeBind2(1, 3, ctx_r4.column.field, ctx_r4.grid.sortingExpressions));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r4.sortingIcon, " ");
} }
function IgxGridHeaderComponent_div_4_igx_icon_2_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 9);
    ɵngcc0.ɵɵlistener("click", function IgxGridHeaderComponent_div_4_igx_icon_2_Template_igx_icon_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r8 = ɵngcc0.ɵɵnextContext(2); return ctx_r8.onFilteringIconClick($event); });
    ɵngcc0.ɵɵtext(1, " more_vert ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r5.filterIconClassName);
    ɵngcc0.ɵɵattribute("draggable", false);
} }
function IgxGridHeaderComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 5);
    ɵngcc0.ɵɵtemplate(1, IgxGridHeaderComponent_div_4_igx_icon_1_Template, 3, 6, "igx-icon", 6);
    ɵngcc0.ɵɵtemplate(2, IgxGridHeaderComponent_div_4_igx_icon_2_Template, 2, 2, "igx-icon", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.column.sortable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.grid.allowFiltering == true && ctx_r3.column.filterable && ctx_r3.grid.filterMode == "excelStyleFilter");
} }
const _c95 = function (a0, a1) { return { $implicit: a0, column: a1 }; };
const _c96 = ["emptyFilter"];
const _c97 = ["defaultFilter"];
const _c98 = ["complexFilter"];
const _c99 = ["chipsArea"];
const _c100 = ["moreIcon"];
const _c101 = ["ghostChip"];
const _c102 = ["complexChip"];
function IgxGridFilteringCellComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-chips-area", 4);
    ɵngcc0.ɵɵelementStart(1, "igx-chip", 5, 6);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringCellComponent_ng_template_0_Template_igx_chip_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onChipClicked(); });
    ɵngcc0.ɵɵelementStart(3, "igx-icon", 7);
    ɵngcc0.ɵɵtext(4, "filter_list");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "span");
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("draggable", false);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r1.displayDensity);
    ɵngcc0.ɵɵattribute("draggable", false);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵattribute("draggable", false);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵattribute("draggable", false);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.filteringService.grid.resourceStrings.igx_grid_filter);
} }
function IgxGridFilteringCellComponent_ng_template_2_ng_container_2_igx_chip_1_Template(rf, ctx) { if (rf & 1) {
    const _r21 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-chip", 15);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringCellComponent_ng_template_2_ng_container_2_igx_chip_1_Template_igx_chip_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r21); const item_r13 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r19 = ɵngcc0.ɵɵnextContext(2); return ctx_r19.onChipClicked(item_r13.expression); })("onRemove", function IgxGridFilteringCellComponent_ng_template_2_ng_container_2_igx_chip_1_Template_igx_chip_onRemove_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r21); const item_r13 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r22 = ɵngcc0.ɵɵnextContext(2); return ctx_r22.onChipRemoved($event, item_r13); });
    ɵngcc0.ɵɵelement(1, "igx-icon", 16);
    ɵngcc0.ɵɵelementStart(2, "span", null, 17);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r13 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r16 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("removable", true)("displayDensity", ctx_r16.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", item_r13.expression.condition.iconName);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r16.filteringService.getChipLabel(item_r13.expression), " ");
} }
function IgxGridFilteringCellComponent_ng_template_2_ng_container_2_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 18);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r13 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r17 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r17.filteringService.getOperatorAsString(item_r13.afterOperator));
} }
function IgxGridFilteringCellComponent_ng_template_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridFilteringCellComponent_ng_template_2_ng_container_2_igx_chip_1_Template, 5, 4, "igx-chip", 13);
    ɵngcc0.ɵɵtemplate(2, IgxGridFilteringCellComponent_ng_template_2_ng_container_2_span_2_Template, 2, 1, "span", 14);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const last_r14 = ctx.last;
    const index_r15 = ctx.index;
    const ctx_r11 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r11.isChipVisible(index_r15));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r14 && ctx_r11.isChipVisible(index_r15 + 1));
} }
function IgxGridFilteringCellComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r27 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-chips-area", 4, 8);
    ɵngcc0.ɵɵtemplate(2, IgxGridFilteringCellComponent_ng_template_2_ng_container_2_Template, 3, 2, "ng-container", 9);
    ɵngcc0.ɵɵelementStart(3, "div", 10, 11);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringCellComponent_ng_template_2_Template_div_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r27); const ctx_r26 = ɵngcc0.ɵɵnextContext(); return ctx_r26.onChipClicked(); });
    ɵngcc0.ɵɵelementStart(5, "igx-icon");
    ɵngcc0.ɵɵtext(6, "filter_list");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(7, "igx-badge", 12);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.expressionsList);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r3.filteringIndicatorClass());
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("value", ctx_r3.moreFiltersCount);
} }
function IgxGridFilteringCellComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    const _r30 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-chip", 19, 20);
    ɵngcc0.ɵɵlistener("onRemove", function IgxGridFilteringCellComponent_ng_template_4_Template_igx_chip_onRemove_0_listener() { ɵngcc0.ɵɵrestoreView(_r30); const ctx_r29 = ɵngcc0.ɵɵnextContext(); return ctx_r29.clearFiltering(); });
    ɵngcc0.ɵɵelementStart(2, "igx-icon", 7);
    ɵngcc0.ɵɵtext(3, "filter_list");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("removable", true)("displayDensity", ctx_r5.displayDensity);
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵtextInterpolate(ctx_r5.filteringService.grid.resourceStrings.igx_grid_complex_filter);
} }
function IgxGridFilteringCellComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridHeaderGroupComponent_ng_container_0_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 7);
} }
function IgxGridHeaderGroupComponent_ng_container_0_ng_container_3_igx_grid_header_group_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 9);
} if (rf & 2) {
    const child_r10 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r11 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("column", child_r10)("gridID", child_r10.grid.id)("igxColumnMovingDrag", child_r10)("ghostHost", ctx_r11.grid.outlet.nativeElement)("igxColumnMovingDrop", child_r10);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridHeaderGroupComponent_ng_container_0_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_0_ng_container_3_igx_grid_header_group_1_Template, 1, 6, "igx-grid-header-group", 8);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const child_r10 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !child_r10.hidden);
} }
function IgxGridHeaderGroupComponent_ng_container_0_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} }
const _c103 = function (a0, a1) { return { "igx-grid__th--pinned-last": a0, "igx-grid__th--pinned-first": a1 }; };
const _c104 = function (a0, a1, a2, a3) { return { "grid-template-rows": a0, "grid-template-columns": a1, "-ms-grid-rows": a2, "-ms-grid-columns": a3 }; };
function IgxGridHeaderGroupComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_0_span_1_Template, 1, 0, "span", 3);
    ɵngcc0.ɵɵelementStart(2, "div", 4);
    ɵngcc0.ɵɵtemplate(3, IgxGridHeaderGroupComponent_ng_container_0_ng_container_3_Template, 2, 1, "ng-container", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, IgxGridHeaderGroupComponent_ng_container_0_span_4_Template, 1, 0, "span", 6);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.grid.hasMovableColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(5, _c103, ctx_r0.hasLastPinnedChildColumn, ctx_r0.hasFirstPinnedChildColumn))("ngStyle", ɵngcc0.ɵɵpureFunction4(8, _c104, ctx_r0.column.getGridTemplate(true, false), ctx_r0.column.getGridTemplate(false, false), ctx_r0.column.getGridTemplate(true, true), ctx_r0.column.getGridTemplate(false, true)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.column.children);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.grid.hasMovableColumns);
} }
function IgxGridHeaderGroupComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 11);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r2.columnTitle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.column.header);
} }
function IgxGridHeaderGroupComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("draggable", false);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r4.column.expanded ? "expand_more" : "chevron_right", " ");
} }
function IgxGridHeaderGroupComponent_ng_container_5_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 7);
} }
function IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r20 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 15);
    ɵngcc0.ɵɵlistener("click", function IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r20); const ctx_r19 = ɵngcc0.ɵɵnextContext(2); return ctx_r19.toggleExpandState($event); });
    ɵngcc0.ɵɵtemplate(2, IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_ng_container_2_Template, 1, 0, "ng-container", 13);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
    const _r3 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r14.column.collapsibleIndicatorTemplate ? ctx_r14.column.collapsibleIndicatorTemplate : _r3)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c95, ctx_r14.column, ctx_r14.column));
} }
function IgxGridHeaderGroupComponent_ng_container_5_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridHeaderGroupComponent_ng_container_5_ng_container_6_igx_grid_header_group_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 17);
} if (rf & 2) {
    const child_r21 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r22 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r22.grid.getHeaderGroupWidth(child_r21))("flex-basis", ctx_r22.grid.getHeaderGroupWidth(child_r21));
    ɵngcc0.ɵɵproperty("column", child_r21)("gridID", child_r21.grid.id);
} }
function IgxGridHeaderGroupComponent_ng_container_5_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_5_ng_container_6_igx_grid_header_group_1_Template, 1, 6, "igx-grid-header-group", 16);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const child_r21 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !child_r21.hidden);
} }
function IgxGridHeaderGroupComponent_ng_container_5_span_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} }
const _c105 = function (a0, a1, a2, a3, a4, a5) { return { "igx-grid__th--pinned-last": a0, "igx-grid__th--pinned-first": a1, "igx-grid__th--collapsible": a2, "igx-grid__th--selectable": a3, "igx-grid__th--selected": a4, "igx-grid__th--active": a5 }; };
function IgxGridHeaderGroupComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    const _r25 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_5_span_1_Template, 1, 0, "span", 3);
    ɵngcc0.ɵɵelementStart(2, "div", 12);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxGridHeaderGroupComponent_ng_container_5_Template_div_pointerdown_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r24 = ɵngcc0.ɵɵnextContext(); return ctx_r24.pointerdown($event); })("click", function IgxGridHeaderGroupComponent_ng_container_5_Template_div_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r26 = ɵngcc0.ɵɵnextContext(); return ctx_r26.groupClicked($event); })("pointerenter", function IgxGridHeaderGroupComponent_ng_container_5_Template_div_pointerenter_2_listener() { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r27 = ɵngcc0.ɵɵnextContext(); return ctx_r27.onPinterEnter(); })("pointerleave", function IgxGridHeaderGroupComponent_ng_container_5_Template_div_pointerleave_2_listener() { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r28 = ɵngcc0.ɵɵnextContext(); return ctx_r28.onPointerLeave(); });
    ɵngcc0.ɵɵtemplate(3, IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_Template, 3, 5, "ng-container", 0);
    ɵngcc0.ɵɵtemplate(4, IgxGridHeaderGroupComponent_ng_container_5_ng_container_4_Template, 1, 0, "ng-container", 13);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "div", 14);
    ɵngcc0.ɵɵtemplate(6, IgxGridHeaderGroupComponent_ng_container_5_ng_container_6_Template, 2, 1, "ng-container", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(7, IgxGridHeaderGroupComponent_ng_container_5_span_7_Template, 1, 0, "span", 6);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.grid.hasMovableColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction6(14, _c105, ctx_r5.hasLastPinnedChildColumn, ctx_r5.hasFirstPinnedChildColumn, ctx_r5.column.collapsible, ctx_r5.selectable, ctx_r5.selected, ctx_r5.activeGroup))("igxColumnMovingDrag", ctx_r5.column)("ghostHost", ctx_r5.grid.outlet.nativeElement)("igxColumnMovingDrop", ctx_r5.column);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r5.column.header || ctx_r5.column.field)("aria-expanded", ctx_r5.column.expanded)("aria-selected", ctx_r5.column.selected)("droppable", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.column.collapsible);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r5.column.headerTemplate ? ctx_r5.column.headerTemplate : _r1)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(21, _c95, ctx_r5.column, ctx_r5.column));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r5.column.children);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.grid.hasMovableColumns);
} }
function IgxGridHeaderGroupComponent_ng_container_6_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 7);
} }
function IgxGridHeaderGroupComponent_ng_container_6_igx_grid_filtering_cell_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-filtering-cell", 21);
} if (rf & 2) {
    const ctx_r30 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("column", ctx_r30.column);
    ɵngcc0.ɵɵattribute("draggable", false);
} }
function IgxGridHeaderGroupComponent_ng_container_6_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 22);
} if (rf & 2) {
    const ctx_r31 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("cursor", ctx_r31.colResizingService.resizeCursor);
    ɵngcc0.ɵɵproperty("igxResizeHandle", ctx_r31.column);
    ɵngcc0.ɵɵattribute("draggable", false);
} }
function IgxGridHeaderGroupComponent_ng_container_6_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} }
function IgxGridHeaderGroupComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    const _r34 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_6_span_1_Template, 1, 0, "span", 3);
    ɵngcc0.ɵɵelementStart(2, "igx-grid-header", 18);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxGridHeaderGroupComponent_ng_container_6_Template_igx_grid_header_pointerdown_2_listener() { ɵngcc0.ɵɵrestoreView(_r34); const ctx_r33 = ɵngcc0.ɵɵnextContext(); return ctx_r33.activate(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, IgxGridHeaderGroupComponent_ng_container_6_igx_grid_filtering_cell_3_Template, 1, 2, "igx-grid-filtering-cell", 19);
    ɵngcc0.ɵɵtemplate(4, IgxGridHeaderGroupComponent_ng_container_6_span_4_Template, 1, 4, "span", 20);
    ɵngcc0.ɵɵtemplate(5, IgxGridHeaderGroupComponent_ng_container_6_span_5_Template, 1, 0, "span", 6);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.grid.hasMovableColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxColumnMovingDrag", ctx_r6.column)("ghostHost", ctx_r6.grid.outlet.nativeElement)("igxColumnMovingDrop", ctx_r6.column)("gridID", ctx_r6.column.grid.id)("column", ctx_r6.column);
    ɵngcc0.ɵɵattribute("droppable", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.grid.allowFiltering && ctx_r6.grid.filterMode == "quickFilter");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r6.column.columnGroup && ctx_r6.column.resizable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.grid.hasMovableColumns);
} }
function IgxSummaryCellComponent_ng_container_0_ng_container_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div");
    ɵngcc0.ɵɵelementStart(2, "div", 5, 6);
    ɵngcc0.ɵɵelementStart(4, "igx-icon", 7);
    ɵngcc0.ɵɵtext(5, "chevron_right");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("igx-grid__tree-cell--padding-level-", ctx_r3.firstCellIndentation, "");
} }
function IgxSummaryCellComponent_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵtemplate(2, IgxSummaryCellComponent_ng_container_0_ng_container_1_ng_container_2_Template, 6, 3, "ng-container", 0);
    ɵngcc0.ɵɵelementStart(3, "span", 3);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "span", 4);
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const summary_r2 = ctx.$implicit;
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("height", ctx_r1.itemHeight, "px");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.visibleColumnIndex === 0 && ctx_r1.firstCellIndentation >= 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("title", summary_r2.label);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.translateSummary(summary_r2));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("title", summary_r2.summaryResult);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", summary_r2.summaryResult, " ");
} }
function IgxSummaryCellComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSummaryCellComponent_ng_container_0_ng_container_1_Template, 7, 7, "ng-container", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.summaryResults);
} }
function IgxSummaryRowComponent_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 4);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxSummaryRowComponent_ng_container_0_ng_container_1_Template_div_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); return $event.preventDefault(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r3.grid.summariesMargin, "px")("flex-basis", ctx_r3.grid.summariesMargin, "px");
} }
function IgxSummaryRowComponent_ng_container_0_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxSummaryRowComponent_ng_container_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSummaryRowComponent_ng_container_0_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1)("ngTemplateOutletContext", ctx_r4.getContext(ctx_r4));
} }
function IgxSummaryRowComponent_ng_container_0_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-cell", 6);
    ɵngcc0.ɵɵpipe(1, "igxStringReplace");
} if (rf & 2) {
    const col_r11 = ctx.$implicit;
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("max-height", ctx_r6.minHeight, "px")("min-height", ctx_r6.minHeight, "px")("min-width", col_r11.getCellWidth())("max-width", col_r11.getCellWidth())("flex-basis", col_r11.getCellWidth());
    ɵngcc0.ɵɵclassProp("igx-grid-summary--cosy", ctx_r6.grid.displayDensity === "cosy")("igx-grid-summary--compact", ctx_r6.grid.displayDensity === "compact")("igx-grid-summary--empty", !col_r11.hasSummary)("igx-grid-summary--pinned-last", col_r11.isLastPinned);
    ɵngcc0.ɵɵproperty("column", col_r11)("rowIndex", ctx_r6.index)("firstCellIndentation", ctx_r6.firstCellIndentation)("summaryResults", ctx_r6.getColumnSummaries(col_r11.field))("hasSummary", col_r11.hasSummary)("density", ctx_r6.grid.displayDensity)("active", ctx_r6.isCellActive(col_r11.visibleIndex));
    ɵngcc0.ɵɵattribute("aria-describedby", ɵngcc0.ɵɵpipeBind3(1, 26, ctx_r6.gridID + "_" + col_r11.field, ".", "_"));
} }
function IgxSummaryRowComponent_ng_container_0_ng_container_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxSummaryRowComponent_ng_container_0_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSummaryRowComponent_ng_container_0_ng_container_6_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1)("ngTemplateOutletContext", ctx_r7.getContext(ctx_r7));
} }
function IgxSummaryRowComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSummaryRowComponent_ng_container_0_ng_container_1_Template, 2, 4, "ng-container", 0);
    ɵngcc0.ɵɵtemplate(2, IgxSummaryRowComponent_ng_container_0_ng_container_2_Template, 2, 2, "ng-container", 0);
    ɵngcc0.ɵɵtemplate(3, IgxSummaryRowComponent_ng_container_0_ng_template_3_Template, 2, 30, "ng-template", 2, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵpipe(5, "igxNotGrouped");
    ɵngcc0.ɵɵtemplate(6, IgxSummaryRowComponent_ng_container_0_ng_container_6_Template, 2, 2, "ng-container", 0);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.grid.summariesMargin);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.pinnedColumns.length > 0 && ctx_r0.grid.isPinningToStart);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(5, 9, ctx_r0.unpinnedColumns))("igxForScrollContainer", ctx_r0.grid.parentVirtDir)("igxForScrollOrientation", "horizontal")("igxForContainerSize", ctx_r0.grid.unpinnedWidth)("igxForTrackBy", ctx_r0.grid.trackColumnChanges)("igxForSizePropName", "calcPixelWidth");
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.pinnedColumns.length > 0 && !ctx_r0.grid.isPinningToStart);
} }
function IgxSummaryRowComponent_ng_template_1_igx_grid_summary_cell_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-cell", 8);
    ɵngcc0.ɵɵpipe(1, "igxStringReplace");
} if (rf & 2) {
    const col_r16 = ctx.$implicit;
    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("max-height", ctx_r15.minHeight, "px")("min-height", ctx_r15.minHeight, "px")("min-width", col_r16.getCellWidth())("max-width", col_r16.getCellWidth())("flex-basis", col_r16.getCellWidth())("left", col_r16.rightPinnedOffset);
    ɵngcc0.ɵɵclassProp("igx-grid-summary--cosy", ctx_r15.grid.displayDensity === "cosy")("igx-grid-summary--compact", ctx_r15.grid.displayDensity === "compact")("igx-grid-summary--empty", !col_r16.hasSummary)("igx-grid-summary--pinned-first", col_r16.isFirstPinned)("igx-grid-summary--pinned-last", col_r16.isLastPinned);
    ɵngcc0.ɵɵproperty("column", col_r16)("firstCellIndentation", ctx_r15.firstCellIndentation)("rowIndex", ctx_r15.index)("summaryResults", ctx_r15.getColumnSummaries(col_r16.field))("hasSummary", col_r16.hasSummary)("density", ctx_r15.grid.displayDensity)("active", ctx_r15.isCellActive(col_r16.visibleIndex));
    ɵngcc0.ɵɵattribute("aria-describedby", ɵngcc0.ɵɵpipeBind3(1, 30, ctx_r15.gridID + "_" + col_r16.field, ".", "_"));
} }
function IgxSummaryRowComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxSummaryRowComponent_ng_template_1_igx_grid_summary_cell_0_Template, 2, 34, "igx-grid-summary-cell", 7);
    ɵngcc0.ɵɵpipe(1, "igxNotGrouped");
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r2.pinnedColumns));
} }
const _c106 = ["leftPanningTmpl"];
const _c107 = ["rightPanningTmpl"];
function IgxListItemComponent_div_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7, 8);
    ɵngcc0.ɵɵtemplate(2, IgxListItemComponent_div_0_ng_container_2_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r0.element.offsetWidth, "px")("height", ctx_r0.element.offsetHeight, "px");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.list.listItemLeftPanningTemplate.template)("ngTemplateOutletContext", ctx_r0.context);
} }
function IgxListItemComponent_div_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10, 11);
    ɵngcc0.ɵɵtemplate(2, IgxListItemComponent_div_1_ng_container_2_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r1.element.offsetWidth, "px")("height", ctx_r1.element.offsetHeight, "px");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.list.listItemRightPanningTemplate.template)("ngTemplateOutletContext", ctx_r1.context);
} }
function IgxListItemComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function IgxListItemComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxListItemComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵprojection(1, 2);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxListItemComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵprojection(1, 3);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxListItemComponent_ng_container_10_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxListItemComponent_ng_container_10_ng_container_1_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
} }
function IgxListItemComponent_ng_container_11_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_ng_container_11_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_ng_container_11_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_ng_container_11_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 16);
    ɵngcc0.ɵɵtemplate(2, IgxListItemComponent_ng_container_11_ng_container_2_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵtemplate(3, IgxListItemComponent_ng_container_11_ng_container_3_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵtemplate(4, IgxListItemComponent_ng_container_11_ng_container_4_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵtemplate(5, IgxListItemComponent_ng_container_11_ng_container_5_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r4 = ɵngcc0.ɵɵreference(5);
    const _r6 = ɵngcc0.ɵɵreference(7);
    const _r8 = ɵngcc0.ɵɵreference(9);
    const _r2 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r8);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
} }
const _c108 = ["*", [["", "igxListThumbnail", ""], ["igx-list__item-thumbnail"], ["igx-avatar"]], [["", "igxListLine", ""], ["", 8, "igx-list__item-lines"], ["", "igxListLineTitle", ""], ["", "igxListLineSubTitle", ""], ["", 8, "igx-list__item-line-title"], ["", 8, "igx-list__item-line-subtitle"]], [["", "igxListAction", ""], ["", 8, "igx-list__item-actions"]]];
const _c109 = ["*", "[igxListThumbnail], igx-list__item-thumbnail, igx-avatar", "[igxListLine], .igx-list__item-lines, [igxListLineTitle], [igxListLineSubTitle], .igx-list__item-line-title, .igx-list__item-line-subtitle", "[igxListAction], .igx-list__item-actions"];
const _c110 = ["defaultEmptyList"];
const _c111 = ["defaultDataLoading"];
function IgxListComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "article", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.resourceStrings.igx_list_no_items, " ");
} }
function IgxListComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "article", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.resourceStrings.igx_list_loading, " ");
} }
function IgxListComponent_ng_container_5_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxListComponent_ng_container_5_ng_container_1_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.template)("ngTemplateOutletContext", ctx_r4.context);
} }
const _c112 = ["list"];
const _c113 = ["defaultExcelStyleLoadingValuesTemplate"];
function IgxExcelStyleSearchComponent_igx_icon_5_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 13);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleSearchComponent_igx_icon_5_Template_igx_icon_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.clearInput(); });
    ɵngcc0.ɵɵtext(1, " clear ");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxExcelStyleSearchComponent_igx_list_item_9_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-list-item");
    ɵngcc0.ɵɵelementStart(1, "igx-checkbox", 14);
    ɵngcc0.ɵɵlistener("change", function IgxExcelStyleSearchComponent_igx_list_item_9_Template_igx_checkbox_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onCheckboxChange($event); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r9 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", item_r9)("checked", item_r9.isSelected)("disableRipple", true)("indeterminate", item_r9.indeterminate)("disableTransitions", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", item_r9.label, " ");
} }
function IgxExcelStyleSearchComponent_ng_template_10_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxExcelStyleSearchComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵtemplate(1, IgxExcelStyleSearchComponent_ng_template_10_ng_container_1_Template, 1, 0, "ng-container", 16);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.valuesLoadingTemplate);
} }
function IgxExcelStyleSearchComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-circular-bar", 17);
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
const _c114 = ["defaultFilterUI"];
const _c115 = ["defaultDateUI"];
const _c116 = ["inputGroupConditions"];
const _c117 = ["inputGroupPrefix"];
const _c118 = ["operand"];
const _c119 = ["closeButton"];
const _c120 = ["operators"];
function IgxGridFilteringRowComponent_igx_drop_down_item_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-drop-down-item", 17);
    ɵngcc0.ɵɵelementStart(1, "div", 18);
    ɵngcc0.ɵɵelement(2, "igx-icon", 19);
    ɵngcc0.ɵɵelementStart(3, "span", 20);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const condition_r14 = ctx.$implicit;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", condition_r14)("selected", ctx_r1.isConditionSelected(condition_r14));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r1.getCondition(condition_r14).iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.translateCondition(condition_r14));
} }
function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template(rf, ctx) { if (rf & 1) {
    const _r20 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-suffix");
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 28);
    ɵngcc0.ɵɵlistener("keydown", function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template_igx_icon_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r20); const ctx_r19 = ɵngcc0.ɵɵnextContext(2); return ctx_r19.onCommitKeyDown($event); })("click", function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template_igx_icon_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r20); const ctx_r21 = ɵngcc0.ɵɵnextContext(2); return ctx_r21.onCommitClick(); });
    ɵngcc0.ɵɵtext(2, "done");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "igx-icon", 28);
    ɵngcc0.ɵɵlistener("keydown", function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template_igx_icon_keydown_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r20); const ctx_r22 = ɵngcc0.ɵɵnextContext(2); return ctx_r22.onClearKeyDown($event); })("click", function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template_igx_icon_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r20); const ctx_r23 = ɵngcc0.ɵɵnextContext(2); return ctx_r23.onClearClick(); });
    ɵngcc0.ɵɵtext(4, "clear");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridFilteringRowComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    const _r25 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 21, 22);
    ɵngcc0.ɵɵlistener("focusout", function IgxGridFilteringRowComponent_ng_template_3_Template_igx_input_group_focusout_0_listener() { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r24 = ɵngcc0.ɵɵnextContext(); return ctx_r24.onInputGroupFocusout(); });
    ɵngcc0.ɵɵelementStart(2, "igx-prefix", 23, 24);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_ng_template_3_Template_igx_prefix_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r26 = ɵngcc0.ɵɵnextContext(); return ctx_r26.inputGroupPrefixClick($event); })("keydown", function IgxGridFilteringRowComponent_ng_template_3_Template_igx_prefix_keydown_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r27 = ɵngcc0.ɵɵnextContext(); return ctx_r27.onPrefixKeyDown($event); });
    ɵngcc0.ɵɵelement(4, "igx-icon", 19);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "input", 25, 26);
    ɵngcc0.ɵɵlistener("input", function IgxGridFilteringRowComponent_ng_template_3_Template_input_input_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r28 = ɵngcc0.ɵɵnextContext(); return ctx_r28.onInput($event); })("click", function IgxGridFilteringRowComponent_ng_template_3_Template_input_click_5_listener() { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r29 = ɵngcc0.ɵɵnextContext(); return ctx_r29.onInputClick(); })("compositionstart", function IgxGridFilteringRowComponent_ng_template_3_Template_input_compositionstart_5_listener() { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r30 = ɵngcc0.ɵɵnextContext(); return ctx_r30.onCompositionStart(); })("compositionend", function IgxGridFilteringRowComponent_ng_template_3_Template_input_compositionend_5_listener() { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r31 = ɵngcc0.ɵɵnextContext(); return ctx_r31.onCompositionEnd(); })("keydown", function IgxGridFilteringRowComponent_ng_template_3_Template_input_keydown_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r32 = ɵngcc0.ɵɵnextContext(); return ctx_r32.onInputKeyDown($event); })("keyup", function IgxGridFilteringRowComponent_ng_template_3_Template_input_keyup_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r33 = ɵngcc0.ɵɵnextContext(); return ctx_r33.onInputKeyUp($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(7, IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template, 5, 0, "igx-suffix", 27);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r3.displayDensity);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("igxDropDownItemNavigation", _r0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r3.getIconName());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("placeholder", ctx_r3.placeholder)("value", ctx_r3.value)("type", ctx_r3.type)("readonly", ctx_r3.isUnaryCondition);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.value || ctx_r3.value === 0);
} }
function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_igx_suffix_8_Template(rf, ctx) { if (rf & 1) {
    const _r41 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-suffix");
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 28);
    ɵngcc0.ɵɵlistener("keydown", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_igx_suffix_8_Template_igx_icon_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r41); const ctx_r40 = ɵngcc0.ɵɵnextContext(3); return ctx_r40.onCommitKeyDown($event); })("click", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_igx_suffix_8_Template_igx_icon_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r41); const ctx_r42 = ɵngcc0.ɵɵnextContext(3); return ctx_r42.onCommitClick(); });
    ɵngcc0.ɵɵtext(2, "done");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "igx-icon", 28);
    ɵngcc0.ɵɵlistener("keydown", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_igx_suffix_8_Template_igx_icon_keydown_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r41); const ctx_r43 = ɵngcc0.ɵɵnextContext(3); return ctx_r43.onClearKeyDown($event); })("click", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_igx_suffix_8_Template_igx_icon_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r41); const ctx_r44 = ɵngcc0.ɵɵnextContext(3); return ctx_r44.clearInput(); });
    ɵngcc0.ɵɵtext(4, "clear");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r46 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 21, 22);
    ɵngcc0.ɵɵlistener("focusout", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template_igx_input_group_focusout_0_listener() { ɵngcc0.ɵɵrestoreView(_r46); const ctx_r45 = ɵngcc0.ɵɵnextContext(2); return ctx_r45.onInputGroupFocusout(); });
    ɵngcc0.ɵɵelementStart(2, "igx-prefix", 23, 24);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template_igx_prefix_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r46); const ctx_r47 = ɵngcc0.ɵɵnextContext(2); return ctx_r47.inputGroupPrefixClick($event); })("keydown", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template_igx_prefix_keydown_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r46); const ctx_r48 = ɵngcc0.ɵɵnextContext(2); return ctx_r48.onPrefixKeyDown($event); });
    ɵngcc0.ɵɵelement(4, "igx-icon", 19);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "input", 31, 26);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template_input_click_5_listener() { ɵngcc0.ɵɵrestoreView(_r46); const openDialog_r35 = ctx.openDialog; const _r36 = ɵngcc0.ɵɵreference(1); const ctx_r49 = ɵngcc0.ɵɵnextContext(2); return ctx_r49.expression.condition.isUnary ? ctx_r49.noop() : openDialog_r35(_r36.element.nativeElement); })("keydown", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template_input_keydown_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r46); const ctx_r50 = ɵngcc0.ɵɵnextContext(2); return ctx_r50.onInputKeyDown($event); });
    ɵngcc0.ɵɵpipe(7, "date");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(8, IgxGridFilteringRowComponent_ng_template_5_ng_template_1_igx_suffix_8_Template, 5, 0, "igx-suffix", 27);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r34 = ɵngcc0.ɵɵnextContext(2);
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r34.displayDensity);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("igxDropDownItemNavigation", _r0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r34.expression.condition.iconName);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("placeholder", ctx_r34.placeholder)("value", ɵngcc0.ɵɵpipeBind4(7, 7, ctx_r34.value, ctx_r34.column.pipeArgs.format, undefined, ctx_r34.filteringService.grid.locale))("readonly", true);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r34.value);
} }
function IgxGridFilteringRowComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    const _r52 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-date-picker", 29);
    ɵngcc0.ɵɵlistener("onSelection", function IgxGridFilteringRowComponent_ng_template_5_Template_igx_date_picker_onSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r52); const ctx_r51 = ɵngcc0.ɵɵnextContext(); return ctx_r51.onDateSelected($event); })("onClosed", function IgxGridFilteringRowComponent_ng_template_5_Template_igx_date_picker_onClosed_0_listener() { ɵngcc0.ɵɵrestoreView(_r52); const ctx_r53 = ɵngcc0.ɵɵnextContext(); return ctx_r53.datePickerClose(); });
    ɵngcc0.ɵɵtemplate(1, IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template, 9, 12, "ng-template", 30);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", ctx_r5.value)("outlet", ctx_r5.filteringService.grid.outlet)("locale", ctx_r5.filteringService.grid.locale);
} }
function IgxGridFilteringRowComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridFilteringRowComponent_button_8_Template(rf, ctx) { if (rf & 1) {
    const _r55 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 32);
    ɵngcc0.ɵɵlistener("keydown", function IgxGridFilteringRowComponent_button_8_Template_button_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r55); const ctx_r54 = ɵngcc0.ɵɵnextContext(); return ctx_r54.onLeftArrowKeyDown($event); })("click", function IgxGridFilteringRowComponent_button_8_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r55); const ctx_r56 = ɵngcc0.ɵɵnextContext(); return ctx_r56.scrollChipsOnArrowPress("left"); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon");
    ɵngcc0.ɵɵtext(2, "navigate_before");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridFilteringRowComponent_ng_container_14_span_6_Template(rf, ctx) { if (rf & 1) {
    const _r64 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 38);
    ɵngcc0.ɵɵelementStart(1, "button", 39);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_ng_container_14_span_6_Template_button_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r64); const i_r58 = ɵngcc0.ɵɵnextContext().index; const ctx_r63 = ɵngcc0.ɵɵnextContext(); return ctx_r63.toggleOperatorsDropDown($event, i_r58); });
    ɵngcc0.ɵɵelementStart(2, "igx-icon");
    ɵngcc0.ɵɵtext(3, "expand_more");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "igx-drop-down", 40, 41);
    ɵngcc0.ɵɵlistener("onSelection", function IgxGridFilteringRowComponent_ng_container_14_span_6_Template_igx_drop_down_onSelection_6_listener($event) { ɵngcc0.ɵɵrestoreView(_r64); const item_r57 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r66 = ɵngcc0.ɵɵnextContext(); return ctx_r66.onLogicOperatorChanged($event, item_r57); });
    ɵngcc0.ɵɵelementStart(8, "igx-drop-down-item", 17);
    ɵngcc0.ɵɵtext(9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(10, "igx-drop-down-item", 17);
    ɵngcc0.ɵɵtext(11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r62 = ɵngcc0.ɵɵreference(7);
    const item_r57 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r61 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxDropDownItemNavigation", _r62)("displayDensity", ctx_r61.column.grid.displayDensity);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r61.filteringService.getOperatorAsString(item_r57.afterOperator));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r61.column.grid.displayDensity);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("value", 0)("selected", item_r57.afterOperator === 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r61.filteringService.grid.resourceStrings.igx_grid_filter_operator_and);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", 1)("selected", item_r57.afterOperator === 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r61.filteringService.grid.resourceStrings.igx_grid_filter_operator_or);
} }
function IgxGridFilteringRowComponent_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    const _r70 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0, 33);
    ɵngcc0.ɵɵelementStart(1, "igx-chip", 34, 35);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxGridFilteringRowComponent_ng_container_14_Template_igx_chip_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r70); const _r60 = ɵngcc0.ɵɵreference(2); const ctx_r69 = ɵngcc0.ɵɵnextContext(); return ctx_r69.onChipPointerdown($event, _r60); })("click", function IgxGridFilteringRowComponent_ng_container_14_Template_igx_chip_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r70); const item_r57 = ctx.$implicit; const ctx_r71 = ɵngcc0.ɵɵnextContext(); return ctx_r71.onChipClick($event, item_r57); })("keydown", function IgxGridFilteringRowComponent_ng_container_14_Template_igx_chip_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r70); const item_r57 = ctx.$implicit; const ctx_r72 = ɵngcc0.ɵɵnextContext(); return ctx_r72.onChipKeyDown($event, item_r57); })("onRemove", function IgxGridFilteringRowComponent_ng_container_14_Template_igx_chip_onRemove_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r70); const item_r57 = ctx.$implicit; const ctx_r73 = ɵngcc0.ɵɵnextContext(); return ctx_r73.onChipRemoved($event, item_r57); });
    ɵngcc0.ɵɵelement(3, "igx-icon", 36);
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, IgxGridFilteringRowComponent_ng_container_14_span_6_Template, 12, 10, "span", 37);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r57 = ctx.$implicit;
    const last_r59 = ctx.last;
    const ctx_r10 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("selectable", false)("selected", item_r57.isSelected)("displayDensity", ctx_r10.displayDensity)("removable", true);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", item_r57.expression.condition.iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r10.filteringService.getChipLabel(item_r57.expression));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r59);
} }
function IgxGridFilteringRowComponent_button_15_Template(rf, ctx) { if (rf & 1) {
    const _r75 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 42);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_button_15_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r75); const ctx_r74 = ɵngcc0.ɵɵnextContext(); return ctx_r74.scrollChipsOnArrowPress("right"); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon");
    ɵngcc0.ɵɵtext(2, "navigate_next");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
const _c121 = ["editingInputsContainer"];
const _c122 = ["addModeContainer"];
const _c123 = ["currentGroupButtonsContainer"];
const _c124 = ["columnSelect"];
const _c125 = ["conditionSelect"];
const _c126 = ["searchValueInput"];
const _c127 = ["addRootAndGroupButton"];
const _c128 = ["addConditionButton"];
const _c129 = ["expressionsContainer"];
const _c130 = ["overlayOutlet"];
function IgxAdvancedFilteringDialogComponent_article_0_ng_container_13_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 20, 21);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_13_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.addAndGroup(); });
    ɵngcc0.ɵɵelementStart(3, "igx-icon", 22);
    ɵngcc0.ɵɵtext(4, "add");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "span");
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "button", 20);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_13_Template_button_click_7_listener() { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r16 = ɵngcc0.ɵɵnextContext(2); return ctx_r16.addOrGroup(); });
    ɵngcc0.ɵɵelementStart(8, "igx-icon", 22);
    ɵngcc0.ɵɵtext(9, "add");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(10, "span");
    ɵngcc0.ɵɵtext(11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(12, "div", 23);
    ɵngcc0.ɵɵelementStart(13, "h6", 24);
    ɵngcc0.ɵɵtext(14);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r3.displayDensity);
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.grid.resourceStrings.igx_grid_advanced_filter_and_group);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r3.displayDensity);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.grid.resourceStrings.igx_grid_advanced_filter_or_group);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.grid.resourceStrings.igx_grid_advanced_filter_initial_text, " ");
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template(rf, ctx) { if (rf & 1) {
    const _r21 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 25, 26);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r21); const expressionItem_r17 = ctx.$implicit; const afterExpression_r18 = ctx.afterExpression; const ctx_r20 = ɵngcc0.ɵɵnextContext(2); return ctx_r20.addCondition(expressionItem_r17, afterExpression_r18); });
    ɵngcc0.ɵɵelementStart(2, "igx-icon", 22);
    ɵngcc0.ɵɵtext(3, "add");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "button", 25);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template_button_click_6_listener() { ɵngcc0.ɵɵrestoreView(_r21); const expressionItem_r17 = ctx.$implicit; const afterExpression_r18 = ctx.afterExpression; const ctx_r22 = ɵngcc0.ɵɵnextContext(2); return ctx_r22.addAndGroup(expressionItem_r17, afterExpression_r18); });
    ɵngcc0.ɵɵelementStart(7, "igx-icon", 22);
    ɵngcc0.ɵɵtext(8, "add");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "span");
    ɵngcc0.ɵɵtext(10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(11, "button", 25);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template_button_click_11_listener() { ɵngcc0.ɵɵrestoreView(_r21); const expressionItem_r17 = ctx.$implicit; const afterExpression_r18 = ctx.afterExpression; const ctx_r23 = ɵngcc0.ɵɵnextContext(2); return ctx_r23.addOrGroup(expressionItem_r17, afterExpression_r18); });
    ɵngcc0.ɵɵelementStart(12, "igx-icon", 22);
    ɵngcc0.ɵɵtext(13, "add");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(14, "span");
    ɵngcc0.ɵɵtext(15);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r5.displayDensity)("disabled", ctx_r5.editedExpression);
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵtextInterpolate(ctx_r5.grid.resourceStrings.igx_grid_advanced_filter_add_condition);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r5.displayDensity)("disabled", ctx_r5.editedExpression);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r5.grid.resourceStrings.igx_grid_advanced_filter_and_group);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r5.displayDensity)("disabled", ctx_r5.editedExpression);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r5.grid.resourceStrings.igx_grid_advanced_filter_or_group);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_span_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 37);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "date");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r24 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r28 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r28.isDate(expressionItem_r24.expression.searchVal) ? ɵngcc0.ɵɵpipeBind4(2, 1, expressionItem_r24.expression.searchVal, ctx_r28.getFormat(expressionItem_r24.expression.fieldName), undefined, ctx_r28.grid.locale) : expressionItem_r24.expression.searchVal, " ");
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_igx_icon_3_Template(rf, ctx) { if (rf & 1) {
    const _r33 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 39);
    ɵngcc0.ɵɵlistener("keydown", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_igx_icon_3_Template_igx_icon_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r32 = ɵngcc0.ɵɵnextContext(5); return ctx_r32.invokeClick($event); })("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_igx_icon_3_Template_igx_icon_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r33); const expressionItem_r24 = ɵngcc0.ɵɵnextContext(3).$implicit; const ctx_r34 = ɵngcc0.ɵɵnextContext(2); return ctx_r34.enterExpressionAdd(expressionItem_r24); });
    ɵngcc0.ɵɵtext(1, " add ");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_Template(rf, ctx) { if (rf & 1) {
    const _r37 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 38);
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 39);
    ɵngcc0.ɵɵlistener("keydown", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_Template_igx_icon_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r37); const ctx_r36 = ɵngcc0.ɵɵnextContext(4); return ctx_r36.invokeClick($event); })("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_Template_igx_icon_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r37); const expressionItem_r24 = ɵngcc0.ɵɵnextContext(2).$implicit; const ctx_r38 = ɵngcc0.ɵɵnextContext(2); return ctx_r38.enterExpressionEdit(expressionItem_r24); });
    ɵngcc0.ɵɵtext(2, " edit ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_igx_icon_3_Template, 2, 0, "igx-icon", 40);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r24 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r29 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", !expressionItem_r24.inAddMode && (expressionItem_r24.parent !== ctx_r29.currentGroup || expressionItem_r24 !== ctx_r29.currentGroup.children[ctx_r29.currentGroup.children.length - 1]));
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r43 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 30);
    ɵngcc0.ɵɵlistener("mouseenter", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_div_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r43); const expressionItem_r24 = ɵngcc0.ɵɵnextContext().$implicit; return expressionItem_r24.hovered = true; })("mouseleave", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_div_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r43); const expressionItem_r24 = ɵngcc0.ɵɵnextContext().$implicit; return expressionItem_r24.hovered = false; });
    ɵngcc0.ɵɵelementStart(1, "igx-chip", 31);
    ɵngcc0.ɵɵlistener("keydown", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r43); const ctx_r46 = ɵngcc0.ɵɵnextContext(3); return ctx_r46.invokeClick($event); })("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r43); const expressionItem_r24 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r47 = ɵngcc0.ɵɵnextContext(2); return ctx_r47.onChipClick(expressionItem_r24); })("dblclick", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_dblclick_1_listener() { ɵngcc0.ɵɵrestoreView(_r43); const expressionItem_r24 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r49 = ɵngcc0.ɵɵnextContext(2); return ctx_r49.onChipDblClick(expressionItem_r24); })("onRemove", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_onRemove_1_listener() { ɵngcc0.ɵɵrestoreView(_r43); const expressionItem_r24 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r51 = ɵngcc0.ɵɵnextContext(2); return ctx_r51.onChipRemove(expressionItem_r24); })("onSelectionDone", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_onSelectionDone_1_listener() { ɵngcc0.ɵɵrestoreView(_r43); const ctx_r53 = ɵngcc0.ɵɵnextContext(3); return ctx_r53.onChipSelectionEnd(); });
    ɵngcc0.ɵɵelementStart(2, "span", 32);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "igx-prefix");
    ɵngcc0.ɵɵelement(5, "igx-icon", 33);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "span", 34);
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(8, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_span_8_Template, 3, 6, "span", 35);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(9, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_Template, 4, 1, "div", 36);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r24 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r25 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("data", expressionItem_r24)("displayDensity", ctx_r25.displayDensity === "compact" ? "cosy" : ctx_r25.displayDensity)("removable", true)("selected", expressionItem_r24.selected);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(expressionItem_r24.columnHeader || expressionItem_r24.expression.fieldName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", expressionItem_r24.expression.condition.iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r25.getConditionFriendlyName(expressionItem_r24.expression.condition.name), " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !expressionItem_r24.expression.condition.isUnary);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", expressionItem_r24.selected && ctx_r25.selectedExpressions.length === 1 || expressionItem_r24.hovered);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_select_item_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-select-item", 53);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r63 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("value", column_r63);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", column_r63.header || column_r63.field, " ");
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_prefix_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-prefix");
    ɵngcc0.ɵɵelement(1, "igx-icon", 33);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r58 = ɵngcc0.ɵɵreference(6);
    const ctx_r59 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r59.selectedColumn.filters.condition(_r58.value).iconName);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_select_item_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-select-item", 53);
    ɵngcc0.ɵɵelementStart(1, "div", 54);
    ɵngcc0.ɵɵelement(2, "igx-icon", 33);
    ɵngcc0.ɵɵelementStart(3, "span", 55);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const condition_r64 = ctx.$implicit;
    const ctx_r60 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵproperty("value", condition_r64);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r60.selectedColumn.filters.condition(condition_r64).iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r60.getConditionFriendlyName(condition_r64));
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_input_group_9_Template(rf, ctx) { if (rf & 1) {
    const _r67 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 56);
    ɵngcc0.ɵɵelementStart(1, "input", 57, 58);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_input_group_9_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r67); const ctx_r66 = ɵngcc0.ɵɵnextContext(4); return ctx_r66.searchValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r61 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵproperty("disabled", !ctx_r61.selectedColumn || !ctx_r61.selectedCondition || ctx_r61.selectedColumn && ctx_r61.selectedColumn.filters.condition(ctx_r61.selectedCondition).isUnary)("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("type", ctx_r61.selectedColumn && ctx_r61.selectedColumn.dataType === "number" ? "number" : "text")("placeholder", ctx_r61.grid.resourceStrings.igx_grid_advanced_filter_value_placeholder)("ngModel", ctx_r61.searchValue);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r74 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 61, 62);
    ɵngcc0.ɵɵelementStart(2, "input", 63, 58);
    ɵngcc0.ɵɵlistener("keydown", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_ng_template_1_Template_input_keydown_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r74); const ctx_r73 = ɵngcc0.ɵɵnextContext(5); return ctx_r73.invokeClick($event); })("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_ng_template_1_Template_input_click_2_listener() { ɵngcc0.ɵɵrestoreView(_r74); const openDialog_r69 = ctx.openDialog; const _r71 = ɵngcc0.ɵɵreference(1); return openDialog_r69(_r71.element.nativeElement); });
    ɵngcc0.ɵɵpipe(4, "date");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const value_r70 = ctx.value;
    const ctx_r68 = ɵngcc0.ɵɵnextContext(5);
    ɵngcc0.ɵɵproperty("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("placeholder", ctx_r68.grid.resourceStrings.igx_grid_filter_row_date_placeholder)("value", ɵngcc0.ɵɵpipeBind4(4, 5, value_r70, ctx_r68.selectedColumn.pipeArgs.format, undefined, ctx_r68.grid.locale))("readonly", true)("disabled", !ctx_r68.selectedColumn || !ctx_r68.selectedCondition || ctx_r68.selectedColumn && ctx_r68.selectedColumn.filters.condition(ctx_r68.selectedCondition).isUnary);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_Template(rf, ctx) { if (rf & 1) {
    const _r77 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-date-picker", 59);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_Template_igx_date_picker_ngModelChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r77); const ctx_r76 = ɵngcc0.ɵɵnextContext(4); return ctx_r76.searchValue = $event; });
    ɵngcc0.ɵɵtemplate(1, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_ng_template_1_Template, 5, 10, "ng-template", 60);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r62 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r62.searchValue)("locale", ctx_r62.grid.locale)("outlet", ctx_r62.grid.outlet);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r79 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 41, 42);
    ɵngcc0.ɵɵelementStart(2, "igx-select", 43, 44);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template_igx_select_ngModelChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r79); const ctx_r78 = ɵngcc0.ɵɵnextContext(3); return ctx_r78.selectedColumn = $event; });
    ɵngcc0.ɵɵtemplate(4, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_select_item_4_Template, 2, 2, "igx-select-item", 45);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "igx-select", 46, 47);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template_igx_select_ngModelChange_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r79); const ctx_r80 = ɵngcc0.ɵɵnextContext(3); return ctx_r80.selectedCondition = $event; });
    ɵngcc0.ɵɵtemplate(7, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_prefix_7_Template, 2, 1, "igx-prefix", 11);
    ɵngcc0.ɵɵtemplate(8, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_select_item_8_Template, 5, 3, "igx-select-item", 45);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(9, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_input_group_9_Template, 3, 5, "igx-input-group", 48);
    ɵngcc0.ɵɵtemplate(10, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_Template, 2, 3, "igx-date-picker", 49);
    ɵngcc0.ɵɵelementStart(11, "div", 50);
    ɵngcc0.ɵɵelementStart(12, "button", 51);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template_button_click_12_listener() { ɵngcc0.ɵɵrestoreView(_r79); const ctx_r81 = ɵngcc0.ɵɵnextContext(3); return ctx_r81.commitOperandEdit(); });
    ɵngcc0.ɵɵelementStart(13, "igx-icon", 22);
    ɵngcc0.ɵɵtext(14, "check");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(15, "button", 52);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template_button_click_15_listener() { ɵngcc0.ɵɵrestoreView(_r79); const ctx_r82 = ɵngcc0.ɵɵnextContext(3); return ctx_r82.cancelOperandEdit(); });
    ɵngcc0.ɵɵelementStart(16, "igx-icon", 22);
    ɵngcc0.ɵɵtext(17, "close");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r58 = ɵngcc0.ɵɵreference(6);
    const ctx_r26 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", "compact")("overlaySettings", ctx_r26.columnSelectOverlaySettings)("placeholder", ctx_r26.grid.resourceStrings.igx_grid_advanced_filter_column_placeholder)("ngModel", ctx_r26.selectedColumn);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r26.filterableColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", "compact")("overlaySettings", ctx_r26.conditionSelectOverlaySettings)("placeholder", ctx_r26.grid.resourceStrings.igx_grid_filter_condition_placeholder)("ngModel", ctx_r26.selectedCondition)("disabled", !ctx_r26.selectedColumn);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r26.selectedColumn && _r58.value && ctx_r26.selectedColumn.filters.condition(_r58.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r26.getConditionList());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r26.selectedColumn || ctx_r26.selectedColumn.dataType !== "date");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r26.selectedColumn && ctx_r26.selectedColumn.dataType === "date");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r26.displayDensity)("disabled", !ctx_r26.operandCanBeCommitted());
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r26.displayDensity);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r86 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 64, 65);
    ɵngcc0.ɵɵtemplate(2, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_ng_container_2_Template, 1, 0, "ng-container", 66);
    ɵngcc0.ɵɵelementStart(3, "button", 52);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_Template_button_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r86); const ctx_r85 = ɵngcc0.ɵɵnextContext(3); return ctx_r85.cancelOperandAdd(); });
    ɵngcc0.ɵɵelementStart(4, "igx-icon", 22);
    ɵngcc0.ɵɵtext(5, "close");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r24 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵnextContext();
    const _r4 = ɵngcc0.ɵɵreference(15);
    const ctx_r27 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4)("ngTemplateOutletContext", ctx_r27.context(expressionItem_r24.parent, expressionItem_r24));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r27.displayDensity);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template, 10, 9, "div", 27);
    ɵngcc0.ɵɵtemplate(1, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template, 18, 17, "div", 28);
    ɵngcc0.ɵɵtemplate(2, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_Template, 6, 3, "div", 29);
} if (rf & 2) {
    const expressionItem_r24 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngIf", !expressionItem_r24.inEditMode);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", expressionItem_r24.inEditMode);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", expressionItem_r24.inAddMode);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_ng_container_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_ng_container_3_ng_container_1_Template, 1, 0, "ng-container", 66);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const expr_r91 = ctx.$implicit;
    ɵngcc0.ɵɵnextContext(2);
    const _r8 = ɵngcc0.ɵɵreference(19);
    const _r6 = ɵngcc0.ɵɵreference(17);
    const ctx_r89 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r89.isExpressionGroup(expr_r91) ? _r8 : _r6)("ngTemplateOutletContext", ctx_r89.context(expr_r91));
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r98 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 25);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_button_3_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r98); const expressionItem_r88 = ɵngcc0.ɵɵnextContext(2).$implicit; const ctx_r96 = ɵngcc0.ɵɵnextContext(2); return ctx_r96.endGroup(expressionItem_r88); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r88 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r95 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r95.displayDensity)("disabled", ctx_r95.editedExpression || expressionItem_r88.children.length < 2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r95.grid.resourceStrings.igx_grid_advanced_filter_end_group);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 64, 71);
    ɵngcc0.ɵɵtemplate(2, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_ng_container_2_Template, 1, 0, "ng-container", 66);
    ɵngcc0.ɵɵtemplate(3, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_button_3_Template, 3, 3, "button", 72);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r88 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵnextContext();
    const _r4 = ɵngcc0.ɵɵreference(15);
    const ctx_r90 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4)("ngTemplateOutletContext", ctx_r90.context(expressionItem_r88));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", expressionItem_r88 !== ctx_r90.rootGroup);
} }
const _c131 = function (a0, a1, a2) { return { "igx-filter-tree__line--and": a0, "igx-filter-tree__line--or": a1, "igx-filter-tree__line--selected": a2 }; };
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_Template(rf, ctx) { if (rf & 1) {
    const _r102 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 67);
    ɵngcc0.ɵɵelementStart(1, "div", 68);
    ɵngcc0.ɵɵlistener("keydown", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_Template_div_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r102); const ctx_r101 = ɵngcc0.ɵɵnextContext(2); return ctx_r101.invokeClick($event); })("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_Template_div_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r102); const expressionItem_r88 = ctx.$implicit; const ctx_r103 = ɵngcc0.ɵɵnextContext(2); return ctx_r103.onGroupClick(expressionItem_r88); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "div", 69);
    ɵngcc0.ɵɵtemplate(3, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_ng_container_3_Template, 2, 2, "ng-container", 70);
    ɵngcc0.ɵɵtemplate(4, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_Template, 4, 3, "div", 29);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r88 = ctx.$implicit;
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction3(3, _c131, expressionItem_r88.operator === 0, expressionItem_r88.operator === 1, expressionItem_r88.selected));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", expressionItem_r88.children);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r9.currentGroup === expressionItem_r88);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_container_20_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_container_20_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxAdvancedFilteringDialogComponent_article_0_ng_container_20_ng_container_1_Template, 1, 0, "ng-container", 66);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r8 = ɵngcc0.ɵɵreference(19);
    const ctx_r10 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r8)("ngTemplateOutletContext", ctx_r10.context(ctx_r10.rootGroup));
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template(rf, ctx) { if (rf & 1) {
    const _r106 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-buttongroup", 73);
    ɵngcc0.ɵɵlistener("onSelect", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template_igx_buttongroup_onSelect_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r106); const ctx_r105 = ɵngcc0.ɵɵnextContext(2); return ctx_r105.selectFilteringLogic($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "button", 25);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template_button_click_2_listener() { ɵngcc0.ɵɵrestoreView(_r106); const ctx_r107 = ɵngcc0.ɵɵnextContext(2); return ctx_r107.ungroup(); });
    ɵngcc0.ɵɵelement(3, "igx-icon", 74);
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "button", 75);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template_button_click_6_listener() { ɵngcc0.ɵɵrestoreView(_r106); const ctx_r108 = ɵngcc0.ɵɵnextContext(2); return ctx_r108.deleteGroup(); });
    ɵngcc0.ɵɵelementStart(7, "igx-icon");
    ɵngcc0.ɵɵtext(8, "delete");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "span");
    ɵngcc0.ɵɵtext(10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r11.displayDensity)("multiSelection", false)("values", ctx_r11.filteringLogics);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r11.displayDensity)("disabled", !ctx_r11.contextualGroup.parent);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r11.grid.resourceStrings.igx_grid_advanced_filter_ungroup);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r11.displayDensity);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r11.grid.resourceStrings.igx_grid_advanced_filter_delete);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template(rf, ctx) { if (rf & 1) {
    const _r110 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 20);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r110); const ctx_r109 = ɵngcc0.ɵɵnextContext(2); return ctx_r109.createAndGroup(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "button", 20);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template_button_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r110); const ctx_r111 = ɵngcc0.ɵɵnextContext(2); return ctx_r111.createOrGroup(); });
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "button", 75);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template_button_click_5_listener() { ɵngcc0.ɵɵrestoreView(_r110); const ctx_r112 = ɵngcc0.ɵɵnextContext(2); return ctx_r112.deleteFilters(); });
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r12.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r12.grid.resourceStrings.igx_grid_advanced_filter_create_and_group, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r12.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r12.grid.resourceStrings.igx_grid_advanced_filter_create_or_group, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r12.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r12.grid.resourceStrings.igx_grid_advanced_filter_delete_filters, " ");
} }
const _c132 = function (a0, a1, a2) { return { "igx-advanced-filter--cosy": a0, "igx-advanced-filter--compact": a1, "igx-advanced-filter--inline": a2 }; };
const _c133 = function (a0, a1) { return { "igx-filter-contextual-menu--cosy": a0, "igx-filter-contextual-menu--compact": a1 }; };
function IgxAdvancedFilteringDialogComponent_article_0_Template(rf, ctx) { if (rf & 1) {
    const _r114 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "article", 3);
    ɵngcc0.ɵɵlistener("dragStart", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_dragStart_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r114); const ctx_r113 = ɵngcc0.ɵɵnextContext(); return ctx_r113.dragStart($event); })("dragEnd", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_dragEnd_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r114); const ctx_r115 = ɵngcc0.ɵɵnextContext(); return ctx_r115.dragEnd($event); })("dragMove", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_dragMove_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r114); const ctx_r116 = ɵngcc0.ɵɵnextContext(); return ctx_r116.onDragMove($event); })("keydown", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r114); const ctx_r117 = ɵngcc0.ɵɵnextContext(); return ctx_r117.onKeyDown($event); });
    ɵngcc0.ɵɵelementStart(1, "header", 4);
    ɵngcc0.ɵɵelementStart(2, "h4", 5);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "div", 6);
    ɵngcc0.ɵɵelementStart(5, "div", 7);
    ɵngcc0.ɵɵelementStart(6, "span");
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "div", 8);
    ɵngcc0.ɵɵelementStart(9, "span");
    ɵngcc0.ɵɵtext(10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(11, "article", 9, 10);
    ɵngcc0.ɵɵlistener("scroll", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_scroll_11_listener() { ɵngcc0.ɵɵrestoreView(_r114); const ctx_r118 = ɵngcc0.ɵɵnextContext(); return ctx_r118.onExpressionsScrolled(); });
    ɵngcc0.ɵɵtemplate(13, IgxAdvancedFilteringDialogComponent_article_0_ng_container_13_Template, 15, 5, "ng-container", 11);
    ɵngcc0.ɵɵtemplate(14, IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template, 16, 9, "ng-template", null, 12, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(16, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_Template, 3, 3, "ng-template", null, 13, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(18, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_Template, 5, 7, "ng-template", null, 14, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(20, IgxAdvancedFilteringDialogComponent_article_0_ng_container_20_Template, 2, 2, "ng-container", 11);
    ɵngcc0.ɵɵelementStart(21, "div", 15);
    ɵngcc0.ɵɵlistener("keydown", function IgxAdvancedFilteringDialogComponent_article_0_Template_div_keydown_21_listener($event) { ɵngcc0.ɵɵrestoreView(_r114); const ctx_r119 = ɵngcc0.ɵɵnextContext(); return ctx_r119.onKeyDown($event); })("onClosed", function IgxAdvancedFilteringDialogComponent_article_0_Template_div_onClosed_21_listener() { ɵngcc0.ɵɵrestoreView(_r114); const ctx_r120 = ɵngcc0.ɵɵnextContext(); return ctx_r120.contextMenuClosed(); });
    ɵngcc0.ɵɵelementStart(22, "button", 16);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_Template_button_click_22_listener() { ɵngcc0.ɵɵrestoreView(_r114); const ctx_r121 = ɵngcc0.ɵɵnextContext(); return ctx_r121.clearSelection(); });
    ɵngcc0.ɵɵelementStart(23, "igx-icon");
    ɵngcc0.ɵɵtext(24, "close");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(25, IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template, 11, 8, "ng-container", 11);
    ɵngcc0.ɵɵtemplate(26, IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template, 7, 6, "ng-container", 11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(27, "footer", 17);
    ɵngcc0.ɵɵelementStart(28, "button", 18);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_Template_button_click_28_listener() { ɵngcc0.ɵɵrestoreView(_r114); const ctx_r122 = ɵngcc0.ɵɵnextContext(); return ctx_r122.onClearButtonClick(); });
    ɵngcc0.ɵɵtext(29);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(30, "div");
    ɵngcc0.ɵɵelementStart(31, "button", 18);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_Template_button_click_31_listener() { ɵngcc0.ɵɵrestoreView(_r114); const ctx_r123 = ɵngcc0.ɵɵnextContext(); return ctx_r123.cancelChanges(); });
    ɵngcc0.ɵɵtext(32);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(33, "button", 19);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_Template_button_click_33_listener() { ɵngcc0.ɵɵrestoreView(_r114); const ctx_r124 = ɵngcc0.ɵɵnextContext(); return ctx_r124.onApplyButtonClick(); });
    ɵngcc0.ɵɵtext(34);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ghost", false)("dragTolerance", 0)("ngClass", ɵngcc0.ɵɵpureFunction3(17, _c132, ctx_r0.grid.displayDensity === "cosy", ctx_r0.grid.displayDensity === "compact", ctx_r0.inline));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.grid.resourceStrings.igx_grid_advanced_filter_title, " ");
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.grid.resourceStrings.igx_grid_advanced_filter_and_label);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.grid.resourceStrings.igx_grid_advanced_filter_or_label);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.rootGroup);
    ɵngcc0.ɵɵadvance(7);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.rootGroup);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(21, _c133, ctx_r0.displayDensity === "cosy", ctx_r0.displayDensity === "compact"));
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.contextualGroup);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.contextualGroup);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r0.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.grid.resourceStrings.igx_grid_excel_custom_dialog_clear);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r0.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.grid.resourceStrings.igx_grid_excel_cancel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r0.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.grid.resourceStrings.igx_grid_excel_apply, " ");
} }
function IgxSnackbarComponent_div_0_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("click", function IgxSnackbarComponent_div_0_button_4_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(2); return ctx_r2.triggerAction(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("@fadeInOut", undefined);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.actionText, " ");
} }
function IgxSnackbarComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵlistener("@slideInOut.start", function IgxSnackbarComponent_div_0_Template_div_animation_slideInOut_start_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.snackbarAnimationStarted($event); })("@slideInOut.done", function IgxSnackbarComponent_div_0_Template_div_animation_slideInOut_done_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.snackbarAnimationDone($event); });
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵprojection(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, IgxSnackbarComponent_div_0_button_4_Template, 2, 2, "button", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@slideInOut", ctx_r0.isVisible);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("@fadeInOut", ctx_r0.isVisible);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.snackbarMessage, " ");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.actionText);
} }
const _c134 = ["toolbar"];
const _c135 = ["defaultExpandedTemplate"];
const _c136 = ["defaultCollapsedTemplate"];
const _c137 = ["loadingOverlay"];
const _c138 = ["igxLoadingOverlayOutlet"];
const _c139 = ["emptyFilteredGrid"];
const _c140 = ["defaultEmptyGrid"];
const _c141 = ["defaultLoadingGrid"];
const _c142 = ["verticalScrollContainer"];
const _c143 = ["verticalScrollHolder"];
const _c144 = ["scr"];
const _c145 = ["footer"];
const _c146 = ["hContainer"];
const _c147 = ["headerSelectorContainer"];
const _c148 = ["headerDragContainer"];
const _c149 = ["headerGroupContainer"];
const _c150 = ["filteringRow"];
const _c151 = ["theadRow"];
const _c152 = ["tbody"];
const _c153 = ["pinContainer"];
const _c154 = ["tfoot"];
const _c155 = ["igxFilteringOverlayOutlet"];
const _c156 = ["igxRowEditingOverlayOutlet"];
const _c157 = ["dragIndicatorIconBase"];
const _c158 = ["defaultRowEditTemplate"];
const _c159 = ["row"];
const _c160 = ["pinnedRow"];
const _c161 = ["summaryRow"];
const _c162 = ["defaultGroupByExpandedTemplate"];
const _c163 = ["defaultGroupByCollapsedTemplate"];
const _c164 = ["groupContent"];
function IgxGridGroupByRowComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridGroupByRowComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridGroupByRowComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 8);
    ɵngcc0.ɵɵtext(1, "expand_more");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridGroupByRowComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 8);
    ɵngcc0.ɵɵtext(1, "chevron_right");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridGroupByRowComponent_ng_template_11_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span", 15);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r10.groupRow.value);
} }
function IgxGridGroupByRowComponent_ng_template_11_ng_template_6_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span", 15);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵpipe(3, "number");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(3, 1, ctx_r13.groupRow.value));
} }
function IgxGridGroupByRowComponent_ng_template_11_ng_template_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span", 15);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵpipe(3, "date");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(3, 1, ctx_r14.groupRow.value));
} }
function IgxGridGroupByRowComponent_ng_template_11_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridGroupByRowComponent_ng_template_11_ng_template_6_ng_container_0_Template, 4, 3, "ng-container", 16);
    ɵngcc0.ɵɵtemplate(1, IgxGridGroupByRowComponent_ng_template_11_ng_template_6_ng_container_1_Template, 4, 3, "ng-container", 16);
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r12.dataType === "number");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r12.dataType === "date");
} }
function IgxGridGroupByRowComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 10);
    ɵngcc0.ɵɵtext(2, "group_work");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "span", 11);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxGridGroupByRowComponent_ng_template_11_ng_container_5_Template, 3, 1, "ng-container", 12);
    ɵngcc0.ɵɵtemplate(6, IgxGridGroupByRowComponent_ng_template_11_ng_template_6_Template, 2, 2, "ng-template", null, 13, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelement(8, "igx-badge", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r11 = ɵngcc0.ɵɵreference(7);
    const ctx_r9 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r9.groupRow.column && ctx_r9.groupRow.column.header ? ctx_r9.groupRow.column.header : ctx_r9.groupRow.expression ? ctx_r9.groupRow.expression.fieldName : "", ": ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r9.dataType === "boolean" || ctx_r9.dataType === "string")("ngIfElse", _r11);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("value", ctx_r9.groupRow.records ? ctx_r9.groupRow.records.length : 0);
} }
const _c165 = ["defaultDropArea"];
const _c166 = ["groupArea"];
const _c167 = ["record_template"];
const _c168 = ["detail_template_container"];
const _c169 = ["group_template"];
const _c170 = ["summary_template"];
function IgxGridComponent_igx_grid_toolbar_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-toolbar", 71, 72);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("max-width", ctx_r0.outerWidth, "px")("flex-basis", ctx_r0.outerWidth, "px");
    ɵngcc0.ɵɵproperty("gridID", ctx_r0.id)("displayDensity", ctx_r0.displayDensity);
} }
function IgxGridComponent_div_1_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r85 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-chip", 78);
    ɵngcc0.ɵɵlistener("onKeyDown", function IgxGridComponent_div_1_ng_container_3_Template_igx_chip_onKeyDown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r85); const ctx_r84 = ɵngcc0.ɵɵnextContext(2); return ctx_r84.onChipKeyDown($event); })("onRemove", function IgxGridComponent_div_1_ng_container_3_Template_igx_chip_onRemove_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r85); const ctx_r86 = ɵngcc0.ɵɵnextContext(2); return ctx_r86.onChipRemoved($event); })("onClick", function IgxGridComponent_div_1_ng_container_3_Template_igx_chip_onClick_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r85); const expr_r82 = ctx.$implicit; const ctx_r87 = ɵngcc0.ɵɵnextContext(2); return ctx_r87.getColumnGroupable(expr_r82.fieldName) ? ctx_r87.onChipClicked($event) : null; });
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "igx-icon", 79);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "span", 80);
    ɵngcc0.ɵɵelementStart(7, "igx-icon");
    ɵngcc0.ɵɵtext(8, "arrow_forward ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const expr_r82 = ctx.$implicit;
    const last_r83 = ctx.last;
    const ctx_r80 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", expr_r82.fieldName)("title", ctx_r80.getGroupByChipTitle(expr_r82))("removable", ctx_r80.getColumnGroupable(expr_r82.fieldName))("draggable", ctx_r80.getColumnGroupable(expr_r82.fieldName))("displayDensity", ctx_r80.displayDensity)("disabled", !ctx_r80.getColumnGroupable(expr_r82.fieldName));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r80.getGroupByChipTitle(expr_r82));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(expr_r82.dir == 1 ? "arrow_upward" : "arrow_downward");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵstyleProp("visibility", !last_r83 || ctx_r80.dropAreaVisible ? "visible" : "hidden");
} }
function IgxGridComponent_div_1_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r89 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 73, 74);
    ɵngcc0.ɵɵelementStart(2, "igx-chips-area", 75);
    ɵngcc0.ɵɵlistener("onReorder", function IgxGridComponent_div_1_Template_igx_chips_area_onReorder_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r89); const ctx_r88 = ɵngcc0.ɵɵnextContext(); return ctx_r88.chipsOrderChanged($event); })("onMoveEnd", function IgxGridComponent_div_1_Template_igx_chips_area_onMoveEnd_2_listener() { ɵngcc0.ɵɵrestoreView(_r89); const ctx_r90 = ɵngcc0.ɵɵnextContext(); return ctx_r90.chipsMovingEnded(); });
    ɵngcc0.ɵɵtemplate(3, IgxGridComponent_div_1_ng_container_3_Template, 9, 10, "ng-container", 76);
    ɵngcc0.ɵɵelementStart(4, "div", 77);
    ɵngcc0.ɵɵtemplate(5, IgxGridComponent_div_1_ng_container_5_Template, 1, 0, "ng-container", 18);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("flex-basis", ctx_r1.outerWidth, "px");
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.chipsGoupingExpressions);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMap(ctx_r1.groupAreaHostClass);
    ɵngcc0.ɵɵstyleProp("visibility", ctx_r1.dropAreaVisible ? "visible" : "hidden");
    ɵngcc0.ɵɵattribute("gridId", ctx_r1.id);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.dropAreaTemplateResolved);
} }
function IgxGridComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 81);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r3.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r3.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridComponent_span_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 82);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r4.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r4.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridComponent_ng_container_8_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c171 = function (a0) { return { "igx-grid__header-indentation--no-border": a0 }; };
function IgxGridComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    const _r94 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 83, 84);
    ɵngcc0.ɵɵlistener("click", function IgxGridComponent_ng_container_8_Template_div_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r94); const ctx_r93 = ɵngcc0.ɵɵnextContext(); return ctx_r93.toggleAllGroupRows(); })("pointerdown", function IgxGridComponent_ng_container_8_Template_div_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r94); return $event.preventDefault(); });
    ɵngcc0.ɵɵtemplate(3, IgxGridComponent_ng_container_8_ng_container_3_Template, 1, 0, "ng-container", 85);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("igx-grid__header-indentation igx-grid__row-indentation--level-", ctx_r5.groupingExpressions.length, "");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(6, _c171, ctx_r5.isRowSelectable || ctx_r5.rowDraggable));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r5.iconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(8, _c17, ctx_r5));
} }
function IgxGridComponent_ng_container_9_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c172 = function (a0) { return { "igx-grid__drag-indicator--header": a0 }; };
function IgxGridComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    const _r99 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 86, 87);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxGridComponent_ng_container_9_Template_div_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r99); return $event.preventDefault(); });
    ɵngcc0.ɵɵelementStart(3, "div", 88);
    ɵngcc0.ɵɵtemplate(4, IgxGridComponent_ng_container_9_ng_container_4_Template, 1, 0, "ng-container", 18);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    const _r71 = ɵngcc0.ɵɵreference(107);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c172, !ctx_r6.isRowSelectable));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r6.dragIndicatorIconTemplate ? ctx_r6.dragIndicatorIconTemplate : _r71);
} }
function IgxGridComponent_ng_container_10_3_ng_template_0_Template(rf, ctx) { }
function IgxGridComponent_ng_container_10_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridComponent_ng_container_10_3_ng_template_0_Template, 0, 0, "ng-template", null, 91, ɵngcc0.ɵɵtemplateRefExtractor);
} }
const _c173 = function (a0) { return { "igx-grid__cbx-selection--push": a0 }; };
const _c174 = function (a0, a1) { return { selectedCount: a0, totalCount: a1 }; };
function IgxGridComponent_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    const _r105 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 89, 90);
    ɵngcc0.ɵɵlistener("click", function IgxGridComponent_ng_container_10_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r105); const ctx_r104 = ɵngcc0.ɵɵnextContext(); return ctx_r104.onHeaderSelectorClick($event); })("pointerdown", function IgxGridComponent_ng_container_10_Template_div_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r105); return $event.preventDefault(); });
    ɵngcc0.ɵɵtemplate(3, IgxGridComponent_ng_container_10_3_Template, 2, 0, undefined, 85);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    const _r73 = ɵngcc0.ɵɵreference(109);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c173, ctx_r7.filteringService.isFilterRowVisible));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r7.headSelectorTemplate ? ctx_r7.headSelectorTemplate : _r73)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(8, _c17, ɵngcc0.ɵɵpureFunction2(5, _c174, ctx_r7.selectionService.filteredSelectedRowIds.length, ctx_r7.totalRowsCountAfterFilter)));
} }
function IgxGridComponent_ng_container_11_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 93);
} if (rf & 2) {
    const col_r108 = ctx.$implicit;
    const ctx_r107 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r107.getHeaderGroupWidth(col_r108))("flex-basis", ctx_r107.getHeaderGroupWidth(col_r108));
    ɵngcc0.ɵɵproperty("column", col_r108)("gridID", ctx_r107.id);
} }
function IgxGridComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridComponent_ng_container_11_ng_template_1_Template, 1, 6, "ng-template", 92);
    ɵngcc0.ɵɵpipe(2, "igxTopLevel");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r8.pinnedColumns));
} }
function IgxGridComponent_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 93);
} if (rf & 2) {
    const col_r109 = ctx.$implicit;
    const ctx_r10 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r10.getHeaderGroupWidth(col_r109))("flex-basis", ctx_r10.getHeaderGroupWidth(col_r109));
    ɵngcc0.ɵɵproperty("column", col_r109)("gridID", ctx_r10.id);
} }
function IgxGridComponent_ng_container_15_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 93);
} if (rf & 2) {
    const col_r111 = ctx.$implicit;
    const ctx_r110 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r110.getHeaderGroupWidth(col_r111))("flex-basis", ctx_r110.getHeaderGroupWidth(col_r111))("left", col_r111.rightPinnedOffset);
    ɵngcc0.ɵɵproperty("column", col_r111)("gridID", ctx_r110.id);
} }
function IgxGridComponent_ng_container_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridComponent_ng_container_15_ng_template_1_Template, 1, 8, "ng-template", 92);
    ɵngcc0.ɵɵpipe(2, "igxTopLevel");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r11.pinnedColumns));
} }
function IgxGridComponent_igx_grid_filtering_row_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-filtering-row", 94, 95);
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r12.calcWidth, "px");
    ɵngcc0.ɵɵproperty("column", ctx_r12.filteringService.filteredColumn);
} }
function IgxGridComponent_span_17_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 96);
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r13.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridComponent_span_22_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 81);
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r15.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridComponent_span_23_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 82);
} if (rf & 2) {
    const ctx_r16 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r16.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r16.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridComponent_ng_container_24_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 85);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const rowData_r118 = ctx.$implicit;
    const rowIndex_r119 = ctx.index;
    const ctx_r117 = ɵngcc0.ɵɵnextContext(4);
    const _r25 = ɵngcc0.ɵɵreference(43);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r25)("ngTemplateOutletContext", ctx_r117.getContext(rowData_r118, rowIndex_r119, true));
} }
const _c175 = function (a0, a1) { return { "igx-grid__tr--pinned-bottom": a0, "igx-grid__tr--pinned-top": a1 }; };
function IgxGridComponent_ng_template_25_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 98, 99);
    ɵngcc0.ɵɵtemplate(2, IgxGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_Template, 2, 2, "ng-container", 76);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const pinnedData_r114 = ɵngcc0.ɵɵnextContext().ngIf;
    const ctx_r115 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("width", ctx_r115.calcWidth, "px");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(4, _c175, !ctx_r115.isRowPinningToTop, ctx_r115.isRowPinningToTop));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", pinnedData_r114);
} }
function IgxGridComponent_ng_template_25_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridComponent_ng_template_25_ng_container_0_div_1_Template, 3, 7, "div", 97);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const pinnedData_r114 = ctx.ngIf;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", pinnedData_r114.length > 0);
} }
const _c176 = function (a0, a1, a2, a3, a4, a5, a6) { return [a0, a1, a2, a3, a4, a5, a6, true]; };
const _c177 = function (a0, a1, a2, a3, a4) { return [a0, a1, a2, a3, a4, true]; };
function IgxGridComponent_ng_template_25_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridComponent_ng_template_25_ng_container_0_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵpipe(1, "gridAddRow");
    ɵngcc0.ɵɵpipe(2, "gridSort");
    ɵngcc0.ɵɵpipe(3, "gridFiltering");
    ɵngcc0.ɵɵpipe(4, "gridRowPinning");
    ɵngcc0.ɵɵpipe(5, "visibleColumns");
    ɵngcc0.ɵɵpipe(6, "gridTransaction");
} if (rf & 2) {
    const ctx_r19 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBind3(1, 1, ɵngcc0.ɵɵpipeBindV(2, 5, ɵngcc0.ɵɵpureFunction5(41, _c177, ɵngcc0.ɵɵpipeBindV(3, 12, ɵngcc0.ɵɵpureFunction7(33, _c176, ɵngcc0.ɵɵpipeBind4(4, 21, ɵngcc0.ɵɵpipeBind2(5, 26, ɵngcc0.ɵɵpipeBind3(6, 29, ctx_r19.data, ctx_r19.id, ctx_r19.pipeTrigger), ctx_r19.hasVisibleColumns), ctx_r19.id, true, ctx_r19.pipeTrigger), ctx_r19.filteringExpressionsTree, ctx_r19.filterStrategy, ctx_r19.advancedFilteringExpressionsTree, ctx_r19.id, ctx_r19.pipeTrigger, ctx_r19.filteringPipeTrigger)), ctx_r19.sortingExpressions, ctx_r19.sortStrategy, ctx_r19.id, ctx_r19.pipeTrigger)), true, ctx_r19.pipeTrigger));
} }
function IgxGridComponent_ng_template_27_ng_template_0_Template(rf, ctx) { }
function IgxGridComponent_ng_template_27_Template(rf, ctx) { if (rf & 1) {
    const _r126 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, IgxGridComponent_ng_template_27_ng_template_0_Template, 0, 0, "ng-template", 100);
    ɵngcc0.ɵɵlistener("onCachedViewLoaded", function IgxGridComponent_ng_template_27_Template_ng_template_onCachedViewLoaded_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r126); const ctx_r125 = ɵngcc0.ɵɵnextContext(); return ctx_r125.cachedViewLoaded($event); })("onViewCreated", function IgxGridComponent_ng_template_27_Template_ng_template_onViewCreated_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r126); const ctx_r127 = ɵngcc0.ɵɵnextContext(); return ctx_r127.viewCreatedHandler($event); })("onViewMoved", function IgxGridComponent_ng_template_27_Template_ng_template_onViewMoved_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r126); const ctx_r128 = ɵngcc0.ɵɵnextContext(); return ctx_r128.viewMovedHandler($event); });
} if (rf & 2) {
    const rowData_r122 = ctx.$implicit;
    const rowIndex_r123 = ctx.index;
    const ctx_r21 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxTemplateOutlet", ctx_r21.getRowTemplate(rowData_r122))("igxTemplateOutletContext", ctx_r21.getContext(rowData_r122, rowIndex_r123));
} }
function IgxGridComponent_ng_container_39_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_template_40_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-row", 101, 102);
} if (rf & 2) {
    const rowIndex_r129 = ctx.index;
    const rowData_r130 = ctx.$implicit;
    const disabledRow_r131 = ctx.disabled;
    const isAddRow_r132 = ctx.addRow;
    const ctx_r24 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r24.id)("index", rowIndex_r129)("rowData", rowData_r130)("disabled", disabledRow_r131)("addRow", isAddRow_r132);
} }
function IgxGridComponent_ng_template_42_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-row", 103, 104);
} if (rf & 2) {
    const rowIndex_r134 = ctx.index;
    const rowData_r135 = ctx.$implicit;
    const isAddRow_r136 = ctx.addRow;
    const ctx_r26 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r26.id)("index", rowIndex_r134)("rowData", rowData_r135)("addRow", isAddRow_r136);
} }
function IgxGridComponent_ng_template_44_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-groupby-row", 105, 102);
} if (rf & 2) {
    const rowIndex_r139 = ctx.index;
    const rowData_r140 = ctx.$implicit;
    const ctx_r28 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r28.id)("index", rowIndex_r139)("groupRow", rowData_r140);
} }
function IgxGridComponent_ng_template_46_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-row", 106, 107);
} if (rf & 2) {
    const rowIndex_r142 = ctx.index;
    const rowData_r143 = ctx.$implicit;
    const ctx_r30 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r30.id)("summaries", rowData_r143.summaries)("index", rowIndex_r142);
} }
function IgxGridComponent_ng_template_48_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r148 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("igx-grid__row-indentation igx-grid__row-indentation--level-", ctx_r148.groupingExpressions.length, "");
} }
function IgxGridComponent_ng_template_48_ng_template_4_Template(rf, ctx) { }
const _c178 = function (a1) { return { "igx-grid__tr-container": true, "igx-grid__tr-container--active": a1 }; };
function IgxGridComponent_ng_template_48_Template(rf, ctx) { if (rf & 1) {
    const _r151 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 108, 109);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxGridComponent_ng_template_48_Template_div_pointerdown_0_listener() { ɵngcc0.ɵɵrestoreView(_r151); const rowIndex_r145 = ctx.index; const _r147 = ɵngcc0.ɵɵreference(1); const ctx_r150 = ɵngcc0.ɵɵnextContext(); return ctx_r150.detailsViewFocused(_r147, rowIndex_r145); });
    ɵngcc0.ɵɵelementStart(2, "div", 110);
    ɵngcc0.ɵɵtemplate(3, IgxGridComponent_ng_template_48_ng_container_3_Template, 2, 3, "ng-container", 8);
    ɵngcc0.ɵɵtemplate(4, IgxGridComponent_ng_template_48_ng_template_4_Template, 0, 0, "ng-template", 111);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const rowIndex_r145 = ctx.index;
    const rowData_r146 = ctx.$implicit;
    const ctx_r32 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵpropertyInterpolate2("id", "", ctx_r32.id, "_", rowIndex_r145, "");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(7, _c178, ctx_r32.isDetailActive(rowIndex_r145)));
    ɵngcc0.ɵɵattribute("data-rowindex", rowIndex_r145);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r32.groupingExpressions.length > 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r32.detailTemplate)("ngTemplateOutletContext", ctx_r32.getDetailsContext(rowData_r146, rowIndex_r145));
} }
function IgxGridComponent_ng_container_50_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_igx_circular_bar_56_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-circular-bar", 112);
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxGridComponent_span_57_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 96);
} if (rf & 2) {
    const ctx_r37 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r37.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridComponent_ng_template_61_Template(rf, ctx) { }
function IgxGridComponent_igx_grid_summary_row_70_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-row", 113, 107);
    ɵngcc0.ɵɵpipe(2, "igxGridSummaryDataPipe");
} if (rf & 2) {
    const ctx_r42 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r42.calcWidth, "px")("height", ctx_r42.summariesHeight, "px");
    ɵngcc0.ɵɵproperty("gridID", ctx_r42.id)("summaries", ɵngcc0.ɵɵpipeBind2(2, 7, ctx_r42.id, ctx_r42.summaryService.retriggerRootPipe))("index", ctx_r42.dataView.length);
} }
function IgxGridComponent_ng_template_76_Template(rf, ctx) { }
function IgxGridComponent_ng_container_82_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_container_82_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridComponent_ng_container_82_ng_container_1_Template, 1, 0, "ng-container", 85);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r47 = ɵngcc0.ɵɵnextContext();
    const _r48 = ɵngcc0.ɵɵreference(84);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r47.paginationTemplate ? ctx_r47.paginationTemplate : _r48)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, ctx_r47));
} }
function IgxGridComponent_ng_template_83_Template(rf, ctx) { if (rf & 1) {
    const _r155 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-paginator", 114);
    ɵngcc0.ɵɵlistener("pageChange", function IgxGridComponent_ng_template_83_Template_igx_paginator_pageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r155); const ctx_r154 = ɵngcc0.ɵɵnextContext(); return ctx_r154.page = $event; })("perPageChange", function IgxGridComponent_ng_template_83_Template_igx_paginator_perPageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r155); const ctx_r156 = ɵngcc0.ɵɵnextContext(); return ctx_r156.perPage = $event; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r49 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("overlaySettings", ctx_r49.paginatorSettings)("displayDensity", ctx_r49.displayDensity)("page", ctx_r49.page)("totalRecords", ctx_r49.totalRecords)("perPage", ctx_r49.perPage);
} }
function IgxGridComponent_ng_template_85_span_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_template_85_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, IgxGridComponent_ng_template_85_span_3_ng_container_1_Template, 1, 0, "ng-container", 18);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r157 = ɵngcc0.ɵɵnextContext(2);
    const _r54 = ɵngcc0.ɵɵreference(90);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r157.addRowEmptyTemplate || _r54);
} }
function IgxGridComponent_ng_template_85_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 115);
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, IgxGridComponent_ng_template_85_span_3_Template, 2, 1, "span", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r51 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r51.emptyFilteredGridMessage);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r51.showAddButton);
} }
function IgxGridComponent_ng_template_87_span_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_template_87_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, IgxGridComponent_ng_template_87_span_3_ng_container_1_Template, 1, 0, "ng-container", 18);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r159 = ɵngcc0.ɵɵnextContext(2);
    const _r54 = ɵngcc0.ɵɵreference(90);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r159.addRowEmptyTemplate || _r54);
} }
function IgxGridComponent_ng_template_87_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 115);
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, IgxGridComponent_ng_template_87_span_3_Template, 2, 1, "span", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r53 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r53.emptyGridMessage);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r53.showAddButton);
} }
function IgxGridComponent_ng_template_89_Template(rf, ctx) { if (rf & 1) {
    const _r162 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 116);
    ɵngcc0.ɵɵlistener("click", function IgxGridComponent_ng_template_89_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r162); const ctx_r161 = ɵngcc0.ɵɵnextContext(); return ctx_r161.beginAddRowByIndex(null, -1); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r55 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r55.resourceStrings.igx_grid_add_row_label, " ");
} }
function IgxGridComponent_ng_template_91_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 117);
    ɵngcc0.ɵɵelement(1, "igx-circular-bar", 112);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxGridComponent_ng_template_93_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 118);
    ɵngcc0.ɵɵtext(1, "group_work");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "span", 119);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r59 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r59.dropAreaMessage);
} }
const _c179 = function (a0) { return { "igx-grid__group-expand-btn--push": a0 }; };
function IgxGridComponent_ng_template_95_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 120);
    ɵngcc0.ɵɵtext(1, "unfold_less");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r61 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(1, _c179, ctx_r61.filteringService.isFilterRowVisible));
} }
function IgxGridComponent_ng_template_97_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 120);
    ɵngcc0.ɵɵtext(1, "unfold_more");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r63 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(1, _c179, ctx_r63.filteringService.isFilterRowVisible));
} }
function IgxGridComponent_div_99_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c180 = function (a0, a1) { return { rowChangesCount: a0, endEdit: a1 }; };
function IgxGridComponent_div_99_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 121);
    ɵngcc0.ɵɵelementStart(1, "div", 122);
    ɵngcc0.ɵɵtemplate(2, IgxGridComponent_div_99_ng_container_2_Template, 1, 0, "ng-container", 85);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r64 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("className", ctx_r64.bannerClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r64.rowEditContainer)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(3, _c180, ctx_r64.rowChangesCount, ctx_r64.endEdit.bind(ctx_r64)));
} }
function IgxGridComponent_ng_template_100_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r66 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" You have ", ctx_r66.rowChangesCount, " changes in this row\n");
} }
function IgxGridComponent_ng_template_102_Template(rf, ctx) { if (rf & 1) {
    const _r165 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 123);
    ɵngcc0.ɵɵlistener("click", function IgxGridComponent_ng_template_102_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r165); const ctx_r164 = ɵngcc0.ɵɵnextContext(); return ctx_r164.endRowEdit(false, $event); });
    ɵngcc0.ɵɵtext(1, "Cancel");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "button", 123);
    ɵngcc0.ɵɵlistener("click", function IgxGridComponent_ng_template_102_Template_button_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r165); const ctx_r166 = ɵngcc0.ɵɵnextContext(); return ctx_r166.endRowEdit(true, $event); });
    ɵngcc0.ɵɵtext(3, "Done");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridComponent_ng_template_104_div_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_template_104_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 127);
    ɵngcc0.ɵɵelementStart(1, "span", 128);
    ɵngcc0.ɵɵtemplate(2, IgxGridComponent_ng_template_104_div_0_ng_container_2_Template, 1, 0, "ng-container", 85);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r167 = ɵngcc0.ɵɵnextContext(2);
    const _r65 = ɵngcc0.ɵɵreference(101);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r167.rowEditText ? ctx_r167.rowEditText : _r65)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, ctx_r167.rowChangesCount));
} }
function IgxGridComponent_ng_template_104_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_template_104_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridComponent_ng_template_104_div_0_Template, 3, 4, "div", 124);
    ɵngcc0.ɵɵelementStart(1, "div", 125);
    ɵngcc0.ɵɵelementStart(2, "div", 126);
    ɵngcc0.ɵɵtemplate(3, IgxGridComponent_ng_template_104_ng_container_3_Template, 1, 0, "ng-container", 85);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r70 = ɵngcc0.ɵɵnextContext();
    const _r67 = ɵngcc0.ɵɵreference(103);
    ɵngcc0.ɵɵproperty("ngIf", !(ctx_r70.crudService.row == null ? null : ctx_r70.crudService.row.isAddRow));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r70.rowEditActions ? ctx_r70.rowEditActions : _r67)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(3, _c17, ctx_r70.endEdit.bind(ctx_r70)));
} }
function IgxGridComponent_ng_template_106_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 129);
    ɵngcc0.ɵɵtext(1, "drag_indicator");
    ɵngcc0.ɵɵelementEnd();
} }
const _c181 = function (a0) { return { "visibility": a0 }; };
function IgxGridComponent_ng_template_108_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 130);
    ɵngcc0.ɵɵelement(1, "igx-checkbox", 131, 132);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r170 = ctx.$implicit;
    const ctx_r74 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("tabindex", -1)("readonly", true)("checked", context_r170.selectedCount > 0 && context_r170.totalCount === context_r170.selectedCount)("ngStyle", ɵngcc0.ɵɵpureFunction1(6, _c181, ctx_r74.isMultiRowSelectionEnabled ? "visible" : "hidden"))("indeterminate", context_r170.selectedCount > 0 && context_r170.selectedCount !== context_r170.totalCount)("aria-label", ctx_r74.headSelectorBaseAriaLabel);
} }
function IgxGridComponent_igx_grid_column_resizer_110_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-column-resizer");
} }
const _c182 = [[["igx-grid-footer"]]];
const _c183 = function (a0, a1, a2, a3, a4, a5, a6) { return [a0, a1, a2, a3, a4, a5, a6]; };
const _c184 = function (a0, a1, a2, a3, a4, a5, a6, a7) { return [a0, a1, a2, a3, a4, a5, a6, a7]; };
const _c185 = function () { return []; };
const _c186 = ["igx-grid-footer"];
function IgxColumnHidingComponent_h4_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "h4", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.title);
} }
function IgxColumnHidingComponent_igx_input_group_2_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 8);
    ɵngcc0.ɵɵelementStart(1, "input", 9);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxColumnHidingComponent_igx_input_group_2_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.filterCriteria = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r1.filterCriteria)("placeholder", ctx_r1.filterColumnsPrompt);
} }
function IgxColumnHidingComponent_igx_checkbox_4_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-checkbox", 10);
    ɵngcc0.ɵɵlistener("onColumnVisibilityChanged", function IgxColumnHidingComponent_igx_checkbox_4_Template_igx_checkbox_onColumnVisibilityChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.onVisibilityChanged($event); })("change", function IgxColumnHidingComponent_igx_checkbox_4_Template_igx_checkbox_change_0_listener() { const columnItem_r5 = ctx.$implicit; return columnItem_r5.value = !columnItem_r5.value; });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const columnItem_r5 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("margin-left", columnItem_r5.calcIndent, "px");
    ɵngcc0.ɵɵproperty("checked", columnItem_r5.value)("disabled", columnItem_r5.disabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", columnItem_r5.name, " ");
} }
function IgxExcelStyleClearFiltersComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleClearFiltersComponent_div_0_Template_div_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.onClearFilterKeyDown($event); })("click", function IgxExcelStyleClearFiltersComponent_div_0_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.clearFilter(); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "igx-icon");
    ɵngcc0.ɵɵtext(4, "clear");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.clearFilterClass());
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_clear);
} }
const _c187 = ["dropdownConditions"];
const _c188 = ["logicOperatorButtonGroup"];
const _c189 = ["inputValues"];
function IgxExcelStyleDefaultExpressionComponent_igx_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-icon", 13);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("name", ctx_r1.getIconName());
} }
function IgxExcelStyleDefaultExpressionComponent_igx_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, "filter_list");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxExcelStyleDefaultExpressionComponent_igx_select_item_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-select-item", 14);
    ɵngcc0.ɵɵelementStart(1, "div", 15);
    ɵngcc0.ɵɵelement(2, "igx-icon", 13);
    ɵngcc0.ɵɵelementStart(3, "span", 16);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const condition_r9 = ctx.$implicit;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", condition_r9)("selected", ctx_r3.isConditionSelected(condition_r9));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r3.getCondition(condition_r9).iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.translateCondition(condition_r9));
} }
function IgxExcelStyleDefaultExpressionComponent_button_10_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 17);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleDefaultExpressionComponent_button_10_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onRemoveButtonClick(); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon");
    ɵngcc0.ɵɵtext(2, "cancel");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r6.displayDensity);
} }
function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_11_Template(rf, ctx) { if (rf & 1) {
    const _r16 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-buttongroup", 18, 19);
    ɵngcc0.ɵɵelementStart(2, "span", 20, 21);
    ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_11_Template_span_keydown_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r16); const ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.onLogicOperatorKeyDown($event, 0); })("click", function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_11_Template_span_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r16); const ctx_r17 = ɵngcc0.ɵɵnextContext(); return ctx_r17.onLogicOperatorButtonClicked($event, 0); });
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "span", 20, 22);
    ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_11_Template_span_keydown_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r16); const ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.onLogicOperatorKeyDown($event, 1); })("click", function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_11_Template_span_click_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r16); const ctx_r19 = ɵngcc0.ɵɵnextContext(); return ctx_r19.onLogicOperatorButtonClicked($event, 1); });
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("multiSelection", false);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r7.displayDensity)("selected", ctx_r7.expressionUI.afterOperator === 0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r7.grid.resourceStrings.igx_grid_filter_operator_and, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r7.displayDensity)("selected", ctx_r7.expressionUI.afterOperator === 1);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r7.grid.resourceStrings.igx_grid_filter_operator_or, " ");
} }
const _c190 = ["datePicker"];
function IgxExcelStyleDateExpressionComponent_igx_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-icon", 12);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("name", ctx_r1.getIconName());
} }
function IgxExcelStyleDateExpressionComponent_igx_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, "filter_list");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxExcelStyleDateExpressionComponent_igx_select_item_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-select-item", 13);
    ɵngcc0.ɵɵelement(1, "igx-icon", 12);
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const condition_r9 = ctx.$implicit;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", condition_r9)("selected", ctx_r3.isConditionSelected(condition_r9));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r3.getCondition(condition_r9).iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.translateCondition(condition_r9));
} }
function IgxExcelStyleDateExpressionComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 14, 15);
    ɵngcc0.ɵɵelementStart(2, "input", 16, 17);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleDateExpressionComponent_ng_template_8_Template_input_click_2_listener() { ɵngcc0.ɵɵrestoreView(_r15); const openDialog_r10 = ctx.openDialog; const _r12 = ɵngcc0.ɵɵreference(1); return openDialog_r10(_r12.element.nativeElement); });
    ɵngcc0.ɵɵpipe(4, "date");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const value_r11 = ctx.value;
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r5.displayDensity);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("placeholder", ctx_r5.inputDatePlaceholder)("value", ɵngcc0.ɵɵpipeBind4(4, 5, value_r11, ctx_r5.column.pipeArgs.format, undefined, ctx_r5.grid.locale))("readonly", true)("disabled", ctx_r5.expressionUI.expression.condition && ctx_r5.expressionUI.expression.condition.isUnary);
} }
function IgxExcelStyleDateExpressionComponent_button_9_Template(rf, ctx) { if (rf & 1) {
    const _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 18);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleDateExpressionComponent_button_9_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); const ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.onRemoveButtonClick(); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon");
    ɵngcc0.ɵɵtext(2, "cancel");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r6.displayDensity);
} }
function IgxExcelStyleDateExpressionComponent_igx_buttongroup_10_Template(rf, ctx) { if (rf & 1) {
    const _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-buttongroup", 19, 20);
    ɵngcc0.ɵɵelementStart(2, "span", 21, 22);
    ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleDateExpressionComponent_igx_buttongroup_10_Template_span_keydown_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.onLogicOperatorKeyDown($event, 0); })("click", function IgxExcelStyleDateExpressionComponent_igx_buttongroup_10_Template_span_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r23 = ɵngcc0.ɵɵnextContext(); return ctx_r23.onLogicOperatorButtonClicked($event, 0); });
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "span", 21, 23);
    ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleDateExpressionComponent_igx_buttongroup_10_Template_span_keydown_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r24 = ɵngcc0.ɵɵnextContext(); return ctx_r24.onLogicOperatorKeyDown($event, 1); })("click", function IgxExcelStyleDateExpressionComponent_igx_buttongroup_10_Template_span_click_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r25 = ɵngcc0.ɵɵnextContext(); return ctx_r25.onLogicOperatorButtonClicked($event, 1); });
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("multiSelection", false);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r7.displayDensity)("selected", ctx_r7.expressionUI.afterOperator === 0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r7.grid.resourceStrings.igx_grid_filter_operator_and, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r7.displayDensity)("selected", ctx_r7.expressionUI.afterOperator === 1);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r7.grid.resourceStrings.igx_grid_filter_operator_or, " ");
} }
const _c191 = ["toggle"];
const _c192 = ["defaultExpressionTemplate"];
const _c193 = ["dateExpressionTemplate"];
function IgxExcelStyleCustomDialogComponent_ng_container_7_igx_excel_style_date_expression_1_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-excel-style-date-expression", 12);
    ɵngcc0.ɵɵlistener("onExpressionRemoved", function IgxExcelStyleCustomDialogComponent_ng_container_7_igx_excel_style_date_expression_1_Template_igx_excel_style_date_expression_onExpressionRemoved_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(2); return ctx_r6.onExpressionRemoved($event); })("onLogicOperatorChanged", function IgxExcelStyleCustomDialogComponent_ng_container_7_igx_excel_style_date_expression_1_Template_igx_excel_style_date_expression_onLogicOperatorChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r8 = ɵngcc0.ɵɵnextContext(2); return ctx_r8.onLogicOperatorChanged($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expression_r5 = ctx.$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("expressionUI", expression_r5)("column", ctx_r4.column)("grid", ctx_r4.grid)("displayDensity", ctx_r4.displayDensity)("expressionsList", ctx_r4.expressionsList);
} }
function IgxExcelStyleCustomDialogComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxExcelStyleCustomDialogComponent_ng_container_7_igx_excel_style_date_expression_1_Template, 1, 5, "igx-excel-style-date-expression", 11);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r2.expressionsList);
} }
function IgxExcelStyleCustomDialogComponent_ng_container_8_igx_excel_style_default_expression_1_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-excel-style-default-expression", 12);
    ɵngcc0.ɵɵlistener("onExpressionRemoved", function IgxExcelStyleCustomDialogComponent_ng_container_8_igx_excel_style_default_expression_1_Template_igx_excel_style_default_expression_onExpressionRemoved_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(2); return ctx_r11.onExpressionRemoved($event); })("onLogicOperatorChanged", function IgxExcelStyleCustomDialogComponent_ng_container_8_igx_excel_style_default_expression_1_Template_igx_excel_style_default_expression_onLogicOperatorChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r13 = ɵngcc0.ɵɵnextContext(2); return ctx_r13.onLogicOperatorChanged($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expression_r10 = ctx.$implicit;
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("expressionUI", expression_r10)("column", ctx_r9.column)("grid", ctx_r9.grid)("displayDensity", ctx_r9.displayDensity)("expressionsList", ctx_r9.expressionsList);
} }
function IgxExcelStyleCustomDialogComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxExcelStyleCustomDialogComponent_ng_container_8_igx_excel_style_default_expression_1_Template, 1, 5, "igx-excel-style-default-expression", 11);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.expressionsList);
} }
const _c194 = function (a0, a1) { return { "igx-excel-filter__secondary--cosy": a0, "igx-excel-filter__secondary--compact": a1 }; };
const _c195 = ["customDialog"];
const _c196 = ["subMenu"];
function IgxExcelStyleConditionalFilterComponent_ng_container_0_igx_drop_down_item_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-drop-down-item", 7);
    ɵngcc0.ɵɵelementStart(1, "div", 8);
    ɵngcc0.ɵɵelement(2, "igx-icon", 9);
    ɵngcc0.ɵɵelementStart(3, "span", 10);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const condition_r5 = ctx.$implicit;
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("value", condition_r5);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r2.getCondition(condition_r5).iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.translateCondition(condition_r5));
} }
function IgxExcelStyleConditionalFilterComponent_ng_container_0_igx_drop_down_item_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-drop-down-item");
    ɵngcc0.ɵɵelementStart(1, "div", 8);
    ɵngcc0.ɵɵelementStart(2, "igx-icon");
    ɵngcc0.ɵɵtext(3, "filter_list");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "span", 10);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.esf.grid.resourceStrings.igx_grid_excel_custom_filter);
} }
function IgxExcelStyleConditionalFilterComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 1);
    ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleConditionalFilterComponent_ng_container_0_Template_div_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.onTextFilterKeyDown($event); })("click", function IgxExcelStyleConditionalFilterComponent_ng_container_0_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onTextFilterClick($event); });
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "igx-icon");
    ɵngcc0.ɵɵtext(5, "keyboard_arrow_right");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "igx-drop-down", 2, 3);
    ɵngcc0.ɵɵlistener("onSelection", function IgxExcelStyleConditionalFilterComponent_ng_container_0_Template_igx_drop_down_onSelection_6_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onSubMenuSelection($event); })("onClosed", function IgxExcelStyleConditionalFilterComponent_ng_container_0_Template_igx_drop_down_onClosed_6_listener() { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onSubMenuClosed(); });
    ɵngcc0.ɵɵelementStart(8, "div");
    ɵngcc0.ɵɵtemplate(9, IgxExcelStyleConditionalFilterComponent_ng_container_0_igx_drop_down_item_9_Template, 5, 3, "igx-drop-down-item", 4);
    ɵngcc0.ɵɵtemplate(10, IgxExcelStyleConditionalFilterComponent_ng_container_0_igx_drop_down_item_10_Template, 6, 1, "igx-drop-down-item", 0);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(11, "igx-excel-style-custom-dialog", 5, 6);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const _r1 = ɵngcc0.ɵɵreference(7);
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxDropDownItemNavigation", _r1);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.subMenuText);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("maxHeight", "397px")("displayDensity", ctx_r0.esf.grid.displayDensity);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.conditions);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.showCustomFilterItem());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("column", ctx_r0.esf.column)("filteringService", ctx_r0.esf.grid.filteringService)("overlayComponentId", ctx_r0.esf.overlayComponentId)("overlayService", ctx_r0.esf.overlayService)("displayDensity", ctx_r0.esf.grid.displayDensity);
} }
function IgxExcelStyleHeaderComponent_header_0_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 5);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleHeaderComponent_header_0_button_4_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(2); return ctx_r4.esf.onSelect(); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 6);
    ɵngcc0.ɵɵtext(2, "done");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1.esf.selectedClass());
} }
function IgxExcelStyleHeaderComponent_header_0_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 7);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleHeaderComponent_header_0_button_5_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(2); return ctx_r6.esf.onPin(); });
    ɵngcc0.ɵɵelement(1, "igx-icon", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r2.esf.column.pinned ? "unpin-left" : "pin-left");
} }
function IgxExcelStyleHeaderComponent_header_0_button_6_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 7);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleHeaderComponent_header_0_button_6_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r8 = ɵngcc0.ɵɵnextContext(2); return ctx_r8.esf.onHideToggle(); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.esf.column.hidden ? "visibility" : "visibility_off");
} }
function IgxExcelStyleHeaderComponent_header_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "header", 1);
    ɵngcc0.ɵɵelementStart(1, "h4");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 2);
    ɵngcc0.ɵɵtemplate(4, IgxExcelStyleHeaderComponent_header_0_button_4_Template, 3, 1, "button", 3);
    ɵngcc0.ɵɵtemplate(5, IgxExcelStyleHeaderComponent_header_0_button_5_Template, 2, 1, "button", 4);
    ɵngcc0.ɵɵtemplate(6, IgxExcelStyleHeaderComponent_header_0_button_6_Template, 3, 1, "button", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.esf.column.header || ctx_r0.esf.column.field);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.showSelecting);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.showPinning);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.showHiding);
} }
function IgxExcelStyleHidingComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleHidingComponent_div_0_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.esf.onHideToggle(); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "igx-icon");
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.esf.column.hidden ? ctx_r0.esf.grid.resourceStrings.igx_grid_excel_show : ctx_r0.esf.grid.resourceStrings.igx_grid_excel_hide);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.esf.column.hidden ? "visibility" : "visibility_off");
} }
function IgxExcelStyleMovingComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "header");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "section", 1);
    ɵngcc0.ɵɵelementStart(4, "button", 2);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleMovingComponent_ng_container_0_Template_button_click_4_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.onMoveButtonClicked(0); });
    ɵngcc0.ɵɵelementStart(5, "igx-icon");
    ɵngcc0.ɵɵtext(6, "arrow_back");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "span");
    ɵngcc0.ɵɵtext(8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "button", 2);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleMovingComponent_ng_container_0_Template_button_click_9_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.onMoveButtonClicked(1); });
    ɵngcc0.ɵɵelementStart(10, "span");
    ɵngcc0.ɵɵtext(11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(12, "igx-icon");
    ɵngcc0.ɵɵtext(13, "arrow_forwards");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_moving_header, "\n");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r0.esf.grid.displayDensity)("disabled", ctx_r0.canNotMoveLeft);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.esf.grid.displayDensity === "compact" ? ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_moving_left_short : ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_moving_left, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r0.esf.grid.displayDensity)("disabled", ctx_r0.canNotMoveRight);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.esf.grid.displayDensity === "compact" ? ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_moving_right_short : ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_moving_right, " ");
} }
function IgxExcelStylePinningComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStylePinningComponent_div_0_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.esf.onPin(); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(3, "igx-icon", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.esf.column.pinned ? "igx-excel-filter__actions-unpin" : "igx-excel-filter__actions-pin");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.esf.column.pinned ? ctx_r0.esf.grid.resourceStrings.igx_grid_excel_unpin : ctx_r0.esf.grid.resourceStrings.igx_grid_excel_pin);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵpropertyInterpolate("name", ctx_r0.esf.column.pinned ? "unpin-left" : "pin-left");
} }
function IgxExcelStyleSelectingComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleSelectingComponent_div_0_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.esf.onSelect(); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "igx-icon", 2);
    ɵngcc0.ɵɵtext(4, "done");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.esf.selectedClass());
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.esf.grid.resourceStrings.igx_grid_excel_select);
} }
const _c197 = ["sortButtonGroup"];
function IgxExcelStyleSortingComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "header");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "igx-buttongroup", 1, 2);
    ɵngcc0.ɵɵelementStart(5, "button", 3);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleSortingComponent_ng_container_0_Template_button_click_5_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onSortButtonClicked(1); });
    ɵngcc0.ɵɵelementStart(6, "igx-icon");
    ɵngcc0.ɵɵtext(7, "arrow_upwards");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "span");
    ɵngcc0.ɵɵtext(9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(10, "button", 3);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleSortingComponent_ng_container_0_Template_button_click_10_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onSortButtonClicked(2); });
    ɵngcc0.ɵɵelementStart(11, "igx-icon");
    ɵngcc0.ɵɵtext(12, "arrow_downwards");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(13, "span");
    ɵngcc0.ɵɵtext(14);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_sorting_header, "\n");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("multiSelection", false);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r0.esf.grid.displayDensity);
    ɵngcc0.ɵɵattribute("data-togglable", true);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.esf.grid.displayDensity === "compact" ? ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_sorting_asc_short : ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_sorting_asc, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r0.esf.grid.displayDensity);
    ɵngcc0.ɵɵattribute("data-togglable", true);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.esf.grid.displayDensity === "compact" ? ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_sorting_desc_short : ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_sorting_desc, " ");
} }
const _c198 = ["defaultCell"];
const _c199 = ["defaultPinnedIndicator"];
const _c200 = ["inlineEditor"];
const _c201 = ["addRowCell"];
function IgxGridCellComponent_ng_template_0_igx_chip_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-chip", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("disabled", true)("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r10.grid.resourceStrings.igx_grid_pinned_row_indicator);
} }
function IgxGridCellComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridCellComponent_ng_template_0_igx_chip_0_Template, 2, 3, "igx-chip", 5);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.displayPinnedChip);
} }
function IgxGridCellComponent_ng_template_2_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵpipe(1, "columnFormatter");
    ɵngcc0.ɵɵpipe(2, "number");
    ɵngcc0.ɵɵpipe(3, "date");
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵpipe(5, "columnFormatter");
    ɵngcc0.ɵɵpipe(6, "number");
    ɵngcc0.ɵɵpipe(7, "date");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("cssClass", ctx_r11.highlightClass)("activeCssClass", ctx_r11.activeHighlightClass)("groupName", ctx_r11.gridID)("value", ctx_r11.formatter ? ɵngcc0.ɵɵpipeBind2(1, 9, ctx_r11.value, ctx_r11.formatter) : ctx_r11.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind3(2, 12, ctx_r11.value, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale) : ctx_r11.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind4(3, 16, ctx_r11.value, ctx_r11.column.pipeArgs.format, ctx_r11.column.pipeArgs.timezone, ctx_r11.grid.locale) : ctx_r11.value)("row", ctx_r11.rowData)("column", ctx_r11.column.field)("containerClass", "igx-grid__td-text")("metadata", ctx_r11.searchMetadata);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r11.formatter ? ɵngcc0.ɵɵpipeBind2(5, 21, ctx_r11.value, ctx_r11.formatter) : ctx_r11.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind3(6, 24, ctx_r11.value, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale) : ctx_r11.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind4(7, 28, ctx_r11.value, ctx_r11.column.pipeArgs.format, ctx_r11.column.pipeArgs.timezone, ctx_r11.grid.locale) : ctx_r11.value);
} }
const _c202 = function (a0, a1) { return { "igx-icon--success": a0, "igx-icon--error": a1 }; };
function IgxGridCellComponent_ng_template_2_igx_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 10);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(2, _c202, ctx_r12.value, !ctx_r12.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r12.value ? "check" : "close");
} }
function IgxGridCellComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridCellComponent_ng_template_2_div_0_Template, 8, 33, "div", 7);
    ɵngcc0.ɵɵtemplate(1, IgxGridCellComponent_ng_template_2_igx_icon_1_Template, 2, 5, "igx-icon", 8);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.column.dataType !== "boolean");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.column.dataType === "boolean");
} }
function IgxGridCellComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵpipe(1, "columnFormatter");
    ɵngcc0.ɵɵpipe(2, "number");
    ɵngcc0.ɵɵpipe(3, "date");
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("cssClass", ctx_r5.highlightClass)("activeCssClass", ctx_r5.activeHighlightClass)("groupName", ctx_r5.gridID)("value", ctx_r5.formatter ? ɵngcc0.ɵɵpipeBind2(1, 9, ctx_r5.value, ctx_r5.formatter) : ctx_r5.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind3(2, 12, ctx_r5.value, ctx_r5.column.pipeArgs.digitsInfo, ctx_r5.grid.locale) : ctx_r5.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind4(3, 16, ctx_r5.value, ctx_r5.column.pipeArgs.format, ctx_r5.column.pipeArgs.timezone, ctx_r5.grid.locale) : ctx_r5.value)("row", ctx_r5.rowData)("column", ctx_r5.column.field)("containerClass", "igx-grid__td-text")("metadata", ctx_r5.searchMetadata);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(!ctx_r5.isEmptyAddRowCell ? ctx_r5.value : ctx_r5.column.header || ctx_r5.column.field);
} }
function IgxGridCellComponent_ng_template_6_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r20 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 12);
    ɵngcc0.ɵɵelementStart(2, "input", 13);
    ɵngcc0.ɵɵlistener("input", function IgxGridCellComponent_ng_template_6_ng_container_0_Template_input_input_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r20); const ctx_r19 = ɵngcc0.ɵɵnextContext(2); return ctx_r19.editValue = $event.target.value; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("value", ctx_r15.editValue)("igxFocus", true);
} }
function IgxGridCellComponent_ng_template_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 12);
    ɵngcc0.ɵɵelementStart(2, "input", 14);
    ɵngcc0.ɵɵlistener("input", function IgxGridCellComponent_ng_template_6_ng_container_1_Template_input_input_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r21 = ɵngcc0.ɵɵnextContext(2); return ctx_r21.editValue = $event.target.value; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r16 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("value", ctx_r16.editValue)("igxFocus", true);
} }
function IgxGridCellComponent_ng_template_6_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r24 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-checkbox", 15);
    ɵngcc0.ɵɵlistener("change", function IgxGridCellComponent_ng_template_6_ng_container_2_Template_igx_checkbox_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r24); const ctx_r23 = ɵngcc0.ɵɵnextContext(2); return ctx_r23.editValue = $event.checked; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r17.editValue)("checked", ctx_r17.editValue)("igxFocus", true)("disableRipple", true);
} }
function IgxGridCellComponent_ng_template_6_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r26 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-date-picker", 16);
    ɵngcc0.ɵɵlistener("valueChange", function IgxGridCellComponent_ng_template_6_ng_container_3_Template_igx_date_picker_valueChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r26); const ctx_r25 = ɵngcc0.ɵɵnextContext(2); return ctx_r25.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r18 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", 100, "%");
    ɵngcc0.ɵɵproperty("outlet", ctx_r18.grid.outlet)("locale", ctx_r18.grid.locale)("value", ctx_r18.editValue)("igxFocus", true)("labelVisibility", false);
} }
function IgxGridCellComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridCellComponent_ng_template_6_ng_container_0_Template, 3, 2, "ng-container", 11);
    ɵngcc0.ɵɵtemplate(1, IgxGridCellComponent_ng_template_6_ng_container_1_Template, 3, 2, "ng-container", 11);
    ɵngcc0.ɵɵtemplate(2, IgxGridCellComponent_ng_template_6_ng_container_2_Template, 2, 4, "ng-container", 11);
    ɵngcc0.ɵɵtemplate(3, IgxGridCellComponent_ng_template_6_ng_container_3_Template, 2, 7, "ng-container", 11);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "string");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "number");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "boolean");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "date");
} }
function IgxGridCellComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridCellComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxPaginatorComponent_igx_select_item_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-select-item", 11);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const val_r1 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("value", val_r1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", val_r1, " ");
} }
function IgxColumnPinningComponent_h4_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "h4", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.title);
} }
function IgxColumnPinningComponent_igx_input_group_2_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 6);
    ɵngcc0.ɵɵelementStart(1, "input", 7);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxColumnPinningComponent_igx_input_group_2_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.filterCriteria = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r1.filterCriteria)("placeholder", ctx_r1.filterColumnsPrompt);
} }
function IgxColumnPinningComponent_igx_checkbox_4_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-checkbox", 8);
    ɵngcc0.ɵɵlistener("change", function IgxColumnPinningComponent_igx_checkbox_4_Template_igx_checkbox_change_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const columnItem_r5 = ctx.$implicit; const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.checkboxValueChange($event, columnItem_r5); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const columnItem_r5 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("checked", columnItem_r5.value);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", columnItem_r5.name, " ");
} }
function IgxGridRowComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_template_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r19 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵlistener("animationend", function IgxGridRowComponent_ng_template_1_Template_div_animationend_0_listener() { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.animationEndHandler(); });
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_1_ng_container_1_Template, 1, 0, "ng-container", 0);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    const _r3 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵclassProp("igx-grid__tr--add-animate", ctx_r2.animateAdd);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function IgxGridRowComponent_ng_template_3_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r26 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 11);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxGridRowComponent_ng_template_3_ng_container_0_Template_div_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r26); return $event.preventDefault(); })("click", function IgxGridRowComponent_ng_template_3_ng_container_0_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r26); return $event.stopPropagation(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r20 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("igx-grid__row-indentation igx-grid__row-indentation--level-", ctx_r20.grid.groupingExpressions.length, "");
} }
function IgxGridRowComponent_ng_template_3_ng_container_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_template_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r30 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 12);
    ɵngcc0.ɵɵlistener("click", function IgxGridRowComponent_ng_template_3_ng_container_1_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r30); return $event.stopPropagation(); });
    ɵngcc0.ɵɵtemplate(2, IgxGridRowComponent_ng_template_3_ng_container_1_ng_container_2_Template, 1, 0, "ng-container", 0);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r21 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMap(ctx_r21.resolveDragIndicatorClasses);
    ɵngcc0.ɵɵproperty("igxRowDrag", ctx_r21)("ghostTemplate", ctx_r21.grid.getDragGhostCustomTemplate());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r21.grid.dragIndicatorIconTemplate ? ctx_r21.grid.dragIndicatorIconTemplate : ctx_r21.grid.dragIndicatorIconBase);
} }
function IgxGridRowComponent_ng_template_3_ng_container_2_2_ng_template_0_Template(rf, ctx) { }
function IgxGridRowComponent_ng_template_3_ng_container_2_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_3_ng_container_2_2_ng_template_0_Template, 0, 0, "ng-template");
} }
const _c203 = function (a0, a1, a2) { return { index: a0, rowID: a1, selected: a2 }; };
function IgxGridRowComponent_ng_template_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r34 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 13);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxGridRowComponent_ng_template_3_ng_container_2_Template_div_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r34); return $event.preventDefault(); })("click", function IgxGridRowComponent_ng_template_3_ng_container_2_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r34); const ctx_r35 = ɵngcc0.ɵɵnextContext(2); return ctx_r35.onRowSelectorClick($event); });
    ɵngcc0.ɵɵtemplate(2, IgxGridRowComponent_ng_template_3_ng_container_2_2_Template, 1, 0, undefined, 14);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r22 = ɵngcc0.ɵɵnextContext(2);
    const _r7 = ɵngcc0.ɵɵreference(8);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r22.grid.rowSelectorTemplate ? ctx_r22.grid.rowSelectorTemplate : _r7)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(6, _c17, ɵngcc0.ɵɵpureFunction3(2, _c203, ctx_r22.viewIndex, ctx_r22.rowID, ctx_r22.selected)));
} }
function IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_1_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_1_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_1_ng_template_1_ng_container_0_Template, 1, 0, "ng-container", 14);
} if (rf & 2) {
    const col_r41 = ctx.$implicit;
    const ctx_r40 = ɵngcc0.ɵɵnextContext(4);
    const _r11 = ɵngcc0.ɵɵreference(12);
    const _r9 = ɵngcc0.ɵɵreference(10);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r41.visibleIndex === 0 && ctx_r40.grid.hasDetails ? _r11 : _r9)("ngTemplateOutletContext", ctx_r40.getContext(col_r41, ctx_r40));
} }
function IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_1_ng_template_1_Template, 1, 2, "ng-template", 17);
    ɵngcc0.ɵɵpipe(2, "igxNotGrouped");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r36 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r36.pinnedColumns));
} }
function IgxGridRowComponent_ng_template_3_ng_container_3_ng_template_2_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_template_3_ng_container_3_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_3_ng_container_3_ng_template_2_ng_container_0_Template, 1, 0, "ng-container", 14);
} if (rf & 2) {
    const col_r43 = ctx.$implicit;
    const ctx_r38 = ɵngcc0.ɵɵnextContext(3);
    const _r11 = ɵngcc0.ɵɵreference(12);
    const _r9 = ɵngcc0.ɵɵreference(10);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r43.visibleIndex === 0 && ctx_r38.grid.hasDetails ? _r11 : _r9)("ngTemplateOutletContext", ctx_r38.getContext(col_r43, ctx_r38));
} }
function IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_5_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_5_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_5_ng_template_1_ng_container_0_Template, 1, 0, "ng-container", 14);
} if (rf & 2) {
    const col_r46 = ctx.$implicit;
    const ctx_r45 = ɵngcc0.ɵɵnextContext(4);
    const _r11 = ɵngcc0.ɵɵreference(12);
    const _r9 = ɵngcc0.ɵɵreference(10);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r46.visibleIndex === 0 && ctx_r45.grid.hasDetails ? _r11 : _r9)("ngTemplateOutletContext", ctx_r45.getContext(col_r46, ctx_r45));
} }
function IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_5_ng_template_1_Template, 1, 2, "ng-template", 17);
    ɵngcc0.ɵɵpipe(2, "igxNotGrouped");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r39 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r39.pinnedColumns));
} }
function IgxGridRowComponent_ng_template_3_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_1_Template, 3, 3, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(2, IgxGridRowComponent_ng_template_3_ng_container_3_ng_template_2_Template, 1, 2, "ng-template", 15, 16, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵpipe(4, "igxNotGrouped");
    ɵngcc0.ɵɵtemplate(5, IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_5_Template, 3, 3, "ng-container", 10);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r23 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r23.pinnedColumns.length > 0 && ctx_r23.grid.isPinningToStart);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(4, 8, ctx_r23.unpinnedColumns))("igxForScrollContainer", ctx_r23.grid.parentVirtDir)("igxForScrollOrientation", "horizontal")("igxForContainerSize", ctx_r23.grid.unpinnedWidth)("igxForSizePropName", "calcPixelWidth")("igxForTrackBy", ctx_r23.grid.trackColumnChanges);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r23.pinnedColumns.length > 0 && !ctx_r23.grid.isPinningToStart);
} }
function IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 14);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r48 = ɵngcc0.ɵɵnextContext(3);
    const _r5 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r5)("ngTemplateOutletContext", ctx_r48.getContextMRL(ctx_r48.pinnedColumns, ctx_r48));
} }
function IgxGridRowComponent_ng_template_3_ng_container_4_ng_template_2_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_template_3_ng_container_4_ng_template_2_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_3_ng_container_4_ng_template_2_ng_template_1_ng_container_0_Template, 1, 0, "ng-container", 14);
} if (rf & 2) {
    const col_r56 = ctx.$implicit;
    const ctx_r55 = ɵngcc0.ɵɵnextContext(4);
    const _r15 = ɵngcc0.ɵɵreference(16);
    const _r13 = ɵngcc0.ɵɵreference(14);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r56.visibleIndex === 0 && ctx_r55.grid.hasDetails ? _r15 : _r13)("ngTemplateOutletContext", ctx_r55.getContext(col_r56, ctx_r55));
} }
function IgxGridRowComponent_ng_template_3_ng_container_4_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 18);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_4_ng_template_2_ng_template_1_Template, 1, 2, "ng-template", 17);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r53 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction4(2, _c104, col_r53.getGridTemplate(true, false), col_r53.getGridTemplate(false, false), col_r53.getGridTemplate(true, true), col_r53.getGridTemplate(false, true)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", col_r53.children);
} }
function IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_5_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_5_ng_container_1_Template, 1, 0, "ng-container", 14);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r51 = ɵngcc0.ɵɵnextContext(3);
    const _r5 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r5)("ngTemplateOutletContext", ctx_r51.getContextMRL(ctx_r51.pinnedColumns, ctx_r51));
} }
function IgxGridRowComponent_ng_template_3_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_1_Template, 2, 2, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(2, IgxGridRowComponent_ng_template_3_ng_container_4_ng_template_2_Template, 2, 7, "ng-template", 15, 16, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵpipe(4, "igxTopLevel");
    ɵngcc0.ɵɵtemplate(5, IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_5_Template, 2, 2, "ng-container", 10);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r24 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r24.pinnedColumns.length > 0 && ctx_r24.grid.isPinningToStart);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(4, 8, ctx_r24.unpinnedColumns))("igxForScrollContainer", ctx_r24.grid.parentVirtDir)("igxForScrollOrientation", "horizontal")("igxForContainerSize", ctx_r24.grid.unpinnedWidth)("igxForSizePropName", "calcPixelWidth")("igxForTrackBy", ctx_r24.grid.trackColumnChanges);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r24.pinnedColumns.length > 0 && !ctx_r24.grid.isPinningToStart);
} }
function IgxGridRowComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_3_ng_container_0_Template, 2, 3, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_1_Template, 3, 5, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(2, IgxGridRowComponent_ng_template_3_ng_container_2_Template, 3, 8, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(3, IgxGridRowComponent_ng_template_3_ng_container_3_Template, 6, 10, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(4, IgxGridRowComponent_ng_template_3_ng_container_4_Template, 6, 10, "ng-container", 10);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.grid.groupingExpressions.length > 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.rowDraggable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.showRowSelectors);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r4.grid.hasColumnLayouts);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.grid.hasColumnLayouts);
} }
function IgxGridRowComponent_ng_template_5_div_0_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_template_5_div_0_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_5_div_0_ng_template_1_ng_container_0_Template, 1, 0, "ng-container", 14);
} if (rf & 2) {
    const col_r63 = ctx.$implicit;
    const ctx_r62 = ɵngcc0.ɵɵnextContext(3);
    const _r15 = ɵngcc0.ɵɵreference(16);
    const _r13 = ɵngcc0.ɵɵreference(14);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r63.visibleIndex === 0 && ctx_r62.grid.hasDetails ? _r15 : _r13)("ngTemplateOutletContext", ctx_r62.getContext(col_r63, ctx_r62));
} }
const _c204 = function (a0, a1, a2, a3, a4) { return { "grid-template-rows": a0, "grid-template-columns": a1, "z-index": a2, "-ms-grid-rows": a3, "-ms-grid-columns": a4 }; };
function IgxGridRowComponent_ng_template_5_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 18);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_5_div_0_ng_template_1_Template, 1, 2, "ng-template", 17);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r61 = ctx.$implicit;
    const ctx_r60 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("left", ctx_r60.mrlRightPinnedOffset);
    ɵngcc0.ɵɵclassProp("igx-grid__td--pinned-last", col_r61.hasLastPinnedChildColumn)("igx-grid__td--pinned-first", col_r61.hasFirstPinnedChildColumn);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction5(8, _c204, col_r61.getGridTemplate(true, false), col_r61.getGridTemplate(false, false), col_r61.pinned ? 1 : null, col_r61.getGridTemplate(true, true), col_r61.getGridTemplate(false, true)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", col_r61.children);
} }
function IgxGridRowComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_5_div_0_Template, 2, 14, "div", 19);
    ɵngcc0.ɵɵpipe(1, "igxTopLevel");
} if (rf & 2) {
    const pinnedColumns_r59 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(1, 1, pinnedColumns_r59));
} }
function IgxGridRowComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 20);
    ɵngcc0.ɵɵelement(1, "igx-checkbox", 21);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("tabindex", -1)("checked", ctx_r8.selected)("readonly", true)("disabled", ctx_r8.deleted)("disableTransitions", ctx_r8.grid.disableTransitions)("aria-label", ctx_r8.rowCheckboxAriaLabel);
} }
const _c205 = function (a0, a1, a2, a3, a4, a5) { return [a0, a1, a2, a3, a4, a5]; };
function IgxGridRowComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-grid-cell", 22, 23);
    ɵngcc0.ɵɵpipe(2, "transactionState");
    ɵngcc0.ɵɵpipe(3, "igxStringReplace");
    ɵngcc0.ɵɵpipe(4, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(5, "igxCellStyles");
    ɵngcc0.ɵɵpipe(6, "dataMapper");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r65 = ctx.$implicit;
    const ctx_r10 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r10.cellHeight, "px")("min-width", col_r65.width)("max-width", col_r65.width)("flex-basis", col_r65.width)("left", col_r65.rightPinnedOffset);
    ɵngcc0.ɵɵclassProp("igx-grid__td--edited", ɵngcc0.ɵɵpipeBindV(2, 36, ɵngcc0.ɵɵpureFunction7(66, _c183, ctx_r10.rowID, col_r65.field, ctx_r10.grid.rowEditable, ctx_r10.grid.transactions, ctx_r10.grid.pipeTrigger, ctx_r10.grid.crudService.cell, ctx_r10.grid.crudService.row)))("igx-grid__td--pinned", col_r65.pinned)("igx-grid__td--number", col_r65.dataType === "number")("igx-grid__td--bool", col_r65.dataType === "boolean");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(4, 48, ɵngcc0.ɵɵpureFunction6(74, _c205, col_r65.cellClasses, ctx_r10.rowData[col_r65.field], ctx_r10.rowData, col_r65.field, ctx_r10.viewIndex, ctx_r10.grid.pipeTrigger)))("ngStyle", ɵngcc0.ɵɵpipeBindV(5, 55, ɵngcc0.ɵɵpureFunction6(81, _c205, col_r65.cellStyles, ctx_r10.rowData[col_r65.field], ctx_r10.rowData, col_r65.field, ctx_r10.viewIndex, ctx_r10.grid.pipeTrigger)))("editMode", col_r65.editable && ctx_r10.crudService.targetInEdit(ctx_r10.index, col_r65.index))("column", col_r65)("formatter", col_r65.formatter)("row", ctx_r10)("lastPinned", col_r65.columnLayoutChild ? null : col_r65.isLastPinned)("firstPinned", col_r65.columnLayoutChild ? null : col_r65.isFirstPinned)("rowData", ctx_r10.rowData)("width", col_r65.getCellWidth())("visibleColumnIndex", col_r65.visibleIndex)("value", ɵngcc0.ɵɵpipeBind3(6, 62, ctx_r10.rowData, col_r65.field, ctx_r10.grid.pipeTrigger))("cellTemplate", col_r65.bodyTemplate)("lastSearchInfo", ctx_r10.grid.lastSearchInfo)("active", ctx_r10.isCellActive(col_r65.visibleIndex))("cellSelectionMode", ctx_r10.grid.cellSelection)("displayPinnedChip", ctx_r10.shouldDisplayPinnedChip(col_r65.visibleIndex));
    ɵngcc0.ɵɵattribute("aria-describedby", ɵngcc0.ɵɵpipeBind3(3, 44, ctx_r10.gridID + "_" + col_r65.field, ".", "_"));
} }
function IgxGridRowComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-expandable-grid-cell", 24, 23);
    ɵngcc0.ɵɵpipe(2, "transactionState");
    ɵngcc0.ɵɵpipe(3, "igxStringReplace");
    ɵngcc0.ɵɵpipe(4, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(5, "igxCellStyles");
    ɵngcc0.ɵɵpipe(6, "dataMapper");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r67 = ctx.$implicit;
    const ctx_r12 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r12.cellHeight, "px")("min-width", col_r67.width)("max-width", col_r67.width)("flex-basis", col_r67.width);
    ɵngcc0.ɵɵclassProp("igx-grid__td--pinned", col_r67.pinned)("igx-grid__td--edited", ɵngcc0.ɵɵpipeBindV(2, 32, ɵngcc0.ɵɵpureFunction7(62, _c183, ctx_r12.rowID, col_r67.field, ctx_r12.grid.rowEditable, ctx_r12.grid.transactions, ctx_r12.grid.pipeTrigger, ctx_r12.grid.crudService.cell, ctx_r12.grid.crudService.row)))("igx-grid__td--number", col_r67.dataType === "number" && col_r67.visibleIndex !== 0);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(4, 44, ɵngcc0.ɵɵpureFunction6(70, _c205, col_r67.cellClasses, ctx_r12.rowData[col_r67.field], ctx_r12.rowData, col_r67.field, ctx_r12.viewIndex, ctx_r12.grid.pipeTrigger)))("ngStyle", ɵngcc0.ɵɵpipeBindV(5, 51, ɵngcc0.ɵɵpureFunction6(77, _c205, col_r67.cellStyles, ctx_r12.rowData[col_r67.field], ctx_r12.rowData, col_r67.field, ctx_r12.viewIndex, ctx_r12.grid.pipeTrigger)))("expanded", ctx_r12.expanded)("editMode", col_r67.editable && ctx_r12.crudService.targetInEdit(ctx_r12.index, col_r67.index))("column", col_r67)("formatter", col_r67.formatter)("row", ctx_r12)("lastPinned", col_r67.columnLayoutChild ? null : col_r67.isLastPinned)("rowData", ctx_r12.rowData)("width", col_r67.getCellWidth())("visibleColumnIndex", col_r67.visibleIndex)("value", ɵngcc0.ɵɵpipeBind3(6, 58, ctx_r12.rowData, col_r67.field, ctx_r12.grid.pipeTrigger))("cellTemplate", col_r67.bodyTemplate)("lastSearchInfo", ctx_r12.grid.lastSearchInfo)("active", ctx_r12.isCellActive(col_r67.visibleIndex))("cellSelectionMode", ctx_r12.grid.cellSelection)("displayPinnedChip", ctx_r12.shouldDisplayPinnedChip(col_r67.visibleIndex));
    ɵngcc0.ɵɵattribute("aria-describedby", ɵngcc0.ɵɵpipeBind3(3, 40, ctx_r12.gridID + "_" + col_r67.field, ".", "_"));
} }
function IgxGridRowComponent_ng_template_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-grid-cell", 25, 23);
    ɵngcc0.ɵɵpipe(2, "transactionState");
    ɵngcc0.ɵɵpipe(3, "igxStringReplace");
    ɵngcc0.ɵɵpipe(4, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(5, "igxCellStyles");
    ɵngcc0.ɵɵpipe(6, "dataMapper");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r69 = ctx.$implicit;
    const ctx_r14 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("-ms-grid-row-span", col_r69.gridRowSpan)("-ms-grid-column-span", col_r69.gridColumnSpan)("grid-row-end", col_r69.rowEnd)("grid-column-end", col_r69.colEnd)("-ms-grid-row", col_r69.rowStart)("grid-row-start", col_r69.rowStart)("-ms-grid-column", col_r69.colStart)("grid-column-start", col_r69.colStart)("min-height", ctx_r14.cellHeight, "px");
    ɵngcc0.ɵɵclassProp("igx-grid__td--edited", ɵngcc0.ɵɵpipeBindV(2, 41, ɵngcc0.ɵɵpureFunction7(71, _c183, ctx_r14.rowID, col_r69.field, ctx_r14.grid.rowEditable, ctx_r14.grid.transactions, ctx_r14.grid.pipeTrigger, ctx_r14.grid.crudService.cell, ctx_r14.grid.crudService.row)))("igx-grid__td--pinned", col_r69.pinned)("igx-grid__td--number", col_r69.dataType === "number");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(4, 53, ɵngcc0.ɵɵpureFunction6(79, _c205, col_r69.cellClasses, ctx_r14.rowData[col_r69.field], ctx_r14.rowData, col_r69.field, ctx_r14.viewIndex, ctx_r14.grid.pipeTrigger)))("ngStyle", ɵngcc0.ɵɵpipeBindV(5, 60, ɵngcc0.ɵɵpureFunction6(86, _c205, col_r69.cellStyles, ctx_r14.rowData[col_r69.field], ctx_r14.rowData, col_r69.field, ctx_r14.viewIndex, ctx_r14.grid.pipeTrigger)))("editMode", col_r69.editable && ctx_r14.crudService.targetInEdit(ctx_r14.index, col_r69.index))("column", col_r69)("lastPinned", col_r69.columnLayoutChild ? null : col_r69.isLastPinned)("firstPinned", col_r69.columnLayoutChild ? null : col_r69.isFirstPinned)("formatter", col_r69.formatter)("row", ctx_r14)("rowData", ctx_r14.rowData)("visibleColumnIndex", col_r69.visibleIndex)("value", ɵngcc0.ɵɵpipeBind3(6, 67, ctx_r14.rowData, col_r69.field, ctx_r14.grid.pipeTrigger))("cellTemplate", col_r69.bodyTemplate)("lastSearchInfo", ctx_r14.grid.lastSearchInfo)("active", ctx_r14.isCellActive(col_r69.visibleIndex))("cellSelectionMode", ctx_r14.grid.cellSelection)("displayPinnedChip", ctx_r14.shouldDisplayPinnedChip(col_r69.visibleIndex));
    ɵngcc0.ɵɵattribute("aria-describedby", ɵngcc0.ɵɵpipeBind3(3, 49, ctx_r14.gridID + "_" + col_r69.field, ".", "_"));
} }
function IgxGridRowComponent_ng_template_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-expandable-grid-cell", 26, 23);
    ɵngcc0.ɵɵpipe(2, "transactionState");
    ɵngcc0.ɵɵpipe(3, "igxStringReplace");
    ɵngcc0.ɵɵpipe(4, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(5, "igxCellStyles");
    ɵngcc0.ɵɵpipe(6, "dataMapper");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r71 = ctx.$implicit;
    const ctx_r16 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("-ms-grid-row-span", col_r71.gridRowSpan)("-ms-grid-column-span", col_r71.gridColumnSpan)("grid-row-end", col_r71.rowEnd)("grid-column-end", col_r71.colEnd)("-ms-grid-row", col_r71.rowStart)("grid-row-start", col_r71.rowStart)("-ms-grid-column", col_r71.colStart)("grid-column-start", col_r71.colStart)("min-height", ctx_r16.cellHeight, "px");
    ɵngcc0.ɵɵclassProp("igx-grid__td--edited", ɵngcc0.ɵɵpipeBindV(2, 41, ɵngcc0.ɵɵpureFunction7(71, _c183, ctx_r16.rowID, col_r71.field, ctx_r16.grid.rowEditable, ctx_r16.grid.transactions, ctx_r16.grid.pipeTrigger, ctx_r16.grid.crudService.cell, ctx_r16.grid.crudService.row)))("igx-grid__td--pinned", col_r71.pinned)("igx-grid__td--number", col_r71.dataType === "number" && col_r71.visibleIndex !== 0);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(4, 53, ɵngcc0.ɵɵpureFunction6(79, _c205, col_r71.cellClasses, ctx_r16.rowData[col_r71.field], ctx_r16.rowData, col_r71.field, ctx_r16.viewIndex, ctx_r16.grid.pipeTrigger)))("ngStyle", ɵngcc0.ɵɵpipeBindV(5, 60, ɵngcc0.ɵɵpureFunction6(86, _c205, col_r71.cellStyles, ctx_r16.rowData[col_r71.field], ctx_r16.rowData, col_r71.field, ctx_r16.viewIndex, ctx_r16.grid.pipeTrigger)))("expanded", ctx_r16.expanded)("editMode", col_r71.editable && ctx_r16.crudService.targetInEdit(ctx_r16.index, col_r71.index))("column", col_r71)("lastPinned", col_r71.columnLayoutChild ? null : col_r71.isLastPinned)("formatter", col_r71.formatter)("row", ctx_r16)("rowData", ctx_r16.rowData)("visibleColumnIndex", col_r71.visibleIndex)("value", ɵngcc0.ɵɵpipeBind3(6, 67, ctx_r16.rowData, col_r71.field, ctx_r16.grid.pipeTrigger))("cellTemplate", col_r71.bodyTemplate)("lastSearchInfo", ctx_r16.grid.lastSearchInfo)("active", ctx_r16.isCellActive(col_r71.visibleIndex))("cellSelectionMode", ctx_r16.grid.cellSelection)("displayPinnedChip", ctx_r16.shouldDisplayPinnedChip(col_r71.visibleIndex));
    ɵngcc0.ɵɵattribute("aria-describedby", ɵngcc0.ɵɵpipeBind3(3, 49, ctx_r16.gridID + "_" + col_r71.field, ".", "_"));
} }
const _c206 = ["indicator"];
const _c207 = ["indentationDiv"];
function IgxGridExpandableCellComponent_ng_template_0_igx_chip_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-chip", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("disabled", true)("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r15.grid.resourceStrings.igx_grid_pinned_row_indicator);
} }
function IgxGridExpandableCellComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridExpandableCellComponent_ng_template_0_igx_chip_0_Template, 2, 3, "igx-chip", 8);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.displayPinnedChip);
} }
function IgxGridExpandableCellComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵpipe(1, "columnFormatter");
    ɵngcc0.ɵɵpipe(2, "number");
    ɵngcc0.ɵɵpipe(3, "date");
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵpipe(5, "columnFormatter");
    ɵngcc0.ɵɵpipe(6, "number");
    ɵngcc0.ɵɵpipe(7, "date");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("cssClass", ctx_r3.highlightClass)("activeCssClass", ctx_r3.activeHighlightClass)("groupName", ctx_r3.gridID)("value", ctx_r3.formatter ? ɵngcc0.ɵɵpipeBind2(1, 9, ctx_r3.value, ctx_r3.formatter) : ctx_r3.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind3(2, 12, ctx_r3.value, ctx_r3.column.pipeArgs.digitsInfo, ctx_r3.grid.locale) : ctx_r3.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind4(3, 16, ctx_r3.value, ctx_r3.column.pipeArgs.format, ctx_r3.column.pipeArgs.timezone, ctx_r3.grid.locale) : ctx_r3.value)("row", ctx_r3.rowData)("column", ctx_r3.column.field)("containerClass", "igx-grid__td-text")("metadata", ctx_r3.searchMetadata);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.formatter ? ɵngcc0.ɵɵpipeBind2(5, 21, ctx_r3.value, ctx_r3.formatter) : ctx_r3.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind3(6, 24, ctx_r3.value, ctx_r3.column.pipeArgs.digitsInfo, ctx_r3.grid.locale) : ctx_r3.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind4(7, 28, ctx_r3.value, ctx_r3.column.pipeArgs.format, ctx_r3.column.pipeArgs.timezone, ctx_r3.grid.locale) : ctx_r3.value);
} }
function IgxGridExpandableCellComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵpipe(1, "columnFormatter");
    ɵngcc0.ɵɵpipe(2, "number");
    ɵngcc0.ɵɵpipe(3, "date");
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("cssClass", ctx_r5.highlightClass)("activeCssClass", ctx_r5.activeHighlightClass)("groupName", ctx_r5.gridID)("value", ctx_r5.formatter ? ɵngcc0.ɵɵpipeBind2(1, 9, ctx_r5.value, ctx_r5.formatter) : ctx_r5.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind3(2, 12, ctx_r5.value, ctx_r5.column.pipeArgs.digitsInfo, ctx_r5.grid.locale) : ctx_r5.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind4(3, 16, ctx_r5.value, ctx_r5.column.pipeArgs.format, ctx_r5.column.pipeArgs.timezone, ctx_r5.grid.locale) : ctx_r5.value)("row", ctx_r5.rowData)("column", ctx_r5.column.field)("containerClass", "igx-grid__td-text")("metadata", ctx_r5.searchMetadata);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r5.value ? ctx_r5.value : ctx_r5.column.header || ctx_r5.column.field);
} }
function IgxGridExpandableCellComponent_ng_template_6_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r23 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 11);
    ɵngcc0.ɵɵelementStart(2, "input", 12);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxGridExpandableCellComponent_ng_template_6_ng_container_0_Template_input_ngModelChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r23); const ctx_r22 = ɵngcc0.ɵɵnextContext(2); return ctx_r22.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r18 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r18.editValue)("igxFocus", true);
} }
function IgxGridExpandableCellComponent_ng_template_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r25 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 11);
    ɵngcc0.ɵɵelementStart(2, "input", 13);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxGridExpandableCellComponent_ng_template_6_ng_container_1_Template_input_ngModelChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r25); const ctx_r24 = ɵngcc0.ɵɵnextContext(2); return ctx_r24.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r19.editValue)("igxFocus", true);
} }
function IgxGridExpandableCellComponent_ng_template_6_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r27 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-checkbox", 14);
    ɵngcc0.ɵɵlistener("change", function IgxGridExpandableCellComponent_ng_template_6_ng_container_2_Template_igx_checkbox_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r27); const ctx_r26 = ɵngcc0.ɵɵnextContext(2); return ctx_r26.editValue = $event.checked; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r20 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r20.editValue)("checked", ctx_r20.editValue)("disableRipple", true);
} }
function IgxGridExpandableCellComponent_ng_template_6_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r29 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-date-picker", 15);
    ɵngcc0.ɵɵlistener("valueChange", function IgxGridExpandableCellComponent_ng_template_6_ng_container_3_Template_igx_date_picker_valueChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r29); const ctx_r28 = ɵngcc0.ɵɵnextContext(2); return ctx_r28.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r21 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", 100, "%");
    ɵngcc0.ɵɵproperty("outlet", ctx_r21.grid.outlet)("locale", ctx_r21.grid.locale)("value", ctx_r21.editValue)("igxFocus", true)("labelVisibility", false);
} }
function IgxGridExpandableCellComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridExpandableCellComponent_ng_template_6_ng_container_0_Template, 3, 2, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(1, IgxGridExpandableCellComponent_ng_template_6_ng_container_1_Template, 3, 2, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(2, IgxGridExpandableCellComponent_ng_template_6_ng_container_2_Template, 2, 3, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(3, IgxGridExpandableCellComponent_ng_template_6_ng_container_3_Template, 2, 7, "ng-container", 4);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "string");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "number");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "boolean");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "date");
} }
function IgxGridExpandableCellComponent_ng_container_8_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridExpandableCellComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    const _r33 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 16, 17);
    ɵngcc0.ɵɵlistener("click", function IgxGridExpandableCellComponent_ng_container_8_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r32 = ɵngcc0.ɵɵnextContext(); return ctx_r32.toggle($event); })("focus", function IgxGridExpandableCellComponent_ng_container_8_Template_div_focus_1_listener() { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r34 = ɵngcc0.ɵɵnextContext(); return ctx_r34.onIndicatorFocus(); });
    ɵngcc0.ɵɵtemplate(3, IgxGridExpandableCellComponent_ng_container_8_ng_container_3_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r8.iconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, ctx_r8));
} }
function IgxGridExpandableCellComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridExpandableCellComponent_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridExpandableCellComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 18);
    ɵngcc0.ɵɵtext(1, "expand_more");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridExpandableCellComponent_ng_template_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 18);
    ɵngcc0.ɵɵtext(1, "chevron_right");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxTreeGridComponent_igx_grid_toolbar_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-toolbar", 65, 66);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("max-width", ctx_r0.outerWidth, "px")("flex-basis", ctx_r0.outerWidth, "px");
    ɵngcc0.ɵɵproperty("gridID", ctx_r0.id)("displayDensity", ctx_r0.displayDensity);
} }
function IgxTreeGridComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 67);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r2.featureColumnsWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r2.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxTreeGridComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 68);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r3.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r3.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxTreeGridComponent_ng_container_7_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    const _r70 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 69, 70);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxTreeGridComponent_ng_container_7_Template_div_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r70); return $event.preventDefault(); });
    ɵngcc0.ɵɵelementStart(3, "div", 71);
    ɵngcc0.ɵɵtemplate(4, IgxTreeGridComponent_ng_container_7_ng_container_4_Template, 1, 0, "ng-container", 20);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    const _r59 = ɵngcc0.ɵɵreference(95);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.dragIndicatorIconTemplate ? ctx_r4.dragIndicatorIconTemplate : _r59);
} }
function IgxTreeGridComponent_ng_container_8_3_ng_template_0_Template(rf, ctx) { }
function IgxTreeGridComponent_ng_container_8_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridComponent_ng_container_8_3_ng_template_0_Template, 0, 0, "ng-template", null, 75, ɵngcc0.ɵɵtemplateRefExtractor);
} }
function IgxTreeGridComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    const _r76 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 72, 73);
    ɵngcc0.ɵɵlistener("click", function IgxTreeGridComponent_ng_container_8_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r76); const ctx_r75 = ɵngcc0.ɵɵnextContext(); return ctx_r75.onHeaderSelectorClick($event); })("pointerdown", function IgxTreeGridComponent_ng_container_8_Template_div_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r76); return $event.preventDefault(); });
    ɵngcc0.ɵɵtemplate(3, IgxTreeGridComponent_ng_container_8_3_Template, 2, 0, undefined, 74);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    const _r61 = ɵngcc0.ɵɵreference(97);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c173, ctx_r5.filteringService.isFilterRowVisible));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r5.headSelectorTemplate ? ctx_r5.headSelectorTemplate : _r61)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(8, _c17, ɵngcc0.ɵɵpureFunction2(5, _c174, ctx_r5.selectionService.filteredSelectedRowIds.length, ctx_r5.totalRowsCountAfterFilter)));
} }
function IgxTreeGridComponent_ng_container_9_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 77);
} if (rf & 2) {
    const col_r79 = ctx.$implicit;
    const ctx_r78 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r78.getHeaderGroupWidth(col_r79))("flex-basis", ctx_r78.getHeaderGroupWidth(col_r79));
    ɵngcc0.ɵɵproperty("column", col_r79)("gridID", ctx_r78.id);
} }
function IgxTreeGridComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridComponent_ng_container_9_ng_template_1_Template, 1, 6, "ng-template", 76);
    ɵngcc0.ɵɵpipe(2, "igxTopLevel");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r6.pinnedColumns));
} }
function IgxTreeGridComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 77);
} if (rf & 2) {
    const col_r80 = ctx.$implicit;
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r8.getHeaderGroupWidth(col_r80))("flex-basis", ctx_r8.getHeaderGroupWidth(col_r80));
    ɵngcc0.ɵɵproperty("column", col_r80)("gridID", ctx_r8.id);
} }
function IgxTreeGridComponent_ng_container_13_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 77);
} if (rf & 2) {
    const col_r82 = ctx.$implicit;
    const ctx_r81 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r81.getHeaderGroupWidth(col_r82))("flex-basis", ctx_r81.getHeaderGroupWidth(col_r82))("left", col_r82.rightPinnedOffset);
    ɵngcc0.ɵɵproperty("column", col_r82)("gridID", ctx_r81.id);
} }
function IgxTreeGridComponent_ng_container_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridComponent_ng_container_13_ng_template_1_Template, 1, 8, "ng-template", 76);
    ɵngcc0.ɵɵpipe(2, "igxTopLevel");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r9.pinnedColumns));
} }
function IgxTreeGridComponent_igx_grid_filtering_row_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-filtering-row", 78, 79);
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("column", ctx_r10.filteringService.filteredColumn);
} }
function IgxTreeGridComponent_igx_circular_bar_18_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-circular-bar", 80);
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxTreeGridComponent_span_19_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 81);
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r13.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxTreeGridComponent_span_23_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 67);
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r15.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxTreeGridComponent_span_24_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 68);
} if (rf & 2) {
    const ctx_r16 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r16.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r16.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxTreeGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 74);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const rowData_r89 = ctx.$implicit;
    const rowIndex_r90 = ctx.index;
    const ctx_r88 = ɵngcc0.ɵɵnextContext(4);
    const _r25 = ɵngcc0.ɵɵreference(44);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r25)("ngTemplateOutletContext", ctx_r88.getContext(rowData_r89, rowIndex_r90, true));
} }
function IgxTreeGridComponent_ng_template_25_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 83, 84);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_Template, 2, 2, "ng-container", 85);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const pinnedData_r85 = ɵngcc0.ɵɵnextContext().ngIf;
    const ctx_r86 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("width", ctx_r86.calcWidth, "px");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(4, _c175, !ctx_r86.isRowPinningToTop, ctx_r86.isRowPinningToTop));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", pinnedData_r85);
} }
function IgxTreeGridComponent_ng_template_25_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridComponent_ng_template_25_ng_container_0_div_1_Template, 3, 7, "div", 82);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const pinnedData_r85 = ctx.ngIf;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", pinnedData_r85.length > 0);
} }
function IgxTreeGridComponent_ng_template_25_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridComponent_ng_template_25_ng_container_0_Template, 2, 1, "ng-container", 7);
    ɵngcc0.ɵɵpipe(1, "gridAddRow");
    ɵngcc0.ɵɵpipe(2, "treeGridSorting");
    ɵngcc0.ɵɵpipe(3, "treeGridFiltering");
    ɵngcc0.ɵɵpipe(4, "gridRowPinning");
    ɵngcc0.ɵɵpipe(5, "treeGridNormalizeRecord");
    ɵngcc0.ɵɵpipe(6, "visibleColumns");
    ɵngcc0.ɵɵpipe(7, "treeGridTransaction");
} if (rf & 2) {
    const ctx_r18 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBind3(1, 1, ɵngcc0.ɵɵpipeBindV(2, 5, ɵngcc0.ɵɵpureFunction5(44, _c177, ɵngcc0.ɵɵpipeBindV(3, 12, ɵngcc0.ɵɵpureFunction7(36, _c176, ɵngcc0.ɵɵpipeBind4(4, 21, ɵngcc0.ɵɵpipeBind2(5, 26, ɵngcc0.ɵɵpipeBind2(6, 29, ɵngcc0.ɵɵpipeBind3(7, 32, ctx_r18.data, ctx_r18.id, ctx_r18.pipeTrigger), ctx_r18.hasVisibleColumns), ctx_r18.pipeTrigger), ctx_r18.id, true, ctx_r18.pipeTrigger), ctx_r18.filteringExpressionsTree, ctx_r18.filterStrategy, ctx_r18.advancedFilteringExpressionsTree, ctx_r18.id, ctx_r18.pipeTrigger, ctx_r18.filteringPipeTrigger)), ctx_r18.sortingExpressions, ctx_r18.sortStrategy, ctx_r18.id, ctx_r18.pipeTrigger)), true, ctx_r18.pipeTrigger));
} }
function IgxTreeGridComponent_ng_container_27_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_template_28_ng_template_0_Template(rf, ctx) { }
function IgxTreeGridComponent_ng_template_28_Template(rf, ctx) { if (rf & 1) {
    const _r97 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridComponent_ng_template_28_ng_template_0_Template, 0, 0, "ng-template", 86);
    ɵngcc0.ɵɵlistener("onCachedViewLoaded", function IgxTreeGridComponent_ng_template_28_Template_ng_template_onCachedViewLoaded_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r97); const ctx_r96 = ɵngcc0.ɵɵnextContext(); return ctx_r96.cachedViewLoaded($event); });
} if (rf & 2) {
    const rowData_r93 = ctx.$implicit;
    const rowIndex_r94 = ctx.index;
    const ctx_r21 = ɵngcc0.ɵɵnextContext();
    const _r27 = ɵngcc0.ɵɵreference(46);
    const _r23 = ɵngcc0.ɵɵreference(42);
    ɵngcc0.ɵɵproperty("igxTemplateOutlet", ctx_r21.isSummaryRow(rowData_r93) ? _r27 : _r23)("igxTemplateOutletContext", ctx_r21.getContext(rowData_r93, rowIndex_r94, false));
} }
function IgxTreeGridComponent_ng_container_40_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_template_41_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-tree-grid-row", 87, 88);
} if (rf & 2) {
    const rowIndex_r98 = ctx.index;
    const disabledRow_r99 = ctx.disabled;
    const rowData_r100 = ctx.$implicit;
    const isAddRow_r101 = ctx.addRow;
    const ctx_r24 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r24.id)("index", rowIndex_r98)("treeRow", rowData_r100)("disabled", disabledRow_r99)("addRow", isAddRow_r101);
} }
function IgxTreeGridComponent_ng_template_43_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-tree-grid-row", 89, 90);
} if (rf & 2) {
    const rowIndex_r103 = ctx.index;
    const rowData_r104 = ctx.$implicit;
    const isAddRow_r105 = ctx.addRow;
    const ctx_r26 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r26.id)("index", rowIndex_r103)("treeRow", rowData_r104)("addRow", isAddRow_r105);
} }
function IgxTreeGridComponent_ng_template_45_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-row", 91, 92);
} if (rf & 2) {
    const rowIndex_r108 = ctx.index;
    const rowData_r109 = ctx.$implicit;
    const ctx_r28 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r28.id)("summaries", rowData_r109.summaries)("firstCellIndentation", rowData_r109.cellIndentation)("index", rowIndex_r108);
} }
function IgxTreeGridComponent_ng_container_47_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_span_51_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 81);
} if (rf & 2) {
    const ctx_r31 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r31.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxTreeGridComponent_ng_template_55_Template(rf, ctx) { }
function IgxTreeGridComponent_igx_grid_summary_row_64_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-row", 93, 92);
    ɵngcc0.ɵɵpipe(2, "igxGridSummaryDataPipe");
} if (rf & 2) {
    const ctx_r36 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r36.calcWidth, "px")("height", ctx_r36.summariesHeight, "px");
    ɵngcc0.ɵɵproperty("gridID", ctx_r36.id)("summaries", ɵngcc0.ɵɵpipeBind2(2, 7, ctx_r36.id, ctx_r36.summaryService.retriggerRootPipe))("index", ctx_r36.dataView.length);
} }
function IgxTreeGridComponent_ng_template_70_Template(rf, ctx) { }
function IgxTreeGridComponent_ng_container_76_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_container_76_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridComponent_ng_container_76_ng_container_1_Template, 1, 0, "ng-container", 74);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r41 = ɵngcc0.ɵɵnextContext();
    const _r42 = ɵngcc0.ɵɵreference(78);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r41.paginationTemplate ? ctx_r41.paginationTemplate : _r42)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, ctx_r41));
} }
function IgxTreeGridComponent_ng_template_77_Template(rf, ctx) { if (rf & 1) {
    const _r114 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-paginator", 94);
    ɵngcc0.ɵɵlistener("pageChange", function IgxTreeGridComponent_ng_template_77_Template_igx_paginator_pageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r114); const ctx_r113 = ɵngcc0.ɵɵnextContext(); return ctx_r113.page = $event; })("perPageChange", function IgxTreeGridComponent_ng_template_77_Template_igx_paginator_perPageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r114); const ctx_r115 = ɵngcc0.ɵɵnextContext(); return ctx_r115.perPage = $event; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r43 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("overlaySettings", ctx_r43.paginatorSettings)("displayDensity", ctx_r43.displayDensity)("page", ctx_r43.page)("totalRecords", ctx_r43.totalRecords)("perPage", ctx_r43.perPage);
} }
function IgxTreeGridComponent_ng_template_79_span_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_template_79_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridComponent_ng_template_79_span_3_ng_container_1_Template, 1, 0, "ng-container", 20);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r116 = ɵngcc0.ɵɵnextContext(2);
    const _r48 = ɵngcc0.ɵɵreference(84);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r116.addRowEmptyTemplate || _r48);
} }
function IgxTreeGridComponent_ng_template_79_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 95);
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, IgxTreeGridComponent_ng_template_79_span_3_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r45 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r45.emptyFilteredGridMessage);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r45.showAddButton);
} }
function IgxTreeGridComponent_ng_template_81_span_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_template_81_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridComponent_ng_template_81_span_3_ng_container_1_Template, 1, 0, "ng-container", 20);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r118 = ɵngcc0.ɵɵnextContext(2);
    const _r48 = ɵngcc0.ɵɵreference(84);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r118.addRowEmptyTemplate || _r48);
} }
function IgxTreeGridComponent_ng_template_81_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 95);
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, IgxTreeGridComponent_ng_template_81_span_3_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r47 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r47.emptyGridMessage);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r47.showAddButton);
} }
function IgxTreeGridComponent_ng_template_83_Template(rf, ctx) { if (rf & 1) {
    const _r121 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 96);
    ɵngcc0.ɵɵlistener("click", function IgxTreeGridComponent_ng_template_83_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r121); const ctx_r120 = ɵngcc0.ɵɵnextContext(); return ctx_r120.beginAddRowByIndex(null, -1); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r49 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r49.resourceStrings.igx_grid_add_row_label, " ");
} }
function IgxTreeGridComponent_ng_template_85_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 97);
    ɵngcc0.ɵɵelement(1, "igx-circular-bar", 80);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxTreeGridComponent_div_87_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_div_87_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 98);
    ɵngcc0.ɵɵelementStart(1, "div", 99);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridComponent_div_87_ng_container_2_Template, 1, 0, "ng-container", 74);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r52 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("className", ctx_r52.bannerClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r52.rowEditContainer)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(3, _c180, ctx_r52.rowChangesCount, ctx_r52.endEdit.bind(ctx_r52)));
} }
function IgxTreeGridComponent_ng_template_88_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r54 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" You have ", ctx_r54.rowChangesCount, " changes in this row\n");
} }
function IgxTreeGridComponent_ng_template_90_Template(rf, ctx) { if (rf & 1) {
    const _r124 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 100);
    ɵngcc0.ɵɵlistener("click", function IgxTreeGridComponent_ng_template_90_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r124); const ctx_r123 = ɵngcc0.ɵɵnextContext(); return ctx_r123.endRowEdit(false, $event); });
    ɵngcc0.ɵɵtext(1, "Cancel");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "button", 100);
    ɵngcc0.ɵɵlistener("click", function IgxTreeGridComponent_ng_template_90_Template_button_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r124); const ctx_r125 = ɵngcc0.ɵɵnextContext(); return ctx_r125.endRowEdit(true, $event); });
    ɵngcc0.ɵɵtext(3, "Done");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxTreeGridComponent_ng_template_92_div_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_template_92_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 104);
    ɵngcc0.ɵɵelementStart(1, "span", 105);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridComponent_ng_template_92_div_0_ng_container_2_Template, 1, 0, "ng-container", 74);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r126 = ɵngcc0.ɵɵnextContext(2);
    const _r53 = ɵngcc0.ɵɵreference(89);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r126.rowEditText ? ctx_r126.rowEditText : _r53)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, ctx_r126.rowChangesCount));
} }
function IgxTreeGridComponent_ng_template_92_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_template_92_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridComponent_ng_template_92_div_0_Template, 3, 4, "div", 101);
    ɵngcc0.ɵɵelementStart(1, "div", 102);
    ɵngcc0.ɵɵelementStart(2, "div", 103);
    ɵngcc0.ɵɵtemplate(3, IgxTreeGridComponent_ng_template_92_ng_container_3_Template, 1, 0, "ng-container", 74);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r58 = ɵngcc0.ɵɵnextContext();
    const _r55 = ɵngcc0.ɵɵreference(91);
    ɵngcc0.ɵɵproperty("ngIf", !(ctx_r58.crudService.row == null ? null : ctx_r58.crudService.row.isAddRow));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r58.rowEditActions ? ctx_r58.rowEditActions : _r55)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(3, _c17, ctx_r58.endEdit.bind(ctx_r58)));
} }
function IgxTreeGridComponent_ng_template_94_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 106);
    ɵngcc0.ɵɵtext(1, "drag_indicator");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxTreeGridComponent_ng_template_96_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 107);
    ɵngcc0.ɵɵelement(1, "igx-checkbox", 108, 109);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r129 = ctx.$implicit;
    const ctx_r62 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("tabindex", -1)("checked", context_r129.selectedCount > 0 && context_r129.totalCount === context_r129.selectedCount)("ngStyle", ɵngcc0.ɵɵpureFunction1(6, _c181, ctx_r62.isMultiRowSelectionEnabled ? "visible" : "hidden"))("readonly", true)("indeterminate", context_r129.selectedCount > 0 && context_r129.selectedCount !== context_r129.totalCount)("aria-label", ctx_r62.headSelectorBaseAriaLabel);
} }
function IgxTreeGridComponent_igx_grid_column_resizer_98_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-column-resizer");
} }
const _c208 = ["treeCell"];
function IgxTreeGridRowComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridRowComponent_ng_template_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridRowComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵlistener("animationend", function IgxTreeGridRowComponent_ng_template_1_Template_div_animationend_0_listener() { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.animationEndHandler(); });
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridRowComponent_ng_template_1_ng_container_1_Template, 1, 0, "ng-container", 0);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    const _r3 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵclassProp("igx-grid__tr--add-animate", ctx_r2.animateAdd);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function IgxTreeGridRowComponent_ng_template_3_ng_container_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridRowComponent_ng_template_3_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r20 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 9);
    ɵngcc0.ɵɵlistener("click", function IgxTreeGridRowComponent_ng_template_3_ng_container_0_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r20); return $event.stopPropagation(); });
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_template_3_ng_container_0_ng_container_2_Template, 1, 0, "ng-container", 0);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMap(ctx_r8.resolveDragIndicatorClasses);
    ɵngcc0.ɵɵproperty("igxRowDrag", ctx_r8)("ghostTemplate", ctx_r8.grid.getDragGhostCustomTemplate());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r8.grid.dragIndicatorIconTemplate ? ctx_r8.grid.dragIndicatorIconTemplate : ctx_r8.grid.dragIndicatorIconBase);
} }
function IgxTreeGridRowComponent_ng_template_3_ng_container_1_2_ng_template_0_Template(rf, ctx) { }
function IgxTreeGridRowComponent_ng_template_3_ng_container_1_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_template_3_ng_container_1_2_ng_template_0_Template, 0, 0, "ng-template");
} }
function IgxTreeGridRowComponent_ng_template_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r24 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 10);
    ɵngcc0.ɵɵlistener("click", function IgxTreeGridRowComponent_ng_template_3_ng_container_1_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r24); const ctx_r23 = ɵngcc0.ɵɵnextContext(2); return ctx_r23.onRowSelectorClick($event); })("pointerdown", function IgxTreeGridRowComponent_ng_template_3_ng_container_1_Template_div_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r24); return $event.preventDefault(); });
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_template_3_ng_container_1_2_Template, 1, 0, undefined, 11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r14 = ɵngcc0.ɵɵreference(8);
    const ctx_r9 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r9.grid.rowSelectorTemplate ? ctx_r9.grid.rowSelectorTemplate : _r14)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(6, _c17, ɵngcc0.ɵɵpureFunction3(2, _c203, ctx_r9.viewIndex, ctx_r9.rowID, ctx_r9.selected)));
} }
function IgxTreeGridRowComponent_ng_template_3_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridRowComponent_ng_template_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridRowComponent_ng_template_3_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 11);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r16 = ɵngcc0.ɵɵreference(10);
    const ctx_r10 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r16)("ngTemplateOutletContext", ctx_r10);
} }
function IgxTreeGridRowComponent_ng_template_3_ng_template_3_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-grid-cell", 14, 15);
    ɵngcc0.ɵɵpipe(2, "transactionState");
    ɵngcc0.ɵɵpipe(3, "igxStringReplace");
    ɵngcc0.ɵɵpipe(4, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(5, "igxCellStyles");
    ɵngcc0.ɵɵpipe(6, "dataMapper");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r27 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r30 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r30.cellHeight, "px")("min-width", col_r27.width)("max-width", col_r27.width)("flex-basis", col_r27.width);
    ɵngcc0.ɵɵclassProp("igx-grid__td--edited", ɵngcc0.ɵɵpipeBindV(2, 30, ɵngcc0.ɵɵpureFunction7(60, _c183, ctx_r30.rowID, col_r27.field, ctx_r30.grid.rowEditable, ctx_r30.grid.transactions, ctx_r30.grid.pipeTrigger, ctx_r30.grid.crudService.cell, ctx_r30.grid.crudService.row)))("igx-grid__td--number", col_r27.dataType === "number")("igx-grid__td--bool", col_r27.dataType === "boolean");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(4, 42, ɵngcc0.ɵɵpureFunction6(68, _c205, col_r27.cellClasses, ctx_r30.rowData[col_r27.field], ctx_r30.rowData, col_r27.field, ctx_r30.viewIndex, ctx_r30.grid.pipeTrigger)))("ngStyle", ɵngcc0.ɵɵpipeBindV(5, 49, ɵngcc0.ɵɵpureFunction6(75, _c205, col_r27.cellStyles, ctx_r30.rowData[col_r27.field], ctx_r30.rowData, col_r27.field, ctx_r30.viewIndex, ctx_r30.grid.pipeTrigger)))("editMode", col_r27.editable && ctx_r30.crudService.targetInEdit(ctx_r30.index, col_r27.index))("column", col_r27)("formatter", col_r27.formatter)("row", ctx_r30)("rowData", ctx_r30.rowData)("width", col_r27.getCellWidth())("visibleColumnIndex", col_r27.visibleIndex)("value", ɵngcc0.ɵɵpipeBind3(6, 56, ctx_r30.rowData, col_r27.field, ctx_r30.grid.pipeTrigger))("cellTemplate", col_r27.bodyTemplate)("lastSearchInfo", ctx_r30.grid.lastSearchInfo)("active", ctx_r30.isCellActive(col_r27.visibleIndex))("cellSelectionMode", ctx_r30.grid.cellSelection)("displayPinnedChip", ctx_r30.shouldDisplayPinnedChip(col_r27.visibleIndex));
    ɵngcc0.ɵɵattribute("aria-describedby", ɵngcc0.ɵɵpipeBind3(3, 38, ctx_r30.gridID + "_" + col_r27.field, ".", "_"));
} }
function IgxTreeGridRowComponent_ng_template_3_ng_template_3_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-tree-grid-cell", 16, 15);
    ɵngcc0.ɵɵpipe(2, "transactionState");
    ɵngcc0.ɵɵpipe(3, "igxStringReplace");
    ɵngcc0.ɵɵpipe(4, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(5, "igxCellStyles");
    ɵngcc0.ɵɵpipe(6, "dataMapper");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r27 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r32 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r32.cellHeight, "px")("min-width", col_r27.width)("max-width", col_r27.width)("flex-basis", col_r27.width);
    ɵngcc0.ɵɵclassProp("igx-grid__td--edited", ɵngcc0.ɵɵpipeBindV(2, 32, ɵngcc0.ɵɵpureFunction7(62, _c183, ctx_r32.rowID, col_r27.field, ctx_r32.grid.rowEditable, ctx_r32.grid.transactions, ctx_r32.grid.pipeTrigger, ctx_r32.grid.crudService.cell, ctx_r32.grid.crudService.row)))("igx-grid__td--number", col_r27.dataType === "number" && col_r27.visibleIndex !== 0);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(4, 44, ɵngcc0.ɵɵpureFunction6(70, _c205, col_r27.cellClasses, ctx_r32.rowData[col_r27.field], ctx_r32.rowData, col_r27.field, ctx_r32.viewIndex, ctx_r32.grid.pipeTrigger)))("ngStyle", ɵngcc0.ɵɵpipeBindV(5, 51, ɵngcc0.ɵɵpureFunction6(77, _c205, col_r27.cellStyles, ctx_r32.rowData[col_r27.field], ctx_r32.rowData, col_r27.field, ctx_r32.viewIndex, ctx_r32.grid.pipeTrigger)))("level", ctx_r32.treeRow.level)("expanded", ctx_r32.treeRow.expanded)("showIndicator", ctx_r32.showIndicator)("editMode", col_r27.editable && ctx_r32.crudService.targetInEdit(ctx_r32.index, col_r27.index))("column", col_r27)("formatter", col_r27.formatter)("row", ctx_r32)("rowData", ctx_r32.rowData)("width", col_r27.getCellWidth())("visibleColumnIndex", col_r27.visibleIndex)("value", ɵngcc0.ɵɵpipeBind3(6, 58, ctx_r32.rowData, col_r27.field, ctx_r32.grid.pipeTrigger))("isLoading", ctx_r32.isLoading)("cellTemplate", col_r27.bodyTemplate)("lastSearchInfo", ctx_r32.grid.lastSearchInfo)("active", ctx_r32.isCellActive(col_r27.visibleIndex))("cellSelectionMode", ctx_r32.grid.cellSelection)("displayPinnedChip", ctx_r32.shouldDisplayPinnedChip(col_r27.visibleIndex));
    ɵngcc0.ɵɵattribute("aria-describedby", ɵngcc0.ɵɵpipeBind3(3, 40, ctx_r32.gridID + "_" + col_r27.field, ".", "_"));
} }
function IgxTreeGridRowComponent_ng_template_3_ng_template_3_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridRowComponent_ng_template_3_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_template_3_ng_template_3_ng_template_0_Template, 7, 82, "ng-template", null, 12, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_template_3_ng_template_3_ng_template_2_Template, 7, 84, "ng-template", null, 13, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(4, IgxTreeGridRowComponent_ng_template_3_ng_template_3_ng_container_4_Template, 1, 0, "ng-container", 0);
} if (rf & 2) {
    const col_r27 = ctx.$implicit;
    const _r29 = ɵngcc0.ɵɵreference(1);
    const _r31 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r27.visibleIndex === 0 ? _r31 : _r29);
} }
function IgxTreeGridRowComponent_ng_template_3_ng_container_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridRowComponent_ng_template_3_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridRowComponent_ng_template_3_ng_container_6_ng_container_1_Template, 1, 0, "ng-container", 11);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r16 = ɵngcc0.ɵɵreference(10);
    const ctx_r13 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r16)("ngTemplateOutletContext", ctx_r13);
} }
function IgxTreeGridRowComponent_ng_template_3_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵelement(1, "igx-checkbox", 18);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("tabindex", -1)("readonly", true)("checked", ctx_r15.selected)("disabled", ctx_r15.deleted)("disableTransitions", ctx_r15.grid.disableTransitions)("aria-label", ctx_r15.rowCheckboxAriaLabel);
} }
function IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-grid-cell", 20, 15);
    ɵngcc0.ɵɵpipe(2, "transactionState");
    ɵngcc0.ɵɵpipe(3, "igxStringReplace");
    ɵngcc0.ɵɵpipe(4, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(5, "igxCellStyles");
    ɵngcc0.ɵɵpipe(6, "dataMapper");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r41 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r43 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r43.cellHeight, "px")("min-width", col_r41.width)("max-width", col_r41.width)("flex-basis", col_r41.width)("left", col_r41.rightPinnedOffset);
    ɵngcc0.ɵɵclassProp("igx-grid__td--edited", ɵngcc0.ɵɵpipeBindV(2, 32, ɵngcc0.ɵɵpureFunction7(62, _c183, ctx_r43.rowID, col_r41.field, ctx_r43.grid.rowEditable, ctx_r43.grid.transactions, ctx_r43.grid.pipeTrigger, ctx_r43.grid.crudService.cell, ctx_r43.grid.crudService.row)))("igx-grid__td--number", col_r41.dataType === "number");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(4, 44, ɵngcc0.ɵɵpureFunction6(70, _c205, col_r41.cellClasses, ctx_r43.rowData[col_r41.field], ctx_r43.rowData, col_r41.field, ctx_r43.viewIndex, ctx_r43.grid.pipeTrigger)))("ngStyle", ɵngcc0.ɵɵpipeBindV(5, 51, ɵngcc0.ɵɵpureFunction6(77, _c205, col_r41.cellStyles, ctx_r43.rowData[col_r41.field], ctx_r43.rowData, col_r41.field, ctx_r43.viewIndex, ctx_r43.grid.pipeTrigger)))("editMode", col_r41.editable && ctx_r43.crudService.targetInEdit(ctx_r43.index, col_r41.index))("column", col_r41)("formatter", col_r41.formatter)("row", ctx_r43)("firstPinned", col_r41.isFirstPinned)("lastPinned", col_r41.isLastPinned)("rowData", ctx_r43.rowData)("width", col_r41.getCellWidth())("visibleColumnIndex", col_r41.visibleIndex)("value", ɵngcc0.ɵɵpipeBind3(6, 58, ctx_r43.rowData, col_r41.field, ctx_r43.grid.pipeTrigger))("cellTemplate", col_r41.bodyTemplate)("lastSearchInfo", ctx_r43.grid.lastSearchInfo)("active", ctx_r43.isCellActive(col_r41.visibleIndex))("cellSelectionMode", ctx_r43.grid.cellSelection)("displayPinnedChip", ctx_r43.shouldDisplayPinnedChip(col_r41.visibleIndex));
    ɵngcc0.ɵɵattribute("aria-describedby", ɵngcc0.ɵɵpipeBind3(3, 40, ctx_r43.gridID + "_" + col_r41.field, ".", "_"));
} }
function IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-tree-grid-cell", 21, 15);
    ɵngcc0.ɵɵpipe(2, "transactionState");
    ɵngcc0.ɵɵpipe(3, "igxStringReplace");
    ɵngcc0.ɵɵpipe(4, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(5, "igxCellStyles");
    ɵngcc0.ɵɵpipe(6, "dataMapper");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r41 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r45 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r45.cellHeight, "px")("min-width", col_r41.width)("max-width", col_r41.width)("flex-basis", col_r41.width)("left", col_r41.rightPinnedOffset);
    ɵngcc0.ɵɵclassProp("igx-grid__td--edited", ɵngcc0.ɵɵpipeBindV(2, 35, ɵngcc0.ɵɵpureFunction7(65, _c183, ctx_r45.rowID, col_r41.field, ctx_r45.grid.rowEditable, ctx_r45.grid.transactions, ctx_r45.grid.pipeTrigger, ctx_r45.grid.crudService.cell, ctx_r45.grid.crudService.row)))("igx-grid__td--number", col_r41.dataType === "number" && col_r41.visibleIndex !== 0);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(4, 47, ɵngcc0.ɵɵpureFunction6(73, _c205, col_r41.cellClasses, ctx_r45.rowData[col_r41.field], ctx_r45.rowData, col_r41.field, ctx_r45.viewIndex, ctx_r45.grid.pipeTrigger)))("ngStyle", ɵngcc0.ɵɵpipeBindV(5, 54, ɵngcc0.ɵɵpureFunction6(80, _c205, col_r41.cellStyles, ctx_r45.rowData[col_r41.field], ctx_r45.rowData, col_r41.field, ctx_r45.viewIndex, ctx_r45.grid.pipeTrigger)))("level", ctx_r45.treeRow.level)("expanded", ctx_r45.treeRow.expanded)("showIndicator", ctx_r45.showIndicator)("editMode", col_r41.editable && ctx_r45.crudService.targetInEdit(ctx_r45.index, col_r41.index))("column", col_r41)("formatter", col_r41.formatter)("row", ctx_r45)("lastPinned", col_r41.isLastPinned)("rowData", ctx_r45.rowData)("width", col_r41.getCellWidth())("visibleColumnIndex", col_r41.visibleIndex)("value", ɵngcc0.ɵɵpipeBind3(6, 61, ctx_r45.rowData, col_r41.field, ctx_r45.grid.pipeTrigger))("isLoading", ctx_r45.isLoading)("cellTemplate", col_r41.bodyTemplate)("lastSearchInfo", ctx_r45.grid.lastSearchInfo)("active", ctx_r45.isCellActive(col_r41.visibleIndex))("cellSelectionMode", ctx_r45.grid.cellSelection)("displayPinnedChip", ctx_r45.shouldDisplayPinnedChip(col_r41.visibleIndex));
    ɵngcc0.ɵɵattribute("aria-describedby", ɵngcc0.ɵɵpipeBind3(3, 43, ctx_r45.gridID + "_" + col_r41.field, ".", "_"));
} }
function IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_ng_template_0_Template, 7, 84, "ng-template", null, 12, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_ng_template_2_Template, 7, 87, "ng-template", null, 13, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(4, IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_ng_container_4_Template, 1, 0, "ng-container", 0);
} if (rf & 2) {
    const col_r41 = ctx.$implicit;
    const _r42 = ɵngcc0.ɵɵreference(1);
    const _r44 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r41.visibleIndex === 0 ? _r44 : _r42);
} }
function IgxTreeGridRowComponent_ng_template_3_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_Template, 5, 1, "ng-template", 19);
    ɵngcc0.ɵɵpipe(1, "igxNotGrouped");
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r17.pinnedColumns));
} }
function IgxTreeGridRowComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_template_3_ng_container_0_Template, 3, 5, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridRowComponent_ng_template_3_ng_container_1_Template, 3, 8, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_template_3_ng_container_2_Template, 2, 2, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(3, IgxTreeGridRowComponent_ng_template_3_ng_template_3_Template, 5, 1, "ng-template", 5, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵpipe(5, "igxNotGrouped");
    ɵngcc0.ɵɵtemplate(6, IgxTreeGridRowComponent_ng_template_3_ng_container_6_Template, 2, 2, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(7, IgxTreeGridRowComponent_ng_template_3_ng_template_7_Template, 2, 6, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(9, IgxTreeGridRowComponent_ng_template_3_ng_template_9_Template, 2, 3, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.rowDraggable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.showRowSelectors);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.pinnedColumns.length > 0 && ctx_r4.grid.isPinningToStart);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(5, 10, ctx_r4.unpinnedColumns))("igxForScrollContainer", ctx_r4.grid.parentVirtDir)("igxForScrollOrientation", "horizontal")("igxForContainerSize", ctx_r4.grid.unpinnedWidth)("igxForSizePropName", "calcPixelWidth")("igxForTrackBy", ctx_r4.grid.trackColumnChanges);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.pinnedColumns.length > 0 && !ctx_r4.grid.isPinningToStart);
} }
function IgxTreeGridCellComponent_ng_template_0_igx_chip_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-chip", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("disabled", true)("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r14.grid.resourceStrings.igx_grid_pinned_row_indicator);
} }
function IgxTreeGridCellComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridCellComponent_ng_template_0_igx_chip_0_Template, 2, 3, "igx-chip", 8);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.displayPinnedChip);
} }
function IgxTreeGridCellComponent_ng_template_2_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵpipe(1, "columnFormatter");
    ɵngcc0.ɵɵpipe(2, "number");
    ɵngcc0.ɵɵpipe(3, "date");
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵpipe(5, "columnFormatter");
    ɵngcc0.ɵɵpipe(6, "number");
    ɵngcc0.ɵɵpipe(7, "date");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("cssClass", ctx_r15.highlightClass)("activeCssClass", ctx_r15.activeHighlightClass)("groupName", ctx_r15.gridID)("value", ctx_r15.formatter ? ɵngcc0.ɵɵpipeBind2(1, 9, ctx_r15.value, ctx_r15.formatter) : ctx_r15.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind3(2, 12, ctx_r15.value, ctx_r15.column.pipeArgs.digitsInfo, ctx_r15.grid.locale) : ctx_r15.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind4(3, 16, ctx_r15.value, ctx_r15.column.pipeArgs.format, ctx_r15.column.pipeArgs.timezone, ctx_r15.grid.locale) : ctx_r15.value)("row", ctx_r15.rowData)("column", ctx_r15.column.field)("containerClass", "igx-grid__td-text")("metadata", ctx_r15.searchMetadata);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r15.formatter ? ɵngcc0.ɵɵpipeBind2(5, 21, ctx_r15.value, ctx_r15.formatter) : ctx_r15.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind3(6, 24, ctx_r15.value, ctx_r15.column.pipeArgs.digitsInfo, ctx_r15.grid.locale) : ctx_r15.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind4(7, 28, ctx_r15.value, ctx_r15.column.pipeArgs.format, ctx_r15.column.pipeArgs.timezone, ctx_r15.grid.locale) : ctx_r15.value);
} }
function IgxTreeGridCellComponent_ng_template_2_igx_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 13);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r16 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(2, _c202, ctx_r16.value, !ctx_r16.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r16.value ? "check" : "close");
} }
function IgxTreeGridCellComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridCellComponent_ng_template_2_div_0_Template, 8, 33, "div", 10);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridCellComponent_ng_template_2_igx_icon_1_Template, 2, 5, "igx-icon", 11);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.column.dataType !== "boolean");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.column.dataType === "boolean");
} }
function IgxTreeGridCellComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵpipe(1, "columnFormatter");
    ɵngcc0.ɵɵpipe(2, "number");
    ɵngcc0.ɵɵpipe(3, "date");
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("cssClass", ctx_r5.highlightClass)("activeCssClass", ctx_r5.activeHighlightClass)("groupName", ctx_r5.gridID)("value", ctx_r5.formatter ? ɵngcc0.ɵɵpipeBind2(1, 9, ctx_r5.value, ctx_r5.formatter) : ctx_r5.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind3(2, 12, ctx_r5.value, ctx_r5.column.pipeArgs.digitsInfo, ctx_r5.grid.locale) : ctx_r5.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind4(3, 16, ctx_r5.value, ctx_r5.column.pipeArgs.format, ctx_r5.column.pipeArgs.timezone, ctx_r5.grid.locale) : ctx_r5.value)("row", ctx_r5.rowData)("column", ctx_r5.column.field)("containerClass", "igx-grid__td-text")("metadata", ctx_r5.searchMetadata);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(!ctx_r5.isEmptyAddRowCell ? ctx_r5.value : ctx_r5.column.header || ctx_r5.column.field);
} }
function IgxTreeGridCellComponent_ng_template_6_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r24 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 14);
    ɵngcc0.ɵɵelementStart(2, "input", 15);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxTreeGridCellComponent_ng_template_6_ng_container_0_Template_input_ngModelChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r24); const ctx_r23 = ɵngcc0.ɵɵnextContext(2); return ctx_r23.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r19.editValue)("igxFocus", true);
} }
function IgxTreeGridCellComponent_ng_template_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r26 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 14);
    ɵngcc0.ɵɵelementStart(2, "input", 16);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxTreeGridCellComponent_ng_template_6_ng_container_1_Template_input_ngModelChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r26); const ctx_r25 = ɵngcc0.ɵɵnextContext(2); return ctx_r25.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r20 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r20.editValue)("igxFocus", true);
} }
function IgxTreeGridCellComponent_ng_template_6_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r28 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-checkbox", 17);
    ɵngcc0.ɵɵlistener("change", function IgxTreeGridCellComponent_ng_template_6_ng_container_2_Template_igx_checkbox_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r28); const ctx_r27 = ɵngcc0.ɵɵnextContext(2); return ctx_r27.editValue = $event.checked; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r21 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r21.editValue)("checked", ctx_r21.editValue)("disableRipple", true);
} }
function IgxTreeGridCellComponent_ng_template_6_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r30 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-date-picker", 18);
    ɵngcc0.ɵɵlistener("valueChange", function IgxTreeGridCellComponent_ng_template_6_ng_container_3_Template_igx_date_picker_valueChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r30); const ctx_r29 = ɵngcc0.ɵɵnextContext(2); return ctx_r29.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r22 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", 100, "%");
    ɵngcc0.ɵɵproperty("outlet", ctx_r22.grid.outlet)("locale", ctx_r22.grid.locale)("value", ctx_r22.editValue)("igxFocus", true)("labelVisibility", false);
} }
function IgxTreeGridCellComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridCellComponent_ng_template_6_ng_container_0_Template, 3, 2, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridCellComponent_ng_template_6_ng_container_1_Template, 3, 2, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridCellComponent_ng_template_6_ng_container_2_Template, 2, 3, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(3, IgxTreeGridCellComponent_ng_template_6_ng_container_3_Template, 2, 7, "ng-container", 4);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "string");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "number");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "boolean");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "date");
} }
function IgxTreeGridCellComponent_ng_container_8_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", null, 22);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r31 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("igx-grid__tree-cell--padding-level-", ctx_r31.level, "");
} }
function IgxTreeGridCellComponent_ng_container_8_div_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridCellComponent_ng_container_8_div_2_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c209 = function (a0) { return { visibility: a0 }; };
function IgxTreeGridCellComponent_ng_container_8_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r41 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 23, 24);
    ɵngcc0.ɵɵlistener("click", function IgxTreeGridCellComponent_ng_container_8_div_2_Template_div_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r41); const ctx_r40 = ɵngcc0.ɵɵnextContext(2); return ctx_r40.toggle($event); })("focus", function IgxTreeGridCellComponent_ng_container_8_div_2_Template_div_focus_0_listener() { ɵngcc0.ɵɵrestoreView(_r41); const ctx_r42 = ɵngcc0.ɵɵnextContext(2); return ctx_r42.onIndicatorFocus(); });
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridCellComponent_ng_container_8_div_2_ng_container_2_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵtemplate(3, IgxTreeGridCellComponent_ng_container_8_div_2_ng_container_3_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r32 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(5, _c209, ctx_r32.showIndicator ? "visible" : "hidden"));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r32.iconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(7, _c17, ctx_r32));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r32.pinnedIndicatorTemplate)("ngTemplateOutletContext", ctx_r32.context);
} }
function IgxTreeGridCellComponent_ng_container_8_div_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridCellComponent_ng_container_8_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r45 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 25);
    ɵngcc0.ɵɵlistener("dblclick", function IgxTreeGridCellComponent_ng_container_8_div_3_Template_div_dblclick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r45); const ctx_r44 = ɵngcc0.ɵɵnextContext(2); return ctx_r44.onLoadingDblClick($event); });
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridCellComponent_ng_container_8_div_3_ng_container_1_Template, 1, 0, "ng-container", 26);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r34 = ɵngcc0.ɵɵreference(5);
    const ctx_r33 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r33.grid.rowLoadingIndicatorTemplate ? ctx_r33.grid.rowLoadingIndicatorTemplate : _r34);
} }
function IgxTreeGridCellComponent_ng_container_8_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-circular-bar", 27);
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxTreeGridCellComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridCellComponent_ng_container_8_ng_container_1_Template, 3, 3, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridCellComponent_ng_container_8_div_2_Template, 4, 9, "div", 19);
    ɵngcc0.ɵɵtemplate(3, IgxTreeGridCellComponent_ng_container_8_div_3_Template, 2, 1, "div", 20);
    ɵngcc0.ɵɵtemplate(4, IgxTreeGridCellComponent_ng_container_8_ng_template_4_Template, 1, 1, "ng-template", null, 21, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r8.level > 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r8.isLoading);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r8.isLoading);
} }
function IgxTreeGridCellComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridCellComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 28);
    ɵngcc0.ɵɵtext(1, "expand_more");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxTreeGridCellComponent_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 28);
    ɵngcc0.ɵɵtext(1, "chevron_right");
    ɵngcc0.ɵɵelementEnd();
} }
const _c210 = ["hgrid"];
const _c211 = function (a0) { return { "igx-grid__hierarchical-indent--scroll": a0 }; };
const _c212 = ["hierarchical_record_template"];
const _c213 = ["child_record_template"];
const _c214 = ["headerHierarchyExpander"];
function IgxHierarchicalGridComponent_igx_grid_toolbar_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-toolbar", 69, 70);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("max-width", ctx_r0.outerWidth, "px")("flex-basis", ctx_r0.outerWidth, "px");
    ɵngcc0.ɵɵproperty("gridID", ctx_r0.id)("displayDensity", ctx_r0.displayDensity);
} }
function IgxHierarchicalGridComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 71);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r2.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 72);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r3.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r3.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_container_10_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    const _r78 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 73, 74);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxHierarchicalGridComponent_ng_container_10_Template_div_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r78); return $event.preventDefault(); });
    ɵngcc0.ɵɵelementStart(3, "div", 75);
    ɵngcc0.ɵɵtemplate(4, IgxHierarchicalGridComponent_ng_container_10_ng_container_4_Template, 1, 0, "ng-container", 22);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    const _r67 = ɵngcc0.ɵɵreference(101);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c172, !ctx_r6.isRowSelectable));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r6.dragIndicatorIconTemplate ? ctx_r6.dragIndicatorIconTemplate : _r67);
} }
function IgxHierarchicalGridComponent_ng_container_11_3_ng_template_0_Template(rf, ctx) { }
function IgxHierarchicalGridComponent_ng_container_11_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridComponent_ng_container_11_3_ng_template_0_Template, 0, 0, "ng-template", null, 78, ɵngcc0.ɵɵtemplateRefExtractor);
} }
const _c215 = function (a0, a1, a2, a3) { return { selectedCount: a0, totalCount: a1, selectAll: a2, deselectAll: a3 }; };
function IgxHierarchicalGridComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    const _r84 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 76, 77);
    ɵngcc0.ɵɵlistener("click", function IgxHierarchicalGridComponent_ng_container_11_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r84); const ctx_r83 = ɵngcc0.ɵɵnextContext(); return ctx_r83.onHeaderSelectorClick($event); })("pointerdown", function IgxHierarchicalGridComponent_ng_container_11_Template_div_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r84); return $event.preventDefault(); });
    ɵngcc0.ɵɵtemplate(3, IgxHierarchicalGridComponent_ng_container_11_3_Template, 2, 0, undefined, 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    const _r69 = ɵngcc0.ɵɵreference(103);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c173, ctx_r7.filteringService.isFilterRowVisible));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r7.headSelectorTemplate ? ctx_r7.headSelectorTemplate : _r69)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(10, _c17, ɵngcc0.ɵɵpureFunction4(5, _c215, ctx_r7.selectionService.filteredSelectedRowIds.length, ctx_r7.totalRowsCountAfterFilter, ctx_r7.selectAllRows.bind(ctx_r7), ctx_r7.deselectAllRows.bind(ctx_r7))));
} }
function IgxHierarchicalGridComponent_ng_container_12_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 80);
} if (rf & 2) {
    const col_r87 = ctx.$implicit;
    const ctx_r86 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r86.getHeaderGroupWidth(col_r87))("flex-basis", ctx_r86.getHeaderGroupWidth(col_r87));
    ɵngcc0.ɵɵproperty("column", col_r87)("gridID", ctx_r86.id);
} }
function IgxHierarchicalGridComponent_ng_container_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_container_12_ng_template_1_Template, 1, 6, "ng-template", 79);
    ɵngcc0.ɵɵpipe(2, "igxTopLevel");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r8.pinnedColumns));
} }
function IgxHierarchicalGridComponent_ng_template_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 80);
} if (rf & 2) {
    const col_r88 = ctx.$implicit;
    const ctx_r10 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r10.getHeaderGroupWidth(col_r88))("flex-basis", ctx_r10.getHeaderGroupWidth(col_r88));
    ɵngcc0.ɵɵproperty("column", col_r88)("gridID", ctx_r10.id);
} }
function IgxHierarchicalGridComponent_ng_container_16_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 80);
} if (rf & 2) {
    const col_r90 = ctx.$implicit;
    const ctx_r89 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r89.getHeaderGroupWidth(col_r90))("flex-basis", ctx_r89.getHeaderGroupWidth(col_r90))("left", col_r90.rightPinnedOffset);
    ɵngcc0.ɵɵproperty("column", col_r90)("gridID", ctx_r89.id);
} }
function IgxHierarchicalGridComponent_ng_container_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_container_16_ng_template_1_Template, 1, 8, "ng-template", 79);
    ɵngcc0.ɵɵpipe(2, "igxTopLevel");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r11.pinnedColumns));
} }
function IgxHierarchicalGridComponent_igx_grid_filtering_row_17_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-filtering-row", 81, 82);
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r12.calcWidth, "px");
    ɵngcc0.ɵɵproperty("column", ctx_r12.filteringService.filteredColumn);
} }
function IgxHierarchicalGridComponent_igx_circular_bar_20_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-circular-bar", 83);
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxHierarchicalGridComponent_span_21_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 84);
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r15.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_span_26_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 71);
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r17.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_span_27_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 72);
} if (rf & 2) {
    const ctx_r18 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r18.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r18.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_ng_template_28_ng_container_0_div_1_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_template_28_ng_container_0_div_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_template_28_ng_container_0_div_1_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const rowData_r97 = ctx.$implicit;
    const rowIndex_r98 = ctx.index;
    const ctx_r96 = ɵngcc0.ɵɵnextContext(4);
    const _r26 = ɵngcc0.ɵɵreference(44);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r26)("ngTemplateOutletContext", ctx_r96.getContext(rowData_r97, rowIndex_r98, true));
} }
function IgxHierarchicalGridComponent_ng_template_28_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 86, 87);
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalGridComponent_ng_template_28_ng_container_0_div_1_ng_container_2_Template, 2, 2, "ng-container", 88);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const pinnedData_r93 = ɵngcc0.ɵɵnextContext().ngIf;
    const ctx_r94 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("width", ctx_r94.calcWidth, "px");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(4, _c175, !ctx_r94.isRowPinningToTop, ctx_r94.isRowPinningToTop));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", pinnedData_r93);
} }
function IgxHierarchicalGridComponent_ng_template_28_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_template_28_ng_container_0_div_1_Template, 3, 7, "div", 85);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const pinnedData_r93 = ctx.ngIf;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", pinnedData_r93.length > 0);
} }
function IgxHierarchicalGridComponent_ng_template_28_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridComponent_ng_template_28_ng_container_0_Template, 2, 1, "ng-container", 10);
    ɵngcc0.ɵɵpipe(1, "gridAddRow");
    ɵngcc0.ɵɵpipe(2, "gridSort");
    ɵngcc0.ɵɵpipe(3, "gridFiltering");
    ɵngcc0.ɵɵpipe(4, "gridRowPinning");
    ɵngcc0.ɵɵpipe(5, "visibleColumns");
    ɵngcc0.ɵɵpipe(6, "gridTransaction");
} if (rf & 2) {
    const ctx_r20 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBind3(1, 1, ɵngcc0.ɵɵpipeBindV(2, 5, ɵngcc0.ɵɵpureFunction5(41, _c177, ɵngcc0.ɵɵpipeBindV(3, 12, ɵngcc0.ɵɵpureFunction7(33, _c176, ɵngcc0.ɵɵpipeBind4(4, 21, ɵngcc0.ɵɵpipeBind2(5, 26, ɵngcc0.ɵɵpipeBind3(6, 29, ctx_r20.data, ctx_r20.id, ctx_r20.pipeTrigger), ctx_r20.hasVisibleColumns), ctx_r20.id, true, ctx_r20.pipeTrigger), ctx_r20.filteringExpressionsTree, ctx_r20.filterStrategy, ctx_r20.advancedFilteringExpressionsTree, ctx_r20.id, ctx_r20.pipeTrigger, ctx_r20.filteringPipeTrigger)), ctx_r20.sortingExpressions, ctx_r20.sortStrategy, ctx_r20.id, ctx_r20.pipeTrigger)), true, ctx_r20.pipeTrigger));
} }
function IgxHierarchicalGridComponent_ng_container_30_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_template_31_ng_template_0_Template(rf, ctx) { }
function IgxHierarchicalGridComponent_ng_template_31_Template(rf, ctx) { if (rf & 1) {
    const _r105 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridComponent_ng_template_31_ng_template_0_Template, 0, 0, "ng-template", 89);
    ɵngcc0.ɵɵlistener("onViewCreated", function IgxHierarchicalGridComponent_ng_template_31_Template_ng_template_onViewCreated_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r105); const ctx_r104 = ɵngcc0.ɵɵnextContext(); return ctx_r104.viewCreatedHandler($event); })("onViewMoved", function IgxHierarchicalGridComponent_ng_template_31_Template_ng_template_onViewMoved_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r105); const ctx_r106 = ɵngcc0.ɵɵnextContext(); return ctx_r106.viewMovedHandler($event); })("onCachedViewLoaded", function IgxHierarchicalGridComponent_ng_template_31_Template_ng_template_onCachedViewLoaded_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r105); const ctx_r107 = ɵngcc0.ɵɵnextContext(); return ctx_r107.cachedViewLoaded($event); });
} if (rf & 2) {
    const rowData_r101 = ctx.$implicit;
    const rowIndex_r102 = ctx.index;
    const ctx_r23 = ɵngcc0.ɵɵnextContext();
    const _r24 = ɵngcc0.ɵɵreference(42);
    const _r28 = ɵngcc0.ɵɵreference(46);
    ɵngcc0.ɵɵproperty("igxTemplateOutlet", ctx_r23.isHierarchicalRecord(rowData_r101) ? _r24 : ctx_r23.isChildGridRecord(rowData_r101) && ctx_r23.isExpanded(rowData_r101) ? _r28 : _r24)("igxTemplateOutletContext", ctx_r23.getContext(rowData_r101, rowIndex_r102, false));
} }
function IgxHierarchicalGridComponent_ng_template_41_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-hierarchical-grid-row", 90, 91);
} if (rf & 2) {
    const rowIndex_r108 = ctx.index;
    const disabledRow_r109 = ctx.disabled;
    const rowData_r110 = ctx.$implicit;
    const isAddRow_r111 = ctx.addRow;
    const ctx_r25 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r25.id)("index", rowIndex_r108)("disabled", disabledRow_r109)("rowData", rowData_r110)("addRow", isAddRow_r111);
} }
function IgxHierarchicalGridComponent_ng_template_43_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-hierarchical-grid-row", 92, 93);
} if (rf & 2) {
    const rowIndex_r113 = ctx.index;
    const rowData_r114 = ctx.$implicit;
    const isAddRow_r115 = ctx.addRow;
    const ctx_r27 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r27.id)("index", rowIndex_r113)("rowData", rowData_r114)("addRow", isAddRow_r115);
} }
function IgxHierarchicalGridComponent_ng_template_45_igx_child_grid_row_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-child-grid-row", 96, 91);
} if (rf & 2) {
    const layout_r121 = ctx.$implicit;
    const ctx_r123 = ɵngcc0.ɵɵnextContext();
    const rowIndex_r118 = ctx_r123.index;
    const rowData_r119 = ctx_r123.$implicit;
    const ctx_r120 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("parentGridID", ctx_r120.id)("index", rowIndex_r118)("rowData", rowData_r119)("layout", layout_r121);
} }
const _c216 = function (a1) { return { "igx-grid__tr-container": true, "igx-grid__tr--highlighted": a1 }; };
function IgxHierarchicalGridComponent_ng_template_45_Template(rf, ctx) { if (rf & 1) {
    const _r125 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 94);
    ɵngcc0.ɵɵlistener("scroll", function IgxHierarchicalGridComponent_ng_template_45_Template_div_scroll_0_listener() { ɵngcc0.ɵɵrestoreView(_r125); const ctx_r124 = ɵngcc0.ɵɵnextContext(); return ctx_r124.onContainerScroll(); });
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_template_45_igx_child_grid_row_1_Template, 2, 4, "igx-child-grid-row", 95);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const rowIndex_r118 = ctx.index;
    const rowData_r119 = ctx.$implicit;
    const ctx_r29 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c216, ctx_r29.isRowHighlighted(rowData_r119)));
    ɵngcc0.ɵɵattribute("data-rowindex", rowIndex_r118);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r29.childLayoutList);
} }
function IgxHierarchicalGridComponent_ng_container_47_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_container_48_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_span_49_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 84);
} if (rf & 2) {
    const ctx_r32 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r32.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_igc_trial_watermark_52_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igc-trial-watermark");
} }
function IgxHierarchicalGridComponent_span_53_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 84);
} if (rf & 2) {
    const ctx_r35 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r35.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_ng_template_57_Template(rf, ctx) { }
function IgxHierarchicalGridComponent_igx_grid_summary_row_66_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-row", 97, 98);
    ɵngcc0.ɵɵpipe(2, "igxGridSummaryDataPipe");
} if (rf & 2) {
    const ctx_r40 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r40.calcWidth, "px")("height", ctx_r40.summariesHeight, "px");
    ɵngcc0.ɵɵproperty("gridID", ctx_r40.id)("summaries", ɵngcc0.ɵɵpipeBind2(2, 7, ctx_r40.id, ctx_r40.summaryService.retriggerRootPipe))("index", ctx_r40.dataView.length);
} }
function IgxHierarchicalGridComponent_ng_template_72_Template(rf, ctx) { }
function IgxHierarchicalGridComponent_ng_container_78_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_container_78_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_container_78_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r45 = ɵngcc0.ɵɵnextContext();
    const _r46 = ɵngcc0.ɵɵreference(80);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r45.paginationTemplate ? ctx_r45.paginationTemplate : _r46)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, ctx_r45));
} }
function IgxHierarchicalGridComponent_ng_template_79_Template(rf, ctx) { if (rf & 1) {
    const _r129 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-paginator", 99);
    ɵngcc0.ɵɵlistener("pageChange", function IgxHierarchicalGridComponent_ng_template_79_Template_igx_paginator_pageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r129); const ctx_r128 = ɵngcc0.ɵɵnextContext(); return ctx_r128.page = $event; })("perPageChange", function IgxHierarchicalGridComponent_ng_template_79_Template_igx_paginator_perPageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r129); const ctx_r130 = ɵngcc0.ɵɵnextContext(); return ctx_r130.perPage = $event; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r47 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("overlaySettings", ctx_r47.paginatorSettings)("displayDensity", ctx_r47.displayDensity)("page", ctx_r47.page)("totalRecords", ctx_r47.totalRecords)("perPage", ctx_r47.perPage);
} }
function IgxHierarchicalGridComponent_ng_template_81_span_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_template_81_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_template_81_span_3_ng_container_1_Template, 1, 0, "ng-container", 22);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r131 = ɵngcc0.ɵɵnextContext(2);
    const _r52 = ɵngcc0.ɵɵreference(86);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r131.addRowEmptyTemplate || _r52);
} }
function IgxHierarchicalGridComponent_ng_template_81_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 100);
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, IgxHierarchicalGridComponent_ng_template_81_span_3_Template, 2, 1, "span", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r49 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r49.emptyFilteredGridMessage);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r49.showAddButton);
} }
function IgxHierarchicalGridComponent_ng_template_83_span_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_template_83_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_template_83_span_3_ng_container_1_Template, 1, 0, "ng-container", 22);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r133 = ɵngcc0.ɵɵnextContext(2);
    const _r52 = ɵngcc0.ɵɵreference(86);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r133.addRowEmptyTemplate || _r52);
} }
function IgxHierarchicalGridComponent_ng_template_83_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 100);
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, IgxHierarchicalGridComponent_ng_template_83_span_3_Template, 2, 1, "span", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r51 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r51.emptyGridMessage);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r51.showAddButton);
} }
function IgxHierarchicalGridComponent_ng_template_85_Template(rf, ctx) { if (rf & 1) {
    const _r136 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 101);
    ɵngcc0.ɵɵlistener("click", function IgxHierarchicalGridComponent_ng_template_85_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r136); const ctx_r135 = ɵngcc0.ɵɵnextContext(); return ctx_r135.beginAddRowByIndex(null, -1); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r53 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r53.resourceStrings.igx_grid_add_row_label, " ");
} }
function IgxHierarchicalGridComponent_ng_template_87_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 102);
    ɵngcc0.ɵɵelement(1, "igx-circular-bar", 83);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxHierarchicalGridComponent_ng_template_89_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 103);
    ɵngcc0.ɵɵtext(1, "unfold_more");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxHierarchicalGridComponent_ng_template_91_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 104);
    ɵngcc0.ɵɵtext(1, "unfold_less");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r59 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("isActive", ctx_r59.hasExpandedRecords() && ctx_r59.hasExpandableChildren);
} }
function IgxHierarchicalGridComponent_div_93_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_div_93_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 105);
    ɵngcc0.ɵɵelementStart(1, "div", 106);
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalGridComponent_div_93_ng_container_2_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r60 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("className", ctx_r60.bannerClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r60.rowEditContainer)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(3, _c180, ctx_r60.rowChangesCount, ctx_r60.endEdit.bind(ctx_r60)));
} }
function IgxHierarchicalGridComponent_ng_template_94_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r62 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" You have ", ctx_r62.rowChangesCount, " changes in this row\n");
} }
function IgxHierarchicalGridComponent_ng_template_96_Template(rf, ctx) { if (rf & 1) {
    const _r139 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 107);
    ɵngcc0.ɵɵlistener("click", function IgxHierarchicalGridComponent_ng_template_96_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r139); const ctx_r138 = ɵngcc0.ɵɵnextContext(); return ctx_r138.endRowEdit(false, $event); });
    ɵngcc0.ɵɵtext(1, "Cancel");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "button", 107);
    ɵngcc0.ɵɵlistener("click", function IgxHierarchicalGridComponent_ng_template_96_Template_button_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r139); const ctx_r140 = ɵngcc0.ɵɵnextContext(); return ctx_r140.endRowEdit(true, $event); });
    ɵngcc0.ɵɵtext(3, "Done");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxHierarchicalGridComponent_ng_template_98_div_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_template_98_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 111);
    ɵngcc0.ɵɵelementStart(1, "span", 112);
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalGridComponent_ng_template_98_div_0_ng_container_2_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r141 = ɵngcc0.ɵɵnextContext(2);
    const _r61 = ɵngcc0.ɵɵreference(95);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r141.rowEditText ? ctx_r141.rowEditText : _r61)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, ctx_r141.rowChangesCount));
} }
function IgxHierarchicalGridComponent_ng_template_98_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_template_98_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridComponent_ng_template_98_div_0_Template, 3, 4, "div", 108);
    ɵngcc0.ɵɵelementStart(1, "div", 109);
    ɵngcc0.ɵɵelementStart(2, "div", 110);
    ɵngcc0.ɵɵtemplate(3, IgxHierarchicalGridComponent_ng_template_98_ng_container_3_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r66 = ɵngcc0.ɵɵnextContext();
    const _r63 = ɵngcc0.ɵɵreference(97);
    ɵngcc0.ɵɵproperty("ngIf", !(ctx_r66.crudService.row == null ? null : ctx_r66.crudService.row.isAddRow));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r66.rowEditActions ? ctx_r66.rowEditActions : _r63)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(3, _c17, ctx_r66.endEdit.bind(ctx_r66)));
} }
function IgxHierarchicalGridComponent_ng_template_100_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 113);
    ɵngcc0.ɵɵtext(1, "drag_indicator");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxHierarchicalGridComponent_ng_template_102_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 114);
    ɵngcc0.ɵɵelement(1, "igx-checkbox", 115, 116);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r144 = ctx.$implicit;
    const ctx_r70 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("tabindex", -1)("readonly", true)("checked", context_r144.selectedCount > 0 && context_r144.totalCount === context_r144.selectedCount)("ngStyle", ɵngcc0.ɵɵpureFunction1(6, _c181, ctx_r70.isMultiRowSelectionEnabled ? "visible" : "hidden"))("indeterminate", context_r144.selectedCount > 0 && context_r144.selectedCount !== context_r144.totalCount)("aria-label", ctx_r70.headSelectorBaseAriaLabel);
} }
function IgxHierarchicalGridComponent_igx_grid_column_resizer_104_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-column-resizer");
} }
const _c217 = function (a0, a1, a2) { return { "igx-grid__hierarchical-expander igx-grid__hierarchical-expander--header": a0, "igx-grid__hierarchical-expander--push": a1, "igx-grid__hierarchical-expander--no-border": a2 }; };
function IgxHierarchicalGridCellComponent_ng_template_0_igx_chip_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-chip", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("disabled", true)("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r10.grid.resourceStrings.igx_grid_pinned_row_indicator);
} }
function IgxHierarchicalGridCellComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridCellComponent_ng_template_0_igx_chip_0_Template, 2, 3, "igx-chip", 5);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.displayPinnedChip);
} }
function IgxHierarchicalGridCellComponent_ng_template_2_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵpipe(1, "columnFormatter");
    ɵngcc0.ɵɵpipe(2, "number");
    ɵngcc0.ɵɵpipe(3, "date");
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵpipe(5, "columnFormatter");
    ɵngcc0.ɵɵpipe(6, "number");
    ɵngcc0.ɵɵpipe(7, "date");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("cssClass", ctx_r11.highlightClass)("activeCssClass", ctx_r11.activeHighlightClass)("groupName", ctx_r11.gridID)("value", ctx_r11.formatter ? ɵngcc0.ɵɵpipeBind2(1, 9, ctx_r11.value, ctx_r11.formatter) : ctx_r11.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind3(2, 12, ctx_r11.value, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale) : ctx_r11.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind4(3, 16, ctx_r11.value, ctx_r11.column.pipeArgs.format, ctx_r11.column.pipeArgs.timezone, ctx_r11.grid.locale) : ctx_r11.value)("row", ctx_r11.rowData)("column", ctx_r11.column.field)("containerClass", "igx-grid__td-text")("metadata", ctx_r11.searchMetadata);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r11.formatter ? ɵngcc0.ɵɵpipeBind2(5, 21, ctx_r11.value, ctx_r11.formatter) : ctx_r11.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind3(6, 24, ctx_r11.value, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale) : ctx_r11.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind4(7, 28, ctx_r11.value, ctx_r11.column.pipeArgs.format, ctx_r11.column.pipeArgs.timezone, ctx_r11.grid.locale) : ctx_r11.value);
} }
function IgxHierarchicalGridCellComponent_ng_template_2_igx_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 10);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(2, _c202, ctx_r12.value, !ctx_r12.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r12.value ? "check" : "close");
} }
function IgxHierarchicalGridCellComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridCellComponent_ng_template_2_div_0_Template, 8, 33, "div", 7);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridCellComponent_ng_template_2_igx_icon_1_Template, 2, 5, "igx-icon", 8);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.column.dataType !== "boolean");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.column.dataType === "boolean");
} }
function IgxHierarchicalGridCellComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵpipe(1, "columnFormatter");
    ɵngcc0.ɵɵpipe(2, "number");
    ɵngcc0.ɵɵpipe(3, "date");
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("cssClass", ctx_r5.highlightClass)("activeCssClass", ctx_r5.activeHighlightClass)("groupName", ctx_r5.gridID)("value", ctx_r5.formatter ? ɵngcc0.ɵɵpipeBind2(1, 9, ctx_r5.value, ctx_r5.formatter) : ctx_r5.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind3(2, 12, ctx_r5.value, ctx_r5.column.pipeArgs.digitsInfo, ctx_r5.grid.locale) : ctx_r5.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind4(3, 16, ctx_r5.value, ctx_r5.column.pipeArgs.format, ctx_r5.column.pipeArgs.timezone, ctx_r5.grid.locale) : ctx_r5.value)("row", ctx_r5.rowData)("column", ctx_r5.column.field)("containerClass", "igx-grid__td-text")("metadata", ctx_r5.searchMetadata);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(!ctx_r5.isEmptyAddRowCell ? ctx_r5.value : ctx_r5.column.header || ctx_r5.column.field);
} }
function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r20 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 12);
    ɵngcc0.ɵɵelementStart(2, "input", 13);
    ɵngcc0.ɵɵlistener("input", function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_0_Template_input_input_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r20); const ctx_r19 = ɵngcc0.ɵɵnextContext(2); return ctx_r19.editValue = $event.target.value; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("value", ctx_r15.editValue)("igxFocus", true);
} }
function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 12);
    ɵngcc0.ɵɵelementStart(2, "input", 14);
    ɵngcc0.ɵɵlistener("input", function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_1_Template_input_input_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r21 = ɵngcc0.ɵɵnextContext(2); return ctx_r21.editValue = $event.target.value; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r16 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("value", ctx_r16.editValue)("igxFocus", true);
} }
function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r24 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-checkbox", 15);
    ɵngcc0.ɵɵlistener("change", function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_2_Template_igx_checkbox_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r24); const ctx_r23 = ɵngcc0.ɵɵnextContext(2); return ctx_r23.editValue = $event.checked; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r17.editValue)("checked", ctx_r17.editValue)("igxFocus", true)("disableRipple", true);
} }
function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r26 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-date-picker", 16);
    ɵngcc0.ɵɵlistener("valueChange", function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_3_Template_igx_date_picker_valueChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r26); const ctx_r25 = ɵngcc0.ɵɵnextContext(2); return ctx_r25.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r18 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", 100, "%");
    ɵngcc0.ɵɵproperty("outlet", ctx_r18.grid.outlet)("locale", ctx_r18.grid.locale)("value", ctx_r18.editValue)("igxFocus", true)("labelVisibility", false);
} }
function IgxHierarchicalGridCellComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_0_Template, 3, 2, "ng-container", 11);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_1_Template, 3, 2, "ng-container", 11);
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_2_Template, 2, 4, "ng-container", 11);
    ɵngcc0.ɵɵtemplate(3, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_3_Template, 2, 7, "ng-container", 11);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "string");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "number");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "boolean");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.column.dataType === "date");
} }
function IgxHierarchicalGridCellComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridCellComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c218 = ["expander"];
const _c219 = ["defaultEmptyTemplate"];
function IgxHierarchicalRowComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalRowComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 6);
    ɵngcc0.ɵɵtext(1, "expand_more");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("isActive", !ctx_r2.added);
} }
function IgxHierarchicalRowComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 6);
    ɵngcc0.ɵɵtext(1, "chevron_right");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("isActive", !ctx_r4.added);
} }
function IgxHierarchicalRowComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-icon", 7);
} }
function IgxHierarchicalRowComponent_ng_template_7_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalRowComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    const _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵlistener("animationend", function IgxHierarchicalRowComponent_ng_template_7_Template_div_animationend_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.animationEndHandler(); });
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalRowComponent_ng_template_7_ng_container_1_Template, 1, 0, "ng-container", 0);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    const _r9 = ɵngcc0.ɵɵreference(10);
    ɵngcc0.ɵɵclassProp("igx-grid__tr--add-animate", ctx_r8.animateAdd);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r9);
} }
function IgxHierarchicalRowComponent_ng_template_9_div_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalRowComponent_ng_template_9_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r28 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 15, 16);
    ɵngcc0.ɵɵlistener("click", function IgxHierarchicalRowComponent_ng_template_9_div_0_Template_div_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r28); const ctx_r27 = ɵngcc0.ɵɵnextContext(2); return ctx_r27.expanderClick($event); })("mousedown", function IgxHierarchicalRowComponent_ng_template_9_div_0_Template_div_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r28); return $event.preventDefault(); });
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalRowComponent_ng_template_9_div_0_ng_container_2_Template, 1, 0, "ng-container", 17);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r14.expanderClassResolved);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r14.iconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(3, _c17, ctx_r14));
} }
function IgxHierarchicalRowComponent_ng_template_9_ng_container_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalRowComponent_ng_template_9_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r32 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 18);
    ɵngcc0.ɵɵlistener("click", function IgxHierarchicalRowComponent_ng_template_9_ng_container_1_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r32); return $event.stopPropagation(); })("pointerdown", function IgxHierarchicalRowComponent_ng_template_9_ng_container_1_Template_div_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r32); return $event.preventDefault(); });
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalRowComponent_ng_template_9_ng_container_1_ng_container_2_Template, 1, 0, "ng-container", 0);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMap(ctx_r15.resolveDragIndicatorClasses);
    ɵngcc0.ɵɵproperty("igxRowDrag", ctx_r15)("ghostTemplate", ctx_r15.grid.getDragGhostCustomTemplate());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r15.grid.dragIndicatorIconTemplate ? ctx_r15.grid.dragIndicatorIconTemplate : ctx_r15.grid.dragIndicatorIconBase);
} }
function IgxHierarchicalRowComponent_ng_template_9_ng_container_2_2_ng_template_0_Template(rf, ctx) { }
function IgxHierarchicalRowComponent_ng_template_9_ng_container_2_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_template_9_ng_container_2_2_ng_template_0_Template, 0, 0, "ng-template");
} }
const _c220 = function (a0, a1, a2, a3, a4) { return { index: a0, rowID: a1, selected: a2, select: a3, deselect: a4 }; };
function IgxHierarchicalRowComponent_ng_template_9_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r37 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 19);
    ɵngcc0.ɵɵlistener("click", function IgxHierarchicalRowComponent_ng_template_9_ng_container_2_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r37); const ctx_r36 = ɵngcc0.ɵɵnextContext(2); return ctx_r36.onRowSelectorClick($event); })("pointerdown", function IgxHierarchicalRowComponent_ng_template_9_ng_container_2_Template_div_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r37); return $event.preventDefault(); });
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalRowComponent_ng_template_9_ng_container_2_2_Template, 1, 0, undefined, 17);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r21 = ɵngcc0.ɵɵreference(9);
    const ctx_r16 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r16.grid.rowSelectorTemplate ? ctx_r16.grid.rowSelectorTemplate : _r21)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(8, _c17, ɵngcc0.ɵɵpureFunction5(2, _c220, ctx_r16.viewIndex, ctx_r16.rowID, ctx_r16.selected, ctx_r16.select, ctx_r16.deselect)));
} }
function IgxHierarchicalRowComponent_ng_template_9_ng_container_3_1_ng_template_0_Template(rf, ctx) { }
function IgxHierarchicalRowComponent_ng_template_9_ng_container_3_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_template_9_ng_container_3_1_ng_template_0_Template, 0, 0, "ng-template");
} }
function IgxHierarchicalRowComponent_ng_template_9_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalRowComponent_ng_template_9_ng_container_3_1_Template, 1, 0, undefined, 17);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r23 = ɵngcc0.ɵɵreference(11);
    const ctx_r17 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r23)("ngTemplateOutletContext", ctx_r17);
} }
function IgxHierarchicalRowComponent_ng_template_9_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-hierarchical-grid-cell", 20);
    ɵngcc0.ɵɵpipe(1, "transactionState");
    ɵngcc0.ɵɵpipe(2, "igxStringReplace");
    ɵngcc0.ɵɵpipe(3, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(4, "igxCellStyles");
    ɵngcc0.ɵɵpipe(5, "dataMapper");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r41 = ctx.$implicit;
    const ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r19.cellHeight, "px")("min-width", col_r41.width)("max-width", col_r41.width)("flex-basis", col_r41.width);
    ɵngcc0.ɵɵclassProp("igx-grid__td--edited", ɵngcc0.ɵɵpipeBindV(1, 30, ɵngcc0.ɵɵpureFunction7(60, _c183, ctx_r19.rowID, col_r41.field, ctx_r19.grid.rowEditable, ctx_r19.grid.transactions, ctx_r19.grid.pipeTrigger, ctx_r19.grid.crudService.cell, ctx_r19.grid.crudService.row)))("igx-grid__td--number", col_r41.dataType === "number")("igx-grid__td--bool", col_r41.dataType === "boolean");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(3, 42, ɵngcc0.ɵɵpureFunction6(68, _c205, col_r41.cellClasses, ctx_r19.rowData[col_r41.field], ctx_r19.rowData, col_r41.field, ctx_r19.viewIndex, ctx_r19.grid.pipeTrigger)))("ngStyle", ɵngcc0.ɵɵpipeBindV(4, 49, ɵngcc0.ɵɵpureFunction6(75, _c205, col_r41.cellStyles, ctx_r19.rowData[col_r41.field], ctx_r19.rowData, col_r41.field, ctx_r19.viewIndex, ctx_r19.grid.pipeTrigger)))("editMode", col_r41.editable && ctx_r19.crudService.targetInEdit(ctx_r19.index, col_r41.index))("column", col_r41)("formatter", col_r41.formatter)("row", ctx_r19)("active", ctx_r19.isCellActive(col_r41.visibleIndex))("rowData", ctx_r19.rowData)("width", col_r41.getCellWidth())("visibleColumnIndex", col_r41.visibleIndex)("value", ɵngcc0.ɵɵpipeBind3(5, 56, ctx_r19.rowData, col_r41.field, ctx_r19.grid.pipeTrigger))("cellTemplate", col_r41.bodyTemplate)("lastSearchInfo", ctx_r19.grid.lastSearchInfo)("cellSelectionMode", ctx_r19.grid.cellSelection)("displayPinnedChip", ctx_r19.shouldDisplayPinnedChip(col_r41.visibleIndex));
    ɵngcc0.ɵɵattribute("aria-describedby", ɵngcc0.ɵɵpipeBind3(2, 38, ctx_r19.gridID + "_" + col_r41.field, ".", "_"));
} }
function IgxHierarchicalRowComponent_ng_template_9_ng_container_7_1_ng_template_0_Template(rf, ctx) { }
function IgxHierarchicalRowComponent_ng_template_9_ng_container_7_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_template_9_ng_container_7_1_ng_template_0_Template, 0, 0, "ng-template");
} }
function IgxHierarchicalRowComponent_ng_template_9_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalRowComponent_ng_template_9_ng_container_7_1_Template, 1, 0, undefined, 17);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r23 = ɵngcc0.ɵɵreference(11);
    const ctx_r20 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r23)("ngTemplateOutletContext", ctx_r20);
} }
function IgxHierarchicalRowComponent_ng_template_9_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 21);
    ɵngcc0.ɵɵelement(1, "igx-checkbox", 22);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r22 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("tabindex", -1)("readonly", true)("checked", ctx_r22.selected)("disabled", ctx_r22.deleted)("disableTransitions", ctx_r22.grid.disableTransitions)("aria-label", ctx_r22.rowCheckboxAriaLabel);
} }
function IgxHierarchicalRowComponent_ng_template_9_ng_template_10_igx_hierarchical_grid_cell_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-hierarchical-grid-cell", 24);
    ɵngcc0.ɵɵpipe(1, "transactionState");
    ɵngcc0.ɵɵpipe(2, "igxStringReplace");
    ɵngcc0.ɵɵpipe(3, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(4, "igxCellStyles");
    ɵngcc0.ɵɵpipe(5, "dataMapper");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r47 = ctx.$implicit;
    const ctx_r46 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r46.cellHeight, "px")("min-width", col_r47.width)("max-width", col_r47.width)("flex-basis", col_r47.width)("left", col_r47.rightPinnedOffset);
    ɵngcc0.ɵɵclassProp("igx-grid__td--edited", ɵngcc0.ɵɵpipeBindV(1, 32, ɵngcc0.ɵɵpureFunction7(62, _c183, ctx_r46.rowID, col_r47.field, ctx_r46.grid.rowEditable, ctx_r46.grid.transactions, ctx_r46.grid.pipeTrigger, ctx_r46.grid.crudService.cell, ctx_r46.grid.crudService.row)))("igx-grid__td--number", col_r47.dataType === "number");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(3, 44, ɵngcc0.ɵɵpureFunction6(70, _c205, col_r47.cellClasses, ctx_r46.rowData[col_r47.field], ctx_r46.rowData, col_r47.field, ctx_r46.viewIndex, ctx_r46.grid.pipeTrigger)))("ngStyle", ɵngcc0.ɵɵpipeBindV(4, 51, ɵngcc0.ɵɵpureFunction6(77, _c205, col_r47.cellStyles, ctx_r46.rowData[col_r47.field], ctx_r46.rowData, col_r47.field, ctx_r46.viewIndex, ctx_r46.grid.pipeTrigger)))("editMode", col_r47.editable && ctx_r46.crudService.targetInEdit(ctx_r46.index, col_r47.index))("column", col_r47)("formatter", col_r47.formatter)("row", ctx_r46)("active", ctx_r46.isCellActive(col_r47.visibleIndex))("firstPinned", col_r47.isFirstPinned)("lastPinned", col_r47.isLastPinned)("rowData", ctx_r46.rowData)("width", col_r47.getCellWidth())("visibleColumnIndex", col_r47.visibleIndex)("value", ɵngcc0.ɵɵpipeBind3(5, 58, ctx_r46.rowData, col_r47.field, ctx_r46.grid.pipeTrigger))("cellTemplate", col_r47.bodyTemplate)("lastSearchInfo", ctx_r46.grid.lastSearchInfo)("cellSelectionMode", ctx_r46.grid.cellSelection)("displayPinnedChip", ctx_r46.shouldDisplayPinnedChip(col_r47.visibleIndex));
    ɵngcc0.ɵɵattribute("aria-describedby", ɵngcc0.ɵɵpipeBind3(2, 40, ctx_r46.gridID + "_" + col_r47.field, ".", "_"));
} }
function IgxHierarchicalRowComponent_ng_template_9_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_template_9_ng_template_10_igx_hierarchical_grid_cell_0_Template, 6, 84, "igx-hierarchical-grid-cell", 23);
    ɵngcc0.ɵɵpipe(1, "igxNotGrouped");
} if (rf & 2) {
    const ctx_r24 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r24.pinnedColumns));
} }
function IgxHierarchicalRowComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_template_9_div_0_Template, 3, 5, "div", 9);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalRowComponent_ng_template_9_ng_container_1_Template, 3, 5, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalRowComponent_ng_template_9_ng_container_2_Template, 3, 10, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(3, IgxHierarchicalRowComponent_ng_template_9_ng_container_3_Template, 2, 2, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(4, IgxHierarchicalRowComponent_ng_template_9_ng_template_4_Template, 6, 82, "ng-template", 11, 12, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵpipe(6, "igxNotGrouped");
    ɵngcc0.ɵɵtemplate(7, IgxHierarchicalRowComponent_ng_template_9_ng_container_7_Template, 2, 2, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(8, IgxHierarchicalRowComponent_ng_template_9_ng_template_8_Template, 2, 6, "ng-template", null, 13, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(10, IgxHierarchicalRowComponent_ng_template_9_ng_template_10_Template, 2, 3, "ng-template", null, 14, ɵngcc0.ɵɵtemplateRefExtractor);
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r10.hasChildren);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r10.rowDraggable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r10.showRowSelectors);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r10.pinnedColumns.length > 0 && ctx_r10.grid.isPinningToStart);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(6, 11, ctx_r10.unpinnedColumns))("igxForScrollContainer", ctx_r10.grid.parentVirtDir)("igxForSizePropName", "calcPixelWidth")("igxForScrollOrientation", "horizontal")("igxForContainerSize", ctx_r10.grid.unpinnedWidth)("igxForTrackBy", ctx_r10.grid.trackColumnChanges);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r10.pinnedColumns.length > 0 && !ctx_r10.grid.isPinningToStart);
} }
function IgxNavbarComponent_igx_icon_2_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 5);
    ɵngcc0.ɵɵlistener("click", function IgxNavbarComponent_igx_icon_2_Template_igx_icon_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2._triggerAction(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.actionButtonIcon, " ");
} }
function IgxNavbarComponent_h1_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "h1", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("id", ctx_r1.titleId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.title, " ");
} }
const _c221 = [[["igx-navbar-action"], ["", "igxNavbarAction", ""]], [["igx-navbar-title"], ["", "igxNavbarTitle", ""]], "*"];
const _c222 = ["igx-navbar-action, [igxNavbarAction]", "igx-navbar-title, [igxNavbarTitle]", "*"];
const _c223 = ["aside"];
const _c224 = ["overlay"];
const _c225 = ["dummy"];
function IgxNavigationDrawerComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtext(1, "Navigation Drawer");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "div", 9);
    ɵngcc0.ɵɵtext(3, " Start by adding");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "div", 9);
    ɵngcc0.ɵɵelementStart(5, "code");
    ɵngcc0.ɵɵtext(6, "<ng-template igxDrawer>");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "div", 9);
    ɵngcc0.ɵɵtext(8, " And some items inside ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "div", 9);
    ɵngcc0.ɵɵtext(10, " Style with igxDrawerItem ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(11, "div", 9);
    ɵngcc0.ɵɵtext(12, " and igxRipple directives");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("isHeader", true);
} }
function IgxNavigationDrawerComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxThumbLabelComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxThumbLabelComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r2.value, "\n");
} }
function IgxTicksComponent_div_0_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c226 = function (a0) { return { "igx-slider__ticks-group--tall": a0 }; };
const _c227 = function (a0) { return { "igx-slider__tick-label--hidden": a0 }; };
function IgxTicksComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵelementStart(1, "div", 3);
    ɵngcc0.ɵɵelementStart(2, "span", 4);
    ɵngcc0.ɵɵtemplate(3, IgxTicksComponent_div_0_ng_container_3_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const idx_r4 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(4, _c226, ctx_r0.isPrimary(idx_r4)));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(6, _c227, !ctx_r0.hiddenTickLabels(idx_r4)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.tickLabelTemplateRef ? ctx_r0.tickLabelTemplateRef : _r1)("ngTemplateOutletContext", ctx_r0.context(idx_r4));
} }
function IgxTicksComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const value_r6 = ctx.$implicit;
    ɵngcc0.ɵɵtextInterpolate1(" ", value_r6, "\n");
} }
const _c228 = ["ticks"];
const _c229 = ["track"];
function IgxSliderComponent_igx_ticks_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-ticks", 12);
    ɵngcc0.ɵɵpipe(1, "spreadTickLabels");
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ticksOrientation", 0)("primaryTicks", ctx_r0.primaryTicks)("secondaryTicks", ctx_r0.secondaryTicks)("primaryTickLabels", ctx_r0.primaryTickLabels)("secondaryTickLabels", ctx_r0.secondaryTickLabels)("tickLabelsOrientation", ctx_r0.tickLabelsOrientation)("labelsViewEnabled", ctx_r0.labelsViewEnabled)("labels", ɵngcc0.ɵɵpipeBind2(1, 11, ctx_r0.labels, ctx_r0.secondaryTicks))("tickLabelTemplateRef", ctx_r0.tickLabelTemplateRef)("minValue", ctx_r0.minValue)("maxValue", ctx_r0.maxValue);
} }
function IgxSliderComponent_igx_ticks_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-ticks", 12);
    ɵngcc0.ɵɵpipe(1, "spreadTickLabels");
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ticksOrientation", 1)("primaryTicks", ctx_r3.primaryTicks)("secondaryTicks", ctx_r3.secondaryTicks)("primaryTickLabels", ctx_r3.primaryTickLabels)("secondaryTickLabels", ctx_r3.secondaryTickLabels)("tickLabelsOrientation", ctx_r3.tickLabelsOrientation)("labelsViewEnabled", ctx_r3.labelsViewEnabled)("labels", ɵngcc0.ɵɵpipeBind2(1, 11, ctx_r3.labels, ctx_r3.secondaryTicks))("tickLabelTemplateRef", ctx_r3.tickLabelTemplateRef)("minValue", ctx_r3.minValue)("maxValue", ctx_r3.maxValue);
} }
function IgxSliderComponent_igx_thumb_label_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-thumb-label", 13);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("type", 0)("value", ctx_r4.lowerLabel)("templateRef", ctx_r4.thumbFromTemplateRef)("continuous", ctx_r4.continuous)("context", ctx_r4.context)("deactiveState", ctx_r4.deactivateThumbLabel);
} }
function IgxSliderComponent_igx_thumb_9_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-thumb", 10, 14);
    ɵngcc0.ɵɵlistener("onChange", function IgxSliderComponent_igx_thumb_9_Template_igx_thumb_onChange_0_listener() { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onThumbChange(); })("onHoverChange", function IgxSliderComponent_igx_thumb_9_Template_igx_thumb_onHoverChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onHoverChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("type", 0)("value", ctx_r5.lowerLabel)("disabled", ctx_r5.disabled)("continuous", ctx_r5.continuous)("onPan", ctx_r5.onPan)("stepDistance", ctx_r5.stepDistance)("step", ctx_r5.step)("templateRef", ctx_r5.thumbFromTemplateRef)("context", ctx_r5.context)("deactiveState", ctx_r5.deactivateThumbLabel)("thumbLabelVisibilityDuration", ctx_r5.thumbLabelVisibilityDuration);
} }
function IgxBottomNavComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxBottomNavComponent_ng_container_3_igx_tab_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-tab", 4);
    ɵngcc0.ɵɵtext(1, "> ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const panel_r4 = ctx.$implicit;
    const i_r5 = ctx.index;
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("relatedPanel", panel_r4)("autoGenerated", true)("id", ctx_r3.getTabId(i_r5));
    ɵngcc0.ɵɵattribute("aria-controls", ctx_r3.getTabPanelId(i_r5));
} }
function IgxBottomNavComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxBottomNavComponent_ng_container_3_igx_tab_1_Template, 2, 4, "igx-tab", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r2.panels);
} }
const _c230 = [[["igx-tab"]], "*"];
const _c231 = ["igx-tab", "*"];
const _c232 = ["defaultTabTemplate"];
function IgxTabComponent_ng_template_0_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 5);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(3, "igx-badge", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(context_r3.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", context_r3.changesCount)("hidden", context_r3.changesCount === 0);
} }
function IgxTabComponent_ng_template_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(context_r3.label);
} }
function IgxTabComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTabComponent_ng_template_0_div_0_Template, 4, 3, "div", 2);
    ɵngcc0.ɵɵtemplate(1, IgxTabComponent_ng_template_0_div_1_Template, 2, 1, "div", 3);
} if (rf & 2) {
    const context_r3 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngIf", context_r3.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", context_r3.label);
} }
function IgxTabComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTabItemComponent_ng_template_0_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 5);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(3, "igx-badge", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(context_r3.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r4.changesCount)("hidden", ctx_r4.changesCount === 0);
} }
function IgxTabItemComponent_ng_template_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(context_r3.label);
} }
function IgxTabItemComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTabItemComponent_ng_template_0_div_0_Template, 4, 3, "div", 2);
    ɵngcc0.ɵɵtemplate(1, IgxTabItemComponent_ng_template_0_div_1_Template, 2, 1, "div", 3);
} if (rf & 2) {
    const context_r3 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngIf", context_r3.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", context_r3.label);
} }
function IgxTabItemComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTabsGroupComponent_ng_content_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "isSelected"]);
} }
const _c233 = ["contentsContainer"];
const _c234 = ["headerContainer"];
const _c235 = ["itemsContainer"];
const _c236 = ["selectedIndicator"];
const _c237 = ["tabsContainer"];
const _c238 = ["viewPort"];
function IgxTabsComponent_ng_container_11_igx_tab_item_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-tab-item", 16);
} if (rf & 2) {
    const group_r8 = ctx.$implicit;
    const i_r9 = ctx.index;
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("relatedGroup", group_r8)("autoGenerated", true)("id", ctx_r7.getTabItemId(i_r9));
    ɵngcc0.ɵɵattribute("aria-controls", ctx_r7.getTabsGroupId(i_r9));
} }
function IgxTabsComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTabsComponent_ng_container_11_igx_tab_item_1_Template, 1, 4, "igx-tab-item", 15);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.groups);
} }
function IgxTabsComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 17, 18);
} }
const _c239 = [[["igx-tab-item"]], "*"];
const _c240 = ["igx-tab-item", "*"];
const _c241 = ["hourList"];
const _c242 = ["minuteList"];
const _c243 = ["secondsList"];
const _c244 = ["ampmList"];
const _c245 = ["defaultTimePickerTemplate"];
const _c246 = ["dropdownInputTemplate"];
function IgxTimePickerComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function IgxTimePickerComponent_ng_template_2_label_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 18);
    ɵngcc0.ɵɵtext(1, "Time");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxTimePickerComponent_ng_template_2_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 19);
} }
function IgxTimePickerComponent_ng_template_2_igx_suffix_8_Template(rf, ctx) { if (rf & 1) {
    const _r20 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-suffix", 20);
    ɵngcc0.ɵɵlistener("click", function IgxTimePickerComponent_ng_template_2_igx_suffix_8_Template_igx_suffix_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r20); const ctx_r19 = ɵngcc0.ɵɵnextContext(2); return ctx_r19.clear(); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 21);
    ɵngcc0.ɵɵtext(2, "clear");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function IgxTimePickerComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 11, 12);
    ɵngcc0.ɵɵlistener("mousedown", function IgxTimePickerComponent_ng_template_2_Template_igx_input_group_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.mouseDown($event); });
    ɵngcc0.ɵɵtemplate(2, IgxTimePickerComponent_ng_template_2_label_2_Template, 2, 0, "label", 13);
    ɵngcc0.ɵɵtemplate(3, IgxTimePickerComponent_ng_template_2_ng_container_3_Template, 1, 0, "ng-container", 14);
    ɵngcc0.ɵɵelementStart(4, "igx-prefix", 15);
    ɵngcc0.ɵɵlistener("click", function IgxTimePickerComponent_ng_template_2_Template_igx_prefix_click_4_listener() { ɵngcc0.ɵɵrestoreView(_r22); const _r15 = ɵngcc0.ɵɵreference(1); const ctx_r23 = ɵngcc0.ɵɵnextContext(); return ctx_r23.openDialog(_r15.element.nativeElement); });
    ɵngcc0.ɵɵelementStart(5, "igx-icon");
    ɵngcc0.ɵɵtext(6, "access_time");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "input", 16);
    ɵngcc0.ɵɵlistener("input", function IgxTimePickerComponent_ng_template_2_Template_input_input_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r24 = ɵngcc0.ɵɵnextContext(); return ctx_r24.onInput($event); })("blur", function IgxTimePickerComponent_ng_template_2_Template_input_blur_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r25 = ɵngcc0.ɵɵnextContext(); return ctx_r25.onBlur($event); })("focus", function IgxTimePickerComponent_ng_template_2_Template_input_focus_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r26 = ɵngcc0.ɵɵnextContext(); return ctx_r26.onFocus($event); })("wheel", function IgxTimePickerComponent_ng_template_2_Template_input_wheel_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r27 = ɵngcc0.ɵɵnextContext(); return ctx_r27.spinOnEdit($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(8, IgxTimePickerComponent_ng_template_2_igx_suffix_8_Template, 3, 0, "igx-suffix", 17);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("suppressInputAutofocus", true);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r3.labelDirective);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r0);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("igxMask", ctx_r3.mask)("includeLiterals", true)("placeholder", ctx_r3.format)("displayValuePipe", ctx_r3.displayFormat)("focusedValuePipe", ctx_r3.inputFormat)("promptChar", ctx_r3.promptChar)("value", ctx_r3.displayValue)("igxTextSelection", true)("disabled", ctx_r3.disabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.showClearButton);
} }
function IgxTimePickerComponent_ng_template_4_label_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 18);
    ɵngcc0.ɵɵtext(1, "Time");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxTimePickerComponent_ng_template_4_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 19);
} }
function IgxTimePickerComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    const _r31 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 22);
    ɵngcc0.ɵɵlistener("click", function IgxTimePickerComponent_ng_template_4_Template_igx_input_group_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r31); const ctx_r30 = ɵngcc0.ɵɵnextContext(); return ctx_r30.openDialog(); })("mousedown", function IgxTimePickerComponent_ng_template_4_Template_igx_input_group_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r31); const ctx_r32 = ɵngcc0.ɵɵnextContext(); return ctx_r32.mouseDown($event); });
    ɵngcc0.ɵɵelementStart(1, "igx-prefix");
    ɵngcc0.ɵɵelementStart(2, "igx-icon");
    ɵngcc0.ɵɵtext(3, "access_time");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, IgxTimePickerComponent_ng_template_4_label_4_Template, 2, 0, "label", 13);
    ɵngcc0.ɵɵtemplate(5, IgxTimePickerComponent_ng_template_4_ng_container_5_Template, 1, 0, "ng-container", 14);
    ɵngcc0.ɵɵelementStart(6, "input", 23);
    ɵngcc0.ɵɵlistener("blur", function IgxTimePickerComponent_ng_template_4_Template_input_blur_6_listener($event) { ɵngcc0.ɵɵrestoreView(_r31); const ctx_r33 = ɵngcc0.ɵɵnextContext(); return ctx_r33.onBlur($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r5.labelDirective);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r5.displayTime || "")("disabled", ctx_r5.disabled);
} }
function IgxTimePickerComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTimePickerComponent_ng_template_7_div_0_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r38 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 27);
    ɵngcc0.ɵɵlistener("click", function IgxTimePickerComponent_ng_template_7_div_0_button_1_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r38); const ctx_r37 = ɵngcc0.ɵɵnextContext(3); return ctx_r37.cancelButtonClick(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r35 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r35.cancelButtonLabel, " ");
} }
function IgxTimePickerComponent_ng_template_7_div_0_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r40 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 27);
    ɵngcc0.ɵɵlistener("click", function IgxTimePickerComponent_ng_template_7_div_0_button_2_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r40); const ctx_r39 = ɵngcc0.ɵɵnextContext(3); return ctx_r39.okButtonClick(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r36 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r36.okButtonLabel, " ");
} }
function IgxTimePickerComponent_ng_template_7_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 25);
    ɵngcc0.ɵɵtemplate(1, IgxTimePickerComponent_ng_template_7_div_0_button_1_Template, 2, 1, "button", 26);
    ɵngcc0.ɵɵtemplate(2, IgxTimePickerComponent_ng_template_7_div_0_button_2_Template, 2, 1, "button", 26);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r34 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r34.cancelButtonLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r34.okButtonLabel);
} }
function IgxTimePickerComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTimePickerComponent_ng_template_7_div_0_Template, 3, 2, "div", 24);
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r8.cancelButtonLabel || ctx_r8.okButtonLabel);
} }
function IgxTimePickerComponent_div_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 28);
    ɵngcc0.ɵɵelementStart(1, "h5", 29);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "h2", 30);
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtext(6, ":");
    ɵngcc0.ɵɵelementStart(7, "span");
    ɵngcc0.ɵɵtext(8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtext(9, ":");
    ɵngcc0.ɵɵelementStart(10, "span");
    ɵngcc0.ɵɵtext(11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r9.selectedAmPm);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r9.selectedHour);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r9.selectedMinute);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r9.selectedSeconds);
} }
const _c247 = function (a0) { return { "igx-time-picker__item--disabled": a0 }; };
function IgxTimePickerComponent_div_13_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 34);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const hour_r43 = ctx.$implicit;
    const ctx_r42 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("igxHourItem", hour_r43)("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c247, ctx_r42.applyDisabledStyleForItem(ctx_r42.timeParts.Hour, hour_r43)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(hour_r43);
} }
function IgxTimePickerComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 31, 32);
    ɵngcc0.ɵɵtemplate(2, IgxTimePickerComponent_div_13_span_2_Template, 2, 5, "span", 33);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxItemList", "hourList");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r10.hourView);
} }
function IgxTimePickerComponent_div_14_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 37);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const minute_r46 = ctx.$implicit;
    const ctx_r45 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("igxMinuteItem", minute_r46)("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c247, ctx_r45.applyDisabledStyleForItem(ctx_r45.timeParts.Minute, minute_r46)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(minute_r46);
} }
function IgxTimePickerComponent_div_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 31, 35);
    ɵngcc0.ɵɵtemplate(2, IgxTimePickerComponent_div_14_span_2_Template, 2, 5, "span", 36);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxItemList", "minuteList");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r11.minuteView);
} }
function IgxTimePickerComponent_div_15_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 40);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const seconds_r49 = ctx.$implicit;
    const ctx_r48 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("igxSecondsItem", seconds_r49)("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c247, ctx_r48.applyDisabledStyleForItem(ctx_r48.timeParts.Seconds, seconds_r49)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(seconds_r49);
} }
function IgxTimePickerComponent_div_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 31, 38);
    ɵngcc0.ɵɵtemplate(2, IgxTimePickerComponent_div_15_span_2_Template, 2, 5, "span", 39);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxItemList", "secondsList");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r12.secondsView);
} }
function IgxTimePickerComponent_div_16_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 43);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ampm_r52 = ctx.$implicit;
    const ctx_r51 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("igxAmPmItem", ampm_r52)("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c247, ctx_r51.applyDisabledStyleForItem(ctx_r51.timeParts.amPM, ampm_r52)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ampm_r52);
} }
function IgxTimePickerComponent_div_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 31, 41);
    ɵngcc0.ɵɵtemplate(2, IgxTimePickerComponent_div_16_span_2_Template, 2, 5, "span", 42);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxItemList", "ampmList");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r13.ampmView);
} }
function IgxTimePickerComponent_ng_container_17_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c248 = function (a0, a1) { return { "igx-time-picker--dropdown": a0, "igx-time-picker--vertical": a1 }; };
function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-splitter-bar", 2);
    ɵngcc0.ɵɵlistener("moveStart", function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template_igx_splitter_bar_moveStart_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(2); return ctx_r5.onMoveStart($event); })("moving", function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template_igx_splitter_bar_moving_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r7 = ɵngcc0.ɵɵnextContext(2); return ctx_r7.onMoving($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    const pane_r1 = ctx_r8.$implicit;
    const index_r3 = ctx_r8.index;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("order", pane_r1.order + 1)("type", ctx_r4.type)("pane", pane_r1)("siblings", ctx_r4.getPaneSiblingsByOrder(pane_r1.order + 1, index_r3));
} }
function IgxSplitterComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template, 1, 4, "igx-splitter-bar", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const last_r2 = ctx.last;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r2);
} }
const _c249 = [[["igx-splitter-pane"]]];
const _c250 = ["igx-splitter-pane"];
function IgxDateRangeStartComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_div_0_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r16 = ɵngcc0.ɵɵreference(19);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r16);
} }
function IgxDateRangeStartComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 13);
} }
function IgxDateRangeStartComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1);
} }
function IgxDateRangeStartComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2);
} }
function IgxDateRangeStartComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3);
} }
function IgxDateRangeStartComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 4);
} }
function IgxDateRangeStartComponent_ng_template_12_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_12_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_12_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_12_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_12_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementStart(2, "div", 15);
    ɵngcc0.ɵɵtemplate(3, IgxDateRangeStartComponent_ng_template_12_ng_container_3_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵtemplate(4, IgxDateRangeStartComponent_ng_template_12_ng_container_4_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxDateRangeStartComponent_ng_template_12_ng_container_5_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r6 = ɵngcc0.ɵɵreference(9);
    const _r2 = ɵngcc0.ɵɵreference(5);
    const _r4 = ɵngcc0.ɵɵreference(7);
    const _r8 = ɵngcc0.ɵɵreference(11);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r8);
} }
function IgxDateRangeStartComponent_ng_template_14_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_14_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_14_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_14_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxDateRangeStartComponent_ng_template_14_ng_container_0_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementStart(1, "div", 14);
    ɵngcc0.ɵɵtemplate(2, IgxDateRangeStartComponent_ng_template_14_ng_container_2_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementStart(3, "div", 15);
    ɵngcc0.ɵɵtemplate(4, IgxDateRangeStartComponent_ng_template_14_ng_container_4_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxDateRangeStartComponent_ng_template_14_ng_container_5_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(5);
    const _r6 = ɵngcc0.ɵɵreference(9);
    const _r4 = ɵngcc0.ɵɵreference(7);
    const _r8 = ɵngcc0.ɵɵreference(11);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r8);
} }
function IgxDateRangeStartComponent_ng_template_16_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_16_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_16_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_16_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxDateRangeStartComponent_ng_template_16_ng_container_0_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementStart(1, "div", 14);
    ɵngcc0.ɵɵtemplate(2, IgxDateRangeStartComponent_ng_template_16_ng_container_2_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵtemplate(3, IgxDateRangeStartComponent_ng_template_16_ng_container_3_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵtemplate(4, IgxDateRangeStartComponent_ng_template_16_ng_container_4_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(5);
    const _r6 = ɵngcc0.ɵɵreference(9);
    const _r4 = ɵngcc0.ɵɵreference(7);
    const _r8 = ɵngcc0.ɵɵreference(11);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r8);
} }
function IgxDateRangeStartComponent_ng_template_18_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_18_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_18_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r14 = ɵngcc0.ɵɵreference(17);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r14);
} }
function IgxDateRangeStartComponent_ng_template_18_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_18_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_18_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r12 = ɵngcc0.ɵɵreference(15);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r12);
} }
function IgxDateRangeStartComponent_ng_template_18_ng_container_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_18_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_18_ng_container_3_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r12 = ɵngcc0.ɵɵreference(15);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r12);
} }
function IgxDateRangeStartComponent_ng_template_18_ng_container_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_18_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_18_ng_container_4_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r10 = ɵngcc0.ɵɵreference(13);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r10);
} }
function IgxDateRangeStartComponent_ng_template_18_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0, 16);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_18_ng_container_1_Template, 2, 1, "ng-container", 17);
    ɵngcc0.ɵɵtemplate(2, IgxDateRangeStartComponent_ng_template_18_ng_container_2_Template, 2, 1, "ng-container", 17);
    ɵngcc0.ɵɵtemplate(3, IgxDateRangeStartComponent_ng_template_18_ng_container_3_Template, 2, 1, "ng-container", 17);
    ɵngcc0.ɵɵtemplate(4, IgxDateRangeStartComponent_ng_template_18_ng_container_4_Template, 2, 1, "ng-container", 18);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r17.theme);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "bootstrap");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "fluent");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "indigo-design");
} }
function IgxDateRangeEndComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_div_0_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r16 = ɵngcc0.ɵɵreference(19);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r16);
} }
function IgxDateRangeEndComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 13);
} }
function IgxDateRangeEndComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1);
} }
function IgxDateRangeEndComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2);
} }
function IgxDateRangeEndComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3);
} }
function IgxDateRangeEndComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 4);
} }
function IgxDateRangeEndComponent_ng_template_12_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_12_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_12_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_12_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_12_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementStart(2, "div", 15);
    ɵngcc0.ɵɵtemplate(3, IgxDateRangeEndComponent_ng_template_12_ng_container_3_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵtemplate(4, IgxDateRangeEndComponent_ng_template_12_ng_container_4_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxDateRangeEndComponent_ng_template_12_ng_container_5_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r6 = ɵngcc0.ɵɵreference(9);
    const _r2 = ɵngcc0.ɵɵreference(5);
    const _r4 = ɵngcc0.ɵɵreference(7);
    const _r8 = ɵngcc0.ɵɵreference(11);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r8);
} }
function IgxDateRangeEndComponent_ng_template_14_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_14_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_14_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_14_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxDateRangeEndComponent_ng_template_14_ng_container_0_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementStart(1, "div", 14);
    ɵngcc0.ɵɵtemplate(2, IgxDateRangeEndComponent_ng_template_14_ng_container_2_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementStart(3, "div", 15);
    ɵngcc0.ɵɵtemplate(4, IgxDateRangeEndComponent_ng_template_14_ng_container_4_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxDateRangeEndComponent_ng_template_14_ng_container_5_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(5);
    const _r6 = ɵngcc0.ɵɵreference(9);
    const _r4 = ɵngcc0.ɵɵreference(7);
    const _r8 = ɵngcc0.ɵɵreference(11);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r8);
} }
function IgxDateRangeEndComponent_ng_template_16_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_16_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_16_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_16_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxDateRangeEndComponent_ng_template_16_ng_container_0_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementStart(1, "div", 14);
    ɵngcc0.ɵɵtemplate(2, IgxDateRangeEndComponent_ng_template_16_ng_container_2_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵtemplate(3, IgxDateRangeEndComponent_ng_template_16_ng_container_3_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵtemplate(4, IgxDateRangeEndComponent_ng_template_16_ng_container_4_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(5);
    const _r6 = ɵngcc0.ɵɵreference(9);
    const _r4 = ɵngcc0.ɵɵreference(7);
    const _r8 = ɵngcc0.ɵɵreference(11);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r8);
} }
function IgxDateRangeEndComponent_ng_template_18_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_18_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_18_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r14 = ɵngcc0.ɵɵreference(17);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r14);
} }
function IgxDateRangeEndComponent_ng_template_18_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_18_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_18_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r12 = ɵngcc0.ɵɵreference(15);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r12);
} }
function IgxDateRangeEndComponent_ng_template_18_ng_container_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_18_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_18_ng_container_3_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r12 = ɵngcc0.ɵɵreference(15);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r12);
} }
function IgxDateRangeEndComponent_ng_template_18_ng_container_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_18_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_18_ng_container_4_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r10 = ɵngcc0.ɵɵreference(13);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r10);
} }
function IgxDateRangeEndComponent_ng_template_18_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0, 16);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_18_ng_container_1_Template, 2, 1, "ng-container", 17);
    ɵngcc0.ɵɵtemplate(2, IgxDateRangeEndComponent_ng_template_18_ng_container_2_Template, 2, 1, "ng-container", 17);
    ɵngcc0.ɵɵtemplate(3, IgxDateRangeEndComponent_ng_template_18_ng_container_3_Template, 2, 1, "ng-container", 17);
    ɵngcc0.ɵɵtemplate(4, IgxDateRangeEndComponent_ng_template_18_ng_container_4_Template, 2, 1, "ng-container", 18);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r17.theme);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "bootstrap");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "fluent");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "indigo-design");
} }
function IgxDateRangePickerComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 12);
    ɵngcc0.ɵɵlistener("click", function IgxDateRangePickerComponent_ng_container_5_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.close(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.doneButtonText);
} }
function IgxDateRangePickerComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangePickerComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    const _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵlistener("click", function IgxDateRangePickerComponent_ng_template_7_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); const ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.open(); });
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxDateRangePickerComponent_ng_template_9_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangePickerComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1);
    ɵngcc0.ɵɵelementStart(1, "div", 14);
    ɵngcc0.ɵɵtemplate(2, IgxDateRangePickerComponent_ng_template_9_ng_container_2_Template, 1, 0, "ng-container", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵprojection(3, 2);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    const _r10 = ɵngcc0.ɵɵreference(14);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("className", ctx_r7.separatorClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r7.dateSeparatorTemplate ? ctx_r7.dateSeparatorTemplate : _r10);
} }
function IgxDateRangePickerComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, " calendar_today ");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxDateRangePickerComponent_ng_template_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate(ctx_r11.dateSeparator);
} }
function IgxDateRangePickerComponent_ng_template_15_igx_prefix_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangePickerComponent_ng_template_15_igx_prefix_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-prefix");
    ɵngcc0.ɵɵtemplate(1, IgxDateRangePickerComponent_ng_template_15_igx_prefix_4_ng_container_1_Template, 1, 0, "ng-container", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r8 = ɵngcc0.ɵɵreference(12);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r8);
} }
function IgxDateRangePickerComponent_ng_template_15_Template(rf, ctx) { if (rf & 1) {
    const _r23 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 15);
    ɵngcc0.ɵɵlistener("click", function IgxDateRangePickerComponent_ng_template_15_Template_igx_input_group_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r23); const ctx_r22 = ɵngcc0.ɵɵnextContext(); return ctx_r22.open(); });
    ɵngcc0.ɵɵelement(1, "input", 16, 17);
    ɵngcc0.ɵɵpipe(3, "dateRange");
    ɵngcc0.ɵɵtemplate(4, IgxDateRangePickerComponent_ng_template_15_igx_prefix_4_Template, 2, 1, "igx-prefix", 5);
    ɵngcc0.ɵɵelementContainerStart(5, 18);
    ɵngcc0.ɵɵprojection(6, 3);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementContainerStart(7, 19);
    ɵngcc0.ɵɵprojection(8, 4);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementContainerStart(9, 20);
    ɵngcc0.ɵɵprojection(10, 5);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementContainerStart(11, 21);
    ɵngcc0.ɵɵprojection(12, 6);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext();
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("placeholder", ctx_r13.value ? "" : ctx_r13.singleInputFormat)("value", ɵngcc0.ɵɵpipeBind4(3, 5, ctx_r13.value, ctx_r13.appliedFormat, ctx_r13.locale, ctx_r13.formatter));
    ɵngcc0.ɵɵattribute("aria-expanded", !_r0.collapsed)("aria-labelledby", ctx_r13.label == null ? null : ctx_r13.label.id);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r13.toggleComponents.length);
} }
const _c251 = [[["igx-date-single"]], [["igx-date-range-start"]], [["igx-date-range-end"]], [["", "igxLabel", ""]], [["igx-prefix"], ["", "igxPrefix", ""]], [["igx-suffix"], ["", "igxSuffix", ""]], [["igx-hint"], ["", "igxHint", ""]]];
const _c252 = ["igx-date-single", "igx-date-range-start", "igx-date-range-end", "[igxLabel]", "igx-prefix,[igxPrefix]", "igx-suffix,[igxSuffix]", "igx-hint,[igxHint]"];
var EaseIn;
(function (EaseIn) {
    EaseIn[EaseIn["quad"] = `cubic-bezier(0.550, 0.085, 0.680, 0.530)`] = "quad";
    EaseIn[EaseIn["cubic"] = `cubic-bezier(0.550, 0.055, 0.675, 0.190)`] = "cubic";
    EaseIn[EaseIn["quart"] = `cubic-bezier(0.895, 0.030, 0.685, 0.220)`] = "quart";
    EaseIn[EaseIn["quint"] = `cubic-bezier(0.755, 0.050, 0.855, 0.060)`] = "quint";
    EaseIn[EaseIn["sine"] = `cubic-bezier(0.470, 0.000, 0.745, 0.715)`] = "sine";
    EaseIn[EaseIn["expo"] = `cubic-bezier(0.950, 0.050, 0.795, 0.035)`] = "expo";
    EaseIn[EaseIn["circ"] = `cubic-bezier(0.600, 0.040, 0.980, 0.335)`] = "circ";
    EaseIn[EaseIn["back"] = `cubic-bezier(0.600, -0.280, 0.735, 0.045)`] = "back";
})(EaseIn || (EaseIn = {}));
var EaseOut;
(function (EaseOut) {
    EaseOut[EaseOut["quad"] = `cubic-bezier(0.250, 0.460, 0.450, 0.940)`] = "quad";
    EaseOut[EaseOut["cubic"] = `cubic-bezier(0.215, 0.610, 0.355, 1.000)`] = "cubic";
    EaseOut[EaseOut["quart"] = `cubic-bezier(0.165, 0.840, 0.440, 1.000)`] = "quart";
    EaseOut[EaseOut["quint"] = `cubic-bezier(0.230, 1.000, 0.320, 1.000)`] = "quint";
    EaseOut[EaseOut["sine"] = `cubic-bezier(0.390, 0.575, 0.565, 1.000)`] = "sine";
    EaseOut[EaseOut["expo"] = `cubic-bezier(0.190, 1.000, 0.220, 1.000)`] = "expo";
    EaseOut[EaseOut["circ"] = `cubic-bezier(0.075, 0.820, 0.165, 1.000)`] = "circ";
    EaseOut[EaseOut["back"] = `cubic-bezier(0.175, 0.885, 0.320, 1.275)`] = "back";
})(EaseOut || (EaseOut = {}));
var EaseInOut;
(function (EaseInOut) {
    EaseInOut[EaseInOut["quad"] = `cubic-bezier(0.455, 0.030, 0.515, 0.955)`] = "quad";
    EaseInOut[EaseInOut["cubic"] = `cubic-bezier(0.645, 0.045, 0.355, 1.000)`] = "cubic";
    EaseInOut[EaseInOut["quart"] = `cubic-bezier(0.770, 0.000, 0.175, 1.000)`] = "quart";
    EaseInOut[EaseInOut["quint"] = `cubic-bezier(0.860, 0.000, 0.070, 1.000)`] = "quint";
    EaseInOut[EaseInOut["sine"] = `cubic-bezier(0.445, 0.050, 0.550, 0.950)`] = "sine";
    EaseInOut[EaseInOut["expo"] = `cubic-bezier(1.000, 0.000, 0.000, 1.000)`] = "expo";
    EaseInOut[EaseInOut["circ"] = `cubic-bezier(0.785, 0.135, 0.150, 0.860)`] = "circ";
    EaseInOut[EaseInOut["back"] = `cubic-bezier(0.680, -0.550, 0.265, 1.550)`] = "back";
})(EaseInOut || (EaseInOut = {}));

const base = [
    style({
        opacity: `{{startOpacity}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{endOpacity}}`
    }))
];
const baseParams = {
    delay: '0s',
    duration: '350ms',
    easing: EaseOut.sine,
    endOpacity: 1,
    startOpacity: 0
};
const fadeIn = animation(base, {
    params: baseParams
});
const fadeOut = animation(base, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.sine,
        endOpacity: 0,
        startOpacity: 1
    }
});

const baseRecipe = [
    style({
        backfaceVisibility: 'hidden',
        transformStyle: 'preserve-3d'
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            offset: 0,
            transform: `translateZ({{startDistance}})
                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{startAngle}}deg)`
        }),
        style({
            offset: 1,
            transform: `translateZ({{endDistance}})
                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{endAngle}}deg)`
        })
    ]))
];
const baseParams$1 = {
    delay: '0s',
    duration: '600ms',
    easing: EaseOut.quad,
    endAngle: 180,
    endDistance: '0px',
    rotateX: 1,
    rotateY: 0,
    rotateZ: 0,
    startAngle: 0,
    startDistance: '0px'
};
const flipTop = animation(baseRecipe, {
    params: Object.assign({}, baseParams$1)
});
const flipBottom = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endAngle: -180 })
});
const flipLeft = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { rotateX: 0, rotateY: 1 })
});
const flipRight = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endAngle: -180, rotateX: 0, rotateY: 1 })
});
const flipHorFwd = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '170px' })
});
const flipHorBck = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '-170px' })
});
const flipVerFwd = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '170px', rotateX: 0, rotateY: 1 })
});
const flipVerBck = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '-170px', rotateX: 0, rotateY: 1 })
});

const baseRecipe$1 = [
    style({
        opacity: `{{startOpacity}}`,
        transform: `rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{startAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        offset: 0,
        opacity: `{{endOpacity}}`,
        transform: `rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{endAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }))
];
const baseInParams = {
    delay: '0s',
    duration: '600ms',
    easing: EaseOut.quad,
    endAngle: 0,
    endOpacity: 1,
    rotateX: 0,
    rotateY: 0,
    rotateZ: 1,
    startAngle: -360,
    startOpacity: 0,
    xPos: 'center',
    yPos: 'center'
};
const baseOutParams = Object.assign(Object.assign({}, baseInParams), { easing: EaseIn.quad, endOpacity: 0, startOpacity: 1 });
const rotateInCenter = animation(baseRecipe$1, {
    params: Object.assign({}, baseInParams)
});
const rotateOutCenter = animation(baseRecipe$1, {
    params: Object.assign({}, baseOutParams)
});
const rotateInTop = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'top' })
});
const rotateOutTop = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'top' })
});
const rotateInRight = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'right' })
});
const rotateOutRight = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'right' })
});
const rotateInBottom = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'bottom' })
});
const rotateOutBottom = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'bottom' })
});
const rotateInLeft = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'left' })
});
const rotateOutLeft = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'left' })
});
const rotateInTr = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'right', yPos: 'top' })
});
const rotateOutTr = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'right', yPos: 'top' })
});
const rotateInBr = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'right', yPos: 'bottom' })
});
const rotateOutBr = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'right', yPos: 'bottom' })
});
const rotateInBl = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'left', yPos: 'bottom' })
});
const rotateOutBl = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'left', yPos: 'bottom' })
});
const rotateInTl = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'left', yPos: 'top' })
});
const rotateOutTl = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'left', yPos: 'top' })
});
const rotateInDiagonal1 = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { rotateX: 1, rotateY: 1, rotateZ: 0 })
});
const rotateOutDiagonal1 = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { rotateX: 1, rotateY: 1, rotateZ: 0 })
});
const rotateInDiagonal2 = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { rotateX: -1, rotateY: 1, rotateZ: 0 })
});
const rotateOutDiagonal2 = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { rotateX: -1, rotateY: 1, rotateZ: 0 })
});
const rotateInHor = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { rotateX: 0, rotateY: 1, rotateZ: 0 })
});
const rotateOutHor = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { rotateX: 0, rotateY: 1, rotateZ: 0 })
});
const rotateInVer = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { rotateX: 1, rotateY: 0, rotateZ: 0 })
});
const rotateOutVer = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { rotateX: 1, rotateY: 0, rotateZ: 0 })
});

const baseRecipe$2 = [
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            offset: 0,
            transform: `rotate(0deg) translate{{direction}}(0)`,
            transformOrigin: `{{xPos}} {{yPos}}`
        }),
        style({
            offset: 0.1,
            transform: `rotate({{endAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        style({
            offset: 0.2,
            transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`
        }),
        style({
            offset: 0.3,
            transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        style({
            offset: 0.4,
            transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`
        }),
        style({
            offset: 0.5,
            transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        style({
            offset: 0.6,
            transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`
        }),
        style({
            offset: 0.7,
            transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        style({
            offset: 0.8,
            transform: `rotate(-{{endAngle}}deg) translate{{direction}}({{endDistance}})`
        }),
        style({
            offset: 0.9,
            transform: `rotate({{endAngle}}deg) translate{{direction}}(-{{endDistance}})`
        }),
        style({
            offset: 1,
            transform: `rotate(0deg) translate{{direction}}(0)`,
            transformOrigin: `{{xPos}} {{yPos}}`
        })
    ]))
];
const baseParams$2 = {
    delay: '0s',
    direction: 'X',
    duration: '800ms',
    easing: EaseInOut.quad,
    endAngle: 0,
    endDistance: '8px',
    startAngle: 0,
    startDistance: '10px',
    xPos: 'center',
    yPos: 'center'
};
const shakeHor = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'X' })
});
const shakeVer = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y' })
});
const shakeTop = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'top' })
});
const shakeBottom = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'bottom' })
});
const shakeRight = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'center' })
});
const shakeLeft = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'center' })
});
const shakeCenter = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 8, endDistance: '0', startAngle: 10, startDistance: '0', xPos: 'center', yPos: 'center' })
});
const shakeTr = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'top' })
});
const shakeBr = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'bottom' })
});
const shakeBl = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'bottom' })
});
const shakeTl = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'top' })
});

const heartbeatBase = [
    style({
        animationTimingFunction: `ease-out`,
        transform: `scale(1)`,
        transformOrigin: `center center`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            animationTimingFunction: `ease-in`,
            offset: 0.1,
            transform: `scale(0.91)`
        }),
        style({
            animationTimingFunction: `ease-out`,
            offset: 0.17,
            transform: `scale(0.98)`
        }),
        style({
            animationTimingFunction: `ease-in`,
            offset: 0.33,
            transform: `scale(0.87)`
        }),
        style({
            animationTimingFunction: `ease-out`,
            offset: 0.45,
            transform: `scale(1)`
        })
    ]))
];
const heartbeatParams = {
    delay: '0s',
    duration: '1.5s',
    easing: 'ease-in-out'
};
const pulsateBase = [
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            offset: 0,
            transform: `scale({{fromScale}})`
        }),
        style({
            offset: 0.5,
            transform: `scale({{toScale}})`
        }),
        style({
            offset: 1,
            transform: `scale({{fromScale}})`
        })
    ]))
];
const pulsateParams = {
    delay: '0s',
    duration: '.5s',
    easing: 'ease-in-out',
    fromScale: 1,
    toScale: 1.1
};
const blinkBase = [
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            offset: 0,
            opacity: .8,
            transform: `scale({{fromScale}})`
        }),
        style({
            offset: 0.8,
            opacity: 0,
            transform: `scale({{midScale}})`
        }),
        style({
            offset: 1,
            opacity: 0,
            transform: `scale({{toScale}})`
        })
    ]))
];
const blinkParams = {
    delay: '0s',
    duration: '.8s',
    easing: 'ease-in-out',
    fromScale: .2,
    midScale: 1.2,
    toScale: 2.2
};
const pulsateFwd = animation(pulsateBase, {
    params: Object.assign({}, pulsateParams)
});
const pulsateBck = animation(pulsateBase, {
    params: Object.assign(Object.assign({}, pulsateParams), { toScale: .9 })
});
const heartbeat = animation(heartbeatBase, {
    params: Object.assign({}, heartbeatParams)
});
const blink = animation(blinkBase, {
    params: Object.assign({}, blinkParams)
});

const base$1 = [
    style({
        opacity: `{{startOpacity}}`,
        transform: `scale{{direction}}({{fromScale}})`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{endOpacity}}`,
        transform: `scale{{direction}}({{toScale}})`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }))
];
const baseInParams$1 = {
    delay: '0s',
    direction: '',
    duration: '350ms',
    easing: EaseOut.quad,
    endOpacity: 1,
    fromScale: .5,
    startOpacity: 0,
    toScale: 1,
    xPos: '50%',
    yPos: '50%'
};
const baseOutParams$1 = Object.assign(Object.assign({}, baseInParams$1), { easing: EaseOut.sine, endOpacity: 0, fromScale: 1, startOpacity: 1, toScale: .5 });
const scaleInCenter = animation(base$1, { params: baseInParams$1 });
const scaleInBl = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '0', yPos: '100%' })
});
const scaleInVerCenter = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'Y', fromScale: .4 })
});
const scaleInTop = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '50%', yPos: '0' })
});
const scaleInLeft = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '0', yPos: '50%' })
});
const scaleInVerTop = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'Y', fromScale: .4, xPos: '100%', yPos: '0' })
});
const scaleInTr = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '100%', yPos: '0' })
});
const scaleInTl = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '0', yPos: '0' })
});
const scaleInVerBottom = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'Y', fromScale: .4, xPos: '0', yPos: '100%' })
});
const scaleInRight = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '100%', yPos: '50%' })
});
const scaleInHorCenter = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'X', fromScale: .4 })
});
const scaleInBr = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '100%', yPos: '100%' })
});
const scaleInHorLeft = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'X', fromScale: .4, xPos: '0', yPos: '0' })
});
const scaleInBottom = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '50%', yPos: '100%' })
});
const scaleInHorRight = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'X', fromScale: .4, xPos: '100%', yPos: '100%' })
});
const scaleOutCenter = animation(base$1, { params: baseOutParams$1 });
const scaleOutBl = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '0', yPos: '100%' })
});
const scaleOutBr = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '100%', yPos: '100%' })
});
const scaleOutVerCenter = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'Y', toScale: .3 })
});
const scaleOutVerTop = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'Y', toScale: .3, xPos: '100%', yPos: '0' })
});
const scaleOutVerBottom = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'Y', toScale: .3, xPos: '0', yPos: '100%' })
});
const scaleOutTop = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '50%', yPos: '0' })
});
const scaleOutLeft = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '0', yPos: '50%' })
});
const scaleOutTr = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '100%', yPos: '0' })
});
const scaleOutTl = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '0', yPos: '0' })
});
const scaleOutRight = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '100%', yPos: '50%' })
});
const scaleOutBottom = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '50%', yPos: '100%' })
});
const scaleOutHorCenter = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'X', toScale: .3 })
});
const scaleOutHorLeft = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'X', toScale: .3, xPos: '0', yPos: '0' })
});
const scaleOutHorRight = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'X', toScale: .3, xPos: '100%', yPos: '100%' })
});

const base$2 = [
    style({
        opacity: `{{startOpacity}}`,
        transform: `{{fromPosition}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{endOpacity}}`,
        transform: `{{toPosition}}`
    }))
];
const baseInParams$2 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseOut.quad,
    endOpacity: 1,
    fromPosition: 'translateY(-500px)',
    startOpacity: 0,
    toPosition: 'translateY(0)'
};
const baseOutParams$2 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseIn.quad,
    endOpacity: 0,
    fromPosition: 'translateY(0)',
    startOpacity: 1,
    toPosition: 'translateY(-500px)'
};
const slideInTop = animation(base$2, { params: baseInParams$2 });
const slideInLeft = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateX(-500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
const slideInRight = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateX(500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
const slideInBottom = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateY(500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
const slideInTr = animation(base$2, {
    params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(-500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
});
const slideInTl = animation(base$2, {
    params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(-500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
});
const slideInBr = animation(base$2, {
    params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
});
const slideInBl = animation(base$2, {
    params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
});
const slideOutTop = animation(base$2, { params: baseOutParams$2 });
const slideOutRight = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { toPosition: 'translateX(500px)' })
});
const slideOutBottom = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseIn.quad,
        endOpacity: 0,
        fromPosition: 'translateY(0)',
        startOpacity: 1,
        toPosition: 'translateY(500px)'
    }
});
const slideOutLeft = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { toPosition: 'translateX(-500px)' })
});
const slideOutTr = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(500px)' })
});
const slideOutBr = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(500px)' })
});
const slideOutBl = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(-500px)' })
});
const slideOutTl = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(-500px)' })
});

const swingBase = [
    style({
        opacity: `{{startOpacity}}`,
        transform: `rotate{{direction}}({{startAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{endOpacity}}`,
        transform: `rotate{{direction}}({{endAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }))
];
const swingParams = {
    delay: '0s',
    direction: 'X',
    duration: '.5s',
    easing: EaseOut.back,
    endAngle: 0,
    endOpacity: 1,
    startAngle: -100,
    startOpacity: 0,
    xPos: 'top',
    yPos: 'center'
};
const swingOutParams = Object.assign(Object.assign({}, swingParams), { duration: '.55s', easing: EaseIn.back, endAngle: 70, endOpacity: 0, startAngle: 0, startOpacity: 1 });
const swingInTopFwd = animation(swingBase, {
    params: Object.assign({}, swingParams)
});
const swingInRightFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', xPos: 'center', yPos: 'right' })
});
const swingInBottomFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { startAngle: 100, xPos: 'bottom' })
});
const swingInLeftFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', startAngle: 100, xPos: 'center', yPos: 'left' })
});
const swingInTopBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { duration: '.6s', startAngle: 70 })
});
const swingInRightBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', duration: '.6s', startAngle: 70, xPos: 'center', yPos: 'right' })
});
const swingInBottomBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { duration: '.6s', startAngle: -70, xPos: 'bottom' })
});
const swingInLeftBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', duration: '.6s', startAngle: -70, xPos: 'center', yPos: 'left' })
});
const swingOutTopFwd = animation(swingBase, {
    params: Object.assign({}, swingOutParams)
});
const swingOutRightFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', xPos: 'center', yPos: 'right' })
});
const swingOutBottomFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { endAngle: -70, xPos: 'bottom' })
});
const swingOutLefttFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', endAngle: -70, xPos: 'center', yPos: 'left' })
});
const swingOutTopBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { duration: '.45s', endAngle: -100 })
});
const swingOutRightBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', duration: '.45s', endAngle: -100, xPos: 'center', yPos: 'right' })
});
const swingOutBottomBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { duration: '.45s', endAngle: 100, xPos: 'bottom' })
});
const swingOutLeftBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', duration: '.45s', endAngle: 100, xPos: 'center', yPos: 'left' })
});

const base$3 = [
    style({
        opacity: `{{ startOpacity }}`,
        height: `{{ startHeight }}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{ endOpacity }}`,
        height: `{{ endHeight }}`
    }))
];
const baseParams$3 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseIn.quad,
    startOpacity: 0,
    endOpacity: 1,
    startHeight: '',
    endHeight: ''
};
const growVerIn = animation(base$3, {
    params: Object.assign(Object.assign({}, baseParams$3), { easing: EaseOut.quad, startOpacity: 0, endOpacity: 1, startHeight: '0px', endHeight: '*' })
});
const growVerOut = animation(base$3, {
    params: Object.assign(Object.assign({}, baseParams$3), { easing: EaseOut.quad, startOpacity: 1, endOpacity: 0, startHeight: '*', endHeight: '0px' })
});

/**
 * Common service to be injected between components where those implementing common
 * ToggleView interface can register and toggle directives can call their methods.
 * TODO: Track currently active? Events?
 */
class IgxNavigationService {
    constructor() {
        this.navs = {};
    }
    add(id, navItem) {
        this.navs[id] = navItem;
    }
    remove(id) {
        delete this.navs[id];
    }
    get(id) {
        if (id) {
            return this.navs[id];
        }
    }
    toggle(id, ...args) {
        if (this.navs[id]) {
            return this.navs[id].toggle(...args);
        }
    }
    open(id, ...args) {
        if (this.navs[id]) {
            return this.navs[id].open(...args);
        }
    }
    close(id, ...args) {
        if (this.navs[id]) {
            return this.navs[id].close(...args);
        }
    }
}
IgxNavigationService.ɵfac = function IgxNavigationService_Factory(t) { return new (t || IgxNavigationService)(); };
IgxNavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxNavigationService, factory: IgxNavigationService.ɵfac });
IgxNavigationService.ctorParameters = () => [];

/**
 * Directive that can toggle targets through provided NavigationService.
 *
 * Usage:
 * ```
 * <button igxNavToggle="ID"> Toggle </button>
 * ```
 * Where the `ID` matches the ID of compatible `IToggleView` component.
 */
class IgxNavigationToggleDirective {
    constructor(nav) {
        this.state = nav;
    }
    toggleNavigationDrawer() {
        this.state.toggle(this.target, true);
    }
}
IgxNavigationToggleDirective.ɵfac = function IgxNavigationToggleDirective_Factory(t) { return new (t || IgxNavigationToggleDirective)(ɵngcc0.ɵɵdirectiveInject(IgxNavigationService)); };
IgxNavigationToggleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxNavigationToggleDirective, selectors: [["", "igxNavToggle", ""]], hostBindings: function IgxNavigationToggleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxNavigationToggleDirective_click_HostBindingHandler() { return ctx.toggleNavigationDrawer(); });
    } }, inputs: { target: ["igxNavToggle", "target"] } });
IgxNavigationToggleDirective.ctorParameters = () => [
    { type: IgxNavigationService }
];
IgxNavigationToggleDirective.propDecorators = {
    target: [{ type: Input, args: ['igxNavToggle',] }],
    toggleNavigationDrawer: [{ type: HostListener, args: ['click',] }]
};
/**
 * Directive that can close targets through provided NavigationService.
 *
 * Usage:
 * ```
 * <button igxNavClose="ID"> Close </button>
 * ```
 * Where the `ID` matches the ID of compatible `IToggleView` component.
 */
class IgxNavigationCloseDirective {
    constructor(nav) {
        this.state = nav;
    }
    closeNavigationDrawer() {
        this.state.close(this.target, true);
    }
}
IgxNavigationCloseDirective.ɵfac = function IgxNavigationCloseDirective_Factory(t) { return new (t || IgxNavigationCloseDirective)(ɵngcc0.ɵɵdirectiveInject(IgxNavigationService)); };
IgxNavigationCloseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxNavigationCloseDirective, selectors: [["", "igxNavClose", ""]], hostBindings: function IgxNavigationCloseDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxNavigationCloseDirective_click_HostBindingHandler() { return ctx.closeNavigationDrawer(); });
    } }, inputs: { target: ["igxNavClose", "target"] } });
IgxNavigationCloseDirective.ctorParameters = () => [
    { type: IgxNavigationService }
];
IgxNavigationCloseDirective.propDecorators = {
    target: [{ type: Input, args: ['igxNavClose',] }],
    closeNavigationDrawer: [{ type: HostListener, args: ['click',] }]
};
/**
 * @hidden
 */
class IgxNavigationModule {
}
IgxNavigationModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxNavigationModule });
IgxNavigationModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxNavigationModule_Factory(t) { return new (t || IgxNavigationModule)(); }, providers: [IgxNavigationService] });

/* Copyright (c) 2014-2020 Denis Pushkarev
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE
 */
// Note: Originally copied from core-js-pure package and modified. (https://github.com/zloirock/core-js)
const queue = {};
let counter = 0;
let eventListenerAdded = false;
const run = function (id) {
    if (queue.hasOwnProperty(id)) {
        const fn = queue[id];
        delete queue[id];
        fn();
    }
};
const ɵ0 = run;
const listener = function (event) {
    run(event.data);
};
const ɵ1 = listener;
function setImmediate(cb) {
    if (window.setImmediate) {
        return window.setImmediate(cb);
    }
    if (!eventListenerAdded) {
        eventListenerAdded = true;
        window.addEventListener('message', listener, false);
    }
    const args = [];
    let i = 1;
    while (arguments.length > i) {
        args.push(arguments[i++]);
    }
    queue[++counter] = function () {
        (typeof cb === 'function' ? cb : Function(cb)).apply(undefined, args);
    };
    const windowLocation = window.location;
    window.postMessage(counter + '', windowLocation.protocol + '//' + windowLocation.host);
    return counter;
}
function clearImmediate(id) {
    if (window.clearImmediate) {
        return window.clearImmediate(id);
    }
    delete queue[id];
}

/**
 * @hidden
 */
function cloneArray(array, deep) {
    const arr = [];
    if (!array) {
        return arr;
    }
    let i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
}
/**
 * Doesn't clone leaf items
 * @hidden
 */
function cloneHierarchicalArray(array, childDataKey) {
    const result = [];
    if (!array) {
        return result;
    }
    for (const item of array) {
        const clonedItem = cloneValue(item);
        if (Array.isArray(item[childDataKey])) {
            clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
        }
        result.push(clonedItem);
    }
    return result;
}
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @param obj1 Object to merge into
 * @param obj2 Object to merge from
 * @returns Obj1 with merged cloned keys from Obj2
 * @hidden
 */
function mergeObjects(obj1, obj2) {
    return merge(obj1, obj2);
}
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @param value value to clone
 * @returns Deep copy of provided value
 * @hidden
 */
function cloneValue(value) {
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return [...value];
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        const result = {};
        for (const key of Object.keys(value)) {
            result[key] = cloneValue(value[key]);
        }
        return result;
    }
    return value;
}
/**
 * Checks if provided variable is Object
 * @param value Value to check
 * @returns true if provided variable is Object
 * @hidden
 */
function isObject(value) {
    return value && value.toString() === '[object Object]';
}
/**
 * Checks if provided variable is Date
 * @param value Value to check
 * @returns true if provided variable is Date
 * @hidden
 */
function isDate(value) {
    return value instanceof Date;
}
/**
 * Parse provided input to Date.
 * @param value input to parse
 * @returns Date if parse succeed or null
 * @hidden
 */
function parseDate(value) {
    // if value is Invalid Date return null
    if (isDate(value)) {
        return !isNaN(value.getTime()) ? value : null;
    }
    return value ? new Date(value) : null;
}
/**
 * Returns an array with unique dates only.
 * @param columnValues collection of date values (might be numbers or ISO 8601 strings)
 * @returns collection of unique dates.
 * @hidden
 */
function uniqueDates(columnValues) {
    return columnValues.reduce((a, c) => {
        if (!a.cache[c.label]) {
            a.result.push(c);
        }
        a.cache[c.label] = true;
        return a;
    }, { result: [], cache: {} }).result;
}
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * @param obj1
 * @param obj2
 * @returns: `boolean`
 * @hidden
 */
function isEqual(obj1, obj2) {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
 * ```
 */
function getNodeSizeViaRange(range, node) {
    let overflow = null;
    if (!isFirefox()) {
        overflow = node.style.overflow;
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = 'visible';
    }
    range.selectNodeContents(node);
    const width = range.getBoundingClientRect().width;
    if (!isFirefox()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
    }
    return width;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Canvas
 * ```typescript
 * let ctx = document.createElement('canvas').getContext('2d');
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
 * ```
 */
function getNodeSizeViaCanvas(canvas2dCtx, node) {
    const s = this.grid.document.defaultView.getComputedStyle(node);
    // need to set the font to get correct width
    canvas2dCtx.font = s.fontSize + ' ' + s.fontFamily;
    return canvas2dCtx.measureText(node.textContent).width;
}
/**
 * @hidden
 */
function isIE() {
    return navigator.appVersion.indexOf('Trident/') > 0;
}
/**
 * @hidden
 */
function isEdge() {
    const edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return edgeBrowser;
}
/**
 * @hidden
 */
function isFirefox() {
    const firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return firefoxBrowser;
}
/**
 * @hidden
 */
class PlatformUtil {
    constructor(platformId) {
        this.platformId = platformId;
        this.isBrowser = isPlatformBrowser(this.platformId);
        this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
    }
}
PlatformUtil.ɵfac = function PlatformUtil_Factory(t) { return new (t || PlatformUtil)(ɵngcc0.ɵɵinject(PLATFORM_ID)); };
PlatformUtil.ɵprov = ɵɵdefineInjectable({ factory: function PlatformUtil_Factory() { return new PlatformUtil(ɵɵinject(PLATFORM_ID)); }, token: PlatformUtil, providedIn: "root" });
PlatformUtil.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
/**
 * @hidden
 */
function isLeftClick(event) {
    return event.button === 0;
}
/** @hidden */
function isNavigationKey(key) {
    return [
        'down',
        'up',
        'left',
        'right',
        'arrowdown',
        'arrowup',
        'arrowleft',
        'arrowright',
        'home',
        'end',
        'space',
        'spacebar',
        ' '
    ].indexOf(key) !== -1;
}
/**
 * @hidden
 */
function flatten(arr) {
    let result = [];
    arr.forEach(el => {
        result.push(el);
        if (el.children) {
            const children = Array.isArray(el.children) ? el.children : el.children.toArray();
            result = result.concat(flatten(children));
        }
    });
    return result;
}
const HORIZONTAL_NAV_KEYS = new Set(['arrowleft', 'left', 'arrowright', 'right', 'home', 'end']);
const NAVIGATION_KEYS = new Set([
    'down',
    'up',
    'left',
    'right',
    'arrowdown',
    'arrowup',
    'arrowleft',
    'arrowright',
    'home',
    'end',
    'space',
    'spacebar',
    ' '
]);
const ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
const ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
const ROW_ADD_KEYS = new Set(['+', 'add', '≠', '±', '=']);
const SUPPORTED_KEYS = new Set([...Array.from(NAVIGATION_KEYS), ...Array.from(ROW_ADD_KEYS), 'enter', 'f2', 'escape', 'esc', 'pagedown', 'pageup']);
const HEADER_KEYS = new Set([...Array.from(NAVIGATION_KEYS), 'escape', 'esc', 'l',
    /** This symbol corresponds to the Alt + L combination under MAC. */
    '¬']);
/**
 * @hidden
 * @internal
 *
 * Creates a new ResizeObserver on `target` and returns it as an Observable.
 * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.
 * Related issue: https://github.com/angular/angular/issues/31712
 */
function resizeObservable(target) {
    return new Observable((observer) => {
        const instance = new ResizeObserver((entries) => {
            observer.next(entries);
        });
        instance.observe(target);
        const unsubscribe = () => instance.disconnect();
        return unsubscribe;
    });
}
/**
 * @hidden
 * @internal
 *
 * Compares two maps.
 */
function compareMaps(map1, map2) {
    if (!map2) {
        return !map1 ? true : false;
    }
    if (map1.size !== map2.size) {
        return false;
    }
    let match = true;
    const keys = Array.from(map2.keys());
    for (const key of keys) {
        if (map1.has(key)) {
            match = map1.get(key) === map2.get(key);
        }
        else {
            match = false;
        }
        if (!match) {
            break;
        }
    }
    return match;
}
/**
 *
 * Given a property access path in the format `x.y.z` resolves and returns
 * the value of the `z` property in the passed object.
 *
 * @hidden
 * @internal
 */
function resolveNestedPath(obj, path) {
    var _a;
    const parts = (_a = path === null || path === void 0 ? void 0 : path.split('.')) !== null && _a !== void 0 ? _a : [];
    let current = obj[parts.shift()];
    parts.forEach(prop => {
        if (current) {
            current = current[prop];
        }
    });
    return current;
}
/**
 *
 * Given a property access path in the format `x.y.z` and a value
 * this functions builds and returns an object following the access path.
 *
 * @example
 * ```typescript
 * console.log('x.y.z.', 42);
 * >> { x: { y: { z: 42 } } }
 * ```
 *
 * @hidden
 * @internal
 */
function reverseMapper(path, value) {
    var _a;
    const obj = {};
    const parts = (_a = path === null || path === void 0 ? void 0 : path.split('.')) !== null && _a !== void 0 ? _a : [];
    let _prop = parts.shift();
    let mapping;
    // Initial binding for first level bindings
    obj[_prop] = value;
    mapping = obj;
    parts.forEach(prop => {
        // Start building the hierarchy
        mapping[_prop] = {};
        // Go down a level
        mapping = mapping[_prop];
        // Bind the value and move the key
        mapping[prop] = value;
        _prop = prop;
    });
    return obj;
}
function yieldingLoop(count, chunkSize, callback, done) {
    let i = 0;
    const chunk = () => {
        const end = Math.min(i + chunkSize, count);
        for (; i < end; ++i) {
            callback(i);
        }
        if (i < count) {
            setImmediate(chunk);
        }
        else {
            done();
        }
    };
    chunk();
}
function mkenum(x) { return x; }

/**
 * Represents sorting expressions.
 */
var SortingDirection;
(function (SortingDirection) {
    SortingDirection[SortingDirection["None"] = 0] = "None";
    SortingDirection[SortingDirection["Asc"] = 1] = "Asc";
    SortingDirection[SortingDirection["Desc"] = 2] = "Desc";
})(SortingDirection || (SortingDirection = {}));

function isHierarchyMatch(h1, h2) {
    if (h1.length !== h2.length) {
        return false;
    }
    return h1.every((level, index) => {
        return level.fieldName === h2[index].fieldName && level.value === h2[index].value;
    });
}
function getHierarchy(gRow) {
    const hierarchy = [];
    if (gRow !== undefined && gRow.expression) {
        hierarchy.push({ fieldName: gRow.expression.fieldName, value: gRow.value });
        while (gRow.groupParent) {
            gRow = gRow.groupParent;
            hierarchy.unshift({ fieldName: gRow.expression.fieldName, value: gRow.value });
        }
    }
    return hierarchy;
}

const DATE_TYPE = 'date';
class DefaultSortingStrategy {
    constructor() { }
    static instance() {
        return this._instance || (this._instance = new this());
    }
    sort(data, fieldName, dir, ignoreCase, valueResolver, isDate) {
        const key = fieldName;
        const reverse = (dir === SortingDirection.Desc ? -1 : 1);
        const cmpFunc = (obj1, obj2) => {
            return this.compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver, isDate);
        };
        return this.arraySort(data, cmpFunc);
    }
    compareValues(a, b) {
        const an = (a === null || a === undefined);
        const bn = (b === null || b === undefined);
        if (an) {
            if (bn) {
                return 0;
            }
            return -1;
        }
        else if (bn) {
            return 1;
        }
        return a > b ? 1 : a < b ? -1 : 0;
    }
    compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver, isDate = false) {
        let a = valueResolver(obj1, key, isDate);
        let b = valueResolver(obj2, key, isDate);
        if (ignoreCase) {
            a = a && a.toLowerCase ? a.toLowerCase() : a;
            b = b && b.toLowerCase ? b.toLowerCase() : b;
        }
        return reverse * this.compareValues(a, b);
    }
    arraySort(data, compareFn) {
        return data.sort(compareFn);
    }
}
DefaultSortingStrategy._instance = null;
class NoopSortingStrategy {
    constructor() { }
    static instance() {
        return this._instance || (this._instance = new NoopSortingStrategy());
    }
    sort(data, expressions) {
        return data;
    }
}
NoopSortingStrategy._instance = null;
class IgxSorting {
    sort(data, expressions, grid) {
        return this.sortDataRecursive(data, expressions, 0, grid);
    }
    groupedRecordsByExpression(data, index, expression, isDate = false) {
        let i;
        let groupval;
        const res = [];
        const key = expression.fieldName;
        const len = data.length;
        res.push(data[index]);
        groupval = this.getFieldValue(data[index], key, isDate);
        index++;
        const comparer = expression.groupingComparer || DefaultSortingStrategy.instance().compareValues;
        for (i = index; i < len; i++) {
            if (comparer(this.getFieldValue(data[i], key, isDate), groupval) === 0) {
                res.push(data[i]);
            }
            else {
                break;
            }
        }
        return res;
    }
    sortDataRecursive(data, expressions, expressionIndex = 0, grid) {
        let i;
        let j;
        let expr;
        let gbData;
        let gbDataLen;
        const exprsLen = expressions.length;
        const dataLen = data.length;
        expressionIndex = expressionIndex || 0;
        if (expressionIndex >= exprsLen || dataLen <= 1) {
            return data;
        }
        expr = expressions[expressionIndex];
        if (!expr.strategy) {
            expr.strategy = DefaultSortingStrategy.instance();
        }
        const isDate = grid && grid.getColumnByName(expr.fieldName) ?
            grid.getColumnByName(expr.fieldName).dataType === DATE_TYPE : false;
        data = expr.strategy.sort(data, expr.fieldName, expr.dir, expr.ignoreCase, this.getFieldValue, isDate);
        if (expressionIndex === exprsLen - 1) {
            return data;
        }
        // in case of multiple sorting
        for (i = 0; i < dataLen; i++) {
            gbData = this.groupedRecordsByExpression(data, i, expr, isDate);
            gbDataLen = gbData.length;
            if (gbDataLen > 1) {
                gbData = this.sortDataRecursive(gbData, expressions, expressionIndex + 1, grid);
            }
            for (j = 0; j < gbDataLen; j++) {
                data[i + j] = gbData[j];
            }
            i += gbDataLen - 1;
        }
        return data;
    }
    groupDataRecursive(data, state, level, parent, metadata, grid = null, groupsRecords = [], fullResult = { data: [], metadata: [] }) {
        const expressions = state.expressions;
        const expansion = state.expansion;
        let i = 0;
        let result = [];
        while (i < data.length) {
            const column = grid ? grid.getColumnByName(expressions[level].fieldName) : null;
            const isDate = (column === null || column === void 0 ? void 0 : column.dataType) === DATE_TYPE;
            const group = this.groupedRecordsByExpression(data, i, expressions[level], isDate);
            const groupRow = {
                expression: expressions[level],
                level,
                records: cloneArray(group),
                value: this.getFieldValue(group[0], expressions[level].fieldName, isDate),
                groupParent: parent,
                groups: [],
                height: grid ? grid.renderedRowHeight : null,
                column: column
            };
            if (parent) {
                parent.groups.push(groupRow);
            }
            else {
                groupsRecords.push(groupRow);
            }
            const hierarchy = getHierarchy(groupRow);
            const expandState = expansion.find((s) => isHierarchyMatch(s.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy));
            const expanded = expandState ? expandState.expanded : state.defaultExpanded;
            let recursiveResult;
            result.push(groupRow);
            metadata.push(null);
            fullResult.data.push(groupRow);
            fullResult.metadata.push(null);
            if (level < expressions.length - 1) {
                recursiveResult = this.groupDataRecursive(group, state, level + 1, groupRow, expanded ? metadata : [], grid, groupsRecords, fullResult);
                if (expanded) {
                    result = result.concat(recursiveResult);
                }
            }
            else {
                for (const groupItem of group) {
                    fullResult.metadata.push(groupRow);
                    fullResult.data.push(groupItem);
                }
                if (expanded) {
                    metadata.push(...fullResult.metadata.slice(fullResult.metadata.length - group.length));
                    result.push(...fullResult.data.slice(fullResult.data.length - group.length));
                }
            }
            i += group.length;
        }
        return result;
    }
    getFieldValue(obj, key, isDate = false) {
        return isDate ? parseDate(resolveNestedPath(obj, key)) : resolveNestedPath(obj, key);
    }
}
class IgxDataRecordSorting extends IgxSorting {
    getFieldValue(obj, key, isDate = false) {
        return isDate ? parseDate(resolveNestedPath(obj.data, key)) : resolveNestedPath(obj.data, key);
    }
}

class IgxGrouping extends IgxSorting {
    groupBy(data, state, grid, groupsRecords, fullResult = { data: [], metadata: [] }) {
        const metadata = [];
        const grouping = this.groupDataRecursive(data, state, 0, null, metadata, grid, groupsRecords, fullResult);
        return {
            data: grouping,
            metadata: metadata
        };
    }
}

var PagingError;
(function (PagingError) {
    PagingError[PagingError["None"] = 0] = "None";
    PagingError[PagingError["IncorrectPageIndex"] = 1] = "IncorrectPageIndex";
    PagingError[PagingError["IncorrectRecordsPerPage"] = 2] = "IncorrectRecordsPerPage";
})(PagingError || (PagingError = {}));

var FilteringLogic;
(function (FilteringLogic) {
    FilteringLogic[FilteringLogic["And"] = 0] = "And";
    FilteringLogic[FilteringLogic["Or"] = 1] = "Or";
})(FilteringLogic || (FilteringLogic = {}));

var FilteringExpressionsTreeType;
(function (FilteringExpressionsTreeType) {
    FilteringExpressionsTreeType[FilteringExpressionsTreeType["Regular"] = 0] = "Regular";
    FilteringExpressionsTreeType[FilteringExpressionsTreeType["Advanced"] = 1] = "Advanced";
})(FilteringExpressionsTreeType || (FilteringExpressionsTreeType = {}));
class FilteringExpressionsTree {
    constructor(operator, fieldName) {
        /**
         * Sets/gets the filtering operands.
         * ```typescript
         * const gridExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
         * const expression = [
         * {
         *   condition: IgxStringFilteringOperand.instance().condition('contains'),
         *   fieldName: 'Column Field',
         *   searchVal: 'Value',
         *   ignoreCase: false
         * }];
         * gridExpressionsTree.filteringOperands.push(expression);
         * this.grid.filteringExpressionsTree = gridExpressionsTree;
         * ```
         * ```typescript
         * let filteringOperands = gridExpressionsTree.filteringOperands;
         * ```
         * @memberof FilteringExpressionsTree
         */
        this.filteringOperands = [];
        this.operator = operator;
        this.fieldName = fieldName;
    }
    /**
     * Checks if filtering expressions tree is empty.
     * @param expressionTree filtering expressions tree.
     */
    static empty(expressionTree) {
        return !expressionTree || !expressionTree.filteringOperands || !expressionTree.filteringOperands.length;
    }
    /**
     * Returns the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpression = gridExpressionTree.find('Column Field');
     * ```
     * @memberof FilteringExpressionsTree
     */
    find(fieldName) {
        const index = this.findIndex(fieldName);
        if (index > -1) {
            return this.filteringOperands[index];
        }
        return null;
    }
    /**
     * Returns the index of the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpressionIndex = gridExpressionTree.findIndex('Column Field');
     * ```
     * @memberof FilteringExpressionsTree
     */
    findIndex(fieldName) {
        let expr;
        for (let i = 0; i < this.filteringOperands.length; i++) {
            expr = this.filteringOperands[i];
            if (expr instanceof FilteringExpressionsTree) {
                if (this.isFilteringExpressionsTreeForColumn(expr, fieldName)) {
                    return i;
                }
            }
            else {
                if (expr.fieldName === fieldName) {
                    return i;
                }
            }
        }
        return -1;
    }
    isFilteringExpressionsTreeForColumn(expressionsTree, fieldName) {
        if (expressionsTree.fieldName === fieldName) {
            return true;
        }
        let expr;
        for (let i = 0; i < expressionsTree.filteringOperands.length; i++) {
            expr = expressionsTree.filteringOperands[i];
            if ((expr instanceof FilteringExpressionsTree)) {
                return this.isFilteringExpressionsTreeForColumn(expr, fieldName);
            }
            else {
                return expr.fieldName === fieldName;
            }
        }
        return false;
    }
}

const DateType = 'date';
class NoopFilteringStrategy {
    constructor() { }
    static instance() {
        return this._instance || (this._instance = new NoopFilteringStrategy());
    }
    filter(data, expressionsTree, advancedExpressionsTree) {
        return data;
    }
}
NoopFilteringStrategy._instance = null;
class BaseFilteringStrategy {
    findMatchByExpression(rec, expr, isDate) {
        const cond = expr.condition;
        const val = this.getFieldValue(rec, expr.fieldName, isDate);
        return cond.logic(val, expr.searchVal, expr.ignoreCase);
    }
    matchRecord(rec, expressions, grid) {
        if (expressions) {
            if (expressions instanceof FilteringExpressionsTree) {
                const expressionsTree = expressions;
                const operator = expressionsTree.operator;
                let matchOperand, operand;
                if (expressionsTree.filteringOperands && expressionsTree.filteringOperands.length) {
                    for (let i = 0; i < expressionsTree.filteringOperands.length; i++) {
                        operand = expressionsTree.filteringOperands[i];
                        matchOperand = this.matchRecord(rec, operand, grid);
                        // Return false if at least one operand does not match and the filtering logic is And
                        if (!matchOperand && operator === FilteringLogic.And) {
                            return false;
                        }
                        // Return true if at least one operand matches and the filtering logic is Or
                        if (matchOperand && operator === FilteringLogic.Or) {
                            return true;
                        }
                    }
                    return matchOperand;
                }
                return true;
            }
            else {
                const expression = expressions;
                const isDate = grid && grid.getColumnByName(expression.fieldName) ?
                    grid.getColumnByName(expression.fieldName).dataType === DateType : false;
                return this.findMatchByExpression(rec, expression, isDate);
            }
        }
        return true;
    }
}
class FilteringStrategy extends BaseFilteringStrategy {
    constructor() { super(); }
    static instance() {
        return this._instace || (this._instace = new this());
    }
    filter(data, expressionsTree, advancedExpressionsTree, grid) {
        let i;
        let rec;
        const len = data.length;
        const res = [];
        if ((FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree)) || !len) {
            return data;
        }
        for (i = 0; i < len; i++) {
            rec = data[i];
            if (this.matchRecord(rec, expressionsTree, grid) && this.matchRecord(rec, advancedExpressionsTree, grid)) {
                res.push(rec);
            }
        }
        return res;
    }
    getFieldValue(rec, fieldName, isDate = false) {
        let value = resolveNestedPath(rec, fieldName);
        value = value && isDate ? parseDate(value) : value;
        return value;
    }
}
FilteringStrategy._instace = null;

var TransactionType;
(function (TransactionType) {
    TransactionType["ADD"] = "add";
    TransactionType["DELETE"] = "delete";
    TransactionType["UPDATE"] = "update";
})(TransactionType || (TransactionType = {}));
var TransactionEventOrigin;
(function (TransactionEventOrigin) {
    TransactionEventOrigin["UNDO"] = "undo";
    TransactionEventOrigin["REDO"] = "redo";
    TransactionEventOrigin["CLEAR"] = "clear";
    TransactionEventOrigin["ADD"] = "add";
    TransactionEventOrigin["END"] = "endPending";
})(TransactionEventOrigin || (TransactionEventOrigin = {}));

/**
 * @hidden
 */
const DataType = mkenum({
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Date: 'date'
});
/**
 * @hidden
 */
class DataUtil {
    static sort(data, expressions, sorting = new IgxSorting(), grid) {
        return sorting.sort(data, expressions, grid);
    }
    static treeGridSort(hierarchicalData, expressions, sorting = new IgxDataRecordSorting(), parent, grid) {
        let res = [];
        hierarchicalData.forEach((hr) => {
            const rec = DataUtil.cloneTreeGridRecord(hr);
            rec.parent = parent;
            if (rec.children) {
                rec.children = DataUtil.treeGridSort(rec.children, expressions, sorting, rec, grid);
            }
            res.push(rec);
        });
        res = DataUtil.sort(res, expressions, sorting, grid);
        return res;
    }
    static cloneTreeGridRecord(hierarchicalRecord) {
        const rec = {
            rowID: hierarchicalRecord.rowID,
            data: hierarchicalRecord.data,
            children: hierarchicalRecord.children,
            isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
            level: hierarchicalRecord.level,
            expanded: hierarchicalRecord.expanded
        };
        return rec;
    }
    static group(data, state, grid = null, groupsRecords = [], fullResult = { data: [], metadata: [] }) {
        const grouping = new IgxGrouping();
        groupsRecords.splice(0, groupsRecords.length);
        return grouping.groupBy(data, state, grid, groupsRecords, fullResult);
    }
    static page(data, state, dataLength) {
        if (!state) {
            return data;
        }
        const len = dataLength !== undefined ? dataLength : data.length;
        const index = state.index;
        const res = [];
        const recordsPerPage = dataLength !== undefined && state.recordsPerPage > dataLength ? dataLength : state.recordsPerPage;
        state.metadata = {
            countPages: 0,
            countRecords: len,
            error: PagingError.None
        };
        if (index < 0 || isNaN(index)) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
            state.metadata.error = PagingError.IncorrectRecordsPerPage;
            return res;
        }
        state.metadata.countPages = Math.ceil(len / recordsPerPage);
        if (!len) {
            return data;
        }
        if (index >= state.metadata.countPages) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
    }
    static filter(data, state, grid) {
        if (!state.strategy) {
            state.strategy = new FilteringStrategy();
        }
        return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree, grid);
    }
    static correctPagingState(state, length) {
        const maxPage = Math.ceil(length / state.recordsPerPage) - 1;
        if (!isNaN(maxPage) && state.index > maxPage) {
            state.index = maxPage;
        }
    }
    static getHierarchy(gRow) {
        return getHierarchy(gRow);
    }
    static isHierarchyMatch(h1, h2) {
        return isHierarchyMatch(h1, h2);
    }
    /**
     * Merges all changes from provided transactions into provided data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    static mergeTransactions(data, transactions, primaryKey, deleteRows = false) {
        data.forEach((item, index) => {
            const rowId = primaryKey ? item[primaryKey] : item;
            const transaction = transactions.find(t => t.id === rowId);
            if (transaction && transaction.type === TransactionType.UPDATE) {
                data[index] = transaction.newValue;
            }
        });
        if (deleteRows) {
            transactions
                .filter(t => t.type === TransactionType.DELETE)
                .forEach(t => {
                const index = primaryKey ? data.findIndex(d => d[primaryKey] === t.id) : data.findIndex(d => d === t.id);
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
            });
        }
        data.push(...transactions
            .filter(t => t.type === TransactionType.ADD)
            .map(t => t.newValue));
        return data;
    }
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param childDataKey Data key of child collections
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    static mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey, deleteRows = false) {
        for (const transaction of transactions) {
            if (transaction.path) {
                const parent = this.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                let collection = parent ? parent[childDataKey] : data;
                switch (transaction.type) {
                    case TransactionType.ADD:
                        //  if there is no parent this is ADD row at root level
                        if (parent && !parent[childDataKey]) {
                            parent[childDataKey] = collection = [];
                        }
                        collection.push(transaction.newValue);
                        break;
                    case TransactionType.UPDATE:
                        const updateIndex = collection.findIndex(x => x[primaryKey] === transaction.id);
                        if (updateIndex !== -1) {
                            collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                        }
                        break;
                    case TransactionType.DELETE:
                        if (deleteRows) {
                            const deleteIndex = collection.findIndex(r => r[primaryKey] === transaction.id);
                            if (deleteIndex !== -1) {
                                collection.splice(deleteIndex, 1);
                            }
                        }
                        break;
                }
            }
            else {
                //  if there is no path this is ADD row in root. Push the newValue to data
                data.push(transaction.newValue);
            }
        }
        return data;
    }
    static parseValue(dataType, value) {
        if (dataType === DataType.Number) {
            value = parseFloat(value);
        }
        return value;
    }
    static findParentFromPath(data, primaryKey, childDataKey, path) {
        let collection = data;
        let result;
        for (const id of path) {
            result = collection && collection.find(x => x[primaryKey] === id);
            if (!result) {
                break;
            }
            collection = result[childDataKey];
        }
        return result;
    }
}

/**
 * @hidden
 */
class ExportUtilities {
    static getKeysFromData(data) {
        const length = data.length;
        if (length === 0) {
            return [];
        }
        const dataEntry = data[0];
        const dataEntryMiddle = data[Math.floor(length / 2)];
        const dataEntryLast = data[length - 1];
        const keys1 = Object.keys(dataEntry);
        const keys2 = Object.keys(dataEntryMiddle);
        const keys3 = Object.keys(dataEntryLast);
        const keys = new Set(keys1.concat(keys2).concat(keys3));
        return !ExportUtilities.isSpecialData(data) ? Array.from(keys) : ['Column 1'];
    }
    static saveBlobToFile(blob, fileName) {
        const a = document.createElement('a');
        if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(blob, fileName);
        }
        else {
            const url = window.URL.createObjectURL(blob);
            a.download = fileName;
            a.href = url;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
    }
    static stringToArrayBuffer(s) {
        const buf = new ArrayBuffer(s.length);
        const view = new Uint8Array(buf);
        for (let i = 0; i !== s.length; ++i) {
            /* tslint:disable no-bitwise */
            view[i] = s.charCodeAt(i) & 0xFF;
            /* tslint:enable no-bitwise */
        }
        return buf;
    }
    static isSpecialData(data) {
        const dataEntry = data[0];
        return (typeof dataEntry === 'string' ||
            typeof dataEntry === 'number' ||
            dataEntry instanceof Date);
    }
    static hasValue(value) {
        return value !== undefined && value !== null;
    }
    static isNullOrWhitespaces(value) {
        return value === undefined || value === null || !value.trim();
    }
}

/**
 * @hidden
 */
class GridBaseAPIService {
    constructor() {
        this.destroyMap = new Map();
    }
    get_column_by_name(name) {
        return this.grid.columnList.find((col) => col.field === name);
    }
    get_summary_data() {
        const grid = this.grid;
        let data = grid.filteredData;
        if (data && grid.hasPinnedRecords) {
            data = grid._filteredUnpinnedData;
        }
        if (!data) {
            if (grid.transactions.enabled) {
                data = DataUtil.mergeTransactions(cloneArray(grid.data), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
                const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === TransactionType.DELETE).map(t => t.id);
                deletedRows.forEach(rowID => {
                    const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
                    const index = tempData.indexOf(rowID);
                    if (index !== -1) {
                        data.splice(index, 1);
                    }
                });
            }
            else {
                data = grid.data;
            }
        }
        return data;
    }
    /**
     * @hidden
     * @internal
     */
    getRowData(rowID) {
        const data = this.get_all_data(this.grid.transactions.enabled);
        const index = this.get_row_index_in_data(rowID, data);
        return data[index];
    }
    get_row_index_in_data(rowID, dataCollection) {
        const grid = this.grid;
        if (!grid) {
            return -1;
        }
        const data = dataCollection !== null && dataCollection !== void 0 ? dataCollection : this.get_all_data(grid.transactions.enabled);
        return grid.primaryKey ? data.findIndex(record => record.recordRef ? record.recordRef[grid.primaryKey] === rowID
            : record[grid.primaryKey] === rowID) : data.indexOf(rowID);
    }
    get_row_by_key(rowSelector) {
        if (!this.grid) {
            return null;
        }
        const primaryKey = this.grid.primaryKey;
        if (primaryKey !== undefined && primaryKey !== null) {
            return this.grid.dataRowList.find((row) => row.rowData[primaryKey] === rowSelector);
        }
        else {
            return this.grid.dataRowList.find((row) => row.rowData === rowSelector);
        }
    }
    get_row_by_index(rowIndex) {
        return this.grid.rowList.find((row) => row.index === rowIndex);
    }
    get_cell_by_key(rowSelector, field) {
        const row = this.get_row_by_key(rowSelector);
        if (row && row.cells) {
            return row.cells.find((cell) => cell.column.field === field);
        }
    }
    get_cell_by_index(rowIndex, columnIndex) {
        const row = this.get_row_by_index(rowIndex);
        if (row && row.cells) {
            return row.cells.find((cell) => cell.columnIndex === columnIndex);
        }
    }
    get_cell_by_visible_index(rowIndex, columnIndex) {
        const row = this.get_row_by_index(rowIndex);
        if (row && row.cells) {
            return row.cells.find((cell) => cell.visibleColumnIndex === columnIndex);
        }
    }
    submit_value() {
        const cell = this.grid.crudService.cell;
        if (cell) {
            const args = this.update_cell(cell, cell.editValue);
            this.grid.crudService.cellEditingBlocked = args.cancel;
            if (args.cancel) {
                return args.cancel;
            }
            this.grid.crudService.exitCellEdit();
        }
    }
    submit_add_value() {
        const cell = this.grid.crudService.cell;
        if (cell) {
            const args = this.update_add_cell(cell, cell.editValue);
            if (args.cancel) {
                this.grid.endAddRow();
                return args.cancel;
            }
            return this.grid.crudService.exitCellEdit();
        }
    }
    update_add_cell(cell, value) {
        cell.editValue = value;
        const args = cell.createEditEventArgs();
        if (isEqual(args.oldValue, args.newValue)) {
            return args;
        }
        this.grid.cellEdit.emit(args);
        this.grid.crudService.cellEditingBlocked = args.cancel;
        if (args.cancel) {
            return args;
        }
        const data = cell.rowData;
        mergeObjects(data, reverseMapper(cell.column.field, args.newValue));
        this.grid.crudService.row.data = data;
        const doneArgs = cell.createDoneEditEventArgs(args.newValue);
        doneArgs.rowData = data;
        this.grid.cellEditDone.emit(doneArgs);
        return args;
    }
    update_cell(cell, value) {
        cell.editValue = value;
        const args = cell.createEditEventArgs();
        if (isEqual(args.oldValue, args.newValue)) {
            return args;
        }
        this.grid.cellEdit.emit(args);
        this.grid.crudService.cellEditingBlocked = args.cancel;
        if (args.cancel) {
            return args;
        }
        this.grid.summaryService.clearSummaryCache(args);
        const data = this.getRowData(cell.id.rowID);
        this.updateData(this.grid, cell.id.rowID, data, cell.rowData, reverseMapper(cell.column.field, args.newValue));
        if (this.grid.primaryKey === cell.column.field) {
            if (this.grid.selectionService.isRowSelected(cell.id.rowID)) {
                this.grid.selectionService.deselectRow(cell.id.rowID);
                this.grid.selectionService.selectRowById(args.newValue);
            }
            if (this.grid.hasSummarizedColumns) {
                this.grid.summaryService.removeSummaries(cell.id.rowID);
            }
        }
        if (!this.grid.rowEditable || !this.grid.crudService.row ||
            this.grid.crudService.row.id !== cell.id.rowID || !this.grid.transactions.enabled) {
            this.grid.summaryService.clearSummaryCache(args);
            this.grid._pipeTrigger++;
        }
        const doneArgs = cell.createDoneEditEventArgs(args.newValue);
        this.grid.cellEditDone.emit(doneArgs);
        return args;
    }
    /**
     * Updates related row of provided grid's data source with provided new row value
     * @param grid Grid to update data for
     * @param rowID ID of the row to update
     * @param rowValueInDataSource Initial value of the row as it is in data source
     * @param rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param rowNewValue New value of the row
     */
    updateData(grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
        if (grid.transactions.enabled) {
            const transaction = {
                id: rowID,
                type: TransactionType.UPDATE,
                newValue: rowNewValue
            };
            grid.transactions.add(transaction, rowCurrentValue);
        }
        else {
            mergeObjects(rowValueInDataSource, rowNewValue);
        }
    }
    _update_row(row, value) {
        const grid = this.grid;
        const rowInEditMode = grid.crudService.row;
        row.newData = value !== null && value !== void 0 ? value : rowInEditMode.transactionState;
        if (rowInEditMode && row.id === rowInEditMode.id) {
            row.data = Object.assign(Object.assign({}, row.data), rowInEditMode.transactionState);
            // TODO: Workaround for updating a row in edit mode through the API
        }
        else if (this.grid.transactions.enabled) {
            const state = grid.transactions.getState(row.id);
            row.data = state ? Object.assign({}, row.data, state.value) : row.data;
        }
    }
    update_row(row, value) {
        const grid = this.grid;
        const selected = grid.selectionService.isRowSelected(row.id);
        const rowInEditMode = grid.crudService.row;
        const data = this.get_all_data(grid.transactions.enabled);
        const index = this.get_row_index_in_data(row.id, data);
        const hasSummarized = grid.hasSummarizedColumns;
        this._update_row(row, value);
        const args = row.createEditEventArgs();
        // If no valid row is found
        if (index === -1) {
            return args;
        }
        grid.rowEdit.emit(args);
        if (args.cancel) {
            return args;
        }
        const cachedRowData = Object.assign({}, args.oldValue);
        if (rowInEditMode) {
            const hasChanges = grid.transactions.getState(args.rowID, true);
            grid.transactions.endPending(false);
            if (!hasChanges) {
                return args;
            }
        }
        if (!args.newValue) {
            return args;
        }
        if (hasSummarized) {
            grid.summaryService.removeSummaries(args.rowID);
        }
        this.updateData(grid, row.id, data[index], args.oldValue, args.newValue);
        const newId = grid.primaryKey ? args.newValue[grid.primaryKey] : args.newValue;
        if (selected) {
            grid.selectionService.deselectRow(row.id);
            grid.selectionService.selectRowById(newId);
        }
        // make sure selection is handled prior to updating the row.id
        row.id = newId;
        if (hasSummarized) {
            grid.summaryService.removeSummaries(newId);
        }
        grid._pipeTrigger++;
        const doneArgs = row.createDoneEditEventArgs(cachedRowData);
        grid.rowEditDone.emit(doneArgs);
        return args;
    }
    update_row_in_array(value, rowID, index) {
        const grid = this.grid;
        grid.data[index] = value;
    }
    sort(expression) {
        if (expression.dir === SortingDirection.None) {
            this.remove_grouping_expression(expression.fieldName);
        }
        const sortingState = cloneArray(this.grid.sortingExpressions);
        this.prepare_sorting_expression([sortingState], expression);
        this.grid.sortingExpressions = sortingState;
    }
    sort_multiple(expressions) {
        const sortingState = cloneArray(this.grid.sortingExpressions);
        for (const each of expressions) {
            if (each.dir === SortingDirection.None) {
                this.remove_grouping_expression(each.fieldName);
            }
            this.prepare_sorting_expression([sortingState], each);
        }
        this.grid.sortingExpressions = sortingState;
    }
    filter(fieldName, term, conditionOrExpressionsTree, ignoreCase) {
        const grid = this.grid;
        const filteringTree = grid.filteringExpressionsTree;
        this.grid.endEdit(false);
        if (grid.paging) {
            grid.page = 0;
        }
        const fieldFilterIndex = filteringTree.findIndex(fieldName);
        if (fieldFilterIndex > -1) {
            filteringTree.filteringOperands.splice(fieldFilterIndex, 1);
        }
        this.prepare_filtering_expression(filteringTree, fieldName, term, conditionOrExpressionsTree, ignoreCase, fieldFilterIndex);
        grid.filteringExpressionsTree = filteringTree;
    }
    filter_global(term, condition, ignoreCase) {
        if (!condition) {
            return;
        }
        const grid = this.grid;
        const filteringTree = grid.filteringExpressionsTree;
        grid.endEdit(false);
        if (grid.paging) {
            grid.page = 0;
        }
        filteringTree.filteringOperands = [];
        for (const column of grid.columns) {
            this.prepare_filtering_expression(filteringTree, column.field, term, condition, ignoreCase || column.filteringIgnoreCase);
        }
        grid.filteringExpressionsTree = filteringTree;
    }
    clear_filter(fieldName) {
        const grid = this.grid;
        grid.endEdit(false);
        const filteringState = grid.filteringExpressionsTree;
        const index = filteringState.findIndex(fieldName);
        if (index > -1) {
            filteringState.filteringOperands.splice(index, 1);
        }
        else if (!fieldName) {
            filteringState.filteringOperands = [];
        }
        grid.filteringExpressionsTree = filteringState;
    }
    clear_sort(fieldName) {
        const sortingState = this.grid.sortingExpressions;
        const index = sortingState.findIndex((expr) => expr.fieldName === fieldName);
        if (index > -1) {
            sortingState.splice(index, 1);
            this.grid.sortingExpressions = sortingState;
        }
    }
    prepare_filtering_expression(filteringState, fieldName, searchVal, conditionOrExpressionsTree, ignoreCase, insertAtIndex = -1) {
        let newExpressionsTree;
        const oldExpressionsTreeIndex = filteringState.findIndex(fieldName);
        const expressionsTree = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
            conditionOrExpressionsTree : null;
        const condition = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
            null : conditionOrExpressionsTree;
        const newExpression = { fieldName, searchVal, condition, ignoreCase };
        if (oldExpressionsTreeIndex === -1) {
            // no expressions tree found for this field
            if (expressionsTree) {
                if (insertAtIndex > -1) {
                    filteringState.filteringOperands.splice(insertAtIndex, 0, expressionsTree);
                }
                else {
                    filteringState.filteringOperands.push(expressionsTree);
                }
            }
            else if (condition) {
                // create expressions tree for this field and add the new expression to it
                newExpressionsTree = new FilteringExpressionsTree(filteringState.operator, fieldName);
                newExpressionsTree.filteringOperands.push(newExpression);
                filteringState.filteringOperands.push(newExpressionsTree);
            }
        }
    }
    prepare_sorting_expression(stateCollections, expression) {
        if (expression.dir === SortingDirection.None) {
            stateCollections.forEach(state => {
                state.splice(state.findIndex((expr) => expr.fieldName === expression.fieldName), 1);
            });
            return;
        }
        /**
         * We need to make sure the states in each collection with same fields point to the same object reference.
         * If the different state collections provided have different sizes we need to get the largest one.
         * That way we can get the state reference from the largest one that has the same fieldName as the expression to prepare.
         */
        let maxCollection = stateCollections[0];
        for (let i = 1; i < stateCollections.length; i++) {
            if (maxCollection.length < stateCollections[i].length) {
                maxCollection = stateCollections[i];
            }
        }
        const maxExpr = maxCollection.find((expr) => expr.fieldName === expression.fieldName);
        stateCollections.forEach(collection => {
            const myExpr = collection.find((expr) => expr.fieldName === expression.fieldName);
            if (!myExpr && !maxExpr) {
                // Expression with this fieldName is missing from the current and the max collection.
                collection.push(expression);
            }
            else if (!myExpr && maxExpr) {
                // Expression with this fieldName is missing from the current and but the max collection has.
                collection.push(maxExpr);
                Object.assign(maxExpr, expression);
            }
            else {
                // The current collection has the expression so just update it.
                Object.assign(myExpr, expression);
            }
        });
    }
    remove_grouping_expression(fieldName) {
    }
    clear_groupby(name) {
    }
    should_apply_number_style(column) {
        return column.dataType === DataType.Number;
    }
    get_data() {
        const grid = this.grid;
        const data = grid.data ? grid.data : [];
        return data;
    }
    get_all_data(includeTransactions = false) {
        const grid = this.grid;
        let data = grid && grid.data ? grid.data : [];
        data = includeTransactions ? grid.dataWithAddedInTransactionRows : data;
        return data;
    }
    get_filtered_data() {
        return this.grid.filteredData;
    }
    getSortStrategyPerColumn(fieldName) {
        return this.get_column_by_name(fieldName) ?
            this.get_column_by_name(fieldName).sortStrategy : undefined;
    }
    addRowToData(rowData, parentRowID) {
        // Add row goes to transactions and if rowEditable is properly implemented, added rows will go to pending transactions
        // If there is a row in edit - > commit and close
        const grid = this.grid;
        if (grid.transactions.enabled) {
            const transactionId = grid.primaryKey ? rowData[grid.primaryKey] : rowData;
            const transaction = { id: transactionId, type: TransactionType.ADD, newValue: rowData };
            grid.transactions.add(transaction);
        }
        else {
            grid.data.push(rowData);
        }
    }
    deleteRowFromData(rowID, index) {
        //  if there is a row (index !== 0) delete it
        //  if there is a row in ADD or UPDATE state change it's state to DELETE
        const grid = this.grid;
        if (index !== -1) {
            if (grid.transactions.enabled) {
                const transaction = { id: rowID, type: TransactionType.DELETE, newValue: null };
                grid.transactions.add(transaction, grid.data[index]);
            }
            else {
                grid.data.splice(index, 1);
            }
        }
        else {
            const state = grid.transactions.getState(rowID);
            grid.transactions.add({ id: rowID, type: TransactionType.DELETE, newValue: null }, state && state.recordRef);
        }
    }
    deleteRowById(rowId) {
        let index;
        const grid = this.grid;
        const data = this.get_all_data();
        if (grid.primaryKey) {
            index = data.map((record) => record[grid.primaryKey]).indexOf(rowId);
        }
        else {
            index = data.indexOf(rowId);
        }
        const state = grid.transactions.getState(rowId);
        const hasRowInNonDeletedState = state && state.type !== TransactionType.DELETE;
        //  if there is a row (index !== -1) and the we have cell in edit mode on same row exit edit mode
        //  if there is no row (index === -1), but there is a row in ADD or UPDATE state do as above
        //  Otherwise just exit - there is nothing to delete
        if (index !== -1 || hasRowInNonDeletedState) {
            // Always exit edit when row is deleted
            grid.endEdit(true);
        }
        else {
            return;
        }
        //  TODO: should we emit this when cascadeOnDelete is true for each row?!?!
        grid.onRowDeleted.emit({ data: data[index] });
        this.deleteRowFromData(rowId, index);
        grid.selectionService.isRowSelected(rowId) ? grid.selectionService.deselectRow(rowId) : grid.selectionService.clearHeaderCBState();
        grid._pipeTrigger++;
        grid.notifyChanges();
        // Data needs to be recalculated if transactions are in place
        // If no transactions, `data` will be a reference to the grid getter, otherwise it will be stale
        const dataAfterDelete = grid.transactions.enabled ? grid.dataWithAddedInTransactionRows : data;
        grid.refreshSearch();
        if (dataAfterDelete.length % grid.perPage === 0 && dataAfterDelete.length / grid.perPage - 1 < grid.page && grid.page !== 0) {
            grid.page--;
        }
    }
    get_row_id(rowData) {
        return this.grid.primaryKey ? rowData[this.grid.primaryKey] : rowData;
    }
    row_deleted_transaction(rowID) {
        const grid = this.grid;
        if (!grid) {
            return false;
        }
        if (!grid.transactions.enabled) {
            return false;
        }
        const state = grid.transactions.getState(rowID);
        if (state) {
            return state.type === TransactionType.DELETE;
        }
        return false;
    }
    get_row_expansion_state(record) {
        const grid = this.grid;
        const states = grid.expansionStates;
        const rowID = grid.primaryKey ? record[grid.primaryKey] : record;
        const expanded = states.get(rowID);
        if (expanded !== undefined) {
            return expanded;
        }
        else {
            return grid.getDefaultExpandState(record);
        }
    }
    set_row_expansion_state(rowID, expanded, event) {
        const grid = this.grid;
        const expandedStates = grid.expansionStates;
        if (!this.allow_expansion_state_change(rowID, expanded)) {
            return;
        }
        const args = {
            rowID: rowID,
            expanded: expanded,
            event: event,
            cancel: false
        };
        grid.onRowToggle.emit(args);
        if (args.cancel) {
            return;
        }
        expandedStates.set(rowID, expanded);
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
    }
    get_rec_by_id(rowID) {
        return this.grid.primaryKey ? this.getRowData(rowID) : rowID;
    }
    allow_expansion_state_change(rowID, expanded) {
        return this.grid.expansionStates.get(rowID) !== expanded;
    }
    isToggleKey(key) {
        return ROW_COLLAPSE_KEYS.has(key) || ROW_EXPAND_KEYS.has(key);
    }
}
GridBaseAPIService.ɵfac = function GridBaseAPIService_Factory(t) { return new (t || GridBaseAPIService)(); };
GridBaseAPIService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: GridBaseAPIService, factory: GridBaseAPIService.ɵfac });

/** @hidden */
class TreeGridFilteringStrategy extends BaseFilteringStrategy {
    filter(data, expressionsTree, advancedExpressionsTree, grid) {
        return this.filterImpl(data, expressionsTree, advancedExpressionsTree, undefined, grid);
    }
    filterImpl(data, expressionsTree, advancedExpressionsTree, parent, grid) {
        let i;
        let rec;
        const len = data.length;
        const res = [];
        if ((FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree)) || !len) {
            return data;
        }
        for (i = 0; i < len; i++) {
            rec = DataUtil.cloneTreeGridRecord(data[i]);
            rec.parent = parent;
            if (rec.children) {
                const filteredChildren = this.filterImpl(rec.children, expressionsTree, advancedExpressionsTree, rec, grid);
                rec.children = filteredChildren.length > 0 ? filteredChildren : null;
            }
            if (this.matchRecord(rec, expressionsTree, grid) && this.matchRecord(rec, advancedExpressionsTree, grid)) {
                res.push(rec);
            }
            else if (rec.children && rec.children.length > 0) {
                rec.isFilteredOutParent = true;
                res.push(rec);
            }
        }
        return res;
    }
    getFieldValue(rec, fieldName, isDate = false) {
        const hierarchicalRecord = rec;
        let value = resolveNestedPath(hierarchicalRecord.data, fieldName);
        value = value && isDate ? parseDate(value) : value;
        return value;
    }
}
/** @hidden */
class IgxTreeGridFilteringPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(hierarchyData, expressionsTree, filterStrategy, advancedFilteringExpressionsTree, id, pipeTrigger, filteringPipeTrigger, pinned) {
        const grid = this.gridAPI.grid;
        const state = {
            expressionsTree: expressionsTree,
            advancedExpressionsTree: advancedFilteringExpressionsTree,
            strategy: new TreeGridFilteringStrategy()
        };
        if (filterStrategy) {
            state.strategy = filterStrategy;
        }
        this.resetFilteredOutProperty(grid.records);
        if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
            grid.setFilteredData(null, pinned);
            return hierarchyData;
        }
        const result = this.filter(hierarchyData, state, grid);
        const filteredData = [];
        this.expandAllRecursive(grid, result, grid.expansionStates, filteredData);
        grid.setFilteredData(filteredData, pinned);
        return result;
    }
    resetFilteredOutProperty(map) {
        const keys = Array.from(map.keys());
        for (let i = 0; i < keys.length; i++) {
            map.get(keys[i]).isFilteredOutParent = undefined;
        }
    }
    expandAllRecursive(grid, data, expandedStates, filteredData) {
        for (let i = 0; i < data.length; i++) {
            const rec = data[i];
            filteredData.push(rec.data);
            this.updateNonProcessedRecord(grid, rec);
            if (rec.children && rec.children.length > 0) {
                expandedStates.set(rec.rowID, true);
                this.expandAllRecursive(grid, rec.children, expandedStates, filteredData);
            }
        }
    }
    updateNonProcessedRecord(grid, record) {
        const rec = grid.records.get(record.rowID);
        rec.isFilteredOutParent = record.isFilteredOutParent;
    }
    filter(data, state, grid) {
        return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree, grid);
    }
}
IgxTreeGridFilteringPipe.ɵfac = function IgxTreeGridFilteringPipe_Factory(t) { return new (t || IgxTreeGridFilteringPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridFilteringPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridFiltering", type: IgxTreeGridFilteringPipe, pure: true });
IgxTreeGridFilteringPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

const DEFAULT_COLUMN_WIDTH = 8.43;
class IgxBaseExporter {
    constructor() {
        this.flatRecords = [];
        this._isTreeGrid = false;
        this._indexOfLastPinnedColumn = -1;
        this._sort = null;
        this.onExportEnded = new EventEmitter();
        /**
         * This event is emitted when a row is exported.
         * ```typescript
         * this.exporterService.onRowExport.subscribe((args: IRowExportingEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * @memberof IgxBaseExporter
         */
        this.onRowExport = new EventEmitter();
        /**
         * This event is emitted when a column is exported.
         * ```typescript
         * this.exporterService.onColumnExport.subscribe((args: IColumnExportingEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * @memberof IgxBaseExporter
         */
        this.onColumnExport = new EventEmitter();
    }
    get columnWidthList() {
        return this._columnWidthList;
    }
    /**
     * Method for exporting IgxGrid component's data.
     * ```typescript
     * this.exporterService.export(this.igxGridForExport, this.exportOptions);
     * ```
     * @memberof IgxBaseExporter
     */
    export(grid, options) {
        if (options === undefined || options === null) {
            throw Error('No options provided!');
        }
        const columns = grid.columnList.toArray();
        this._columnList = new Array(columns.length);
        this._columnWidthList = new Array(columns.filter(c => !c.hidden).length);
        const hiddenColumns = [];
        let lastVisbleColumnIndex = -1;
        columns.forEach((column) => {
            const columnHeader = column.header !== '' ? column.header : column.field;
            const exportColumn = !column.hidden || options.ignoreColumnsVisibility;
            const index = options.ignoreColumnsOrder ? column.index : column.visibleIndex;
            const columnWidth = Number(column.width.slice(0, -2));
            const columnInfo = {
                header: columnHeader,
                field: column.field,
                skip: !exportColumn,
                formatter: column.formatter,
                skipFormatter: false
            };
            if (index !== -1) {
                this._columnList[index] = columnInfo;
                this._columnWidthList[index] = columnWidth;
                lastVisbleColumnIndex = Math.max(lastVisbleColumnIndex, index);
            }
            else {
                hiddenColumns.push(columnInfo);
            }
            if (column.pinned && exportColumn) {
                this._indexOfLastPinnedColumn++;
            }
        });
        // Append the hidden columns to the end of the list
        hiddenColumns.forEach((hiddenColumn) => {
            this._columnList[++lastVisbleColumnIndex] = hiddenColumn;
        });
        const data = this.prepareData(grid, options);
        this.exportData(data, options);
    }
    /**
     * Method for exporting any kind of array data.
     * ```typescript
     * this.exporterService.exportData(this.arrayForExport, this.exportOptions);
     * ```
     * @memberof IgxBaseExporter
     */
    exportData(data, options) {
        if (options === undefined || options === null) {
            throw Error('No options provided!');
        }
        if (!this._columnList || this._columnList.length === 0) {
            const keys = ExportUtilities.getKeysFromData(data);
            this._columnList = keys.map((k) => ({ header: k, field: k, skip: false }));
            this._columnWidthList = new Array(keys.length).fill(DEFAULT_COLUMN_WIDTH);
        }
        let skippedPinnedColumnsCount = 0;
        let columnsWithoutHeaderCount = 1;
        this._columnList.forEach((column, index) => {
            if (!column.skip) {
                const columnExportArgs = {
                    header: ExportUtilities.isNullOrWhitespaces(column.header) ?
                        'Column' + columnsWithoutHeaderCount++ : column.header,
                    field: column.field,
                    columnIndex: index,
                    cancel: false,
                    skipFormatter: false
                };
                this.onColumnExport.emit(columnExportArgs);
                column.header = columnExportArgs.header;
                column.skip = columnExportArgs.cancel;
                column.skipFormatter = columnExportArgs.skipFormatter;
                if (column.skip && index <= this._indexOfLastPinnedColumn) {
                    skippedPinnedColumnsCount++;
                }
                if (this._sort && this._sort.fieldName === column.field) {
                    if (column.skip) {
                        this._sort = null;
                    }
                    else {
                        this._sort.fieldName = column.header;
                    }
                }
            }
        });
        this._indexOfLastPinnedColumn -= skippedPinnedColumnsCount;
        const dataToExport = new Array();
        const isSpecialData = ExportUtilities.isSpecialData(data);
        yieldingLoop(data.length, 100, (i) => {
            const row = data[i];
            this.exportRow(dataToExport, row, i, isSpecialData);
        }, () => {
            this.exportDataImplementation(dataToExport, options);
            this.resetDefaults();
        });
    }
    exportRow(data, rowData, index, isSpecialData) {
        let row;
        if (!isSpecialData) {
            row = this._columnList.reduce((a, e) => {
                if (!e.skip) {
                    const rawValue = this._isTreeGrid ? resolveNestedPath(rowData.data, e.field) : resolveNestedPath(rowData, e.field);
                    a[e.header] = e.formatter && !e.skipFormatter ? e.formatter(rawValue) : rawValue;
                }
                return a;
            }, {});
        }
        else {
            row = this._isTreeGrid ? rowData.data : rowData;
        }
        const rowArgs = {
            rowData: row,
            rowIndex: index,
            cancel: false
        };
        this.onRowExport.emit(rowArgs);
        if (!rowArgs.cancel) {
            data.push({ rowData: rowArgs.rowData, originalRowData: rowData });
        }
    }
    prepareData(grid, options) {
        this.flatRecords = [];
        let rootRecords = grid.rootRecords;
        this._isTreeGrid = rootRecords !== undefined;
        if (this._isTreeGrid) {
            this.prepareHierarchicalData(rootRecords);
        }
        let data = this._isTreeGrid ? this.flatRecords : grid.data;
        if (((grid.filteringExpressionsTree &&
            grid.filteringExpressionsTree.filteringOperands.length > 0) ||
            (grid.advancedFilteringExpressionsTree &&
                grid.advancedFilteringExpressionsTree.filteringOperands.length > 0)) &&
            !options.ignoreFiltering) {
            const filteringState = {
                expressionsTree: grid.filteringExpressionsTree,
                advancedExpressionsTree: grid.advancedFilteringExpressionsTree,
                logic: grid.filteringLogic
            };
            if (this._isTreeGrid) {
                this.flatRecords = [];
                filteringState.strategy = (grid.filterStrategy) ? grid.filterStrategy : new TreeGridFilteringStrategy();
                rootRecords = filteringState.strategy.filter(rootRecords, filteringState.expressionsTree, filteringState.advancedExpressionsTree);
                this.prepareHierarchicalData(rootRecords);
                data = this.flatRecords;
            }
            else {
                filteringState.strategy = grid.filterStrategy;
                data = DataUtil.filter(data, filteringState, grid);
            }
        }
        if (grid.sortingExpressions &&
            grid.sortingExpressions.length > 0 &&
            !options.ignoreSorting) {
            this._sort = cloneValue(grid.sortingExpressions[0]);
            if (this._isTreeGrid) {
                this.flatRecords = [];
                rootRecords = DataUtil.treeGridSort(rootRecords, grid.sortingExpressions, grid.sortStrategy);
                this.prepareHierarchicalData(rootRecords);
                data = this.flatRecords;
            }
            else {
                data = DataUtil.sort(data, grid.sortingExpressions, grid.sortStrategy, grid);
            }
        }
        return data;
    }
    prepareHierarchicalData(records) {
        if (!records) {
            return;
        }
        for (let i = 0; i < records.length; i++) {
            const hierarchicalRecord = records[i];
            this.flatRecords.push(hierarchicalRecord);
            this.prepareHierarchicalData(hierarchicalRecord.children);
        }
    }
    resetDefaults() {
        this._columnList = [];
        this._indexOfLastPinnedColumn = -1;
        this._sort = null;
        this.flatRecords = [];
    }
}

/**
 * @hidden
 */
class CharSeparatedValueData {
    constructor(_data, valueDelimiter) {
        this._data = _data;
        this._headerRecord = '';
        this._dataRecords = '';
        this._eor = '\r\n';
        this._escapeCharacters = ['\r', '\n', '\r\n'];
        this._delimiterLength = 1;
        this._isSpecialData = false;
        this.setDelimiter(valueDelimiter);
    }
    prepareData() {
        if (!this._data || this._data.length === 0) {
            return '';
        }
        const keys = ExportUtilities.getKeysFromData(this._data);
        if (keys.length === 0) {
            return '';
        }
        this._isSpecialData = ExportUtilities.isSpecialData(this._data);
        this._escapeCharacters.push(this._delimiter);
        this._headerRecord = this.processHeaderRecord(keys, this._escapeCharacters);
        this._dataRecords = this.processDataRecords(this._data, keys, this._escapeCharacters);
        return this._headerRecord + this._dataRecords;
    }
    prepareDataAsync(done) {
        if (!this._data || this._data.length === 0) {
            done('');
        }
        const keys = ExportUtilities.getKeysFromData(this._data);
        if (keys.length === 0) {
            done('');
        }
        this._isSpecialData = ExportUtilities.isSpecialData(this._data);
        this._escapeCharacters.push(this._delimiter);
        this._headerRecord = this.processHeaderRecord(keys, this._escapeCharacters);
        this.processDataRecordsAsync(this._data, keys, this._escapeCharacters, (dr) => {
            done(this._headerRecord + dr);
        });
    }
    processField(value, escapeChars) {
        let safeValue = ExportUtilities.hasValue(value) ? String(value) : '';
        if (escapeChars.some((v) => safeValue.includes(v))) {
            safeValue = `"${safeValue}"`;
        }
        return safeValue + this._delimiter;
    }
    processHeaderRecord(keys, escapeChars) {
        let recordData = '';
        for (const keyName of keys) {
            recordData += this.processField(keyName, this._escapeCharacters);
        }
        return recordData.slice(0, -this._delimiterLength) + this._eor;
    }
    processRecord(record, keys, escapeChars) {
        const recordData = new Array(keys.length);
        for (let index = 0; index < keys.length; index++) {
            const value = (record[keys[index]] !== undefined) ? record[keys[index]] : this._isSpecialData ? record : '';
            recordData[index] = this.processField(value, this._escapeCharacters);
        }
        return recordData.join('').slice(0, -this._delimiterLength) + this._eor;
    }
    processDataRecords(currentData, keys, escapeChars) {
        const dataRecords = new Array(currentData.length);
        for (let i = 0; i < currentData.length; i++) {
            const row = currentData[i];
            dataRecords[i] = this.processRecord(row, keys, escapeChars);
        }
        return dataRecords.join('');
    }
    processDataRecordsAsync(currentData, keys, escapeChars, done) {
        const dataRecords = new Array(currentData.length);
        yieldingLoop(currentData.length, 1000, (i) => {
            const row = currentData[i];
            dataRecords[i] = this.processRecord(row, keys, escapeChars);
        }, () => {
            done(dataRecords.join(''));
        });
    }
    setDelimiter(value) {
        this._delimiter = value;
        this._delimiterLength = value.length;
    }
}

class IgxExporterOptionsBase {
    constructor(fileName, _fileExtension) {
        this._fileExtension = _fileExtension;
        /**
         * Specifies whether hidden columns should be exported.
         * ```typescript
         * let ignoreColumnsVisibility = this.exportOptions.ignoreColumnsVisibility;
         * this.exportOptions.ignoreColumnsVisibility = true;
         * ```
         * @memberof IgxExporterOptionsBase
         */
        this.ignoreColumnsVisibility = false;
        /**
         * Specifies whether filtered out rows should be exported.
         * ```typescript
         * let ignoreFiltering = this.exportOptions.ignoreFiltering;
         * this.exportOptions.ignoreFiltering = true;
         * ```
         * @memberof IgxExporterOptionsBase
         */
        this.ignoreFiltering = false;
        /**
         * Specifies if the exporter should ignore the current column order in the IgxGrid.
         * ```typescript
         * let ignoreColumnsOrder = this.exportOptions.ignoreColumnsOrder;
         * this.exportOptions.ignoreColumnsOrder = true;
         * ```
         * @memberof IgxExporterOptionsBase
         */
        this.ignoreColumnsOrder = false;
        /**
         * Specifies whether the exported data should be sorted as in the provided IgxGrid.
         * ```typescript
         * let ignoreSorting = this.exportOptions.ignoreSorting;
         * this.exportOptions.ignoreSorting = true;
         * ```
         * @memberof IgxExporterOptionsBase
         */
        this.ignoreSorting = false;
        this.setFileName(fileName);
    }
    setFileName(fileName) {
        this._fileName = fileName + (fileName.endsWith(this._fileExtension) === false ? this._fileExtension : '');
    }
    /**
     * Gets the file name which will be used for the exporting operation.
     * ```typescript
     * let fileName = this.exportOptions.fileName;
     * ```
     * @memberof IgxExporterOptionsBase
     */
    get fileName() {
        return this._fileName;
    }
    /**
     * Sets the file name which will be used for the exporting operation.
     * ```typescript
     * this.exportOptions.fileName = 'exportedData01';
     * ```
     * @memberof IgxExporterOptionsBase
     */
    set fileName(value) {
        this.setFileName(value);
    }
}

/**
 * Objects of this class are used to configure the CSV exporting process.
 */
class IgxCsvExporterOptions extends IgxExporterOptionsBase {
    constructor(fileName, fileType) {
        super(fileName, IgxCsvExporterOptions.getExtensionFromFileType(fileType));
        this.setFileType(fileType);
        this.setDelimiter();
    }
    static getExtensionFromFileType(fType) {
        let extension = '';
        switch (fType) {
            case CsvFileTypes.CSV:
                extension = '.csv';
                break;
            case CsvFileTypes.TSV:
                extension = '.tsv';
                break;
            case CsvFileTypes.TAB:
                extension = '.tab';
                break;
            default:
                throw Error('Unsupported CSV file type!');
        }
        return extension;
    }
    /**
     * Gets the value delimiter which will be used for the exporting operation.
     * ```typescript
     * let delimiter = this.exportOptions.valueDelimiter;
     * ```
     * @memberof IgxCsvExporterOptions
     */
    get valueDelimiter() {
        return this._valueDelimiter;
    }
    /**
     * Sets a value delimiter which will overwrite the default delimiter of the selected export format.
     * ```typescript
     * this.exportOptions.valueDelimiter = '|';
     * ```
     * @memberof IgxCsvExporterOptions
     */
    set valueDelimiter(value) {
        this.setDelimiter(value);
    }
    /**
     * Gets the CSV export format.
     * ```typescript
     * let filetype = this.exportOptions.fileType;
     * ```
     * @memberof IgxCsvExporterOptions
     */
    get fileType() {
        return this._fileType;
    }
    /**
     * Sets the CSV export format.
     * ```typescript
     * this.exportOptions.fileType = CsvFileTypes.TAB;
     * ```
     * @memberof IgxCsvExporterOptions
     */
    set fileType(value) {
        this.setFileType(value);
    }
    setFileType(value) {
        if (value !== undefined && value !== null && value !== this._fileType) {
            this._fileType = value;
            const extension = IgxCsvExporterOptions.getExtensionFromFileType(value);
            if (!this.fileName.endsWith(extension)) {
                const oldExt = '.' + this.fileName.split('.').pop();
                const newName = this.fileName.replace(oldExt, extension);
                this._fileExtension = extension;
                this.fileName = newName;
            }
        }
    }
    setDelimiter(value) {
        if (value !== undefined && value !== '' && value !== null) {
            this._valueDelimiter = value;
        }
        else {
            switch (this.fileType) {
                case CsvFileTypes.CSV:
                    this._valueDelimiter = ',';
                    break;
                case CsvFileTypes.TSV:
                case CsvFileTypes.TAB:
                    this._valueDelimiter = '\t';
                    break;
            }
        }
    }
}
/**
 * This enumeration is used to configure the default value separator
 * as well as the default file extension used when performing CSV exporting.
 */
var CsvFileTypes;
(function (CsvFileTypes) {
    /**
     * Character Separated Values, default separator is "comma", default file extension is .csv
     */
    CsvFileTypes[CsvFileTypes["CSV"] = 0] = "CSV";
    /**
     * Tab Separated Values, default separator is tab, default file extension is .tsv
     */
    CsvFileTypes[CsvFileTypes["TSV"] = 1] = "TSV";
    /**
     * Tab Separated Values, default separator is tab, default file extension is .tab
     */
    CsvFileTypes[CsvFileTypes["TAB"] = 2] = "TAB";
})(CsvFileTypes || (CsvFileTypes = {}));

/**
 * **Ignite UI for Angular CSV Exporter Service** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter-csv)
 *
 * The Ignite UI for Angular CSV Exporter service can export data in a Character Separated Values format from
 * both raw data (array) or from an `IgxGrid`.
 *
 * Example:
 * ```typescript
 * public localData = [
 *   { Name: "Eric Ridley", Age: "26" },
 *   { Name: "Alanis Brook", Age: "22" },
 *   { Name: "Jonathan Morris", Age: "23" }
 * ];
 *
 * constructor(private csvExportService: IgxCsvExporterService) {
 * }
 *
 * const opt: IgxCsvExporterOptions = new IgxCsvExporterOptions("FileName", CsvFileTypes.CSV);
 * this.csvExportService.exportData(this.localData, opt);
 * ```
 */
class IgxCsvExporterService extends IgxBaseExporter {
    constructor() {
        super(...arguments);
        /**
         * This event is emitted when the export process finishes.
         * ```typescript
         * this.exporterService.onExportEnded.subscribe((args: ICsvExportEndedEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * @memberof IgxCsvExporterService
         */
        this.onExportEnded = new EventEmitter();
    }
    exportDataImplementation(data, options) {
        data = data.map((item) => item.rowData);
        const csvData = new CharSeparatedValueData(data, options.valueDelimiter);
        csvData.prepareDataAsync((r) => {
            this._stringData = r;
            this.saveFile(options);
            this.onExportEnded.emit({ csvData: this._stringData });
        });
    }
    saveFile(options) {
        switch (options.fileType) {
            case CsvFileTypes.CSV:
                this.exportFile(this._stringData, options.fileName, 'text/csv;charset=utf-8;');
                break;
            case CsvFileTypes.TSV:
            case CsvFileTypes.TAB:
                this.exportFile(this._stringData, options.fileName, 'text/tab-separated-values;charset=utf-8;');
                break;
        }
    }
    exportFile(data, fileName, fileType) {
        const blob = new Blob(['\ufeff', data], { type: fileType });
        ExportUtilities.saveBlobToFile(blob, fileName);
    }
}
IgxCsvExporterService.ɵfac = function IgxCsvExporterService_Factory(t) { return ɵIgxCsvExporterService_BaseFactory(t || IgxCsvExporterService); };
IgxCsvExporterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxCsvExporterService, factory: IgxCsvExporterService.ɵfac });
IgxCsvExporterService.propDecorators = {
    onExportEnded: [{ type: Output }]
};

/**
 * @hidden
 */
var ExcelFolderTypes;
(function (ExcelFolderTypes) {
    ExcelFolderTypes[ExcelFolderTypes["RootExcelFolder"] = 0] = "RootExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["RootRelsExcelFolder"] = 1] = "RootRelsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["DocPropsExcelFolder"] = 2] = "DocPropsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["XLExcelFolder"] = 3] = "XLExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["XLRelsExcelFolder"] = 4] = "XLRelsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["ThemeExcelFolder"] = 5] = "ThemeExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["WorksheetsExcelFolder"] = 6] = "WorksheetsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["WorksheetsRelsExcelFolder"] = 7] = "WorksheetsRelsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["TablesExcelFolder"] = 8] = "TablesExcelFolder";
})(ExcelFolderTypes || (ExcelFolderTypes = {}));
/**
 * @hidden
 */
var ExcelFileTypes;
(function (ExcelFileTypes) {
    ExcelFileTypes[ExcelFileTypes["RootRelsFile"] = 0] = "RootRelsFile";
    ExcelFileTypes[ExcelFileTypes["AppFile"] = 1] = "AppFile";
    ExcelFileTypes[ExcelFileTypes["CoreFile"] = 2] = "CoreFile";
    ExcelFileTypes[ExcelFileTypes["WorkbookRelsFile"] = 3] = "WorkbookRelsFile";
    ExcelFileTypes[ExcelFileTypes["ThemeFile"] = 4] = "ThemeFile";
    ExcelFileTypes[ExcelFileTypes["WorksheetFile"] = 5] = "WorksheetFile";
    ExcelFileTypes[ExcelFileTypes["StyleFile"] = 6] = "StyleFile";
    ExcelFileTypes[ExcelFileTypes["WorkbookFile"] = 7] = "WorkbookFile";
    ExcelFileTypes[ExcelFileTypes["ContentTypesFile"] = 8] = "ContentTypesFile";
    ExcelFileTypes[ExcelFileTypes["SharedStringsFile"] = 9] = "SharedStringsFile";
    ExcelFileTypes[ExcelFileTypes["WorksheetRelsFile"] = 10] = "WorksheetRelsFile";
    ExcelFileTypes[ExcelFileTypes["TablesFile"] = 11] = "TablesFile";
})(ExcelFileTypes || (ExcelFileTypes = {}));

/** @hidden */
class ExcelStrings {
    static getRels() {
        return ExcelStrings.XML_STRING + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>';
    }
    static getApp(worksheetName) {
        return ExcelStrings.XML_STRING + `<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>${worksheetName}</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>`;
    }
    static getCore() {
        return ExcelStrings.XML_STRING + '<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator></dc:creator><cp:lastModifiedBy></cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">2015-06-05T18:17:20Z</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">2015-06-05T18:17:26Z</dcterms:modified></cp:coreProperties>';
    }
    static getTheme() {
        return ExcelStrings.XML_STRING + '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="5B9BD5"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="4472C4"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック Light"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线 Light"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>';
    }
    static getStyles(hasNonStringValues) {
        const additionalCellXF = '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0" applyNumberFormat="1"/>';
        const cellXFCount = hasNonStringValues ? 2 : 1;
        return ExcelStrings.XML_STRING + '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="' + cellXFCount + '"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/>' + additionalCellXF + '</cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles><dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>';
    }
    static getWorkbook(worksheetName) {
        return ExcelStrings.XML_STRING + `<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><fileVersion appName="xl" lastEdited="6" lowestEdited="6" rupBuild="14420"/><workbookPr filterPrivacy="1" defaultThemeVersion="164011"/><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="22260" windowHeight="12645"/></bookViews><sheets><sheet name="${worksheetName}" sheetId="1" r:id="rId1"/></sheets><calcPr calcId="162913"/><extLst><ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:workbookPr chartTrackingRefBase="1"/></ext></extLst></workbook>`;
    }
    static getWorksheetRels() {
        return ExcelStrings.XML_STRING + `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/table" Target="../tables/table1.xml"/></Relationships>`;
    }
    static getWorkbookRels(hasSharedStrings) {
        let retVal = ExcelStrings.XML_STRING + `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>`;
        if (hasSharedStrings) {
            retVal += ExcelStrings.SHARED_STRING_RELATIONSHIP;
        }
        retVal += '</Relationships>';
        return retVal;
    }
    static getSheetXML(dimension, freezePane, cols, sheetData, hasTable, hasGroupedRows = false, outlineLevel = 0) {
        const tableParts = hasTable ? '<tableParts count="1"><tablePart r:id="rId1"/></tableParts>' : '';
        const sheetOutlineProp = hasGroupedRows ? '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>' : '';
        const sOutlineLevel = outlineLevel > 0 ? `outlineLevelRow="${outlineLevel}"` : '';
        // return ExcelStrings.XML_STRING +
        //     '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"><dimension ref="' + dimension + '"/><sheetViews><sheetView tabSelected="1" workbookViewId="0">' + freezePane + '</sheetView></sheetViews><sheetFormatPr defaultRowHeight="15" x14ac:dyDescent="0.25"/>' + cols + sheetData + '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>' + tableParts + '</worksheet>';
        return `${ExcelStrings.XML_STRING}
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">
${sheetOutlineProp}
<dimension ref="${dimension}"/>
<sheetViews><sheetView tabSelected="1" workbookViewId="0">${freezePane}</sheetView></sheetViews>
<sheetFormatPr defaultRowHeight="15" ${sOutlineLevel} x14ac:dyDescent="0.25"/>
${cols}
${sheetData}
<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>
${tableParts}</worksheet>`;
    }
    static getSharedStringXML(count, uniqueCount, table) {
        return ExcelStrings.XML_STRING + '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="' + count + '" uniqueCount="' + uniqueCount + '">' + table + '</sst>';
    }
    static getContentTypesXML(hasSharedStrings, hasTable) {
        let contentTypes = ExcelStrings.XML_STRING +
            `<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types\">
            <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
            <Default Extension="xml" ContentType="application/xml"/>
            <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>
            <Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>
            <Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>
            <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>
            <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
            <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>`;
        contentTypes += hasSharedStrings ?
            `	<Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>` : '';
        contentTypes += hasTable ?
            `<Override PartName="/xl/tables/table1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"/>` : '';
        contentTypes += `</Types>`;
        return contentTypes;
    }
    static getTablesXML(dimension, tableColumns, sort) {
        return `${ExcelStrings.XML_STRING}<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" id="1" name="Table1" displayName="Table1" ref="${dimension}" totalsRowShown="0">
    <autoFilter ref="${dimension}"/>${sort}${tableColumns}<tableStyleInfo name="TableStyleMedium2" showFirstColumn="0" showLastColumn="0" showRowStripes="1" showColumnStripes="0"/>
</table>`;
    }
    /* tslint:enable max-line-length */
    static getExcelColumn(index) {
        // Returns the excel column name for given 0-based index
        // For example 27 should return "AB"
        let returnString = '';
        while (index >= 0) {
            const char = index % 26;
            returnString = String.fromCharCode(65 + char) + returnString;
            index = Math.floor(index / 26) - 1;
        }
        return returnString;
    }
}
/* tslint:disable max-line-length */
ExcelStrings.XML_STRING = '<?xml version="1.0" encoding="UTF-8"?>\r\n';
ExcelStrings.SHARED_STRING_RELATIONSHIP = '<Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml" />';

/**
 * @hidden
 */
class RootRelsFile {
    writeElement(folder, worksheetData) {
        folder.file('.rels', ExcelStrings.getRels());
    }
}
/**
 * @hidden
 */
class AppFile {
    writeElement(folder, worksheetData) {
        folder.file('app.xml', ExcelStrings.getApp(worksheetData.options.worksheetName));
    }
}
/**
 * @hidden
 */
class CoreFile {
    writeElement(folder, worksheetData) {
        folder.file('core.xml', ExcelStrings.getCore());
    }
}
/**
 * @hidden
 */
class WorkbookRelsFile {
    writeElement(folder, worksheetData) {
        const hasSharedStrings = worksheetData.isEmpty === false;
        folder.file('workbook.xml.rels', ExcelStrings.getWorkbookRels(hasSharedStrings));
    }
}
/**
 * @hidden
 */
class ThemeFile {
    writeElement(folder, worksheetData) {
        folder.file('theme1.xml', ExcelStrings.getTheme());
    }
}
/**
 * @hidden
 */
class WorksheetFile {
    constructor() {
        this.maxOutlineLevel = 0;
        this.dimension = '';
        this.freezePane = '';
        this.rowHeight = '';
        /* tslint:enable member-ordering */
    }
    writeElement(folder, worksheetData) {
        const sheetData = [];
        const cols = [];
        let dimension;
        const dictionary = worksheetData.dataDictionary;
        let freezePane = '';
        let maxOutlineLevel = 0;
        if (worksheetData.isEmpty) {
            sheetData.push('<sheetData/>');
            dimension = 'A1';
        }
        else {
            sheetData.push('<sheetData>');
            const height = worksheetData.options.rowHeight;
            const rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
            sheetData.push(`<row r="1"${rowHeight}>`);
            for (let i = 0; i < worksheetData.columnCount; i++) {
                const column = ExcelStrings.getExcelColumn(i) + 1;
                const value = dictionary.saveValue(worksheetData.keys[i], i, true);
                sheetData.push(`<c r="${column}" t="s"><v>${value}</v></c>`);
            }
            sheetData.push('</row>');
            for (let i = 1; i < worksheetData.rowCount; i++) {
                if (!worksheetData.isTreeGridData) {
                    sheetData.push(`<row r="${(i + 1)}"${rowHeight}>`);
                }
                else {
                    const rowData = worksheetData.data[i - 1].originalRowData;
                    const sCollapsed = (!rowData.expanded) ? '' : (rowData.expanded === true) ? '' : ` collapsed="1"`;
                    const sHidden = (rowData.parent && this.hasCollapsedParent(rowData)) ? ` hidden="1"` : '';
                    const rowOutlineLevel = rowData.level ? rowData.level : 0;
                    const sOutlineLevel = rowOutlineLevel > 0 ? ` outlineLevel="${rowOutlineLevel}"` : '';
                    maxOutlineLevel = maxOutlineLevel < rowOutlineLevel ? rowOutlineLevel : maxOutlineLevel;
                    sheetData.push(`<row r="${(i + 1)}"${rowHeight}${sOutlineLevel}${sCollapsed}${sHidden}>`);
                }
                for (let j = 0; j < worksheetData.columnCount; j++) {
                    const cellData = WorksheetFile.getCellData(worksheetData, i, j);
                    sheetData.push(cellData);
                }
                sheetData.push('</row>');
            }
            sheetData.push('</sheetData>');
            dimension = 'A1:' + ExcelStrings.getExcelColumn(worksheetData.columnCount - 1) + worksheetData.rowCount;
            cols.push('<cols>');
            for (let i = 0; i < worksheetData.columnCount; i++) {
                const width = dictionary.columnWidths[i];
                // Use the width provided in the options if it exists
                let widthInTwips = worksheetData.options.columnWidth !== undefined ?
                    worksheetData.options.columnWidth :
                    Math.max(((width / 96) * 14.4), WorksheetFile.MIN_WIDTH);
                if (!(widthInTwips > 0)) {
                    widthInTwips = WorksheetFile.MIN_WIDTH;
                }
                cols.push(`<col min="${(i + 1)}" max="${(i + 1)}" width="${widthInTwips}" customWidth="1"/>`);
            }
            cols.push('</cols>');
            if (worksheetData.indexOfLastPinnedColumn !== -1 &&
                !worksheetData.options.ignorePinning &&
                !worksheetData.options.ignoreColumnsOrder) {
                const frozenColumnCount = worksheetData.indexOfLastPinnedColumn + 1;
                const firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + '1';
                freezePane = `<pane xSplit="${frozenColumnCount}" topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
            }
        }
        const hasTable = !worksheetData.isEmpty && worksheetData.options.exportAsTable;
        folder.file('sheet1.xml', ExcelStrings.getSheetXML(dimension, freezePane, cols.join(''), sheetData.join(''), hasTable, worksheetData.isTreeGridData, maxOutlineLevel));
    }
    writeElementAsync(folder, worksheetData) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                this.prepareDataAsync(worksheetData, (cols, rows) => {
                    const hasTable = !worksheetData.isEmpty && worksheetData.options.exportAsTable;
                    folder.file('sheet1.xml', ExcelStrings.getSheetXML(this.dimension, this.freezePane, cols, rows, hasTable, worksheetData.isTreeGridData, this.maxOutlineLevel));
                    resolve();
                });
            });
        });
    }
    prepareDataAsync(worksheetData, done) {
        let sheetData = '';
        let cols = '';
        const dictionary = worksheetData.dataDictionary;
        if (worksheetData.isEmpty) {
            sheetData += '<sheetData/>';
            this.dimension = 'A1';
            done('', sheetData);
        }
        else {
            sheetData += '<sheetData>';
            const height = worksheetData.options.rowHeight;
            this.rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
            sheetData += `<row r="1"${this.rowHeight}>`;
            for (let i = 0; i < worksheetData.columnCount; i++) {
                const column = ExcelStrings.getExcelColumn(i) + 1;
                const value = dictionary.saveValue(worksheetData.keys[i], i, true);
                sheetData += `<c r="${column}" t="s"><v>${value}</v></c>`;
            }
            sheetData += '</row>';
            this.dimension = 'A1:' + ExcelStrings.getExcelColumn(worksheetData.columnCount - 1) + worksheetData.rowCount;
            cols += '<cols>';
            for (let i = 0; i < worksheetData.columnCount; i++) {
                const width = dictionary.columnWidths[i];
                // Use the width provided in the options if it exists
                let widthInTwips = worksheetData.options.columnWidth !== undefined ?
                    worksheetData.options.columnWidth :
                    Math.max(((width / 96) * 14.4), WorksheetFile.MIN_WIDTH);
                if (!(widthInTwips > 0)) {
                    widthInTwips = WorksheetFile.MIN_WIDTH;
                }
                cols += `<col min="${(i + 1)}" max="${(i + 1)}" width="${widthInTwips}" customWidth="1"/>`;
            }
            cols += '</cols>';
            if (worksheetData.indexOfLastPinnedColumn !== -1 &&
                !worksheetData.options.ignorePinning &&
                !worksheetData.options.ignoreColumnsOrder) {
                const frozenColumnCount = worksheetData.indexOfLastPinnedColumn + 1;
                const firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + '1';
                this.freezePane = `<pane xSplit="${frozenColumnCount}" topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
            }
            this.processDataRecordsAsync(worksheetData, (rows) => {
                sheetData += rows;
                sheetData += '</sheetData>';
                done(cols, sheetData);
            });
        }
    }
    processDataRecordsAsync(worksheetData, done) {
        const rowDataArr = new Array(worksheetData.rowCount - 1);
        const height = worksheetData.options.rowHeight;
        this.rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
        yieldingLoop(worksheetData.rowCount - 1, 1000, (i) => {
            rowDataArr[i] = this.processRow(worksheetData, i + 1);
        }, () => {
            done(rowDataArr.join(''));
        });
    }
    processRow(worksheetData, i) {
        const rowData = new Array(worksheetData.columnCount + 2);
        if (!worksheetData.isTreeGridData) {
            rowData[0] = `<row r="${(i + 1)}"${this.rowHeight}>`;
        }
        else {
            const originalData = worksheetData.data[i - 1].originalRowData;
            const sCollapsed = (!originalData.expanded) ? '' : (originalData.expanded === true) ? '' : ` collapsed="1"`;
            const sHidden = (originalData.parent && this.hasCollapsedParent(originalData)) ? ` hidden="1"` : '';
            const rowOutlineLevel = originalData.level ? originalData.level : 0;
            const sOutlineLevel = rowOutlineLevel > 0 ? ` outlineLevel="${rowOutlineLevel}"` : '';
            this.maxOutlineLevel = this.maxOutlineLevel < rowOutlineLevel ? rowOutlineLevel : this.maxOutlineLevel;
            rowData[0] = `<row r="${(i + 1)}"${this.rowHeight}${sOutlineLevel}${sCollapsed}${sHidden}>`;
        }
        for (let j = 0; j < worksheetData.columnCount; j++) {
            const cellData = WorksheetFile.getCellData(worksheetData, i, j);
            rowData[j + 1] = cellData;
        }
        rowData[worksheetData.columnCount + 1] = '</row>';
        return rowData.join('');
    }
    hasCollapsedParent(rowData) {
        let result = !rowData.parent.expanded;
        while (rowData.parent) {
            result = result || !rowData.parent.expanded;
            rowData = rowData.parent;
        }
        return result;
    }
    /* tslint:disable member-ordering */
    static getCellData(worksheetData, row, column) {
        const dictionary = worksheetData.dataDictionary;
        const columnName = ExcelStrings.getExcelColumn(column) + (row + 1);
        const columnHeader = worksheetData.keys[column];
        const rowData = worksheetData.data[row - 1].rowData;
        const cellValue = worksheetData.isSpecialData ? rowData : rowData[columnHeader];
        if (cellValue === undefined || cellValue === null) {
            return `<c r="${columnName}" s="1"/>`;
        }
        else {
            const savedValue = dictionary.saveValue(cellValue, column, false);
            const isSavedAsString = savedValue !== -1;
            const value = isSavedAsString ? savedValue : cellValue;
            const type = isSavedAsString ? ` t="s"` : '';
            const format = isSavedAsString ? '' : ` s="1"`;
            return `<c r="${columnName}"${type}${format}><v>${value}</v></c>`;
        }
    }
}
WorksheetFile.MIN_WIDTH = 8.43;
/**
 * @hidden
 */
class StyleFile {
    writeElement(folder, worksheetData) {
        folder.file('styles.xml', ExcelStrings.getStyles(worksheetData.dataDictionary && worksheetData.dataDictionary.hasNonStringValues));
    }
}
/**
 * @hidden
 */
class WorkbookFile {
    writeElement(folder, worksheetData) {
        folder.file('workbook.xml', ExcelStrings.getWorkbook(worksheetData.options.worksheetName));
    }
}
/**
 * @hidden
 */
class ContentTypesFile {
    writeElement(folder, worksheetData) {
        folder.file('[Content_Types].xml', ExcelStrings.getContentTypesXML(!worksheetData.isEmpty, worksheetData.options.exportAsTable));
    }
}
/**
 * @hidden
 */
class SharedStringsFile {
    writeElement(folder, worksheetData) {
        const dict = worksheetData.dataDictionary;
        const sortedValues = dict.getKeys();
        const sharedStrings = new Array(sortedValues.length);
        for (const value of sortedValues) {
            sharedStrings[dict.getSanitizedValue(value)] = '<si><t>' + value + '</t></si>';
        }
        folder.file('sharedStrings.xml', ExcelStrings.getSharedStringXML(dict.stringsCount, sortedValues.length, sharedStrings.join('')));
    }
}
/**
 * @hidden
 */
class TablesFile {
    writeElement(folder, worksheetData) {
        const columnCount = worksheetData.columnCount;
        const lastColumn = ExcelStrings.getExcelColumn(columnCount - 1) + worksheetData.rowCount;
        const dimension = 'A1:' + lastColumn;
        const values = worksheetData.keys;
        let sortString = '';
        let tableColumns = '<tableColumns count="' + columnCount + '">';
        for (let i = 0; i < columnCount; i++) {
            const value = values[i];
            tableColumns += '<tableColumn id="' + (i + 1) + '" name="' + value + '"/>';
        }
        tableColumns += '</tableColumns>';
        if (worksheetData.sort) {
            const sortingExpression = worksheetData.sort;
            const sc = ExcelStrings.getExcelColumn(values.indexOf(sortingExpression.fieldName));
            const dir = sortingExpression.dir - 1;
            sortString = `<sortState ref="A2:${lastColumn}"><sortCondition descending="${dir}" ref="${sc}1:${sc}15"/></sortState>`;
        }
        folder.file('table1.xml', ExcelStrings.getTablesXML(dimension, tableColumns, sortString));
    }
}
/**
 * @hidden
 */
class WorksheetRelsFile {
    writeElement(folder, worksheetData) {
        folder.file('sheet1.xml.rels', ExcelStrings.getWorksheetRels());
    }
}

/** @hidden */
class RootExcelFolder {
    get folderName() {
        return '';
    }
    childFiles(data) {
        return [ExcelFileTypes.ContentTypesFile];
    }
    childFolders(data) {
        return [
            ExcelFolderTypes.RootRelsExcelFolder,
            ExcelFolderTypes.DocPropsExcelFolder,
            ExcelFolderTypes.XLExcelFolder
        ];
    }
}
/** @hidden */
class RootRelsExcelFolder {
    get folderName() {
        return '_rels';
    }
    childFiles(data) {
        return [ExcelFileTypes.RootRelsFile];
    }
    childFolders(data) {
        return [];
    }
}
/** @hidden */
class DocPropsExcelFolder {
    get folderName() {
        return 'docProps';
    }
    childFiles(data) {
        return [
            ExcelFileTypes.AppFile,
            ExcelFileTypes.CoreFile
        ];
    }
    childFolders(data) {
        return [];
    }
}
/** @hidden */
class XLExcelFolder {
    get folderName() {
        return 'xl';
    }
    childFiles(data) {
        const retVal = [
            ExcelFileTypes.StyleFile,
            ExcelFileTypes.WorkbookFile
        ];
        if (!data.isEmpty) {
            retVal.push(ExcelFileTypes.SharedStringsFile);
        }
        return retVal;
    }
    childFolders(data) {
        const retVal = [
            ExcelFolderTypes.XLRelsExcelFolder,
            ExcelFolderTypes.ThemeExcelFolder,
            ExcelFolderTypes.WorksheetsExcelFolder
        ];
        if (!data.isEmpty && data.options.exportAsTable) {
            retVal.push(ExcelFolderTypes.TablesExcelFolder);
        }
        return retVal;
    }
}
/** @hidden */
class XLRelsExcelFolder {
    get folderName() {
        return '_rels';
    }
    childFiles(data) {
        return [ExcelFileTypes.WorkbookRelsFile];
    }
    childFolders(data) {
        return [];
    }
}
/** @hidden */
class ThemeExcelFolder {
    get folderName() {
        return 'theme';
    }
    childFiles(data) {
        return [ExcelFileTypes.ThemeFile];
    }
    childFolders(data) {
        return [];
    }
}
/** @hidden */
class WorksheetsExcelFolder {
    get folderName() {
        return 'worksheets';
    }
    childFiles(data) {
        return [ExcelFileTypes.WorksheetFile];
    }
    childFolders(data) {
        return data.isEmpty || !data.options.exportAsTable ? [] : [ExcelFolderTypes.WorksheetsRelsExcelFolder];
    }
}
/** @hidden */
class TablesExcelFolder {
    get folderName() {
        return 'tables';
    }
    childFiles(data) {
        return [ExcelFileTypes.TablesFile];
    }
    childFolders(data) {
        return [];
    }
}
/** @hidden */
class WorksheetsRelsExcelFolder {
    get folderName() {
        return '_rels';
    }
    childFiles(data) {
        return [ExcelFileTypes.WorksheetRelsFile];
    }
    childFolders(data) {
        return [];
    }
}

/** @hidden */
class ExcelElementsFactory {
    static getExcelFolder(type) {
        switch (type) {
            case ExcelFolderTypes.RootExcelFolder:
                return new RootExcelFolder();
            case ExcelFolderTypes.RootRelsExcelFolder:
                return new RootRelsExcelFolder();
            case ExcelFolderTypes.DocPropsExcelFolder:
                return new DocPropsExcelFolder();
            case ExcelFolderTypes.XLExcelFolder:
                return new XLExcelFolder();
            case ExcelFolderTypes.XLRelsExcelFolder:
                return new XLRelsExcelFolder();
            case ExcelFolderTypes.ThemeExcelFolder:
                return new ThemeExcelFolder();
            case ExcelFolderTypes.WorksheetsExcelFolder:
                return new WorksheetsExcelFolder();
            case ExcelFolderTypes.WorksheetsRelsExcelFolder:
                return new WorksheetsRelsExcelFolder();
            case ExcelFolderTypes.TablesExcelFolder:
                return new TablesExcelFolder();
            default:
                throw new Error('Unknown excel folder type!');
        }
    }
    static getExcelFile(type) {
        switch (type) {
            case ExcelFileTypes.RootRelsFile:
                return new RootRelsFile();
            case ExcelFileTypes.AppFile:
                return new AppFile();
            case ExcelFileTypes.CoreFile:
                return new CoreFile();
            case ExcelFileTypes.WorkbookRelsFile:
                return new WorkbookRelsFile();
            case ExcelFileTypes.ThemeFile:
                return new ThemeFile();
            case ExcelFileTypes.WorksheetFile:
                return new WorksheetFile();
            case ExcelFileTypes.StyleFile:
                return new StyleFile();
            case ExcelFileTypes.WorkbookFile:
                return new WorkbookFile();
            case ExcelFileTypes.ContentTypesFile:
                return new ContentTypesFile();
            case ExcelFileTypes.SharedStringsFile:
                return new SharedStringsFile();
            case ExcelFileTypes.WorksheetRelsFile:
                return new WorksheetRelsFile();
            case ExcelFileTypes.TablesFile:
                return new TablesFile();
            default:
                throw Error('Unknown excel file type!');
        }
    }
}

/** @hidden */
class WorksheetDataDictionary {
    constructor(columnCount, columnWidth, columnWidthsList) {
        this.hasNonStringValues = false;
        this._dictionary = {};
        this._widthsDictionary = {};
        this._counter = 0;
        this.dirtyKeyCollections();
        this._columnWidths = new Array(columnCount);
        this._columnTypeInfo = new Array(columnCount);
        if (columnWidth) {
            this._columnWidths.fill(columnWidth);
        }
        else {
            this._columnWidths = columnWidthsList;
        }
        this.stringsCount = 0;
    }
    get columnWidths() {
        return this._columnWidths;
    }
    saveValue(value, column, isHeader) {
        if (this._columnTypeInfo[column] === undefined && isHeader === false) {
            this._columnTypeInfo[column] = typeof value !== 'number' && value !== Number(value) && !Number.isFinite(value);
        }
        let sanitizedValue = '';
        const isSavedAsString = this._columnTypeInfo[column] || isHeader;
        if (isSavedAsString) {
            sanitizedValue = this.sanitizeValue(value);
            if (this._dictionary[sanitizedValue] === undefined) {
                this._dictionary[sanitizedValue] = this._counter++;
                this.dirtyKeyCollections();
            }
            this.stringsCount++;
        }
        else {
            this.hasNonStringValues = true;
        }
        return isSavedAsString ? this.getSanitizedValue(sanitizedValue) : -1;
    }
    getValue(value) {
        return this.getSanitizedValue(this.sanitizeValue(value));
    }
    getSanitizedValue(sanitizedValue) {
        return this._dictionary[sanitizedValue];
    }
    getKeys() {
        if (!this._keysAreValid) {
            this._keys = Object.keys(this._dictionary);
            this._keysAreValid = true;
        }
        return this._keys;
    }
    getTextWidth(value) {
        if (this._widthsDictionary[value] === undefined) {
            const context = this.getContext();
            const metrics = context.measureText(value);
            this._widthsDictionary[value] = metrics.width + WorksheetDataDictionary.TEXT_PADDING;
        }
        return this._widthsDictionary[value];
    }
    getContext() {
        if (!this._context) {
            const canvas = document.createElement('canvas');
            this._context = canvas.getContext('2d');
            this._context.font = WorksheetDataDictionary.DEFAULT_FONT;
        }
        return this._context;
    }
    sanitizeValue(value) {
        if (ExportUtilities.hasValue(value) === false) {
            return '';
        }
        else {
            const stringValue = String(value);
            return stringValue.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }
    }
    dirtyKeyCollections() {
        this._keysAreValid = false;
    }
}
WorksheetDataDictionary.DEFAULT_FONT = '11pt Calibri';
WorksheetDataDictionary.TEXT_PADDING = 5;

/** @hidden */
class WorksheetData {
    constructor(_data, _columnWidths, options, indexOfLastPinnedColumn, sort, isTreeGridData = false) {
        this._data = _data;
        this._columnWidths = _columnWidths;
        this.options = options;
        this.indexOfLastPinnedColumn = indexOfLastPinnedColumn;
        this.sort = sort;
        this.isTreeGridData = isTreeGridData;
        this.initializeData();
    }
    get data() {
        return this._data;
    }
    get columnCount() {
        return this._columnCount;
    }
    get rowCount() {
        return this._rowCount;
    }
    get isEmpty() {
        return !this.rowCount || !this._columnCount;
    }
    get keys() {
        return this._keys;
    }
    get isSpecialData() {
        return this._isSpecialData;
    }
    get dataDictionary() {
        return this._dataDictionary;
    }
    initializeData() {
        if (!this._data || this._data.length === 0) {
            return;
        }
        const actualData = this._data.map((item) => item.rowData);
        this._keys = ExportUtilities.getKeysFromData(actualData);
        if (this._keys.length === 0) {
            return;
        }
        this._isSpecialData = ExportUtilities.isSpecialData(actualData);
        this._columnCount = this._keys.length;
        this._rowCount = this._data.length + 1;
        this._dataDictionary = new WorksheetDataDictionary(this._columnCount, this.options.columnWidth, this._columnWidths);
    }
}

/**
 * **Ignite UI for Angular Excel Exporter Service** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_excel.html)
 *
 * The Ignite UI for Angular Excel Exporter service can export data in Microsoft® Excel® format from both raw data
 * (array) or from an `IgxGrid`.
 *
 * Example:
 * ```typescript
 * public localData = [
 *   { Name: "Eric Ridley", Age: "26" },
 *   { Name: "Alanis Brook", Age: "22" },
 *   { Name: "Jonathan Morris", Age: "23" }
 * ];
 *
 * constructor(private excelExportService: IgxExcelExporterService) {
 * }
 *
 * this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions("FileName"));
 * ```
 */
class IgxExcelExporterService extends IgxBaseExporter {
    constructor() {
        super(...arguments);
        /**
         * This event is emitted when the export process finishes.
         * ```typescript
         * this.exporterService.onExportEnded.subscribe((args: IExcelExportEndedEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * @memberof IgxExcelExporterService
         */
        this.onExportEnded = new EventEmitter();
    }
    static populateFolderAsync(folder, zip, worksheetData) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const childFolder of folder.childFolders(worksheetData)) {
                const folderInstance = ExcelElementsFactory.getExcelFolder(childFolder);
                const zipFolder = zip.folder(folderInstance.folderName);
                yield IgxExcelExporterService.populateFolderAsync(folderInstance, zipFolder, worksheetData);
            }
            for (const childFile of folder.childFiles(worksheetData)) {
                const fileInstance = ExcelElementsFactory.getExcelFile(childFile);
                if (fileInstance instanceof WorksheetFile) {
                    yield fileInstance.writeElementAsync(zip, worksheetData);
                }
                else {
                    fileInstance.writeElement(zip, worksheetData);
                }
            }
        });
    }
    exportDataImplementation(data, options) {
        if (this._isTreeGrid) {
            let maxLevel = 0;
            data.forEach((r) => {
                maxLevel = Math.max(maxLevel, r.originalRowData.level);
            });
            if (maxLevel > 7) {
                throw Error('Can create an outline of up to eight levels!');
            }
        }
        const worksheetData = new WorksheetData(data, this.columnWidthList, options, this._indexOfLastPinnedColumn, this._sort, this._isTreeGrid);
        this._xlsx = new JSZip();
        const rootFolder = ExcelElementsFactory.getExcelFolder(ExcelFolderTypes.RootExcelFolder);
        IgxExcelExporterService.populateFolderAsync(rootFolder, this._xlsx, worksheetData)
            .then(() => {
            this._xlsx.generateAsync(IgxExcelExporterService.ZIP_OPTIONS).then((result) => {
                this.saveFile(result, options.fileName);
                this.onExportEnded.emit({ xlsx: this._xlsx });
            });
        });
    }
    saveFile(data, fileName) {
        const blob = new Blob([ExportUtilities.stringToArrayBuffer(atob(data))], {
            type: ''
        });
        ExportUtilities.saveBlobToFile(blob, fileName);
    }
}
IgxExcelExporterService.ɵfac = function IgxExcelExporterService_Factory(t) { return ɵIgxExcelExporterService_BaseFactory(t || IgxExcelExporterService); };
IgxExcelExporterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxExcelExporterService, factory: IgxExcelExporterService.ɵfac });
IgxExcelExporterService.ZIP_OPTIONS = { compression: 'DEFLATE', type: 'base64' };
IgxExcelExporterService.propDecorators = {
    onExportEnded: [{ type: Output }]
};

/**
 * Objects of this class are used to configure the Excel exporting process.
 */
class IgxExcelExporterOptions extends IgxExporterOptionsBase {
    constructor(fileName) {
        super(fileName, '.xlsx');
        /**
         * Specifies if column pinning should be ignored. If ignoreColumnsOrder is set to true,
         * this option will always be considered as set to true.
         * ```typescript
         * let ignorePinning = this.exportOptions.ignorePinning;
         * this.exportOptions.ignorePinning = true;
         * ```
         * @memberof IgxExcelExporterOptions
         */
        this.ignorePinning = false;
        /**
         * Specifies whether the exported data should be formatted as Excel table. (True by default)
         * ```typescript
         * let exportAsTable = this.exportOptions.exportAsTable;
         * this.exportOptions.exportAsTable = false;
         * ```
         * @memberof IgxExcelExporterOptions
         */
        this.exportAsTable = true;
    }
    /**
     * Gets the width of the columns in the exported excel file.
     * ```typescript
     * let width = this.exportOptions.columnWidth;
     * ```
     * @memberof IgxExcelExporterOptions
     */
    get columnWidth() {
        return this._columnWidth;
    }
    /**
     * Sets the width of the columns in the exported excel file. If left unspecified,
     * the width of the column or the default width of the excel columns will be used.
     * ```typescript
     * this.exportOptions.columnWidth = 55;
     * ```
     * @memberof IgxExcelExporterOptions
     */
    set columnWidth(value) {
        if (value < 0) {
            throw Error('Invalid value for column width!');
        }
        this._columnWidth = value;
    }
    /**
     * Gets the height of the rows in the exported excel file.
     * ```typescript
     * let height = this.exportOptions.rowHeight;
     * ```
     * @memberof IgxExcelExporterOptions
     */
    get rowHeight() {
        return this._rowHeight;
    }
    /**
     * Sets the height of the rows in the exported excel file. If left unspecified or 0,
     * the default height of the excel rows will be used.
     * ```typescript
     * this.exportOptions.rowHeight = 25;
     * ```
     * @memberof IgxExcelExporterOptions
     */
    set rowHeight(value) {
        if (value < 0) {
            throw Error('Invalid value for row height!');
        }
        this._rowHeight = value;
    }
    /**
     * Gets the name of the worksheet in the exported excel file.
     * ```typescript
     * let worksheetName = this.exportOptions.worksheetName;
     * ```
     * @memberof IgxExcelExporterOptions
     */
    get worksheetName() {
        if (this._worksheetName === undefined || this._worksheetName === null) {
            return 'Sheet1';
        }
        return this._worksheetName;
    }
    /**
     * Sets the name of the worksheet in the exported excel file.
     * ```typescript
     * this.exportOptions.worksheetName = "Worksheet";
     * ```
     * @memberof IgxExcelExporterOptions
     */
    set worksheetName(value) {
        this._worksheetName = value;
    }
}

/**
 * @hidden
 */
function DeprecateClass(message) {
    let isMessageShown = false;
    return function (originalClass) {
        return class extends originalClass {
            constructor(...args) {
                const target = originalClass;
                const targetName = typeof target === 'function' ? target.name : target.constructor.name;
                isMessageShown = showMessage(`${targetName}: ${message}`, isMessageShown);
                super(...args);
            }
        };
    };
}
/**
 * @hidden
 */
function DeprecateMethod(message) {
    let isMessageShown = false;
    return function (target, key, descriptor) {
        if (descriptor && descriptor.value) {
            const originalMethod = descriptor.value;
            descriptor.value = function () {
                const targetName = typeof target === 'function' ? target.name : target.constructor.name;
                isMessageShown = showMessage(`${targetName}.${key}: ${message}`, isMessageShown);
                return originalMethod.call(this, arguments);
            };
            return descriptor;
        }
    };
}
/**
 * @hidden
 */
function DeprecateProperty(message) {
    return function (target, key) {
        let isMessageShown = false;
        const messageToDisplay = `${target.constructor.name}.${key}: ${message}`;
        // if the target already has the property defined
        const originalDescriptor = Object.getOwnPropertyDescriptor(target, key);
        if (originalDescriptor) {
            let getter, setter;
            getter = originalDescriptor.get;
            setter = originalDescriptor.set;
            if (getter) {
                originalDescriptor.get = function () {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    return getter.call(this);
                };
            }
            if (setter) {
                originalDescriptor.set = function (value) {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    setter.call(this, value);
                };
            }
            return originalDescriptor;
        }
        // the target doesn't contain a descriptor for that property, so create one
        // use backing field to set/get the value of the property to ensure there won't be infinite recursive calls
        const newKey = generateUniqueKey(target, key);
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: true,
            set: function (value) {
                isMessageShown = showMessage(messageToDisplay, isMessageShown);
                this[newKey] = value;
            },
            get: function () {
                isMessageShown = showMessage(messageToDisplay, isMessageShown);
                return this[newKey];
            }
        });
    };
}
/**
 * @hidden
 */
function generateUniqueKey(target, key) {
    let newKey = '_' + key;
    while (target.hasOwnProperty(newKey)) {
        newKey = '_' + newKey;
    }
    return newKey;
}
/**
 * @hidden
 */
function showMessage(message, isMessageShown) {
    if (!isMessageShown && isDevMode()) {
        console.warn(message);
    }
    return true;
}

var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment[HorizontalAlignment["Left"] = -1] = "Left";
    HorizontalAlignment[HorizontalAlignment["Center"] = -0.5] = "Center";
    HorizontalAlignment[HorizontalAlignment["Right"] = 0] = "Right";
})(HorizontalAlignment || (HorizontalAlignment = {}));
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Top"] = -1] = "Top";
    VerticalAlignment[VerticalAlignment["Middle"] = -0.5] = "Middle";
    VerticalAlignment[VerticalAlignment["Bottom"] = 0] = "Bottom";
})(VerticalAlignment || (VerticalAlignment = {}));
/**
 * Defines the possible values of the overlays' position strategy.
 */
var RelativePositionStrategy;
(function (RelativePositionStrategy) {
    RelativePositionStrategy["Connected"] = "connected";
    RelativePositionStrategy["Auto"] = "auto";
    RelativePositionStrategy["Elastic"] = "elastic";
})(RelativePositionStrategy || (RelativePositionStrategy = {}));
/**
 * Defines the possible positions for the relative overlay settings presets.
 */
var RelativePosition;
(function (RelativePosition) {
    RelativePosition["Above"] = "above";
    RelativePosition["Below"] = "below";
    RelativePosition["Before"] = "before";
    RelativePosition["After"] = "after";
    RelativePosition["Default"] = "default";
})(RelativePosition || (RelativePosition = {}));
/**
 * Defines the possible positions for the absolute overlay settings presets.
 */
var AbsolutePosition;
(function (AbsolutePosition) {
    AbsolutePosition["Bottom"] = "bottom";
    AbsolutePosition["Top"] = "top";
    AbsolutePosition["Center"] = "center";
})(AbsolutePosition || (AbsolutePosition = {}));
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}
/** @hidden */
class Util {
    /**
     * @hidden
     * Calculates the rectangle of target for provided overlay settings. Defaults to 0,0,0,0,0,0 rectangle
     * if no target is provided
     * @param settings Overlay settings for which to calculate target rectangle
     */
    static getTargetRect(target) {
        let targetRect = {
            bottom: 0,
            height: 0,
            left: 0,
            right: 0,
            top: 0,
            width: 0
        };
        if (target instanceof HTMLElement) {
            targetRect = target.getBoundingClientRect();
        }
        else if (target instanceof Point) {
            const targetPoint = target;
            targetRect = {
                bottom: targetPoint.y,
                height: 0,
                left: targetPoint.x,
                right: targetPoint.x,
                top: targetPoint.y,
                width: 0
            };
        }
        return targetRect;
    }
    /** @hidden @internal */
    static getViewportRect(document) {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const scrollPosition = Util.getViewportScrollPosition(document);
        return {
            top: scrollPosition.y,
            left: scrollPosition.x,
            right: scrollPosition.x + width,
            bottom: scrollPosition.y + height,
            width: width,
            height: height,
        };
    }
    /** @hidden @internal */
    static getViewportScrollPosition(document) {
        const documentElement = document.documentElement;
        const documentRect = documentElement.getBoundingClientRect();
        const horizontalScrollPosition = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;
        const verticalScrollPosition = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;
        return new Point(horizontalScrollPosition, verticalScrollPosition);
    }
    /** @hidden @internal */
    static cloneInstance(object) {
        const clonedObj = Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        clonedObj.settings = cloneValue(clonedObj.settings);
        return clonedObj;
    }
}

/**
 * Positions the element based on the directions and start point passed in trough PositionSettings.
 * It is possible to either pass a start point or an HTMLElement as a positioning base.
 */
class ConnectedPositioningStrategy {
    constructor(settings) {
        this._defaultSettings = {
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom,
            openAnimation: scaleInVerTop,
            closeAnimation: scaleOutVerTop,
            minSize: { width: 0, height: 0 }
        };
        this.settings = Object.assign({}, this._defaultSettings, settings);
    }
    /**
     * Obtains the ClientRect objects for the required elements - target and element to position
     * @returns target and element ClientRect objects
     */
    calculateElementRectangles(contentElement, target) {
        return {
            targetRect: Util.getTargetRect(target),
            elementRect: contentElement.getBoundingClientRect()
        };
    }
    /** @inheritdoc */
    position(contentElement, size, document, initialCall, target) {
        const targetElement = target || this.settings.target;
        const rects = this.calculateElementRectangles(contentElement, targetElement);
        this.setStyle(contentElement, rects.targetRect, rects.elementRect, {});
    }
    /**
     * @inheritdoc
     * Creates clone of this position strategy
     * @returns clone of this position strategy
     */
    clone() {
        return Util.cloneInstance(this);
    }
    /**
     * Sets element's style which effectively positions provided element according
     * to provided position settings
     * @param element Element to position
     * @param targetRect Bounding rectangle of strategy target
     * @param elementRect Bounding rectangle of the element
     */
    setStyle(element, targetRect, elementRect, connectedFit) {
        const horizontalOffset = connectedFit.horizontalOffset ? connectedFit.horizontalOffset : 0;
        const verticalOffset = connectedFit.verticalOffset ? connectedFit.verticalOffset : 0;
        const startPoint = {
            x: targetRect.right + targetRect.width * this.settings.horizontalStartPoint + horizontalOffset,
            y: targetRect.bottom + targetRect.height * this.settings.verticalStartPoint + verticalOffset
        };
        const wrapperRect = element.parentElement.getBoundingClientRect();
        //  clean up styles - if auto position strategy is chosen we may pass here several times
        element.style.right = '';
        element.style.left = '';
        element.style.bottom = '';
        element.style.top = '';
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                element.style.right = `${Math.round(wrapperRect.right - startPoint.x)}px`;
                break;
            case HorizontalAlignment.Center:
                element.style.left = `${Math.round(startPoint.x - wrapperRect.left - elementRect.width / 2)}px`;
                break;
            case HorizontalAlignment.Right:
                element.style.left = `${Math.round(startPoint.x - wrapperRect.left)}px`;
                break;
        }
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                element.style.bottom = `${Math.round(wrapperRect.bottom - startPoint.y)}px`;
                break;
            case VerticalAlignment.Middle:
                element.style.top = `${Math.round(startPoint.y - wrapperRect.top - elementRect.height / 2)}px`;
                break;
            case VerticalAlignment.Bottom:
                element.style.top = `${Math.round(startPoint.y - wrapperRect.top)}px`;
                break;
        }
    }
}

/**
 * Positions the element based on the directions passed in trough PositionSettings.
 * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
 */
class GlobalPositionStrategy {
    constructor(settings) {
        this._defaultSettings = {
            horizontalDirection: HorizontalAlignment.Center,
            verticalDirection: VerticalAlignment.Middle,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle,
            openAnimation: fadeIn,
            closeAnimation: fadeOut,
            minSize: { width: 0, height: 0 }
        };
        this.settings = Object.assign({}, this._defaultSettings, settings);
    }
    /** @inheritdoc */
    position(contentElement, size, document, initialCall) {
        contentElement.classList.add('igx-overlay__content--relative');
        contentElement.parentElement.classList.add('igx-overlay__wrapper--flex');
        this.setPosition(contentElement, this.settings);
    }
    setPosition(contentElement, settings) {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                contentElement.parentElement.style.justifyContent = 'flex-start';
                break;
            case HorizontalAlignment.Center:
                contentElement.parentElement.style.justifyContent = 'center';
                break;
            case HorizontalAlignment.Right:
                contentElement.parentElement.style.justifyContent = 'flex-end';
                break;
            default:
                break;
        }
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                contentElement.parentElement.style.alignItems = 'flex-start';
                break;
            case VerticalAlignment.Middle:
                contentElement.parentElement.style.alignItems = 'center';
                break;
            case VerticalAlignment.Bottom:
                contentElement.parentElement.style.alignItems = 'flex-end';
                break;
            default:
                break;
        }
    }
    /** @inheritdoc */
    clone() {
        return Util.cloneInstance(this);
    }
}

class ScrollStrategy {
    constructor(scrollContainer) { }
}

/**
 * Empty scroll strategy. Does nothing.
 */
class NoOpScrollStrategy extends ScrollStrategy {
    constructor(scrollContainer) {
        super(scrollContainer);
    }
    /** @inheritdoc */
    initialize(document, overlayService, id) { }
    /** @inheritdoc */
    attach() { }
    /** @inheritdoc */
    detach() { }
}

/**
 * Positions the element inside the containing outlet based on the directions passed in trough PositionSettings.
 * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
 */
class ContainerPositionStrategy extends GlobalPositionStrategy {
    constructor(settings) {
        super(settings);
    }
    /** @inheritdoc */
    position(contentElement, size, document, initialCall) {
        contentElement.classList.add('igx-overlay__content--relative');
        contentElement.parentElement.classList.add('igx-overlay__wrapper--flex-container');
        this.setPosition(contentElement, this.settings);
    }
}

class BaseFitPositionStrategy extends ConnectedPositioningStrategy {
    /** @inheritdoc */
    position(contentElement, size, document, initialCall, target) {
        const targetElement = target || this.settings.target;
        const rects = super.calculateElementRectangles(contentElement, targetElement);
        const connectedFit = {};
        if (initialCall) {
            connectedFit.targetRect = rects.targetRect;
            connectedFit.contentElementRect = rects.elementRect;
            this._initialSettings = this._initialSettings || Object.assign({}, this.settings);
            this.settings = Object.assign({}, this._initialSettings);
            connectedFit.viewPortRect = Util.getViewportRect(document);
            this.updateViewPortFit(connectedFit);
            if (this.shouldFitInViewPort(connectedFit)) {
                this.fitInViewport(contentElement, connectedFit);
            }
        }
        this.setStyle(contentElement, rects.targetRect, rects.elementRect, connectedFit);
    }
    /**
     * Checks if element can fit in viewport and updates provided connectedFit
     * with the result
     * @param connectedFit connectedFit to update
     */
    updateViewPortFit(connectedFit) {
        connectedFit.left = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.horizontalStartPoint, this.settings.horizontalDirection, connectedFit.horizontalOffset ? connectedFit.horizontalOffset : 0);
        connectedFit.right = connectedFit.left + connectedFit.contentElementRect.width;
        connectedFit.fitHorizontal = {
            back: Math.round(connectedFit.left),
            forward: Math.round(connectedFit.viewPortRect.width - connectedFit.right)
        };
        connectedFit.top = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.verticalStartPoint, this.settings.verticalDirection, connectedFit.verticalOffset ? connectedFit.verticalOffset : 0);
        connectedFit.bottom = connectedFit.top + connectedFit.contentElementRect.height;
        connectedFit.fitVertical = {
            back: Math.round(connectedFit.top),
            forward: Math.round(connectedFit.viewPortRect.height - connectedFit.bottom)
        };
    }
    /**
     * Calculates the position of the left border of the element if it gets positioned
     * with provided start point and direction
     * @param targetRect Rectangle of the target where element is attached
     * @param elementRect Rectangle of the element
     * @param startPoint Start point of the target
     * @param direction Direction in which to show the element
     */
    calculateLeft(targetRect, elementRect, startPoint, direction, offset) {
        return targetRect.right + targetRect.width * startPoint + elementRect.width * direction + offset;
    }
    /**
     * Calculates the position of the top border of the element if it gets positioned
     * with provided position settings related to the target
     * @param targetRect Rectangle of the target where element is attached
     * @param elementRect Rectangle of the element
     * @param startPoint Start point of the target
     * @param direction Direction in which to show the element
     */
    calculateTop(targetRect, elementRect, startPoint, direction, offset) {
        return targetRect.bottom + targetRect.height * startPoint + elementRect.height * direction + offset;
    }
    /**
     * Returns whether the element should fit in viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     */
    shouldFitInViewPort(connectedFit) {
        return connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0 ||
            connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0;
    }
}

/**
 * Positions the element as in **Connected** positioning strategy and resize the element
 * to fit in the view port in case the element is partially getting out of view
 */
class ElasticPositionStrategy extends BaseFitPositionStrategy {
    /** @inheritdoc */
    fitInViewport(element, connectedFit) {
        element.classList.add('igx-overlay__content--elastic');
        const transformString = [];
        if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
            const maxReduction = Math.max(0, connectedFit.contentElementRect.width - this.settings.minSize.width);
            const leftExtend = Math.max(0, -connectedFit.fitHorizontal.back);
            const rightExtend = Math.max(0, -connectedFit.fitHorizontal.forward);
            const reduction = Math.min(maxReduction, leftExtend + rightExtend);
            element.style.width = `${connectedFit.contentElementRect.width - reduction}px`;
            //  if direction is center and element goes off the screen in left direction we should push the
            //  element to the right. Prevents left still going out of view when normally positioned
            if (this.settings.horizontalDirection === HorizontalAlignment.Center) {
                //  the amount of translation depends on whether element goes off the screen to the left,
                //  to the right or in both directions, as well as how much it goes of the screen and finally
                //  on the minSize. The translation should be proportional between left and right extend
                //  taken from the reduction
                const translation = leftExtend * reduction / (leftExtend + rightExtend);
                if (translation > 0) {
                    transformString.push(`translateX(${translation}px)`);
                }
            }
        }
        if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
            const maxReduction = Math.max(0, connectedFit.contentElementRect.height - this.settings.minSize.height);
            const topExtend = Math.max(0, -connectedFit.fitVertical.back);
            const bottomExtend = Math.max(0, -connectedFit.fitVertical.forward);
            const reduction = Math.min(maxReduction, topExtend + bottomExtend);
            element.style.height = `${connectedFit.contentElementRect.height - reduction}px`;
            //  if direction is middle and element goes off the screen in top direction we should push the
            //  element to the bottom. Prevents top still going out of view when normally positioned
            if (this.settings.verticalDirection === VerticalAlignment.Middle) {
                //  the amount of translation depends on whether element goes off the screen to the top,
                //  to the bottom or in both directions, as well as how much it goes of the screen and finally
                //  on the minSize. The translation should be proportional between top and bottom extend
                //  taken from the reduction
                const translation = topExtend * reduction / (topExtend + bottomExtend);
                if (translation > 0) {
                    transformString.push(`translateY(${translation}px)`);
                }
            }
        }
        element.style.transform = transformString.join(' ').trim();
    }
}

/**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
class AutoPositionStrategy extends BaseFitPositionStrategy {
    /** @inheritdoc */
    fitInViewport(element, connectedFit) {
        const transformString = [];
        if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
            if (this.canFlipHorizontal(connectedFit)) {
                this.flipHorizontal();
            }
            else {
                const horizontalPush = this.horizontalPush(connectedFit);
                transformString.push(`translateX(${horizontalPush}px)`);
            }
        }
        if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
            if (this.canFlipVertical(connectedFit)) {
                this.flipVertical();
            }
            else {
                const verticalPush = this.verticalPush(connectedFit);
                transformString.push(`translateY(${verticalPush}px)`);
            }
        }
        element.style.transform = transformString.join(' ').trim();
    }
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    canFlipHorizontal(connectedFit) {
        //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
        //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
        //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
        //  this way:
        //  (-1) * (Left + 1) = 0 = Right
        //  (-1) * (Center + 1) = -0.5 = Center
        //  (-1) * (Right + 1) = -1 = Left
        const flippedStartPoint = (-1) * (this.settings.horizontalStartPoint + 1);
        const flippedDirection = (-1) * (this.settings.horizontalDirection + 1);
        const leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        const rightBorder = leftBorder + connectedFit.contentElementRect.width;
        return 0 < leftBorder && rightBorder < connectedFit.viewPortRect.width;
    }
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    canFlipVertical(connectedFit) {
        const flippedStartPoint = (-1) * (this.settings.verticalStartPoint + 1);
        const flippedDirection = (-1) * (this.settings.verticalDirection + 1);
        const topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        const bottomBorder = topBorder + connectedFit.contentElementRect.height;
        return 0 < topBorder && bottomBorder < connectedFit.viewPortRect.height;
    }
    /**
     * Flips direction and start point of the position settings
     */
    flipHorizontal() {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                this.settings.horizontalDirection = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalDirection = HorizontalAlignment.Left;
                break;
        }
        switch (this.settings.horizontalStartPoint) {
            case HorizontalAlignment.Left:
                this.settings.horizontalStartPoint = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalStartPoint = HorizontalAlignment.Left;
                break;
        }
    }
    /**
     * Flips direction and start point of the position settings
     */
    flipVertical() {
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                this.settings.verticalDirection = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalDirection = VerticalAlignment.Top;
                break;
        }
        switch (this.settings.verticalStartPoint) {
            case VerticalAlignment.Top:
                this.settings.verticalStartPoint = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalStartPoint = VerticalAlignment.Top;
                break;
        }
    }
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    horizontalPush(connectedFit) {
        const leftExtend = connectedFit.left;
        const rightExtend = connectedFit.right - connectedFit.viewPortRect.width;
        //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
        //  as much as it is beyond the screen.
        //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
        //  extend but with amount not bigger than what left between left border of screen and left border of
        //  overlay, e.g. leftExtend
        if (leftExtend < 0) {
            return Math.abs(leftExtend);
        }
        else if (rightExtend > 0) {
            return -Math.min(rightExtend, leftExtend);
        }
        else {
            return 0;
        }
    }
    /**
     * Calculates necessary vertical push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    verticalPush(connectedFit) {
        const topExtend = connectedFit.top;
        const bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.height;
        if (topExtend < 0) {
            return Math.abs(topExtend);
        }
        else if (bottomExtend > 0) {
            return -Math.min(bottomExtend, topExtend);
        }
        else {
            return 0;
        }
    }
}

let warningShown = false;
/**
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/overlay-main)
 * The overlay service allows users to show components on overlay div above all other elements in the page.
 */
class IgxOverlayService {
    constructor(_factoryResolver, _appRef, _injector, builder, document, _zone, platformUtil) {
        this._factoryResolver = _factoryResolver;
        this._appRef = _appRef;
        this._injector = _injector;
        this.builder = builder;
        this.document = document;
        this._zone = _zone;
        this.platformUtil = platformUtil;
        this._componentId = 0;
        this._overlayInfos = [];
        this.destroy$ = new Subject();
        this._cursorStyleIsSet = false;
        this._defaultSettings = {
            excludeFromOutsideClick: [],
            positionStrategy: new GlobalPositionStrategy(),
            scrollStrategy: new NoOpScrollStrategy(),
            modal: true,
            closeOnOutsideClick: true,
            closeOnEscape: false
        };
        /**
         * Emitted before the component is opened.
         * ```typescript
         * onOpening(event: OverlayCancelableEventArgs){
         *     const onOpening = event;
         * }
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted after the component is appended to the overlay, and before animations are started.
         * ```typescript
         * onAppended(event: OverlayEventArgs){
         *     const onAppended = event;
         * }
         * ```
         */
        this.onAppended = new EventEmitter();
        /**
         * Emitted after the component is opened and all animations are finished.
         * ```typescript
         * onOpened(event: OverlayEventArgs){
         *     const onOpened = event;
         * }
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted before the component is closed.
         * ```typescript
         * onClosing(event: OverlayCancelableEventArgs){
         *     const onClosing = event;
         * }
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted after the component is closed and all animations are finished.
         * ```typescript
         * onClosed(event: OverlayEventArgs){
         *     const onClosed = event;
         * }
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted before animation is started
         * ```typescript
         * onAnimation(event: OverlayAnimationEventArgs){
         *     const onAnimation = event;
         * }
         * ```
         */
        this.onAnimation = new EventEmitter();
        this.documentClicked = (ev) => {
            //  if we get to modal overlay just return - we should not close anything under it
            //  if we get to non-modal overlay do the next:
            //   1. Check it has close on outside click. If not go on to next overlay;
            //   2. If true check if click is on the element. If it is on the element we have closed
            //  already all previous non-modal with close on outside click elements, so we return. If
            //  not close the overlay and check next
            for (let i = this._overlayInfos.length; i--;) {
                const info = this._overlayInfos[i];
                if (info.settings.modal) {
                    return;
                }
                if (info.settings.closeOnOutsideClick) {
                    const target = ev.target;
                    const overlayElement = info.elementRef.nativeElement;
                    // check if the click is on the overlay element or on an element from the exclusion list, and if so do not close the overlay
                    const excludeElements = info.settings.excludeFromOutsideClick ?
                        [...info.settings.excludeFromOutsideClick, overlayElement] : [overlayElement];
                    const isInsideClick = excludeElements.some(e => e.contains(target));
                    if (isInsideClick) {
                        return;
                        //  if the click is outside click, but close animation has started do nothing
                    }
                    else if (!(info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted())) {
                        this._hide(info.id, ev);
                    }
                }
            }
        };
        /** @hidden */
        this.repositionAll = () => {
            for (let i = this._overlayInfos.length; i--;) {
                this.reposition(this._overlayInfos[i].id);
            }
        };
        this._document = this.document;
    }
    /**
     * Creates overlay settings with global or container position strategy and preset position settings
     * @param position Preset position settings. Default position is 'center'
     * @param outlet The outlet container to attach the overlay to
     * @returns Non-modal overlay settings based on Global or Container position strategy and the provided position.
     */
    static createAbsoluteOverlaySettings(position, outlet) {
        const positionSettings = this.createAbsolutePositionSettings(position);
        const strategy = outlet ? new ContainerPositionStrategy(positionSettings) : new GlobalPositionStrategy(positionSettings);
        const overlaySettings = {
            positionStrategy: strategy,
            scrollStrategy: new NoOpScrollStrategy(),
            modal: false,
            closeOnOutsideClick: true,
            outlet: outlet
        };
        return overlaySettings;
    }
    /**
     * Creates overlay settings with auto, connected or elastic position strategy and preset position settings
     * @param target Attaching target for the component to show
     * @param strategy The relative position strategy to be applied to the overlay settings. Default is Auto positioning strategy.
     * @param position Preset position settings. By default the element is positioned below the target, left aligned.
     * @returns Non-modal overlay settings based on the provided target, strategy and position.
     */
    static createRelativeOverlaySettings(target, position, strategy) {
        const positionSettings = this.createRelativePositionSettings(position);
        const overlaySettings = {
            target: target,
            positionStrategy: this.createPositionStrategy(strategy, positionSettings),
            scrollStrategy: new NoOpScrollStrategy(),
            modal: false,
            closeOnOutsideClick: true
        };
        return overlaySettings;
    }
    static createAbsolutePositionSettings(position) {
        let positionSettings;
        switch (position) {
            case AbsolutePosition.Bottom:
                positionSettings = {
                    horizontalDirection: HorizontalAlignment.Center,
                    verticalDirection: VerticalAlignment.Bottom,
                    openAnimation: slideInBottom,
                    closeAnimation: slideOutBottom
                };
                break;
            case AbsolutePosition.Top:
                positionSettings = {
                    horizontalDirection: HorizontalAlignment.Center,
                    verticalDirection: VerticalAlignment.Top,
                    openAnimation: slideInTop,
                    closeAnimation: slideOutTop
                };
                break;
            case AbsolutePosition.Center:
            default:
                positionSettings = {
                    horizontalDirection: HorizontalAlignment.Center,
                    verticalDirection: VerticalAlignment.Middle,
                    openAnimation: fadeIn,
                    closeAnimation: fadeOut
                };
        }
        return positionSettings;
    }
    static createRelativePositionSettings(position) {
        let positionSettings;
        switch (position) {
            case RelativePosition.Above:
                positionSettings = {
                    horizontalStartPoint: HorizontalAlignment.Center,
                    verticalStartPoint: VerticalAlignment.Top,
                    horizontalDirection: HorizontalAlignment.Center,
                    verticalDirection: VerticalAlignment.Top,
                    openAnimation: scaleInVerBottom,
                    closeAnimation: scaleOutVerBottom,
                };
                break;
            case RelativePosition.Below:
                positionSettings = {
                    horizontalStartPoint: HorizontalAlignment.Center,
                    verticalStartPoint: VerticalAlignment.Bottom,
                    horizontalDirection: HorizontalAlignment.Center,
                    verticalDirection: VerticalAlignment.Bottom,
                    openAnimation: scaleInVerTop,
                    closeAnimation: scaleOutVerTop
                };
                break;
            case RelativePosition.After:
                positionSettings = {
                    horizontalStartPoint: HorizontalAlignment.Right,
                    verticalStartPoint: VerticalAlignment.Middle,
                    horizontalDirection: HorizontalAlignment.Right,
                    verticalDirection: VerticalAlignment.Middle,
                    openAnimation: scaleInHorLeft,
                    closeAnimation: scaleOutHorLeft
                };
                break;
            case RelativePosition.Before:
                positionSettings = {
                    horizontalStartPoint: HorizontalAlignment.Left,
                    verticalStartPoint: VerticalAlignment.Middle,
                    horizontalDirection: HorizontalAlignment.Left,
                    verticalDirection: VerticalAlignment.Middle,
                    openAnimation: scaleInHorRight,
                    closeAnimation: scaleOutHorRight
                };
                break;
            case RelativePosition.Default:
            default:
                positionSettings = {
                    horizontalStartPoint: HorizontalAlignment.Left,
                    verticalStartPoint: VerticalAlignment.Bottom,
                    horizontalDirection: HorizontalAlignment.Right,
                    verticalDirection: VerticalAlignment.Bottom,
                    openAnimation: scaleInVerTop,
                    closeAnimation: scaleOutVerTop,
                };
                break;
        }
        return positionSettings;
    }
    static createPositionStrategy(strategy, positionSettings) {
        switch (strategy) {
            case RelativePositionStrategy.Connected:
                return new ConnectedPositioningStrategy(positionSettings);
            case RelativePositionStrategy.Elastic:
                return new ElasticPositionStrategy(positionSettings);
            case RelativePositionStrategy.Auto:
            default:
                return new AutoPositionStrategy(positionSettings);
        }
    }
    attach(component, settings, moduleRef) {
        let info;
        info = this.getOverlayInfo(component, moduleRef);
        //  if there is no info most probably wrong type component was provided and we just go out
        if (!info) {
            return null;
        }
        info.id = (this._componentId++).toString();
        settings = Object.assign({}, this._defaultSettings, settings);
        info.settings = settings;
        this._overlayInfos.push(info);
        return info.id;
    }
    show(compOrId, settings) {
        let info;
        let id;
        if (typeof compOrId === 'string') {
            id = compOrId;
            info = this.getOverlayById(compOrId);
            if (!info) {
                console.warn('igxOverlay.show was called with wrong id: ' + compOrId);
                return null;
            }
        }
        else {
            warningShown = showMessage('`show(component, settings?)` overload is deprecated. Use `attach(component)` to obtain an Id.' +
                'Then `show(id, settings?)` with provided Id.', warningShown);
            id = (this._componentId++).toString();
            info = this.getOverlayInfo(compOrId);
            //  if there is no info most probably wrong type component was provided and we just go out
            if (!info) {
                return;
            }
            info.id = id;
        }
        settings = Object.assign({}, this._defaultSettings, info.settings, settings);
        info.settings = settings;
        this._show(info);
        return id;
    }
    /**
     * Hides the component with the ID provided as a parameter.
     * ```typescript
     * this.overlay.hide(id);
     * ```
     */
    hide(id) {
        this._hide(id);
    }
    /**
     * Hides all the components and the overlay.
     * ```typescript
     * this.overlay.hideAll();
     * ```
     */
    hideAll() {
        // since overlays are removed on animation done, que all hides
        for (let i = this._overlayInfos.length; i--;) {
            this.hide(this._overlayInfos[i].id);
        }
    }
    /**
     * Repositions the component with ID provided as a parameter.
     * ```typescript
     * this.overlay.reposition(id);
     * ```
     */
    reposition(id) {
        const overlayInfo = this.getOverlayById(id);
        if (!overlayInfo || !overlayInfo.settings) {
            console.error('Wrong id provided in overlay.reposition method. Id: ' + id);
            return;
        }
        const contentElement = overlayInfo.elementRef.nativeElement.parentElement;
        const contentElementRect = contentElement.getBoundingClientRect();
        overlayInfo.settings.positionStrategy.position(contentElement, {
            width: contentElementRect.width,
            height: contentElementRect.height
        }, this._document, false, overlayInfo.settings.target);
    }
    /**
     * Offsets the content along the corresponding axis by the provided amount
     * ```typescript
     * this.overlay.setOffset(id, deltaX, deltaY);
     * ```
     */
    setOffset(id, deltaX, deltaY) {
        const info = this.getOverlayById(id);
        if (!info) {
            return;
        }
        info.transformX += deltaX;
        info.transformY += deltaY;
        const transformX = info.transformX;
        const transformY = info.transformY;
        const translate = `translate(${transformX}px, ${transformY}px)`;
        info.elementRef.nativeElement.parentElement.style.transform = translate;
    }
    _show(info) {
        const eventArgs = { id: info.id, componentRef: info.componentRef, cancel: false };
        this.onOpening.emit(eventArgs);
        if (eventArgs.cancel) {
            if (info.componentRef) {
                this._appRef.detachView(info.componentRef.hostView);
                info.componentRef.destroy();
            }
            return;
        }
        //  if there is no close animation player, or there is one but it is not started yet we are in clear
        //  opening. Otherwise, if there is close animation player playing animation now we should not setup
        //  overlay this is already done
        if (!info.closeAnimationPlayer || (info.closeAnimationPlayer && !info.closeAnimationPlayer.hasStarted())) {
            const elementRect = info.elementRef.nativeElement.getBoundingClientRect();
            info.initialSize = { width: elementRect.width, height: elementRect.height };
            info.hook = this.placeElementHook(info.elementRef.nativeElement);
            this.moveElementToOverlay(info);
            if (info.componentRef) {
                info.componentRef.changeDetectorRef.detectChanges();
            }
            this.onAppended.emit({ id: info.id, componentRef: info.componentRef });
            this.updateSize(info);
            if (this._overlayInfos.indexOf(info) === -1) {
                this._overlayInfos.push(info);
            }
            info.settings.positionStrategy.position(info.elementRef.nativeElement.parentElement, { width: info.initialSize.width, height: info.initialSize.height }, document, true, info.settings.target);
            info.settings.scrollStrategy.initialize(this._document, this, info.id);
            info.settings.scrollStrategy.attach();
        }
        this.addOutsideClickListener(info);
        this.addResizeHandler();
        this.addCloseOnEscapeListener(info);
        if (info.settings.modal) {
            const wrapperElement = info.elementRef.nativeElement.parentElement.parentElement;
            wrapperElement.classList.remove('igx-overlay__wrapper');
            this.applyAnimationParams(wrapperElement, info.settings.positionStrategy.settings.openAnimation);
            wrapperElement.classList.add('igx-overlay__wrapper--modal');
        }
        if (info.settings.positionStrategy.settings.openAnimation) {
            this.playOpenAnimation(info);
        }
        else {
            //  to eliminate flickering show the element just before onOpened fire
            info.elementRef.nativeElement.parentElement.style.visibility = '';
            this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
        }
    }
    _hide(id, event) {
        const info = this.getOverlayById(id);
        if (!info) {
            console.warn('igxOverlay.hide was called with wrong id: ' + id);
            return;
        }
        const eventArgs = { id, componentRef: info.componentRef, cancel: false, event };
        this.onClosing.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        //  TODO: synchronize where these are added/attached and where removed/detached
        info.settings.scrollStrategy.detach();
        this.removeOutsideClickListener(info);
        this.removeResizeHandler();
        const child = info.elementRef.nativeElement;
        if (info.settings.modal) {
            const parent = child.parentNode.parentNode;
            this.applyAnimationParams(parent, info.settings.positionStrategy.settings.closeAnimation);
            parent.classList.remove('igx-overlay__wrapper--modal');
            parent.classList.add('igx-overlay__wrapper');
        }
        if (info.settings.positionStrategy.settings.closeAnimation) {
            this.playCloseAnimation(info);
        }
        else {
            this.onCloseDone(info);
        }
    }
    getOverlayInfo(component, moduleRef) {
        const info = { ngZone: this._zone, transformX: 0, transformY: 0 };
        if (component instanceof ElementRef) {
            info.elementRef = component;
        }
        else {
            let dynamicFactory;
            const factoryResolver = moduleRef ? moduleRef.componentFactoryResolver : this._factoryResolver;
            try {
                dynamicFactory = factoryResolver.resolveComponentFactory(component);
            }
            catch (error) {
                console.error(error);
                return null;
            }
            const injector = moduleRef ? moduleRef.injector : this._injector;
            const dynamicComponent = dynamicFactory.create(injector);
            this._appRef.attachView(dynamicComponent.hostView);
            // If the element is newly created from a Component, it is wrapped in 'ng-component' tag - we do not want that.
            const element = dynamicComponent.location.nativeElement;
            info.elementRef = { nativeElement: element };
            info.componentRef = dynamicComponent;
        }
        return info;
    }
    placeElementHook(element) {
        if (!element.parentElement) {
            return null;
        }
        const hook = this._document.createElement('div');
        element.parentElement.insertBefore(hook, element);
        return hook;
    }
    moveElementToOverlay(info) {
        const wrapperElement = this.getWrapperElement();
        const contentElement = this.getContentElement(wrapperElement, info.settings.modal);
        this.getOverlayElement(info).appendChild(wrapperElement);
        contentElement.appendChild(info.elementRef.nativeElement);
    }
    getWrapperElement() {
        const wrapper = this._document.createElement('div');
        wrapper.classList.add('igx-overlay__wrapper');
        return wrapper;
    }
    getContentElement(wrapperElement, modal) {
        const content = this._document.createElement('div');
        if (modal) {
            content.classList.add('igx-overlay__content--modal');
            content.addEventListener('click', (ev) => {
                ev.stopPropagation();
            });
        }
        else {
            content.classList.add('igx-overlay__content');
        }
        content.addEventListener('scroll', (ev) => {
            ev.stopPropagation();
        });
        //  hide element to eliminate flickering. Show the element exactly before animation starts
        content.style.visibility = 'hidden';
        wrapperElement.appendChild(content);
        return content;
    }
    getOverlayElement(info) {
        if (info.settings.outlet) {
            return info.settings.outlet.nativeElement;
        }
        if (!this._overlayElement) {
            this._overlayElement = this._document.createElement('div');
            this._overlayElement.classList.add('igx-overlay');
            this._document.body.appendChild(this._overlayElement);
        }
        return this._overlayElement;
    }
    updateSize(info) {
        if (info.componentRef) {
            //  if we are positioning component this is first time it gets visible
            //  and we can finally get its size
            info.initialSize = info.elementRef.nativeElement.getBoundingClientRect();
        }
        // set content div width only if element to show has width
        if (info.initialSize.width !== 0) {
            info.elementRef.nativeElement.parentElement.style.width = info.initialSize.width + 'px';
        }
    }
    onCloseDone(info) {
        this.cleanUp(info);
        this.onClosed.emit({ id: info.id, componentRef: info.componentRef });
    }
    cleanUp(info) {
        const child = info.elementRef.nativeElement;
        const outlet = this.getOverlayElement(info);
        if (!outlet.contains(child)) {
            console.warn('Component with id:' + info.id + ' is already removed!');
            return;
        }
        outlet.removeChild(child.parentNode.parentNode);
        if (info.componentRef) {
            this._appRef.detachView(info.componentRef.hostView);
            info.componentRef.destroy();
        }
        if (info.hook) {
            info.hook.parentElement.insertBefore(info.elementRef.nativeElement, info.hook);
            info.hook.parentElement.removeChild(info.hook);
        }
        const index = this._overlayInfos.indexOf(info);
        this._overlayInfos.splice(index, 1);
        // this._overlayElement.parentElement check just for tests that manually delete the element
        if (this._overlayInfos.length === 0 && this._overlayElement && this._overlayElement.parentElement) {
            this._overlayElement.parentElement.removeChild(this._overlayElement);
            this._overlayElement = null;
            this.removeCloseOnEscapeListener();
        }
    }
    playOpenAnimation(info) {
        if (!info.openAnimationPlayer) {
            const animationBuilder = this.builder.build(info.settings.positionStrategy.settings.openAnimation);
            info.openAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
            //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack
            const innerRenderer = info.openAnimationPlayer._renderer;
            info.openAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.openAnimationPlayer.onDone(() => {
                this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
                if (info.openAnimationPlayer) {
                    info.openAnimationPlayer.reset();
                    info.openAnimationPlayer = null;
                }
                if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
                    info.closeAnimationPlayer.reset();
                }
            });
        }
        //  if there is opening animation already started do nothing
        if (info.openAnimationPlayer.hasStarted()) {
            return;
        }
        //  if there is closing animation already started start open animation from where close one has reached
        //  and remove close animation
        if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one
            const position = 1 - info.closeAnimationInnerPlayer.getPosition();
            info.closeAnimationPlayer.reset();
            info.closeAnimationPlayer = null;
            info.openAnimationPlayer.init();
            info.openAnimationPlayer.setPosition(position);
        }
        this.onAnimation.emit({ id: info.id, animationPlayer: info.openAnimationPlayer, animationType: 'open' });
        //  to eliminate flickering show the element just before animation start
        info.elementRef.nativeElement.parentElement.style.visibility = '';
        info.openAnimationPlayer.play();
    }
    playCloseAnimation(info) {
        if (!info.closeAnimationPlayer) {
            const animationBuilder = this.builder.build(info.settings.positionStrategy.settings.closeAnimation);
            info.closeAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
            //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack
            const innerRenderer = info.closeAnimationPlayer._renderer;
            info.closeAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.closeAnimationPlayer.onDone(() => {
                if (info.closeAnimationPlayer) {
                    info.closeAnimationPlayer.reset();
                    info.closeAnimationPlayer = null;
                }
                if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
                    info.openAnimationPlayer.reset();
                }
                this.onCloseDone(info);
            });
        }
        //  if there is closing animation already started do nothing
        if (info.closeAnimationPlayer.hasStarted()) {
            return;
        }
        //  if there is opening animation already started start close animation from where open one has reached
        //  and remove open animation
        if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one
            const position = 1 - info.openAnimationInnerPlayer.getPosition();
            info.openAnimationPlayer.reset();
            info.openAnimationPlayer = null;
            info.closeAnimationPlayer.init();
            info.closeAnimationPlayer.setPosition(position);
        }
        this.onAnimation.emit({ id: info.id, animationPlayer: info.closeAnimationPlayer, animationType: 'close' });
        info.closeAnimationPlayer.play();
    }
    //  TODO: check if applyAnimationParams will work with complex animations
    applyAnimationParams(wrapperElement, animationOptions) {
        if (!animationOptions) {
            wrapperElement.style.transitionDuration = '0ms';
            return;
        }
        if (animationOptions.type === 10 /* AnimateRef */) {
            animationOptions = animationOptions.animation;
        }
        if (!animationOptions.options || !animationOptions.options.params) {
            return;
        }
        const params = animationOptions.options.params;
        if (params.duration) {
            wrapperElement.style.transitionDuration = params.duration;
        }
        if (params.easing) {
            wrapperElement.style.transitionTimingFunction = params.easing;
        }
    }
    /** @hidden @internal */
    getOverlayById(id) {
        if (!id) {
            return null;
        }
        const info = this._overlayInfos.find(e => e.id === id);
        return info;
    }
    addOutsideClickListener(info) {
        if (info.settings.closeOnOutsideClick) {
            if (info.settings.modal) {
                fromEvent(info.elementRef.nativeElement.parentElement.parentElement, 'click')
                    .pipe(takeUntil(this.destroy$))
                    .subscribe((e) => this._hide(info.id, e));
            }
            else if (
            //  if all overlays minus closing overlays equals one add the handler
            this._overlayInfos.filter(x => x.settings.closeOnOutsideClick && !x.settings.modal).length -
                this._overlayInfos.filter(x => x.settings.closeOnOutsideClick && !x.settings.modal &&
                    x.closeAnimationPlayer &&
                    x.closeAnimationPlayer.hasStarted()).length === 1) {
                // click event is not fired on iOS. To make element "clickable" we are
                // setting the cursor to pointer
                if (this.platformUtil.isIOS && !this._cursorStyleIsSet) {
                    this._cursorOriginalValue = this._document.body.style.cursor;
                    this._document.body.style.cursor = 'pointer';
                    this._cursorStyleIsSet = true;
                }
                this._document.addEventListener('click', this.documentClicked, true);
            }
        }
    }
    removeOutsideClickListener(info) {
        if (info.settings.modal === false) {
            let shouldRemoveClickEventListener = true;
            this._overlayInfos.forEach(o => {
                if (o.settings.modal === false && o.id !== info.id) {
                    shouldRemoveClickEventListener = false;
                }
            });
            if (shouldRemoveClickEventListener) {
                if (this._cursorStyleIsSet) {
                    this._document.body.style.cursor = this._cursorOriginalValue;
                    this._cursorOriginalValue = '';
                    this._cursorStyleIsSet = false;
                }
                this._document.removeEventListener('click', this.documentClicked, true);
            }
        }
    }
    addResizeHandler() {
        const closingOverlaysCount = this._overlayInfos
            .filter(o => o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted())
            .length;
        if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.addEventListener('resize', this.repositionAll);
        }
    }
    removeResizeHandler() {
        const closingOverlaysCount = this._overlayInfos
            .filter(o => o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted())
            .length;
        if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.removeEventListener('resize', this.repositionAll);
        }
    }
    addCloseOnEscapeListener(info) {
        if (info.settings.closeOnEscape && !this._keyPressEventListener) {
            this._keyPressEventListener = fromEvent(this._document, 'keydown').pipe(filter((ev) => ev.key === 'Escape' || ev.key === 'Esc')).subscribe(() => {
                const targetOverlay = this._overlayInfos[this._overlayInfos.length - 1];
                if (targetOverlay.settings.closeOnEscape) {
                    this.hide(targetOverlay.id);
                }
            });
        }
    }
    removeCloseOnEscapeListener() {
        if (this._keyPressEventListener) {
            this._keyPressEventListener.unsubscribe();
            this._keyPressEventListener = null;
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
}
IgxOverlayService.ɵfac = function IgxOverlayService_Factory(t) { return new (t || IgxOverlayService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ɵngcc1.AnimationBuilder), ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PlatformUtil)); };
IgxOverlayService.ɵprov = ɵɵdefineInjectable({ factory: function IgxOverlayService_Factory() { return new IgxOverlayService(ɵɵinject(ComponentFactoryResolver), ɵɵinject(ApplicationRef), ɵɵinject(INJECTOR), ɵɵinject(AnimationBuilder), ɵɵinject(DOCUMENT), ɵɵinject(NgZone), ɵɵinject(PlatformUtil)); }, token: IgxOverlayService, providedIn: "root" });
IgxOverlayService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: Injector },
    { type: AnimationBuilder },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone },
    { type: PlatformUtil }
];

// Export position strategies

/**
 * On scroll reposition the overlay content.
 */
class AbsoluteScrollStrategy extends ScrollStrategy {
    constructor(scrollContainer) {
        super(scrollContainer);
        this._initialized = false;
        this.onScroll = (e) => {
            const overlayInfo = this._overlayService.getOverlayById(this._id);
            if (!overlayInfo) {
                return;
            }
            if (!overlayInfo.elementRef.nativeElement.contains(e.target)) {
                this._overlayService.reposition(this._id);
            }
        };
        this._scrollContainer = scrollContainer;
    }
    /** @inheritdoc */
    initialize(document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._overlayService = overlayService;
        this._id = id;
        this._document = document;
        this._zone = overlayService.getOverlayById(id).ngZone;
        this._initialized = true;
    }
    /** @inheritdoc */
    attach() {
        if (this._zone) {
            this._zone.runOutsideAngular(() => {
                this.addScrollEventListener();
            });
        }
        else {
            this.addScrollEventListener();
        }
    }
    /** @inheritdoc */
    detach() {
        if (this._scrollContainer) {
            this._scrollContainer.removeEventListener('scroll', this.onScroll, true);
        }
        else {
            this._document.removeEventListener('scroll', this.onScroll, true);
        }
        this._initialized = false;
    }
    addScrollEventListener() {
        if (this._scrollContainer) {
            this._scrollContainer.addEventListener('scroll', this.onScroll, true);
        }
        else {
            this._document.addEventListener('scroll', this.onScroll, true);
        }
    }
}

/**
 * Prevents scrolling while the overlay content is shown.
 */
class BlockScrollStrategy extends ScrollStrategy {
    constructor(scrollContainer) {
        super(scrollContainer);
        this._initialized = false;
        this.onScroll = (ev) => {
            ev.preventDefault();
            if (!this._sourceElement || this._sourceElement !== ev.target) {
                this._sourceElement = ev.target;
                this._initialScrollTop = this._sourceElement.scrollTop;
                this._initialScrollLeft = this._sourceElement.scrollLeft;
            }
            this._sourceElement.scrollTop = this._initialScrollTop;
            this._sourceElement.scrollLeft = this._initialScrollLeft;
        };
    }
    /** @inheritdoc */
    initialize(document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._document = document;
        this._initialized = true;
    }
    /** @inheritdoc */
    attach() {
        this._document.addEventListener('scroll', this.onScroll, true);
    }
    /** @inheritdoc */
    detach() {
        this._document.removeEventListener('scroll', this.onScroll, true);
        this._sourceElement = null;
        this._initialScrollTop = 0;
        this._initialScrollLeft = 0;
        this._initialized = false;
    }
}

/**
 * Uses a tolerance and closes the shown component upon scrolling if the tolerance is exceeded
 */
class CloseScrollStrategy extends ScrollStrategy {
    constructor(scrollContainer) {
        super(scrollContainer);
        this._initialized = false;
        this.onScroll = (ev) => {
            if (!this._sourceElement) {
                return;
            }
            this.cumulativeScrollTop += this._sourceElement.scrollTop;
            this.cumulativeScrollLeft += this._sourceElement.scrollLeft;
            if (Math.abs(this.cumulativeScrollTop - this.initialScrollTop) > this._threshold ||
                Math.abs(this.cumulativeScrollLeft - this.initialScrollLeft) > this._threshold) {
                this._document.removeEventListener('scroll', this.onScroll, true);
                this._overlayService.hide(this._id);
            }
        };
        this._scrollContainer = scrollContainer;
        this._threshold = 10;
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
    }
    /** @inheritdoc */
    initialize(document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._overlayService = overlayService;
        this._id = id;
        this._document = document;
        this._initialized = true;
    }
    /** @inheritdoc */
    attach() {
        if (this._scrollContainer) {
            this._scrollContainer.addEventListener('scroll', this.onScroll);
            this._sourceElement = this._scrollContainer;
        }
        else {
            this._document.addEventListener('scroll', this.onScroll);
            if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
                this._sourceElement = document.documentElement;
            }
            else if (document.body.scrollHeight > document.body.clientHeight) {
                this._sourceElement = document.body;
            }
        }
        if (!this._sourceElement) {
            return;
        }
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
        this.initialScrollTop = this._sourceElement.scrollTop;
        this.initialScrollLeft = this._sourceElement.scrollLeft;
    }
    /** @inheritdoc */
    detach() {
        // TODO: check why event listener removes only on first call and remains on each next!!!
        if (this._scrollContainer) {
            this._scrollContainer.removeEventListener('scroll', this.onScroll);
        }
        else {
            this._document.removeEventListener('scroll', this.onScroll);
        }
        this._sourceElement = null;
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
        this.initialScrollTop = 0;
        this.initialScrollLeft = 0;
        this._initialized = false;
    }
}

// Export scroll strategies

class IgxBaseTransactionService {
    constructor() {
        this._isPending = false;
        this._pendingTransactions = [];
        this._pendingStates = new Map();
        /**
         * @inheritdoc
         */
        this.onStateUpdate = new EventEmitter();
    }
    /**
     * @inheritdoc
     */
    get canRedo() {
        return false;
    }
    /**
     * @inheritdoc
     */
    get canUndo() {
        return false;
    }
    /**
     * @inheritdoc
     */
    get enabled() {
        return this._isPending;
    }
    /**
     * @inheritdoc
     */
    add(transaction, recordRef) {
        if (this._isPending) {
            this.updateState(this._pendingStates, transaction, recordRef);
            this._pendingTransactions.push(transaction);
        }
    }
    /**
     * @inheritdoc
     */
    getTransactionLog(id) { return []; }
    /**
     * @inheritdoc
     */
    undo() { }
    /**
     * @inheritdoc
     */
    redo() { }
    /**
     * @inheritdoc
     */
    getAggregatedChanges(mergeChanges) {
        const result = [];
        this._pendingStates.forEach((state, key) => {
            const value = mergeChanges ? this.getAggregatedValue(key, mergeChanges) : state.value;
            result.push({ id: key, newValue: value, type: state.type });
        });
        return result;
    }
    /**
     * @inheritdoc
     */
    getState(id) {
        return this._pendingStates.get(id);
    }
    /**
     * @inheritdoc
     */
    getAggregatedValue(id, mergeChanges) {
        const state = this._pendingStates.get(id);
        if (!state) {
            return null;
        }
        if (mergeChanges) {
            return this.updateValue(state);
        }
        return state.value;
    }
    /**
     * @inheritdoc
     */
    commit(data, id) { }
    /**
     * @inheritdoc
     */
    clear(id) {
        this._pendingStates.clear();
        this._pendingTransactions = [];
    }
    /**
     * @inheritdoc
     */
    startPending() {
        this._isPending = true;
    }
    /**
     * @inheritdoc
     */
    endPending(commit) {
        this._isPending = false;
        this._pendingStates.clear();
        this._pendingTransactions = [];
    }
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @param states States collection to apply the update to
     * @param transaction Transaction to apply to the current state
     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     */
    updateState(states, transaction, recordRef) {
        let state = states.get(transaction.id);
        if (state) {
            if (isObject(state.value)) {
                mergeObjects(state.value, transaction.newValue);
            }
            else {
                state.value = transaction.newValue;
            }
        }
        else {
            state = { value: cloneValue(transaction.newValue), recordRef: recordRef, type: transaction.type };
            states.set(transaction.id, state);
        }
    }
    /**
     * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types
     * @param state State to update value for
     * @returns updated value including all the changes in provided state
     */
    updateValue(state) {
        return this.mergeValues(state.recordRef, state.value);
    }
    /**
     * Merges second values in first value and the result in empty object. If values are primitive type
     * returns second value if exists, or first value.
     * @param first Value to merge into
     * @param second Value to merge
     */
    mergeValues(first, second) {
        if (isObject(first) || isObject(second)) {
            return mergeObjects(Object.assign({}, first), second);
        }
        else {
            return second ? second : first;
        }
    }
}
IgxBaseTransactionService.ɵfac = function IgxBaseTransactionService_Factory(t) { return new (t || IgxBaseTransactionService)(); };
IgxBaseTransactionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxBaseTransactionService, factory: IgxBaseTransactionService.ɵfac });

class IgxTransactionService extends IgxBaseTransactionService {
    constructor() {
        super(...arguments);
        this._transactions = [];
        this._redoStack = [];
        this._undoStack = [];
        this._states = new Map();
        /**
         * @inheritdoc
         */
        this.onStateUpdate = new EventEmitter();
    }
    /**
     * @inheritdoc
     */
    get canUndo() {
        return this._undoStack.length > 0;
    }
    /**
     * @inheritdoc
     */
    get canRedo() {
        return this._redoStack.length > 0;
    }
    /**
     * @inheritdoc
     */
    add(transaction, recordRef) {
        const states = this._isPending ? this._pendingStates : this._states;
        this.verifyAddedTransaction(states, transaction, recordRef);
        this.addTransaction(transaction, states, recordRef);
    }
    addTransaction(transaction, states, recordRef) {
        this.updateState(states, transaction, recordRef);
        const transactions = this._isPending ? this._pendingTransactions : this._transactions;
        transactions.push(transaction);
        if (!this._isPending) {
            const actions = [{ transaction, recordRef }];
            this._undoStack.push(actions);
            this._redoStack = [];
            this.onStateUpdate.emit({ origin: TransactionEventOrigin.ADD, actions });
        }
    }
    /**
     * @inheritdoc
     */
    getTransactionLog(id) {
        if (id !== undefined) {
            return this._transactions.filter(t => t.id === id);
        }
        return [...this._transactions];
    }
    /**
     * @inheritdoc
     */
    getAggregatedChanges(mergeChanges) {
        const result = [];
        this._states.forEach((state, key) => {
            const value = mergeChanges ? this.mergeValues(state.recordRef, state.value) : state.value;
            result.push({ id: key, newValue: value, type: state.type });
        });
        return result;
    }
    /**
     * @inheritdoc
     */
    getState(id, pending = false) {
        return pending ? this._pendingStates.get(id) : this._states.get(id);
    }
    /**
     * @inheritdoc
     */
    get enabled() {
        return true;
    }
    /**
     * @inheritdoc
     */
    getAggregatedValue(id, mergeChanges) {
        const state = this._states.get(id);
        const pendingState = super.getState(id);
        //  if there is no state and there is no pending state return null
        if (!state && !pendingState) {
            return null;
        }
        const pendingChange = super.getAggregatedValue(id, false);
        const change = state && state.value;
        let aggregatedValue = this.mergeValues(change, pendingChange);
        if (mergeChanges) {
            const originalValue = state ? state.recordRef : pendingState.recordRef;
            aggregatedValue = this.mergeValues(originalValue, aggregatedValue);
        }
        return aggregatedValue;
    }
    /**
     * @inheritdoc
     */
    endPending(commit) {
        this._isPending = false;
        if (commit) {
            const actions = [];
            // don't use addTransaction due to custom undo handling
            for (const transaction of this._pendingTransactions) {
                const pendingState = this._pendingStates.get(transaction.id);
                this._transactions.push(transaction);
                this.updateState(this._states, transaction, pendingState.recordRef);
                actions.push({ transaction, recordRef: pendingState.recordRef });
            }
            this._undoStack.push(actions);
            this._redoStack = [];
            this.onStateUpdate.emit({ origin: TransactionEventOrigin.END, actions });
        }
        super.endPending(commit);
    }
    /**
     * @inheritdoc
     */
    commit(data, id) {
        if (id !== undefined) {
            const state = this.getState(id);
            if (state) {
                this.updateRecord(data, state);
            }
        }
        else {
            this._states.forEach((s) => {
                this.updateRecord(data, s);
            });
        }
        this.clear(id);
    }
    /**
     * @inheritdoc
     */
    clear(id) {
        if (id !== undefined) {
            this._transactions = this._transactions.filter(t => t.id !== id);
            this._states.delete(id);
            //  Undo stack is an array of actions. Each action is array of transaction like objects
            //  We are going trough all the actions. For each action we are filtering out transactions
            //  with provided id. Finally if any action ends up as empty array we are removing it from
            //  undo stack
            this._undoStack = this._undoStack.map(a => a.filter(t => t.transaction.id !== id)).filter(a => a.length > 0);
        }
        else {
            this._transactions = [];
            this._states.clear();
            this._undoStack = [];
        }
        this._redoStack = [];
        this.onStateUpdate.emit({ origin: TransactionEventOrigin.CLEAR, actions: [] });
    }
    /**
     * @inheritdoc
     */
    undo() {
        if (this._undoStack.length <= 0) {
            return;
        }
        const lastActions = this._undoStack.pop();
        this._transactions.splice(this._transactions.length - lastActions.length);
        this._redoStack.push(lastActions);
        this._states.clear();
        for (const currentActions of this._undoStack) {
            for (const transaction of currentActions) {
                this.updateState(this._states, transaction.transaction, transaction.recordRef);
            }
        }
        this.onStateUpdate.emit({ origin: TransactionEventOrigin.UNDO, actions: lastActions });
    }
    /**
     * @inheritdoc
     */
    redo() {
        if (this._redoStack.length > 0) {
            let actions;
            actions = this._redoStack.pop();
            for (const action of actions) {
                this.updateState(this._states, action.transaction, action.recordRef);
                this._transactions.push(action.transaction);
            }
            this._undoStack.push(actions);
            this.onStateUpdate.emit({ origin: TransactionEventOrigin.REDO, actions });
        }
    }
    /**
     * Verifies if the passed transaction is correct. If not throws an exception.
     * @param transaction Transaction to be verified
     */
    verifyAddedTransaction(states, transaction, recordRef) {
        const state = states.get(transaction.id);
        switch (transaction.type) {
            case TransactionType.ADD:
                if (state) {
                    //  cannot add same item twice
                    throw new Error(`Cannot add this transaction. Transaction with id: ${transaction.id} has been already added.`);
                }
                break;
            case TransactionType.DELETE:
            case TransactionType.UPDATE:
                if (state && state.type === TransactionType.DELETE) {
                    //  cannot delete or update deleted items
                    throw new Error(`Cannot add this transaction. Transaction with id: ${transaction.id} has been already deleted.`);
                }
                if (!state && !recordRef && !this._isPending) {
                    //  cannot initially add transaction or delete item with no recordRef
                    throw new Error(`Cannot add this transaction. This is first transaction of type ${transaction.type} ` +
                        `for id ${transaction.id}. For first transaction of this type recordRef is mandatory.`);
                }
                break;
        }
    }
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @param states States collection to apply the update to
     * @param transaction Transaction to apply to the current state
     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     */
    updateState(states, transaction, recordRef) {
        let state = states.get(transaction.id);
        //  if TransactionType is ADD simply add transaction to states;
        //  if TransactionType is DELETE:
        //    - if there is state with this id of type ADD remove it from the states;
        //    - if there is state with this id of type UPDATE change its type to DELETE;
        //    - if there is no state with this id add transaction to states;
        //  if TransactionType is UPDATE:
        //    - if there is state with this id of type ADD merge new value and state recordRef into state new value
        //    - if there is state with this id of type UPDATE merge new value into state new value
        //    - if there is state with this id and state type is DELETE change its type to UPDATE
        //    - if there is no state with this id add transaction to states;
        if (state) {
            switch (transaction.type) {
                case TransactionType.DELETE:
                    if (state.type === TransactionType.ADD) {
                        states.delete(transaction.id);
                    }
                    else if (state.type === TransactionType.UPDATE) {
                        state.value = transaction.newValue;
                        state.type = TransactionType.DELETE;
                    }
                    break;
                case TransactionType.UPDATE:
                    if (isObject(state.value)) {
                        if (state.type === TransactionType.ADD) {
                            state.value = this.mergeValues(state.value, transaction.newValue);
                        }
                        if (state.type === TransactionType.UPDATE) {
                            mergeObjects(state.value, transaction.newValue);
                        }
                    }
                    else {
                        state.value = transaction.newValue;
                    }
            }
        }
        else {
            state = { value: cloneValue(transaction.newValue), recordRef: recordRef, type: transaction.type };
            states.set(transaction.id, state);
        }
        //  should not clean pending state. This will happen automatically on endPending call
        if (!this._isPending) {
            this.cleanState(transaction.id, states);
        }
    }
    /**
     * Compares the state with recordRef and clears all duplicated values. If any state ends as
     * empty object removes it from states.
     * @param state State to clean
     */
    cleanState(id, states) {
        const state = states.get(id);
        //  do nothing if
        //  there is no state, or
        //  there is no state value (e.g. DELETED transaction), or
        //  there is no recordRef (e.g. ADDED transaction)
        if (state && state.value && state.recordRef) {
            //  if state's value is object compare each key with the ones in recordRef
            //  if values in any key are the same delete it from state's value
            //  if state's value is not object, simply compare with recordRef and remove
            //  the state if they are equal
            if (isObject(state.recordRef)) {
                for (const key of Object.keys(state.value)) {
                    if (JSON.stringify(state.recordRef[key]) === JSON.stringify(state.value[key])) {
                        delete state.value[key];
                    }
                }
                //  if state's value is empty remove the state from the states, only if state is not DELETE type
                if (state.type !== TransactionType.DELETE && Object.keys(state.value).length === 0) {
                    states.delete(id);
                }
            }
            else {
                if (state.recordRef === state.value) {
                    states.delete(id);
                }
            }
        }
    }
    /**
     * Updates state related record in the provided data
     * @param data Data source to update
     * @param state State to update data from
     */
    updateRecord(data, state) {
        const index = data.findIndex(i => JSON.stringify(i) === JSON.stringify(state.recordRef || {}));
        switch (state.type) {
            case TransactionType.ADD:
                data.push(state.value);
                break;
            case TransactionType.DELETE:
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
                break;
            case TransactionType.UPDATE:
                if (0 <= index && index < data.length) {
                    data[index] = this.updateValue(state);
                }
                break;
        }
    }
}
IgxTransactionService.ɵfac = function IgxTransactionService_Factory(t) { return ɵIgxTransactionService_BaseFactory(t || IgxTransactionService); };
IgxTransactionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxTransactionService, factory: IgxTransactionService.ɵfac });

/** @experimental @hidden */
class IgxHierarchicalTransactionService extends IgxTransactionService {
    getAggregatedChanges(mergeChanges) {
        const result = [];
        this._states.forEach((state, key) => {
            const value = mergeChanges ? this.mergeValues(state.recordRef, state.value) : cloneValue(state.value);
            this.clearArraysFromObject(value);
            result.push({ id: key, path: state.path, newValue: value, type: state.type });
        });
        return result;
    }
    updateState(states, transaction, recordRef) {
        super.updateState(states, transaction, recordRef);
        //  if transaction has no path, e.g. flat data source, get out
        if (!transaction.path) {
            return;
        }
        const currentState = states.get(transaction.id);
        if (currentState) {
            currentState.path = transaction.path;
        }
        //  if transaction has path, Hierarchical data source, and it is DELETE
        //  type transaction for all child rows remove ADD states and update
        //  transaction type and value of UPDATE states
        if (transaction.type === TransactionType.DELETE) {
            states.forEach((v, k) => {
                if (v.path && v.path.indexOf(transaction.id) !== -1) {
                    switch (v.type) {
                        case TransactionType.ADD:
                            states.delete(k);
                            break;
                        case TransactionType.UPDATE:
                            states.get(k).type = TransactionType.DELETE;
                            states.get(k).value = null;
                    }
                }
            });
        }
    }
    commit(data, primaryKeyOrId, childDataKey, id) {
        if (childDataKey !== undefined) {
            let transactions = this.getAggregatedChanges(true);
            if (id !== undefined) {
                transactions = transactions.filter(t => t.id === id);
            }
            DataUtil.mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKeyOrId, true);
            this.clear(id);
        }
        else {
            super.commit(data, primaryKeyOrId);
        }
    }
    //  TODO: remove this method. Force cloning to strip child arrays when needed instead
    clearArraysFromObject(obj) {
        if (obj) {
            for (const prop of Object.keys(obj)) {
                if (Array.isArray(obj[prop])) {
                    delete obj[prop];
                }
            }
        }
    }
}
IgxHierarchicalTransactionService.ɵfac = function IgxHierarchicalTransactionService_Factory(t) { return ɵIgxHierarchicalTransactionService_BaseFactory(t || IgxHierarchicalTransactionService); };
IgxHierarchicalTransactionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxHierarchicalTransactionService, factory: IgxHierarchicalTransactionService.ɵfac });

// Export services

class IgxToggleDirective {
    /**
     * @hidden
     */
    constructor(elementRef, cdr, overlayService, navigationService) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlayService = overlayService;
        this.navigationService = navigationService;
        this.destroy$ = new Subject();
        this._overlaySubFilter = [
            filter(x => x.id === this._overlayId),
            takeUntil(this.destroy$)
        ];
        /**
         * Emits an event after the toggle container is opened.
         *
         * ```typescript
         * onToggleOpened(event) {
         *    alert("Toggle opened!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpened)='onToggleOpened($event)'>
         * </div>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emits an event before the toggle container is opened.
         *
         * ```typescript
         * onToggleOpening(event) {
         *  alert("Toggle opening!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpening)='onToggleOpening($event)'>
         * </div>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emits an event after the toggle container is closed.
         *
         * ```typescript
         * onToggleClosed(event) {
         *  alert("Toggle closed!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onClosed)='onToggleClosed($event)'>
         * </div>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emits an event before the toggle container is closed.
         *
         * ```typescript
         * onToggleClosing(event) {
         *  alert("Toggle closing!");
         * }
         * ```
         *
         * ```html
         * <div
         *  igxToggle
         *  (onClosing)='onToggleClosing($event)'>
         * </div>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emits an event after the toggle element is appended to the overlay container.
         *
         * ```typescript
         * onAppended() {
         *  alert("Content appended!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onAppended)='onToggleAppended()'>
         * </div>
         * ```
         */
        this.onAppended = new EventEmitter();
        this._collapsed = true;
        this.overlayClosed = () => {
            this._collapsed = true;
            this.cdr.detectChanges();
            delete this._overlayId;
            this.unsubscribe();
            const closedEventArgs = { owner: this, id: this._overlayId };
            this.onClosed.emit(closedEventArgs);
        };
    }
    /**
     * @hidden
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get hiddenClass() {
        return this.collapsed;
    }
    /**
     * @hidden
     */
    get defaultClass() {
        return !this.collapsed;
    }
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     */
    open(overlaySettings) {
        //  if there is open animation do nothing
        //  if toggle is not collapsed and there is no close animation do nothing
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasOpenAnimation = info ? info.openAnimationPlayer : false;
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (hasOpenAnimation || !(this._collapsed || hasCloseAnimation)) {
            return;
        }
        if (!info) {
            this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);
        }
        this._collapsed = false;
        this.cdr.detectChanges();
        const openEventArgs = { cancel: false, owner: this, id: this._overlayId };
        this.onOpening.emit(openEventArgs);
        if (openEventArgs.cancel) {
            this._collapsed = true;
            this.cdr.detectChanges();
            return;
        }
        this.unsubscribe();
        this._overlayAppendedSub = this.overlayService.onAppended.pipe(...this._overlaySubFilter).subscribe(() => {
            const appendedEventArgs = { owner: this, id: this._overlayId };
            this.onAppended.emit(appendedEventArgs);
        });
        this._overlayOpenedSub = this.overlayService.onOpened.pipe(...this._overlaySubFilter).subscribe(() => {
            const openedEventArgs = { owner: this, id: this._overlayId };
            this.onOpened.emit(openedEventArgs);
        });
        this._overlayClosingSub = this.overlayService
            .onClosing
            .pipe(...this._overlaySubFilter)
            .subscribe((e) => {
            const eventArgs = { cancel: false, event: e.event, owner: this, id: this._overlayId };
            this.onClosing.emit(eventArgs);
            e.cancel = eventArgs.cancel;
            //  in case event is not canceled this will close the toggle and we need to unsubscribe.
            //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
            //  onClosed was fired we will end with calling onClosing more than once
            if (!e.cancel) {
                this.clearSubscription(this._overlayClosingSub);
            }
        });
        this._overlayClosedSub = this.overlayService.onClosed
            .pipe(...this._overlaySubFilter)
            .subscribe(this.overlayClosed);
        this.overlayService.show(this._overlayId, overlaySettings);
    }
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     */
    close() {
        //  if toggle is collapsed do nothing
        //  if there is close animation do nothing, toggle will close anyway
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (this._collapsed || hasCloseAnimation) {
            return;
        }
        this.overlayService.hide(this._overlayId);
    }
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     */
    toggle(overlaySettings) {
        //  if toggle is collapsed call open
        //  if there is close animation call open
        if (this.collapsed || this.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    }
    /** @hidden @internal */
    get isClosing() {
        const info = this.overlayService.getOverlayById(this._overlayId);
        return info ? info.closeAnimationPlayer : false;
    }
    /**
     * Returns the id of the overlay the content is rendered in.
     * ```typescript
     * this.myToggle.overlayId;
     * ```
     */
    get overlayId() {
        return this._overlayId;
    }
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     */
    reposition() {
        this.overlayService.reposition(this._overlayId);
    }
    /**
     * Offsets the content along the corresponding axis by the provided amount
     */
    setOffset(deltaX, deltaY) {
        this.overlayService.setOffset(this._overlayId, deltaX, deltaY);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.navigationService && this.id) {
            this.navigationService.add(this.id, this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.navigationService && this.id) {
            this.navigationService.remove(this.id);
        }
        if (!this.collapsed && this._overlayId) {
            this.overlayService.hide(this._overlayId);
        }
        this.unsubscribe();
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    unsubscribe() {
        this.clearSubscription(this._overlayOpenedSub);
        this.clearSubscription(this._overlayClosingSub);
        this.clearSubscription(this._overlayClosedSub);
        this.clearSubscription(this._overlayAppendedSub);
    }
    clearSubscription(subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    }
}
IgxToggleDirective.ɵfac = function IgxToggleDirective_Factory(t) { return new (t || IgxToggleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxOverlayService), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8)); };
IgxToggleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxToggleDirective, selectors: [["", "igxToggle", ""]], hostVars: 5, hostBindings: function IgxToggleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-hidden", ctx.hiddenClass);
        ɵngcc0.ɵɵclassProp("igx-toggle--hidden", ctx.hiddenClass)("igx-toggle", ctx.defaultClass);
    } }, inputs: { id: "id" }, outputs: { onOpened: "onOpened", onOpening: "onOpening", onClosed: "onClosed", onClosing: "onClosing", onAppended: "onAppended" }, exportAs: ["toggle"] });
IgxToggleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
IgxToggleDirective.propDecorators = {
    onOpened: [{ type: Output }],
    onOpening: [{ type: Output }],
    onClosed: [{ type: Output }],
    onClosing: [{ type: Output }],
    onAppended: [{ type: Output }],
    id: [{ type: Input }],
    hiddenClass: [{ type: HostBinding, args: ['class.igx-toggle--hidden',] }, { type: HostBinding, args: ['attr.aria-hidden',] }],
    defaultClass: [{ type: HostBinding, args: ['class.igx-toggle',] }]
};
class IgxToggleActionDirective {
    constructor(element, navigationService) {
        this.element = element;
        this.navigationService = navigationService;
    }
    /**
     * @hidden
     */
    set target(target) {
        if (target !== null && target !== '') {
            this._target = target;
        }
    }
    /**
     * @hidden
     */
    get target() {
        if (typeof this._target === 'string') {
            return this.navigationService.get(this._target);
        }
        return this._target;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        const targetElement = this.element.nativeElement;
        this._overlayDefaults = {
            target: targetElement,
            positionStrategy: new ConnectedPositioningStrategy(),
            scrollStrategy: new AbsoluteScrollStrategy(),
            closeOnOutsideClick: true,
            modal: false,
            excludeFromOutsideClick: [targetElement]
        };
    }
    /**
     * @hidden
     */
    onClick() {
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
        const clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);
        this.updateOverlaySettings(clonedSettings);
        this.target.toggle(clonedSettings);
    }
    /**
     * Updates provided overlay settings
     * @param settings settings to update
     * @returns returns updated copy of provided overlay settings
     */
    updateOverlaySettings(settings) {
        if (settings && settings.positionStrategy) {
            const positionStrategyClone = settings.positionStrategy.clone();
            settings.target = this.element.nativeElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    }
}
IgxToggleActionDirective.ɵfac = function IgxToggleActionDirective_Factory(t) { return new (t || IgxToggleActionDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8)); };
IgxToggleActionDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxToggleActionDirective, selectors: [["", "igxToggleAction", ""]], hostBindings: function IgxToggleActionDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxToggleActionDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } }, inputs: { target: ["igxToggleAction", "target"], overlaySettings: "overlaySettings", outlet: ["igxToggleOutlet", "outlet"] }, exportAs: ["toggle-action"] });
IgxToggleActionDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
IgxToggleActionDirective.propDecorators = {
    overlaySettings: [{ type: Input }],
    outlet: [{ type: Input, args: ['igxToggleOutlet',] }],
    target: [{ type: Input, args: ['igxToggleAction',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
class IgxOverlayOutletDirective {
    constructor(element) {
        this.element = element;
    }
    /** @hidden */
    get nativeElement() {
        return this.element.nativeElement;
    }
}
IgxOverlayOutletDirective.ɵfac = function IgxOverlayOutletDirective_Factory(t) { return new (t || IgxOverlayOutletDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxOverlayOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxOverlayOutletDirective, selectors: [["", "igxOverlayOutlet", ""]], exportAs: ["overlay-outlet"] });
IgxOverlayOutletDirective.ctorParameters = () => [
    { type: ElementRef }
];
/**
 * @hidden
 */
class IgxToggleModule {
}
IgxToggleModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxToggleModule });
IgxToggleModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxToggleModule_Factory(t) { return new (t || IgxToggleModule)(); }, providers: [IgxNavigationService] });

/** @hidden */
var Navigate;
(function (Navigate) {
    Navigate[Navigate["Up"] = -1] = "Up";
    Navigate[Navigate["Down"] = 1] = "Down";
})(Navigate || (Navigate = {}));
/** Key actions that have designated handlers in IgxDropDownComponent */
const DropDownActionKey = mkenum({
    ESCAPE: 'escape',
    ENTER: 'enter',
    SPACE: 'space'
});
const IGX_DROPDOWN_BASE = new InjectionToken('IgxDropDownBaseToken');

/** @hidden */
class IgxSelectionAPIService {
    constructor() {
        /**
         * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.
         * If the primaryKey is omitted, then selection is based on the item data
         */
        this.selection = new Map();
    }
    /**
     * Get current component selection.
     * @param componentID ID of the component.
     */
    get(componentID) {
        return this.selection.get(componentID);
    }
    /**
     * Set new component selection.
     * @param componentID ID of the component.
     * @param newSelection The new component selection to be set.
     */
    set(componentID, newSelection) {
        if (!componentID) {
            throw Error('Invalid value for component id!');
        }
        this.selection.set(componentID, newSelection);
    }
    /**
     * Clears selection for component.
     * @param componentID ID of the component.
     */
    clear(componentID) {
        this.selection.set(componentID, this.get_empty());
    }
    /**
     * Get current component selection length.
     * @param componentID ID of the component.
     */
    size(componentID) {
        const sel = this.get(componentID);
        return sel ? sel.size : 0;
    }
    /**
     * Creates new selection that consist of the new item added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_item() one.
     * @param componentID ID of the component, which we add new item to.
     * @param itemID ID of the item to add to component selection.
     * @param sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
     *
     * @returns Selection after the new item is added.
     */
    add_item(componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            sel = this.get_empty();
        }
        if (!itemID && itemID !== 0) {
            throw Error('Invalid value for item id!');
        }
        sel.add(itemID);
        return sel;
    }
    /**
     * Creates new selection that consist of the new items added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_items() one.
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     * @param clearSelection If true it will clear previous selection.
     *
     * @returns Selection after the new items are added.
     */
    add_items(componentID, itemIDs, clearSelection) {
        let selection;
        if (clearSelection) {
            selection = this.get_empty();
        }
        else if (itemIDs && itemIDs.length === 0) {
            selection = new Set(this.get(componentID));
        }
        itemIDs.forEach((item) => selection = this.add_item(componentID, item, selection));
        return selection;
    }
    /**
     * Add item to the current component selection.
     * @param componentID ID of the component, which we add new item to.
     * @param itemID ID of the item to add to component selection.
     * @param sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
     */
    select_item(componentID, itemID, sel) {
        this.set(componentID, this.add_item(componentID, itemID, sel));
    }
    /**
     * Add items to the current component selection.
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     * @param clearSelection If true it will clear previous selection.
     */
    select_items(componentID, itemID, clearSelection) {
        this.set(componentID, this.add_items(componentID, itemID, clearSelection));
    }
    /**
     * Creates new selection that consist of the new items excluded from the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_item() one.
     * @param componentID ID of the component, which we remove items from.
     * @param itemID ID of the item to remove from component selection.
     * @param sel Used internally only by the selection (delete_items method) to accumulate deselected items.
     *
     * @returns Selection after the item is removed.
     */
    delete_item(componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            return;
        }
        sel.delete(itemID);
        return sel;
    }
    /**
     * Creates new selection that consist of the new items removed to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_items() one.
     * @param componentID ID of the component, which we remove items from.
     * @param itemID ID of the items to remove from component selection.
     *
     * @returns Selection after the items are removed.
     */
    delete_items(componentID, itemIDs) {
        let selection;
        itemIDs.forEach((deselectedItem) => selection = this.delete_item(componentID, deselectedItem, selection));
        return selection;
    }
    /**
     * Remove item from the current component selection.
     * @param componentID ID of the component, which we remove item from.
     * @param itemID ID of the item to remove from component selection.
     * @param sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
     */
    deselect_item(componentID, itemID, sel) {
        this.set(componentID, this.delete_item(componentID, itemID, sel));
    }
    /**
     * Remove items to the current component selection.
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     */
    deselect_items(componentID, itemID, clearSelection) {
        this.set(componentID, this.delete_items(componentID, itemID));
    }
    /**
     * Check if the item is selected in the component selection.
     * @param componentID ID of the component.
     * @param itemID ID of the item to search.
     *
     * @returns If item is selected.
     */
    is_item_selected(componentID, itemID) {
        const sel = this.get(componentID);
        if (!sel) {
            return false;
        }
        return sel.has(itemID);
    }
    /**
     * Get first element in the selection.
     * This is correct when we have only one item in the collection (for single selection purposes)
     * and the method returns that item.
     * @param componentID ID of the component.
     *
     * @returns First element in the set.
     */
    first_item(componentID) {
        const sel = this.get(componentID);
        if (sel && sel.size > 0) {
            return sel.values().next().value;
        }
    }
    /**
     * Returns whether all items are selected.
     * @param componentID ID of the component.
     * @param dataCount: number Number of items in the data.
     *
     * @returns If all items are selected.
     */
    are_all_selected(componentID, dataCount) {
        return dataCount > 0 && dataCount === this.size(componentID);
    }
    /**
     * Returns whether any of the items is selected.
     * @param componentID ID of the component.
     * @param data Entire data array.
     *
     * @returns If there is any item selected.
     */
    are_none_selected(componentID) {
        return this.size(componentID) === 0;
    }
    /**
     * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
     * @param data Entire data array.
     * @param primaryKey Data primary key.
     *
     * @returns Array of identifiers, either primary key values or the entire data array.
     */
    get_all_ids(data, primaryKey) {
        // If primaryKey is 0, this should still map to the property
        return primaryKey !== undefined && primaryKey !== null ? data.map((x) => x[primaryKey]) : data;
    }
    /**
     * Returns empty selection collection.
     * @returns empty set.
     */
    get_empty() {
        return new Set();
    }
}
IgxSelectionAPIService.ɵfac = function IgxSelectionAPIService_Factory(t) { return new (t || IgxSelectionAPIService)(); };
IgxSelectionAPIService.ɵprov = ɵɵdefineInjectable({ factory: function IgxSelectionAPIService_Factory() { return new IgxSelectionAPIService(); }, token: IgxSelectionAPIService, providedIn: "root" });

let NEXT_ID = 0;
/**
 * The `<igx-drop-down-item>` is a container intended for row items in
 * a `<igx-drop-down>` container.
 */
class IgxDropDownGroupComponent {
    constructor() {
        this._id = NEXT_ID++;
        /**
         * @hidden @internal
         */
        this.role = 'group';
        /** @hidden @internal */
        this.groupClass = true;
        /**
         * Sets/gets if the item group is disabled
         *
         * ```typescript
         * const myDropDownGroup: IgxDropDownGroupComponent = this.dropdownGroup;
         * // get
         * ...
         * const groupState: boolean = myDropDownGroup.disabled;
         * ...
         * //set
         * ...
         * myDropDownGroup,disabled = false;
         * ...
         * ```
         *
         * ```html
         * <igx-drop-down-item-group [label]="'My Items'" [disabled]="true">
         *     <igx-drop-down-item *ngFor="let item of items[index]" [value]="item.value">
         *         {{ item.text }}
         *     </igx-drop-down-item>
         * </igx-drop-down-item-group>
         * ```
         *
         * **NOTE:** All items inside of a disabled drop down group will be treated as disabled
         */
        this.disabled = false;
    }
    /**
     * @hidden @internal
     */
    get labelId() {
        return `igx-item-group-label-${this._id}`;
    }
    get labelledBy() {
        return this.labelId;
    }
}
IgxDropDownGroupComponent.ɵfac = function IgxDropDownGroupComponent_Factory(t) { return new (t || IgxDropDownGroupComponent)(); };
IgxDropDownGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDropDownGroupComponent, selectors: [["igx-drop-down-item-group"]], hostVars: 7, hostBindings: function IgxDropDownGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("aria-disabled", ctx.disabled)("aria-labelledby", ctx.labelledBy);
        ɵngcc0.ɵɵclassProp("igx-drop-down__group", ctx.groupClass)("igx-drop-down__group--disabled", ctx.disabled);
    } }, inputs: { disabled: "disabled", label: "label" }, ngContentSelectors: _c1, decls: 3, vars: 2, consts: [[3, "id"]], template: function IgxDropDownGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵpropertyInterpolate("id", ctx.labelId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
    } }, encapsulation: 2 });
IgxDropDownGroupComponent.propDecorators = {
    labelledBy: [{ type: HostBinding, args: [`attr.aria-labelledby`,] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    groupClass: [{ type: HostBinding, args: ['class.igx-drop-down__group',] }],
    disabled: [{ type: Input }, { type: HostBinding, args: [`attr.aria-disabled`,] }, { type: HostBinding, args: ['class.igx-drop-down__group--disabled',] }],
    label: [{ type: Input }]
};

let NEXT_ID$1 = 0;
let warningShown$1 = false;
/**
 * An abstract class defining a drop-down item:
 * With properties / styles for selection, highlight, height
 * Bindable property for passing data (`value: any`)
 * Parent component (has to be used under a parent with type `IDropDownBase`)
 * Method for handling click on Host()
 */
class IgxDropDownItemBaseDirective {
    constructor(dropDown, elementRef, group, selection) {
        this.dropDown = dropDown;
        this.elementRef = elementRef;
        this.group = group;
        this.selection = selection;
        /**
         * @hidden
         */
        this._focused = false;
        this._selected = false;
        this._index = null;
        this._disabled = false;
        /**
         * Sets/gets the `id` of the item.
         * ```html
         * <igx-drop-down-item [id] = 'igx-drop-down-item-0'></igx-drop-down-item>
         * ```
         * ```typescript
         * let itemId =  this.item.id;
         * ```
         * @memberof IgxSelectItemComponent
         */
        this.id = `igx-drop-down-item-${NEXT_ID$1++}`;
        /**
         * @hidden
         */
        this.selectedChange = new EventEmitter();
        /**
         * Gets/sets the `role` attribute of the item. Default is 'option'.
         *
         * ```html
         *  <igx-drop-down-item [role]="customRole"></igx-drop-down-item>
         * ```
         */
        this.role = 'option';
    }
    get hasIndex() {
        return this._index !== null && this._index !== undefined;
    }
    /**
     * @hidden @internal
     */
    get itemID() {
        return this;
    }
    /**
     * The data index of the dropdown item.
     *
     * ```typescript
     * // get the data index of the selected dropdown item
     * let selectedItemIndex = this.dropdown.selectedItem.index
     * ```
     */
    get index() {
        if (this._index === null) {
            warningShown$1 = showMessage('IgxDropDownItemBaseDirective: Automatic index is deprecated.' +
                'Bind in the template instead using `<igx-drop-down-item [index]="i"` instead.`', warningShown$1);
            return this.itemIndex;
        }
        return this._index;
    }
    set index(value) {
        this._index = value;
    }
    /**
     * @hidden @internal
     */
    get itemStyle() {
        return !this.isHeader;
    }
    /**
     * @hidden @internal
     */
    get itemStyleCosy() {
        return this.dropDown.displayDensity === 'cosy' && !this.isHeader;
    }
    /**
     * @hidden @internal
     */
    get itemStyleCompact() {
        return this.dropDown.displayDensity === 'compact' && !this.isHeader;
    }
    /**
     * Sets/Gets if the item is the currently selected one in the dropdown
     *
     * ```typescript
     *  let mySelectedItem = this.dropdown.selectedItem;
     *  let isMyItemSelected = mySelectedItem.selected; // true
     * ```
     *
     * Two-way data binding
     * ```html
     * <igx-drop-down-item [(selected)]='model.isSelected'></igx-drop-down-item>
     * ```
     */
    get selected() {
        return this._selected;
    }
    set selected(value) {
        if (this.isHeader) {
            return;
        }
        this._selected = value;
        this.selectedChange.emit(this._selected);
    }
    /**
     * Sets/gets if the given item is focused
     * ```typescript
     *  let mySelectedItem = this.dropdown.selectedItem;
     *  let isMyItemFocused = mySelectedItem.focused;
     * ```
     */
    get focused() {
        return this.isSelectable && this._focused;
    }
    /**
     * ```html
     *  <igx-drop-down-item *ngFor="let item of items" focused={{!item.focused}}>
     *      <div>
     *          {{item.field}}
     *      </div>
     *  </igx-drop-down-item>
     * ```
     */
    set focused(value) {
        this._focused = value;
    }
    /**
     * @hidden @internal
     */
    get headerClassCosy() {
        return this.isHeader && this.dropDown.displayDensity === 'cosy';
    }
    /**
     * @hidden @internal
     */
    get headerClassCompact() {
        return this.isHeader && this.dropDown.displayDensity === 'compact';
    }
    /**
     * Sets/gets if the given item is disabled
     *
     * ```typescript
     *  // get
     *  let mySelectedItem = this.dropdown.selectedItem;
     *  let myItemIsDisabled = mySelectedItem.disabled;
     * ```
     *
     * ```html
     *  <igx-drop-down-item *ngFor="let item of items" disabled={{!item.disabled}}>
     *      <div>
     *          {{item.field}}
     *      </div>
     *  </igx-drop-down-item>
     * ```
     * **NOTE:** Drop-down items inside of a disabled `IgxDropDownGroup` will always count as disabled
     */
    get disabled() {
        return this.group ? this.group.disabled || this._disabled : this._disabled;
    }
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * Gets item index
     * @hidden @internal
     */
    get itemIndex() {
        return this.dropDown.items.indexOf(this);
    }
    /**
     * Gets item element height
     * @hidden @internal
     */
    get elementHeight() {
        return this.elementRef.nativeElement.clientHeight;
    }
    /**
     * Get item html element
     * @hidden @internal
     */
    get element() {
        return this.elementRef;
    }
    ngDoCheck() {
        if (this._selected) {
            const dropDownSelectedItem = this.dropDown.selectedItem;
            if (!dropDownSelectedItem) {
                this.dropDown.selectItem(this);
            }
            else if (this.hasIndex
                ? this._index !== dropDownSelectedItem.index || this.value !== dropDownSelectedItem.value :
                this !== dropDownSelectedItem) {
                this.dropDown.selectItem(this);
            }
        }
    }
    /** Returns true if the items is not a header or disabled  */
    get isSelectable() {
        return !(this.disabled || this.isHeader);
    }
    /** If `allowItemsFocus` is enabled, keep the browser focus on the active item */
    ensureItemFocus() {
        if (this.dropDown.allowItemsFocus) {
            const focusedItem = this.dropDown.items.find((item) => item.focused);
            if (!focusedItem) {
                return;
            }
            focusedItem.element.nativeElement.focus({ preventScroll: true });
        }
    }
    /**
     * @hidden
     * @internal
     */
    clicked(event) {
    }
}
IgxDropDownItemBaseDirective.ɵfac = function IgxDropDownItemBaseDirective_Factory(t) { return new (t || IgxDropDownItemBaseDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_DROPDOWN_BASE), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxDropDownGroupComponent, 8), ɵngcc0.ɵɵdirectiveInject(IgxSelectionAPIService, 8)); };
IgxDropDownItemBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDropDownItemBaseDirective, selectors: [["", "igxDropDownItemBase", ""]], hostVars: 22, hostBindings: function IgxDropDownItemBaseDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxDropDownItemBaseDirective_click_HostBindingHandler($event) { return ctx.clicked($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role)("aria-selected", ctx.selected)("aria-disabled", ctx.disabled);
        ɵngcc0.ɵɵclassProp("igx-drop-down__item", ctx.itemStyle)("igx-drop-down__item--cosy", ctx.itemStyleCosy)("igx-drop-down__item--compact", ctx.itemStyleCompact)("igx-drop-down__item--selected", ctx.selected)("igx-drop-down__item--focused", ctx.focused)("igx-drop-down__header--cosy", ctx.headerClassCosy)("igx-drop-down__header--compact", ctx.headerClassCompact)("igx-drop-down__item--disabled", ctx.disabled)("igx-drop-down__header", ctx.isHeader);
    } }, inputs: { id: "id", role: "role", index: "index", selected: "selected", disabled: "disabled", value: "value", isHeader: "isHeader" }, outputs: { selectedChange: "selectedChange" } });
IgxDropDownItemBaseDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DROPDOWN_BASE,] }] },
    { type: ElementRef },
    { type: IgxDropDownGroupComponent, decorators: [{ type: Optional }] },
    { type: IgxSelectionAPIService, decorators: [{ type: Optional }, { type: Inject, args: [IgxSelectionAPIService,] }] }
];
IgxDropDownItemBaseDirective.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    index: [{ type: Input }],
    value: [{ type: Input }],
    itemStyle: [{ type: HostBinding, args: ['class.igx-drop-down__item',] }],
    itemStyleCosy: [{ type: HostBinding, args: ['class.igx-drop-down__item--cosy',] }],
    itemStyleCompact: [{ type: HostBinding, args: ['class.igx-drop-down__item--compact',] }],
    selected: [{ type: Input }, { type: HostBinding, args: ['attr.aria-selected',] }, { type: HostBinding, args: ['class.igx-drop-down__item--selected',] }],
    selectedChange: [{ type: Output }],
    focused: [{ type: HostBinding, args: ['class.igx-drop-down__item--focused',] }],
    isHeader: [{ type: Input }, { type: HostBinding, args: ['class.igx-drop-down__header',] }],
    headerClassCosy: [{ type: HostBinding, args: ['class.igx-drop-down__header--cosy',] }],
    headerClassCompact: [{ type: HostBinding, args: ['class.igx-drop-down__header--compact',] }],
    disabled: [{ type: Input }, { type: HostBinding, args: ['attr.aria-disabled',] }, { type: HostBinding, args: ['class.igx-drop-down__item--disabled',] }],
    role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }],
    clicked: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * The `<igx-drop-down-item>` is a container intended for row items in
 * a `<igx-drop-down>` container.
 */
class IgxDropDownItemComponent extends IgxDropDownItemBaseDirective {
    /**
     * @inheritdoc
     */
    get focused() {
        let focusedState = this._focused;
        if (this.hasIndex) {
            const focusedItem = this.selection.first_item(`${this.dropDown.id}-active`);
            const focusedIndex = focusedItem ? focusedItem.index : -1;
            focusedState = this._index === focusedIndex;
        }
        return this.isSelectable && focusedState;
    }
    /**
     * @inheritdoc
     */
    set focused(value) {
        this._focused = value;
    }
    /**
     * @inheritdoc
     */
    get selected() {
        if (this.hasIndex) {
            const item = this.selection.first_item(`${this.dropDown.id}`);
            return item ? item.index === this._index && item.value === this.value : false;
        }
        return this._selected;
    }
    /**
     * @inheritdoc
     */
    set selected(value) {
        if (this.isHeader) {
            return;
        }
        this._selected = value;
        this.selectedChange.emit(this._selected);
    }
    /**
     * @hidden @internal
     */
    get setTabIndex() {
        const shouldSetTabIndex = this.dropDown.allowItemsFocus && this.isSelectable;
        if (shouldSetTabIndex) {
            return 0;
        }
        else {
            return null;
        }
    }
    /**
     * @inheritdoc
     */
    clicked(event) {
        if (!this.isSelectable) {
            this.ensureItemFocus();
            return;
        }
        if (this.selection) {
            this.dropDown.selectItem(this, event);
        }
    }
}
IgxDropDownItemComponent.ɵfac = function IgxDropDownItemComponent_Factory(t) { return ɵIgxDropDownItemComponent_BaseFactory(t || IgxDropDownItemComponent); };
IgxDropDownItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDropDownItemComponent, selectors: [["igx-drop-down-item"]], hostVars: 1, hostBindings: function IgxDropDownItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.setTabIndex);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 2, vars: 0, consts: [[1, "igx-drop-down__inner"]], template: function IgxDropDownItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
IgxDropDownItemComponent.propDecorators = {
    setTabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }]
};

/**
 * Defines the possible values of the components' display density.
 */
const DisplayDensity = mkenum({
    comfortable: 'comfortable',
    cosy: 'cosy',
    compact: 'compact'
});
/**
 * Defines the DisplayDensity DI token.
 */
const DisplayDensityToken = new InjectionToken('DisplayDensity');
/**
 * Base class containing all logic required for implementing DisplayDensity.
 */
// tslint:disable-next-line: directive-class-suffix
class DisplayDensityBase {
    constructor(displayDensityOptions) {
        this.displayDensityOptions = displayDensityOptions;
        this.onDensityChanged = new EventEmitter();
        this.oldDisplayDensityOptions = { displayDensity: DisplayDensity.comfortable };
        Object.assign(this.oldDisplayDensityOptions, displayDensityOptions);
    }
    /**
     * Returns the theme of the component.
     * The default theme is `comfortable`.
     * Available options are `comfortable`, `cosy`, `compact`.
     * ```typescript
     * let componentTheme = this.component.displayDensity;
     * ```
     */
    get displayDensity() {
        return this._displayDensity ||
            ((this.displayDensityOptions && this.displayDensityOptions.displayDensity) || DisplayDensity.comfortable);
    }
    /**
     * Sets the theme of the component.
     */
    set displayDensity(val) {
        const currentDisplayDensity = this._displayDensity;
        this._displayDensity = val;
        if (currentDisplayDensity !== this._displayDensity) {
            const densityChangedArgs = {
                oldDensity: currentDisplayDensity,
                newDensity: this._displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.initialDensity = this._displayDensity;
    }
    ngDoCheck() {
        if (!this._displayDensity && this.displayDensityOptions &&
            this.oldDisplayDensityOptions.displayDensity !== this.displayDensityOptions.displayDensity) {
            const densityChangedArgs = {
                oldDensity: this.oldDisplayDensityOptions.displayDensity,
                newDensity: this.displayDensityOptions.displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
            this.oldDisplayDensityOptions = Object.assign(this.oldDisplayDensityOptions, this.displayDensityOptions);
        }
    }
    /**
     * Given a style class of a component/element returns the modified version of it based
     * on the current display density.
     */
    getComponentDensityClass(baseStyleClass) {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return `${baseStyleClass}--${DisplayDensity.cosy}`;
            case DisplayDensity.compact:
                return `${baseStyleClass}--${DisplayDensity.compact}`;
            default:
                return baseStyleClass;
        }
    }
}
DisplayDensityBase.ɵfac = function DisplayDensityBase_Factory(t) { return new (t || DisplayDensityBase)(ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
DisplayDensityBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DisplayDensityBase, selectors: [["", "igxDisplayDensityBase", ""]], inputs: { displayDensity: "displayDensity" }, outputs: { onDensityChanged: "onDensityChanged" } });
DisplayDensityBase.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
DisplayDensityBase.propDecorators = {
    displayDensity: [{ type: Input }],
    onDensityChanged: [{ type: Output }]
};
class IgxDisplayDensityModule {
}
IgxDisplayDensityModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDisplayDensityModule });
IgxDisplayDensityModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDisplayDensityModule_Factory(t) { return new (t || IgxDisplayDensityModule)(); } });

let NEXT_ID$2 = 0;
/**
 * An abstract class, defining a drop-down component, with:
 * Properties for display styles and classes
 * A collection items of type `IgxDropDownItemBaseDirective`
 * Properties and methods for navigating (highlighting/focusing) items from the collection
 * Properties and methods for selecting items from the collection
 */
class IgxDropDownBaseDirective extends DisplayDensityBase {
    constructor(elementRef, cdr, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this._displayDensityOptions = _displayDensityOptions;
        this._focusedItem = null;
        this._id = `igx-drop-down-${NEXT_ID$2++}`;
        /**
         * Emitted when item selection is changing, before the selection completes
         *
         * ```html
         * <igx-drop-down (onSelection)='handleSelection()'></igx-drop-down>
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         * Gets/Sets the drop down's container max height.
         *
         * ```typescript
         * // get
         * let maxHeight = this.dropdown.maxHeight;
         * ```
         * ```html
         * <!--set-->
         * <igx-drop-down [maxHeight]='200px'></igx-drop-down>
         * ```
         */
        this.maxHeight = null;
        /**
         * @hidden @internal
         */
        this.cssClass = true;
    }
    /**
     * @hidden @internal
     * Get dropdown's html element of its scroll container
     */
    get scrollContainer() {
        return this.element;
    }
    /**
     * Gets/Sets the drop down's id
     *
     * ```typescript
     * // get
     * let myDropDownCurrentId = this.dropdown.id;
     * ```
     * ```html
     * <!--set-->
     * <igx-drop-down [id]='newDropDownId'></igx-drop-down>
     * ```
     */
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    /**
     * Get all non-header items
     *
     * ```typescript
     * let myDropDownItems = this.dropdown.items;
     * ```
     */
    get items() {
        const items = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (!child.isHeader) {
                    items.push(child);
                }
            }
        }
        return items;
    }
    /**
     * Get all header items
     *
     * ```typescript
     * let myDropDownHeaderItems = this.dropdown.headers;
     * ```
     */
    get headers() {
        const headers = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (child.isHeader) {
                    headers.push(child);
                }
            }
        }
        return headers;
    }
    /**
     * Get dropdown html element
     *
     * ```typescript
     * let myDropDownElement = this.dropdown.element;
     * ```
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /** Keydown Handler */
    onItemActionKey(key, event) {
        switch (key) {
            case DropDownActionKey.ENTER:
            case DropDownActionKey.SPACE:
                this.selectItem(this.focusedItem, event);
                break;
            case DropDownActionKey.ESCAPE:
        }
    }
    /**
     * Emits onSelection with the target item & event
     * @hidden @internal
     * @param newSelection the item selected
     * @param event the event that triggered the call
     */
    selectItem(newSelection, event) {
        this.onSelection.emit({
            newSelection,
            oldSelection: null,
            cancel: false
        });
    }
    /**
     * @hidden @internal
     */
    get focusedItem() {
        return this._focusedItem;
    }
    /**
     * @hidden @internal
     */
    set focusedItem(item) {
        this._focusedItem = item;
    }
    navigate(direction, currentIndex) {
        let index = -1;
        if (this._focusedItem) {
            index = currentIndex ? currentIndex : this.focusedItem.itemIndex;
        }
        const newIndex = this.getNearestSiblingFocusableItemIndex(index, direction);
        this.navigateItem(newIndex);
    }
    getNearestSiblingFocusableItemIndex(startIndex, direction) {
        let index = startIndex;
        const items = this.items;
        while (items[index + direction] && items[index + direction].disabled) {
            index += direction;
        }
        index += direction;
        if (index >= 0 && index < items.length) {
            return index;
        }
        else {
            return -1;
        }
    }
    /**
     * Navigates to the item on the specified index
     * @param newIndex number - the index of the item in the `items` collection
     */
    navigateItem(newIndex) {
        if (newIndex !== -1) {
            const oldItem = this._focusedItem;
            const newItem = this.items[newIndex];
            if (oldItem) {
                oldItem.focused = false;
            }
            this.focusedItem = newItem;
            this.scrollToHiddenItem(newItem);
            this.focusedItem.focused = true;
        }
    }
    /**
     * @hidden @internal
     */
    navigateFirst() {
        this.navigate(Navigate.Down, -1);
    }
    /**
     * @hidden @internal
     */
    navigateLast() {
        this.navigate(Navigate.Up, this.items.length);
    }
    /**
     * @hidden @internal
     */
    navigateNext() {
        this.navigate(Navigate.Down);
    }
    /**
     * @hidden @internal
     */
    navigatePrev() {
        this.navigate(Navigate.Up);
    }
    scrollToHiddenItem(newItem) {
        const elementRect = newItem.element.nativeElement.getBoundingClientRect();
        const parentRect = this.scrollContainer.getBoundingClientRect();
        if (parentRect.top > elementRect.top) {
            this.scrollContainer.scrollTop -= (parentRect.top - elementRect.top);
        }
        if (parentRect.bottom < elementRect.bottom) {
            this.scrollContainer.scrollTop += (elementRect.bottom - parentRect.bottom);
        }
    }
}
IgxDropDownBaseDirective.ɵfac = function IgxDropDownBaseDirective_Factory(t) { return new (t || IgxDropDownBaseDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxDropDownBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDropDownBaseDirective, hostVars: 4, hostBindings: function IgxDropDownBaseDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("max-height", ctx.maxHeight);
        ɵngcc0.ɵɵclassProp("igx-drop-down", ctx.cssClass);
    } }, inputs: { maxHeight: "maxHeight", id: "id", width: "width", height: "height" }, outputs: { onSelection: "onSelection" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxDropDownBaseDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxDropDownBaseDirective.propDecorators = {
    onSelection: [{ type: Output }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    id: [{ type: Input }],
    maxHeight: [{ type: Input }, { type: HostBinding, args: ['style.maxHeight',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-drop-down',] }]
};

class DisplayContainerComponent {
    constructor(cdr, _viewContainer) {
        this.cdr = cdr;
        this._viewContainer = _viewContainer;
        this.cssClass = 'igx-display-container';
        this.notVirtual = true;
    }
}
DisplayContainerComponent.ɵfac = function DisplayContainerComponent_Factory(t) { return new (t || DisplayContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
DisplayContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DisplayContainerComponent, selectors: [["igx-display-container"]], viewQuery: function DisplayContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c3, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._vcr = _t.first);
    } }, hostVars: 4, hostBindings: function DisplayContainerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.cssClass);
        ɵngcc0.ɵɵclassProp("igx-display-container--inactive", ctx.notVirtual);
    } }, decls: 2, vars: 2, consts: [["igxScrollInertia", "", 3, "IgxScrollInertiaScrollContainer", "IgxScrollInertiaDirection"], ["display_container", ""]], template: function DisplayContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DisplayContainerComponent_ng_template_0_Template, 0, 0, "ng-template", 0, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("IgxScrollInertiaScrollContainer", ctx.scrollContainer)("IgxScrollInertiaDirection", ctx.scrollDirection);
    } }, directives: function () { return [IgxScrollInertiaDirective]; }, encapsulation: 2 });
DisplayContainerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ViewContainerRef }
];
DisplayContainerComponent.propDecorators = {
    _vcr: [{ type: ViewChild, args: ['display_container', { read: ViewContainerRef, static: true },] }],
    cssClass: [{ type: HostBinding, args: ['class',] }],
    notVirtual: [{ type: HostBinding, args: ['class.igx-display-container--inactive',] }]
};

class VirtualHelperBaseDirective {
    constructor(elementRef, cdr, _zone, document) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this._zone = _zone;
        this.document = document;
        this.scrollAmount = 0;
        this._size = 0;
        this._afterViewInit = false;
        this._detached = false;
        this.destroy$ = new Subject();
        this._scrollNativeSize = this.calculateScrollNativeSize();
    }
    ngAfterViewInit() {
        this._afterViewInit = true;
        const delayTime = isIE() ? 40 : 0;
        this._zone.runOutsideAngular(() => {
            resizeObservable(this.nativeElement).pipe(throttleTime(delayTime), takeUntil(this.destroy$)).subscribe((event) => this.handleMutations(event));
        });
    }
    onScroll(event) {
        this.scrollAmount = event.target.scrollTop || event.target.scrollLeft;
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    ngOnDestroy() {
        this.destroyed = true;
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    set size(value) {
        if (this.destroyed) {
            return;
        }
        this._size = value;
        if (this._afterViewInit) {
            this.cdr.detectChanges();
        }
    }
    get size() {
        return this._size;
    }
    get scrollNativeSize() {
        return this._scrollNativeSize;
    }
    get isAttachedToDom() {
        return this.document.body.contains(this.nativeElement);
    }
    handleMutations(event) {
        const hasSize = !(event[0].contentRect.height === 0 && event[0].contentRect.width === 0);
        if (!hasSize && !this.isAttachedToDom) {
            // scroll bar detached from DOM
            this._detached = true;
        }
        else if (this._detached && hasSize && this.isAttachedToDom) {
            // attached back now.
            this.restoreScroll();
        }
    }
    restoreScroll() { }
    calculateScrollNativeSize() {
        const div = document.createElement('div');
        const style = div.style;
        style.width = '100px';
        style.height = '100px';
        style.position = 'absolute';
        style.top = '-10000px';
        style.top = '-10000px';
        style.overflow = 'scroll';
        document.body.appendChild(div);
        const scrollWidth = div.offsetWidth - div.clientWidth;
        document.body.removeChild(div);
        return scrollWidth ? scrollWidth + 1 : 1;
    }
}
VirtualHelperBaseDirective.ɵfac = function VirtualHelperBaseDirective_Factory(t) { return new (t || VirtualHelperBaseDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };
VirtualHelperBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: VirtualHelperBaseDirective, selectors: [["", "igxVirtualHelperBase", ""]], hostBindings: function VirtualHelperBaseDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("scroll", function VirtualHelperBaseDirective_scroll_HostBindingHandler($event) { return ctx.onScroll($event); });
    } } });
VirtualHelperBaseDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
VirtualHelperBaseDirective.propDecorators = {
    onScroll: [{ type: HostListener, args: ['scroll', ['$event'],] }]
};

/**
 * @hidden
 */
class HVirtualHelperComponent extends VirtualHelperBaseDirective {
    constructor(elementRef, cdr, _zone, document) {
        super(elementRef, cdr, _zone, document);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this._zone = _zone;
        this.document = document;
        this.cssClasses = 'igx-vhelper--horizontal';
    }
    restoreScroll() {
        this.nativeElement.scrollLeft = this.scrollAmount;
    }
}
HVirtualHelperComponent.ɵfac = function HVirtualHelperComponent_Factory(t) { return new (t || HVirtualHelperComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };
HVirtualHelperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HVirtualHelperComponent, selectors: [["igx-horizontal-virtual-helper"]], viewQuery: function HVirtualHelperComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c4, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._vcr = _t.first);
    } }, hostVars: 2, hostBindings: function HVirtualHelperComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.cssClasses);
    } }, inputs: { width: "width" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [[1, "igx-vhelper__placeholder-content"], ["horizontal_container", ""]], template: function HVirtualHelperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.size, "px");
    } }, encapsulation: 2 });
HVirtualHelperComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
HVirtualHelperComponent.propDecorators = {
    _vcr: [{ type: ViewChild, args: ['horizontal_container', { read: ViewContainerRef, static: true },] }],
    width: [{ type: Input }],
    cssClasses: [{ type: HostBinding, args: ['class',] }]
};

class VirtualHelperComponent extends VirtualHelperBaseDirective {
    constructor(elementRef, cdr, _zone, document) {
        super(elementRef, cdr, _zone, document);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this._zone = _zone;
        this.document = document;
        this.cssClasses = 'igx-vhelper--vertical';
    }
    ngOnInit() {
        this.scrollWidth = this.scrollNativeSize;
    }
    restoreScroll() {
        this.nativeElement.scrollTop = this.scrollAmount;
    }
}
VirtualHelperComponent.ɵfac = function VirtualHelperComponent_Factory(t) { return new (t || VirtualHelperComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };
VirtualHelperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: VirtualHelperComponent, selectors: [["igx-virtual-helper"]], viewQuery: function VirtualHelperComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c5, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._vcr = _t.first);
    } }, hostVars: 5, hostBindings: function VirtualHelperComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("scrollTop", ctx.scrollTop);
        ɵngcc0.ɵɵclassMap(ctx.cssClasses);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollWidth, "px");
    } }, inputs: { itemsLength: "itemsLength" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [[1, "igx-vhelper__placeholder-content"], ["container", ""]], template: function VirtualHelperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("height", ctx.size, "px");
    } }, encapsulation: 2 });
VirtualHelperComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
VirtualHelperComponent.propDecorators = {
    scrollTop: [{ type: HostBinding, args: ['scrollTop',] }],
    scrollWidth: [{ type: HostBinding, args: ['style.width.px',] }],
    _vcr: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }],
    itemsLength: [{ type: Input }],
    cssClasses: [{ type: HostBinding, args: ['class',] }]
};

/**
 * @hidden
 */
class IgxScrollInertiaDirective {
    constructor(element, _zone) {
        this.element = element;
        this._zone = _zone;
        this.wheelStep = 50;
        this.inertiaStep = 1.5;
        this.swipeToleranceX = 20;
        this.inertiaDeltaY = 3;
        this.inertiaDeltaX = 2;
        this.inertiaDuration = 0.5;
        this._savedSpeedsX = [];
        this.setPointerCaptureFName = typeof Element.prototype['msSetPointerCapture'] === 'function' ?
            'msSetPointerCapture' :
            'setPointerCapture';
        this.releasePointerCaptureFName = typeof Element.prototype['msReleasePointerCapture'] === 'function' ?
            'msReleasePointerCapture' :
            'releasePointerCapture';
        this.baseDeltaMultiplier = 1 / 120;
        this.firefoxDeltaMultiplier = 1 / 30;
    }
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            this.parentElement = this.element.nativeElement.parentElement || this.element.nativeElement.parentNode;
            const targetElem = this.parentElement;
            targetElem.addEventListener('wheel', (evt) => { this.onWheel(evt); });
            targetElem.addEventListener('touchstart', (evt) => { this.onTouchStart(evt); });
            targetElem.addEventListener('touchmove', (evt) => { this.onTouchMove(evt); });
            targetElem.addEventListener('touchend', (evt) => { this.onTouchEnd(evt); });
            targetElem.addEventListener('pointerdown', (evt) => { this.onPointerDown(evt); });
            targetElem.addEventListener('pointerup', (evt) => { this.onPointerUp(evt); });
            targetElem.addEventListener('MSGestureStart', (evt) => { this.onMSGestureStart(evt); });
            targetElem.addEventListener('MSGestureChange', (evt) => { this.onMSGestureChange(evt); });
        });
    }
    /**
     * @hidden
     * Function that is called when scrolling with the mouse wheel or using touchpad
     */
    onWheel(evt) {
        // if no scrollbar return
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        // if ctrl key is pressed and the user want to zoom in/out the page
        if (evt.ctrlKey) {
            return;
        }
        let scrollDeltaX;
        let scrollDeltaY;
        const scrollStep = this.wheelStep;
        const minWheelStep = 1 / this.wheelStep;
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        if (evt.wheelDeltaX) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaX = -evt.wheelDeltaX * this.baseDeltaMultiplier;
            if (-minWheelStep < scrollDeltaX && scrollDeltaX < minWheelStep) {
                scrollDeltaX = Math.sign(scrollDeltaX) * minWheelStep;
            }
        }
        else if (evt.deltaX) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            const deltaScaledX = evt.deltaX * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);
            scrollDeltaX = this.calcAxisCoords(deltaScaledX, -1, 1);
        }
        /** Get delta for the Y axis */
        if (evt.wheelDeltaY) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaY = -evt.wheelDeltaY * this.baseDeltaMultiplier;
            if (-minWheelStep < scrollDeltaY && scrollDeltaY < minWheelStep) {
                scrollDeltaY = Math.sign(scrollDeltaY) * minWheelStep;
            }
        }
        else if (evt.deltaY) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            const deltaScaledY = evt.deltaY * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);
            scrollDeltaY = this.calcAxisCoords(deltaScaledY, -1, 1);
        }
        if (scrollDeltaX && this.IgxScrollInertiaDirection === 'horizontal') {
            this._scrollToX(this._startX + scrollDeltaX * scrollStep);
            const curScrollLeft = this.IgxScrollInertiaScrollContainer.scrollLeft;
            const maxScrollLeft = parseInt(this.IgxScrollInertiaScrollContainer.children[0].style.width, 10);
            if (0 < curScrollLeft && curScrollLeft < maxScrollLeft) {
                // Prevent navigating through pages when scrolling on Mac
                evt.preventDefault();
            }
        }
        else if (scrollDeltaY && this.IgxScrollInertiaDirection === 'vertical') {
            this._scrollToY(this._startY + scrollDeltaY * scrollStep);
            this.preventParentScroll(evt, true);
        }
    }
    /**
     * @hidden
     * When there is still room to scroll up/down prevent the parent elements from scrolling too.
     */
    preventParentScroll(evt, preventDefault) {
        const curScrollTop = this.IgxScrollInertiaScrollContainer.scrollTop;
        const maxScrollTop = this.IgxScrollInertiaScrollContainer.children[0].scrollHeight -
            this.IgxScrollInertiaScrollContainer.offsetHeight;
        if (0 < curScrollTop && curScrollTop < maxScrollTop) {
            if (preventDefault) {
                evt.preventDefault();
            }
            if (evt.stopPropagation) {
                evt.stopPropagation();
            }
        }
    }
    /**
     * @hidden
     * Function that is called the first moment we start interacting with the content on a touch device
     */
    onTouchStart(event) {
        if (typeof MSGesture === 'function' || !this.IgxScrollInertiaScrollContainer) {
            return false;
        }
        // stops any current ongoing inertia
        cancelAnimationFrame(this._touchInertiaAnimID);
        const touch = event.touches[0];
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = touch.pageX;
        this._touchStartY = touch.pageY;
        this._lastTouchEnd = new Date().getTime();
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._savedSpeedsX = [];
        this._savedSpeedsY = [];
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        this._touchPrevented = false;
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    /**
     * @hidden
     * Function that is called when we need to scroll the content based on touch interactions
     */
    onTouchMove(event) {
        if (typeof MSGesture === 'function') {
            this._touchPrevented = false;
            return false;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        const touch = event.touches[0];
        const destX = this._startX + (this._touchStartX - touch.pageX) * Math.sign(this.inertiaStep);
        const destY = this._startY + (this._touchStartY - touch.pageY) * Math.sign(this.inertiaStep);
        /* Handle complex touchmoves when swipe stops but the toch doesn't end and then a swipe is initiated again */
        /* **********************************************************/
        const timeFromLastTouch = (new Date().getTime()) - this._lastTouchEnd;
        if (timeFromLastTouch !== 0 && timeFromLastTouch < 100) {
            const speedX = (this._lastTouchX - touch.pageX) / timeFromLastTouch;
            const speedY = (this._lastTouchY - touch.pageY) / timeFromLastTouch;
            // Save the last 5 speeds between two touchmoves on X axis
            if (this._savedSpeedsX.length < 5) {
                this._savedSpeedsX.push(speedX);
            }
            else {
                this._savedSpeedsX.shift();
                this._savedSpeedsX.push(speedX);
            }
            // Save the last 5 speeds between two touchmoves on Y axis
            if (this._savedSpeedsY.length < 5) {
                this._savedSpeedsY.push(speedY);
            }
            else {
                this._savedSpeedsY.shift();
                this._savedSpeedsY.push(speedY);
            }
        }
        this._lastTouchEnd = new Date().getTime();
        this._lastMovedX = this._lastTouchX - touch.pageX;
        this._lastMovedY = this._lastTouchY - touch.pageY;
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._totalMovedX += this._lastMovedX;
        let scrolledXY; // Object: {x, y}
        /*	Do not scroll using touch untill out of the swipeToleranceX bounds */
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            scrolledXY = this._scrollTo(this._startX, destY);
        }
        else {
            /*	Record the direction the first time we are out of the swipeToleranceX bounds.
            *	That way we know which direction we apply the offset so it doesn't hickup when moving out of the swipeToleranceX bounds */
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /*	Scroll with offset ammout of swipeToleranceX in the direction we have exited the bounds and
            don't change it after that ever until touchend and again touchstart */
            scrolledXY = this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        if (scrolledXY.x === 0 && scrolledXY.y === 0) {
            this._touchPrevented = true;
        }
        // On Safari preventing the touchmove would prevent default page scroll behaviour even if there is the element doesn't have overflow
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, true);
        }
    }
    onTouchEnd(event) {
        if (typeof MSGesture === 'function') {
            return;
        }
        let speedX = 0;
        let speedY = 0;
        // savedSpeedsX and savedSpeedsY have same length
        for (let i = 0; i < this._savedSpeedsX.length; i++) {
            speedX += this._savedSpeedsX[i];
            speedY += this._savedSpeedsY[i];
        }
        speedX = this._savedSpeedsX.length ? speedX / this._savedSpeedsX.length : 0;
        speedY = this._savedSpeedsX.length ? speedY / this._savedSpeedsY.length : 0;
        // Use the lastMovedX and lastMovedY to determine if the swipe stops without lifting the finger so we don't start inertia
        if ((Math.abs(speedX) > 0.1 || Math.abs(speedY) > 0.1) &&
            (Math.abs(this._lastMovedX) > 2 || Math.abs(this._lastMovedY) > 2)) {
            this._inertiaInit(speedX, speedY);
        }
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    /**
     * @hidden
     * Function that is called when we need to detect touch starting on a touch device on IE/Edge
     */
    onPointerDown(event) {
        if (!event || (event.pointerType !== 2 && event.pointerType !== 'touch') ||
            typeof MSGesture !== 'function') {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        // setPointerCaptureFName is the name of the function that is supported
        event.target[this.setPointerCaptureFName](this._pointer = event.pointerId);
        // create gestureObject only one time to prevent overlapping during intertia
        if (!this._gestureObject) {
            this._gestureObject = new MSGesture();
            this._gestureObject.target = this.parentElement;
        }
        this._gestureObject.addPointer(this._pointer);
    }
    /**
     * @hidden
     * Function that is called when we need to detect touch ending on a touch device on IE/Edge
     */
    onPointerUp(event) {
        if (!this._pointer) {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        /* releasePointerCaptureFName is the name of the function that is supported */
        event.target[this.releasePointerCaptureFName](this._pointer);
        delete this._pointer;
    }
    /**
     * @hidden
     *  Function that is called when a gesture begins on IE/Edge
     */
    onMSGestureStart(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = event.screenX;
        this._touchStartY = event.screenY;
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        return false;
    }
    /**
     * @hidden
     * Function that is called when a we need to scroll based on the gesture performed on IE/Edge
     */
    onMSGestureChange(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        const touchPos = event, destX = this._startX + this._touchStartX - touchPos.screenX, destY = this._startY + this._touchStartY - touchPos.screenY;
        /* Logic regarding x tolerance to prevent accidental horizontal scrolling when scrolling vertically */
        this._totalMovedX = this._touchStartX - touchPos.screenX;
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            /* Do not scroll horizontally yet while in the tolerance range */
            this._scrollToY(destY);
        }
        else {
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /* Once the tolerance is exceeded it can be scrolled horizontally */
            this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        return false;
    }
    calcAxisCoords(target, min, max) {
        if (target === undefined || target < min) {
            target = min;
        }
        else if (target > max) {
            target = max;
        }
        return target;
    }
    _scrollTo(destX, destY) {
        const curPosX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        const curPosY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // TODO Trigger scrolling event?
        const scrolledX = this._scrollToX(destX);
        const scrolledY = this._scrollToY(destY);
        return { x: scrolledX, y: scrolledY };
    }
    _scrollToX(dest) {
        this.IgxScrollInertiaScrollContainer.scrollLeft = dest;
    }
    _scrollToY(dest) {
        this.IgxScrollInertiaScrollContainer.scrollTop = dest;
    }
    _inertiaInit(speedX, speedY) {
        const stepModifer = this.inertiaStep, inertiaDuration = this.inertiaDuration;
        let x = 0;
        this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // Sets timeout until executing next movement iteration of the inertia
        const inertiaStep = () => {
            if (x > 6) {
                cancelAnimationFrame(this._touchInertiaAnimID);
                return;
            }
            if (Math.abs(speedX) > Math.abs(speedY)) {
                x += 0.05 / (1 * inertiaDuration);
            }
            else {
                x += 0.05 / (1 * inertiaDuration);
            }
            if (x <= 1) {
                // We use constant quation to determine the offset without speed falloff befor x reaches 1
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += 1 * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += 1 * speedY * 15 * stepModifer;
                }
            }
            else {
                // We use the quation "y = 2 / (x + 0.55) - 0.3" to determine the offset
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += Math.abs(2 / (x + 0.55) - 0.3) * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += Math.abs(2 / (x + 0.55) - 0.3) * speedY * 15 * stepModifer;
                }
            }
            // If we have mixed environment we use the default behaviour. i.e. touchscreen + mouse
            this._scrollTo(this._nextX, this._nextY);
            this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
        };
        // Start inertia and continue it recursively
        this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
    }
    ngOnDestroy() {
        this._zone.runOutsideAngular(() => {
            const targetElem = this.parentElement;
            targetElem.removeEventListener('wheel', (evt) => { this.onWheel(evt); });
            targetElem.removeEventListener('touchstart', (evt) => { this.onTouchStart(evt); });
            targetElem.removeEventListener('touchmove', (evt) => { this.onTouchMove(evt); });
            targetElem.removeEventListener('touchend', (evt) => { this.onTouchEnd(evt); });
            targetElem.removeEventListener('pointerdown', (evt) => { this.onPointerDown(evt); });
            targetElem.removeEventListener('pointerup', (evt) => { this.onPointerUp(evt); });
            targetElem.removeEventListener('MSGestureStart', (evt) => { this.onMSGestureStart(evt); });
            targetElem.removeEventListener('MSGestureChange', (evt) => { this.onMSGestureChange(evt); });
        });
    }
}
IgxScrollInertiaDirective.ɵfac = function IgxScrollInertiaDirective_Factory(t) { return new (t || IgxScrollInertiaDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxScrollInertiaDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxScrollInertiaDirective, selectors: [["", "igxScrollInertia", ""]], inputs: { wheelStep: "wheelStep", inertiaStep: "inertiaStep", swipeToleranceX: "swipeToleranceX", inertiaDeltaY: "inertiaDeltaY", inertiaDeltaX: "inertiaDeltaX", inertiaDuration: "inertiaDuration", IgxScrollInertiaDirection: "IgxScrollInertiaDirection", IgxScrollInertiaScrollContainer: "IgxScrollInertiaScrollContainer" } });
IgxScrollInertiaDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
IgxScrollInertiaDirective.propDecorators = {
    IgxScrollInertiaDirection: [{ type: Input }],
    IgxScrollInertiaScrollContainer: [{ type: Input }],
    wheelStep: [{ type: Input }],
    inertiaStep: [{ type: Input }],
    swipeToleranceX: [{ type: Input }],
    inertiaDeltaY: [{ type: Input }],
    inertiaDeltaX: [{ type: Input }],
    inertiaDuration: [{ type: Input }]
};
/**
 * @hidden
 */
class IgxScrollInertiaModule {
}
IgxScrollInertiaModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxScrollInertiaModule });
IgxScrollInertiaModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxScrollInertiaModule_Factory(t) { return new (t || IgxScrollInertiaModule)(); }, imports: [[CommonModule]] });

class IgxForOfSyncService {
    constructor() {
        this._master = new Map();
    }
    /**
     * @hidden
     */
    isMaster(directive) {
        return this._master.get(directive.igxForScrollOrientation) === directive;
    }
    /**
     * @hidden
     */
    setMaster(directive, forced = false) {
        const orientation = directive.igxForScrollOrientation;
        if (orientation && (forced || !this._master.has(orientation))) {
            this._master.set(orientation, directive);
        }
    }
    /**
     * @hidden
     */
    resetMaster() {
        this._master.clear();
    }
    /**
     * @hidden
     */
    sizesCache(dir) {
        return this._master.get(dir).sizesCache;
    }
    /**
     * @hidden
     */
    chunkSize(dir) {
        return this._master.get(dir).state.chunkSize;
    }
}
IgxForOfSyncService.ɵfac = function IgxForOfSyncService_Factory(t) { return new (t || IgxForOfSyncService)(); };
IgxForOfSyncService.ɵprov = ɵɵdefineInjectable({ factory: function IgxForOfSyncService_Factory() { return new IgxForOfSyncService(); }, token: IgxForOfSyncService, providedIn: "root" });
class IgxForOfScrollSyncService {
    constructor() {
        this._masterScroll = new Map();
    }
    setScrollMaster(dir, scroll) {
        this._masterScroll.set(dir, scroll);
    }
    getScrollMaster(dir) {
        return this._masterScroll.get(dir);
    }
}
IgxForOfScrollSyncService.ɵfac = function IgxForOfScrollSyncService_Factory(t) { return new (t || IgxForOfScrollSyncService)(); };
IgxForOfScrollSyncService.ɵprov = ɵɵdefineInjectable({ factory: function IgxForOfScrollSyncService_Factory() { return new IgxForOfScrollSyncService(); }, token: IgxForOfScrollSyncService, providedIn: "root" });

/**
 *  @publicApi
 */
class IgxForOfContext {
    constructor($implicit, index, count) {
        this.$implicit = $implicit;
        this.index = index;
        this.count = count;
    }
    /**
     * A function that returns whether the element is the first or not
     */
    get first() { return this.index === 0; }
    /**
     * A function that returns whether the element is the last or not
     */
    get last() { return this.index === this.count - 1; }
    /**
     * A function that returns whether the element is even or not
     */
    get even() { return this.index % 2 === 0; }
    /**
     * A function that returns whether the element is odd or not
     */
    get odd() { return !this.even; }
}
class IgxForOfDirective {
    constructor(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService) {
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this.resolver = resolver;
        this.cdr = cdr;
        this._zone = _zone;
        this.syncScrollService = syncScrollService;
        /**
         * An @Input property that specifies the scroll orientation.
         * Scroll orientation can be "vertical" or "horizontal".
         * ```html
         * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'"></ng-template>
         * ```
         */
        this.igxForScrollOrientation = 'vertical';
        /**
         * The current state of the directive. It contains `startIndex` and `chunkSize`.
         * state.startIndex - The index of the item at which the current visible chunk begins.
         * state.chunkSize - The number of items the current visible chunk holds.
         * These options can be used when implementing remote virtualization as they provide the necessary state information.
         * ```typescript
         * const gridState = this.parentVirtDir.state;
         * ```
         */
        this.state = {
            startIndex: 0,
            chunkSize: 0
        };
        this._totalItemCount = null;
        /**
         * An event that is emitted after a new chunk has been loaded.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkLoad)="chunkLoad($event)"></ng-template>
         * ```
         * ```typescript
         * chunkLoad(e){
         * alert("chunk loaded!");
         * }
         * ```
         */
        this.onChunkLoad = new EventEmitter();
        /**
         * @hidden @internal
         * An event that is emitted when scrollbar visibility has changed.
         */
        this.onScrollbarVisibilityChanged = new EventEmitter();
        /**
         * An event that is emitted after the rendered content size of the igxForOf has been changed.
         */
        this.onContentSizeChange = new EventEmitter();
        /**
         * An event that is emitted after data has been changed.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onDataChanged)="dataChanged($event)"></ng-template>
         * ```
         * ```typescript
         * dataChanged(e){
         * alert("data changed!");
         * }
         * ```
         */
        this.onDataChanged = new EventEmitter();
        this.onBeforeViewDestroyed = new EventEmitter();
        /**
         * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
         * Can be used for implementing remote load on demand for the igxFor data.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkPreload)="chunkPreload($event)"></ng-template>
         * ```
         * ```typescript
         * chunkPreload(e){
         * alert("chunk is loading!");
         * }
         * ```
         */
        this.onChunkPreload = new EventEmitter();
        this._sizesCache = [];
        this._differ = null;
        this.heightCache = [];
        this.MAX_PERF_SCROLL_DIFF = 4;
        /** Height that is being virtualized. */
        this._virtHeight = 0;
        /**
         * Ratio for height that's being virtualizaed and the one visible
         * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxHeight > _virtHeight.
         */
        this._virtHeightRatio = 1;
        /** Internal track for scroll top that is being virtualized */
        this._virtScrollTop = 0;
        /** If the next onScroll event is triggered due to internal setting of scrollTop */
        this._bScrollInternal = false;
        // End properties related to virtual height handling
        this._embeddedViews = [];
        this.contentResizeNotify = new Subject();
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
    }
    /**
     * The total count of the virtual data items, when using remote service.
     * Similar to the property totalItemCount, but this will allow setting the data count into the template.
     * ```html
     * <ng-template igxFor let-item [igxForOf]="data | async" [igxForTotalItemCount]="count | async"
     *  [igxForContainerSize]="'500px'" [igxForItemSize]="'50px'"></ng-template>
     * ```
     */
    get igxForTotalItemCount() {
        return this.totalItemCount;
    }
    set igxForTotalItemCount(value) {
        this.totalItemCount = value;
    }
    /**
     * The total count of the virtual data items, when using remote service.
     * ```typescript
     * this.parentVirtDir.totalItemCount = data.Count;
     * ```
     */
    get totalItemCount() {
        return this._totalItemCount;
    }
    set totalItemCount(val) {
        if (this._totalItemCount !== val) {
            this._totalItemCount = val;
            // update sizes in case total count changes.
            const newSize = this.initSizesCache(this.igxForOf);
            const sizeDiff = this.scrollComponent.size - newSize;
            this.scrollComponent.size = newSize;
            const lastChunkExceeded = this.state.startIndex + this.state.chunkSize > val;
            if (lastChunkExceeded) {
                this.state.startIndex = val - this.state.chunkSize;
            }
            this._adjustScrollPositionAfterSizeChange(sizeDiff);
        }
    }
    get displayContainer() {
        var _a, _b, _c, _d;
        return (_d = (_c = (_b = (_a = this.dc) === null || _a === void 0 ? void 0 : _a.instance) === null || _b === void 0 ? void 0 : _b._viewContainer) === null || _c === void 0 ? void 0 : _c.element) === null || _d === void 0 ? void 0 : _d.nativeElement;
    }
    get virtualHelper() {
        return this.scrollComponent.nativeElement;
    }
    get sizesCache() {
        return this._sizesCache;
    }
    set sizesCache(value) {
        this._sizesCache = value;
    }
    get _isScrolledToBottom() {
        if (!this.getScroll()) {
            return true;
        }
        const scrollHeight = this.getScroll().scrollHeight;
        // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.
        // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.
        return Math.round(this.getScroll().scrollTop + this.igxForContainerSize) === scrollHeight;
    }
    get _isAtBottomIndex() {
        return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;
    }
    /**
     * @hidden
     */
    get isRemote() {
        return this.totalItemCount !== null;
    }
    /**
     *
     * Gets/Sets the scroll position.
     * ```typescript
     * const position = directive.scrollPosition;
     * directive.scrollPosition = value;
     * ```
     */
    get scrollPosition() {
        return this.scrollComponent.scrollAmount;
    }
    set scrollPosition(val) {
        if (val === this.scrollComponent.scrollAmount) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal' && this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollLeft = val;
        }
        else if (this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollTop = val;
        }
    }
    /**
     * @hidden
     */
    removeScrollEventListeners() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._zone.runOutsideAngular(() => { var _a, _b; return (_b = (_a = this.scrollComponent) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.removeEventListener('scroll', this.func); });
        }
        else {
            this._zone.runOutsideAngular(() => { var _a, _b; return (_b = (_a = this.scrollComponent) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.removeEventListener('scroll', this.verticalScrollHandler); });
        }
    }
    verticalScrollHandler(event) {
        this.onScroll(event);
    }
    isScrollable() {
        return this.scrollComponent.size > parseInt(this.igxForContainerSize, 10);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        let totalSize = 0;
        const vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;
        this.igxForSizePropName = this.igxForSizePropName || 'width';
        const dcFactory = this.resolver.resolveComponentFactory(DisplayContainerComponent);
        this.dc = this._viewContainer.createComponent(dcFactory, 0);
        this.dc.instance.scrollDirection = this.igxForScrollOrientation;
        if (typeof MSGesture === 'function') {
            // On Edge and IE when scrolling on touch the page scroll instead of the grid.
            this.dc.instance._viewContainer.element.nativeElement.style.touchAction = 'none';
        }
        if (this.igxForOf && this.igxForOf.length) {
            totalSize = this.initSizesCache(this.igxForOf);
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            this.state.chunkSize = this._calculateChunkSize();
            this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);
            if (this.scrollComponent && !this.scrollComponent.destroyed) {
                this.state.startIndex = Math.min(this.getIndexAt(this.scrollPosition, this.sizesCache, 0), this.igxForOf.length - this.state.chunkSize);
            }
            for (let i = this.state.startIndex; i < this.state.startIndex + this.state.chunkSize &&
                this.igxForOf[i] !== undefined; i++) {
                const input = this.igxForOf[i];
                const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
                this._embeddedViews.push(embeddedView);
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
            const factory = this.resolver.resolveComponentFactory(VirtualHelperComponent);
            this.scrollComponent = vc.createComponent(factory).instance;
            this._maxHeight = this._calcMaxBrowserHeight();
            this.scrollComponent.size = this.igxForOf ? this._calcHeight() : 0;
            this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
            this._zone.runOutsideAngular(() => {
                this.verticalScrollHandler = this.verticalScrollHandler.bind(this);
                this.scrollComponent.nativeElement.addEventListener('scroll', this.verticalScrollHandler);
                this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
            });
            const destructor = takeUntil(this.destroy$);
            this.contentResizeNotify.pipe(destructor, filter(() => this.igxForContainerSize && this.igxForOf && this.igxForOf.length > 0), throttleTime(40, undefined, { leading: true, trailing: true }))
                .subscribe(() => {
                this._zone.runTask(() => {
                    this.updateSizes();
                });
            });
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.func = (evt) => { this.onHScroll(evt); };
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            if (!this.scrollComponent) {
                const hvFactory = this.resolver.resolveComponentFactory(HVirtualHelperComponent);
                this.scrollComponent = vc.createComponent(hvFactory).instance;
                this.scrollComponent.size = totalSize;
                this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            else {
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            this._updateHScrollOffset();
        }
    }
    ngAfterViewInit() {
        if (this.igxForScrollOrientation === 'vertical') {
            this._zone.runOutsideAngular(() => {
                this.contentObserver = new ResizeObserver(() => this.contentResizeNotify.next());
                this.contentObserver.observe(this.dc.instance._viewContainer.element.nativeElement);
            });
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.removeScrollEventListeners();
        this.destroy$.next(true);
        this.destroy$.complete();
        if (this.contentObserver) {
            this.contentObserver.disconnect();
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        const forOf = 'igxForOf';
        if (forOf in changes) {
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
        }
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
            this._applyChanges();
        }
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                this._updateSizeCache();
                this._zone.run(() => {
                    this._applyChanges();
                    this.cdr.markForCheck();
                    this._updateScrollOffset();
                    this.onDataChanged.emit();
                });
            }
        }
    }
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScrollTop(5);
     * ```
     * @param addTop negative value to scroll up and positive to scroll down;
     */
    addScrollTop(addTop) {
        if (addTop === 0 && this.igxForScrollOrientation === 'horizontal') {
            return false;
        }
        const originalVirtScrollTop = this._virtScrollTop;
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const maxVirtScrollTop = this._virtHeight - containerSize;
        this._bScrollInternal = true;
        this._virtScrollTop += addTop;
        this._virtScrollTop = this._virtScrollTop > 0 ?
            (this._virtScrollTop < maxVirtScrollTop ? this._virtScrollTop : maxVirtScrollTop) :
            0;
        this.scrollPosition += addTop / this._virtHeightRatio;
        if (Math.abs(addTop / this._virtHeightRatio) < 1) {
            // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px
            const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
            // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        }
        const maxRealScrollTop = this.scrollComponent.nativeElement.scrollHeight - containerSize;
        if ((this._virtScrollTop > 0 && this.scrollPosition === 0) ||
            (this._virtScrollTop < maxVirtScrollTop && this.scrollPosition === maxRealScrollTop)) {
            // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)
            // Recalculate actual scroll position based on the virtual scroll.
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
        }
        else if (this._virtScrollTop === 0 && this.scrollPosition > 0) {
            // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll
            this.scrollPosition = 0;
        }
        else if (this._virtScrollTop === maxVirtScrollTop && this.scrollPosition < maxRealScrollTop) {
            // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll
            this.scrollPosition = maxRealScrollTop;
        }
        return this._virtScrollTop !== originalVirtScrollTop;
    }
    /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     * @param index
     */
    scrollTo(index) {
        if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {
            return;
        }
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const isPrevItem = index < this.state.startIndex || this.scrollPosition > this.sizesCache[index];
        let nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;
        if (nextScroll < 0) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition = nextScroll;
        }
        else {
            const maxVirtScrollTop = this._virtHeight - containerSize;
            if (nextScroll > maxVirtScrollTop) {
                nextScroll = maxVirtScrollTop;
            }
            this._bScrollInternal = true;
            this._virtScrollTop = nextScroll;
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
            this._adjustToIndex = !isPrevItem ? index : null;
        }
    }
    /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     */
    scrollNext() {
        const scr = Math.ceil(this.scrollPosition);
        const endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        this.scrollTo(endIndex);
    }
    /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     */
    scrollPrev() {
        this.scrollTo(this.state.startIndex - 1);
    }
    /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     */
    scrollNextPage() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition += parseInt(this.igxForContainerSize, 10);
        }
        else {
            this.addScrollTop(parseInt(this.igxForContainerSize, 10));
        }
    }
    /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     */
    scrollPrevPage() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition -= parseInt(this.igxForContainerSize, 10);
        }
        else {
            const containerSize = (parseInt(this.igxForContainerSize, 10));
            this.addScrollTop(-containerSize);
        }
    }
    /**
     * @hidden
     */
    getColumnScrollLeft(colIndex) {
        return this.sizesCache[colIndex];
    }
    /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     */
    getItemCountInView() {
        let startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);
        if (this.scrollPosition - this.sizesCache[startIndex] > 0) {
            // fisrt item is not fully in view
            startIndex++;
        }
        const endIndex = this.getIndexAt(this.scrollPosition + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        return endIndex - startIndex;
    }
    /**
     * Returns a reference to the scrollbar DOM element.
     * This is either a vertical or horizontal scrollbar depending on the specified igxForScrollOrientation.
     * ```typescript
     * dir.getScroll();
     * ```
     */
    getScroll() {
        var _a;
        return (_a = this.scrollComponent) === null || _a === void 0 ? void 0 : _a.nativeElement;
    }
    /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     */
    getSizeAt(index) {
        return this.sizesCache[index + 1] - this.sizesCache[index];
    }
    /**
     * @hidden
     * Function that is called to get the native scrollbar size that the browsers renders.
     */
    getScrollNativeSize() {
        return this.scrollComponent ? this.scrollComponent.scrollNativeSize : 0;
    }
    /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     */
    getScrollForIndex(index, bottom) {
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const scroll = bottom ? Math.max(0, this.sizesCache[index + 1] - containerSize) : this.sizesCache[index];
        return scroll;
    }
    /**
     * @hidden
     * Function that is called when scrolling vertically
     */
    onScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollTop(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        const prevStartIndex = this.state.startIndex;
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    }
    updateSizes() {
        this.recalcUpdateSizes();
        this._applyChanges();
        this._updateScrollOffset();
        this.onContentSizeChange.emit();
    }
    /**
     * @hidden
     * Function that recaculates and updates cache sizes.
     */
    recalcUpdateSizes() {
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        const diffs = [];
        let totalDiff = 0;
        const l = this._embeddedViews.length;
        const rNodes = this._embeddedViews.map(view => view.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE) || view.rootNodes[0].nextElementSibling);
        for (let i = 0; i < l; i++) {
            const rNode = rNodes[i];
            if (rNode) {
                const h = rNode.offsetHeight || parseInt(this.igxForItemSize, 10);
                const index = this.state.startIndex + i;
                if (!this.isRemote && !this.igxForOf[index]) {
                    continue;
                }
                const oldVal = dimension === 'height' ? this.heightCache[index] : this.igxForOf[index][dimension];
                const newVal = dimension === 'height' ? h : rNode.clientWidth;
                if (dimension === 'height') {
                    this.heightCache[index] = newVal;
                }
                else {
                    this.igxForOf[index][dimension] = newVal;
                }
                const currDiff = newVal - oldVal;
                diffs.push(currDiff);
                totalDiff += currDiff;
                this.sizesCache[index + 1] += totalDiff;
            }
        }
        // update cache
        if (Math.abs(totalDiff) > 0) {
            for (let j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {
                this.sizesCache[j] += totalDiff;
            }
            // update scrBar heights/widths
            if (this.igxForScrollOrientation === 'horizontal') {
                const totalWidth = parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10) + totalDiff;
                this.scrollComponent.nativeElement.children[0].style.width = totalWidth + 'px';
            }
            const reducer = (acc, val) => acc + val;
            if (this.igxForScrollOrientation === 'vertical') {
                const scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;
                const hSum = this.heightCache.reduce(reducer);
                if (hSum > this._maxHeight) {
                    this._virtHeightRatio = hSum / this._maxHeight;
                }
                this.scrollComponent.size = Math.min(this.scrollComponent.size + totalDiff, this._maxHeight);
                this._virtHeight = hSum;
                if (!this.scrollComponent.destroyed) {
                    this.scrollComponent.cdr.detectChanges();
                }
                if (scrToBottom && !this._isAtBottomIndex) {
                    const containerSize = parseInt(this.igxForContainerSize, 10);
                    const maxVirtScrollTop = this._virtHeight - containerSize;
                    this._bScrollInternal = true;
                    this._virtScrollTop = maxVirtScrollTop;
                    this.scrollPosition = maxVirtScrollTop;
                    return;
                }
                if (this._adjustToIndex) {
                    // in case scrolled to specific index where after scroll heights are changed
                    // need to adjust the offsets so that item is last in view.
                    const updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;
                    const sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);
                    if (sumDiffs !== 0) {
                        this.addScrollTop(sumDiffs);
                    }
                    this._adjustToIndex = null;
                }
            }
        }
    }
    /**
     * @hidden
     */
    fixedUpdateAllElements(inScrollTop) {
        const count = this.isRemote ? this.totalItemCount : this.igxForOf.length;
        let newStart = this.getIndexAt(inScrollTop, this.sizesCache, 0);
        if (newStart + this.state.chunkSize > count) {
            newStart = count - this.state.chunkSize;
        }
        const prevStart = this.state.startIndex;
        const diff = newStart - this.state.startIndex;
        this.state.startIndex = newStart;
        if (diff) {
            this.onChunkPreload.emit(this.state);
            if (!this.isRemote) {
                // recalculate and apply page size.
                if (diff && Math.abs(diff) <= this.MAX_PERF_SCROLL_DIFF) {
                    diff > 0 ? this.moveApplyScrollNext(prevStart) : this.moveApplyScrollPrev(prevStart);
                }
                else {
                    this.fixedApplyScroll();
                }
            }
        }
        return inScrollTop - this.sizesCache[this.state.startIndex];
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     */
    moveApplyScrollNext(prevIndex) {
        const start = prevIndex + this.state.chunkSize;
        const end = start + this.state.startIndex - prevIndex;
        const container = this.dc.instance._vcr;
        for (let i = start; i < end && this.igxForOf[i] !== undefined; i++) {
            const embView = this._embeddedViews.shift();
            this.scrollFocus(embView.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE)
                || embView.rootNodes[0].nextElementSibling);
            const view = container.detach(0);
            this.updateTemplateContext(embView.context, i);
            container.insert(view);
            this._embeddedViews.push(embView);
        }
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     */
    moveApplyScrollPrev(prevIndex) {
        const container = this.dc.instance._vcr;
        for (let i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {
            const embView = this._embeddedViews.pop();
            this.scrollFocus(embView.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE)
                || embView.rootNodes[0].nextElementSibling);
            const view = container.detach(container.length - 1);
            this.updateTemplateContext(embView.context, i);
            container.insert(view, 0);
            this._embeddedViews.unshift(embView);
        }
    }
    /**
     * @hidden
     */
    getContextIndex(input) {
        return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);
    }
    /**
     * @hidden
     * Function which updates the passed context of an embedded view with the provided index
     * from the view container.
     * Often, called while handling a scroll event.
     */
    updateTemplateContext(context, index = 0) {
        context.$implicit = this.igxForOf[index];
        context.index = this.getContextIndex(this.igxForOf[index]);
        context.count = this.igxForOf.length;
    }
    /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     */
    fixedApplyScroll() {
        let j = 0;
        const endIndex = this.state.startIndex + this.state.chunkSize;
        for (let i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
            const embView = this._embeddedViews[j++];
            this.updateTemplateContext(embView.context, i);
        }
    }
    /**
     * @hidden
     * @internal
     *
     * Clears focus inside the virtualized container on small scroll swaps.
     */
    scrollFocus(node) {
        const activeElement = document.activeElement;
        // Remove focus in case the the active element is inside the view container.
        // Otherwise we hit an exception while doing the 'small' scrolls swapping.
        // For more information:
        //
        // https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild
        // https://bugs.chromium.org/p/chromium/issues/detail?id=432392
        if (node && node.contains(document.activeElement)) {
            activeElement.blur();
        }
    }
    /**
     * @hidden
     * Function that is called when scrolling horizontally
     */
    onHScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
        }
        const prevStartIndex = this.state.startIndex;
        // Updating horizontal chunks
        const scrollOffset = this.fixedUpdateAllElements(event.target.scrollLeft);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    }
    /**
     * Gets the function used to track changes in the items collection.
     * By default the object references are compared. However this can be optimized if you have unique identifier
     * value that can be used for the comparison instead of the object ref or if you have some other property values
     * in the item object that should be tracked for changes.
     * This option is similar to ngForTrackBy.
     * ```typescript
     * const trackFunc = this.parentVirtDir.igxForTrackBy;
     * ```
     */
    get igxForTrackBy() { return this._trackByFn; }
    /**
     * Sets the function used to track changes in the items collection.
     * This function can be set in scenarios where you want to optimize or
     * customize the tracking of changes for the items in the collection.
     * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
     * ```typescript
     * this.parentVirtDir.igxForTrackBy = (index, item) => {
     *      return item.id + item.width;
     * };
     * ```
     */
    set igxForTrackBy(fn) { this._trackByFn = fn; }
    /**
     * @hidden
     */
    _applyChanges() {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            let startIndex = this.state.startIndex;
            let endIndex = this.state.chunkSize + this.state.startIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                const embView = embeddedViewCopy.shift();
                this.updateTemplateContext(embView.context, i);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
        }
    }
    /**
     * @hidden
     */
    _calcMaxBrowserHeight() {
        const div = document.createElement('div');
        const style = div.style;
        style.position = 'absolute';
        style.top = '9999999999999999px';
        document.body.appendChild(div);
        const size = Math.abs(div.getBoundingClientRect()['top']);
        document.body.removeChild(div);
        return size;
    }
    /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     */
    _calculateChunkSize() {
        let chunkSize = 0;
        if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {
            if (!this.sizesCache) {
                this.initSizesCache(this.igxForOf);
            }
            chunkSize = this._calcMaxChunkSize();
            if (this.igxForOf && chunkSize > this.igxForOf.length) {
                chunkSize = this.igxForOf.length;
            }
        }
        else {
            if (this.igxForOf) {
                chunkSize = this.igxForOf.length;
            }
        }
        return chunkSize;
    }
    /**
     * @hidden
     */
    getElement(viewref, nodeName) {
        const elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);
        return elem.length > 0 ? elem[0] : null;
    }
    /**
     * @hidden
     */
    initSizesCache(items) {
        let totalSize = 0;
        let size = 0;
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        let i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            if (dimension === 'height') {
                // cols[i][dimension] = parseInt(this.igxForItemSize, 10) || 0;
                size = parseInt(this.igxForItemSize, 10) || 0;
                this.heightCache.push(size);
            }
            else {
                size = this._getItemSize(items[i], dimension);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    _updateSizeCache() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        const oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce((acc, val) => acc + val) : 0;
        const newHeight = this.initSizesCache(this.igxForOf);
        const diff = oldHeight - newHeight;
        this._adjustScrollPositionAfterSizeChange(diff);
    }
    _adjustScrollPositionAfterSizeChange(sizeDiff) {
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(sizeDiff) > 0 && this.scrollPosition > 0) {
            this.recalcUpdateSizes();
            const offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            const newSize = this.sizesCache[this.state.startIndex] - offset;
            this.scrollPosition = newSize === this.scrollPosition ? newSize + 1 : newSize;
        }
    }
    /**
     * @hidden
     */
    _calcMaxChunkSize() {
        let i = 0;
        let length = 0;
        let maxLength = 0;
        const arr = [];
        let sum = 0;
        const availableSize = parseInt(this.igxForContainerSize, 10);
        if (!availableSize) {
            return 0;
        }
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        const reducer = (accumulator, currentItem) => accumulator + this._getItemSize(currentItem, dimension);
        for (i; i < this.igxForOf.length; i++) {
            let item = this.igxForOf[i];
            if (dimension === 'height') {
                item = { value: this.igxForOf[i], height: this.heightCache[i] };
            }
            const size = dimension === 'height' ?
                this.heightCache[i] :
                this._getItemSize(item, dimension);
            sum = arr.reduce(reducer, size);
            if (sum < availableSize) {
                arr.push(item);
                length = arr.length;
                if (i === this.igxForOf.length - 1) {
                    // reached end without exceeding
                    // include prev items until size is filled or first item is reached.
                    let curItem = dimension === 'height' ? arr[0].value : arr[0];
                    let prevIndex = this.igxForOf.indexOf(curItem) - 1;
                    while (prevIndex >= 0 && sum <= availableSize) {
                        curItem = dimension === 'height' ? arr[0].value : arr[0];
                        prevIndex = this.igxForOf.indexOf(curItem) - 1;
                        const prevItem = this.igxForOf[prevIndex];
                        const prevSize = dimension === 'height' ?
                            this.heightCache[prevIndex] :
                            parseInt(prevItem[dimension], 10);
                        sum = arr.reduce(reducer, prevSize);
                        arr.unshift(prevItem);
                        length = arr.length;
                    }
                }
            }
            else {
                arr.push(item);
                length = arr.length + 1;
                arr.shift();
            }
            if (length > maxLength) {
                maxLength = length;
            }
        }
        return maxLength;
    }
    /**
     * @hidden
     */
    getIndexAt(left, set, index) {
        let start = 0;
        let end = set.length - 1;
        if (left === 0) {
            return 0;
        }
        while (start <= end) {
            const midIdx = Math.floor((start + end) / 2);
            const midLeft = set[midIdx];
            const cmp = left - midLeft;
            if (cmp > 0) {
                start = midIdx + 1;
            }
            else if (cmp < 0) {
                end = midIdx - 1;
            }
            else {
                return midIdx;
            }
        }
        return end;
    }
    /**
     * @hidden
     * Reset scroll position.
     * Needed in case scrollbar is hidden/detached but we still need to reset it.
     */
    resetScrollPosition() {
        this.scrollPosition = 0;
        this.scrollComponent.scrollAmount = 0;
        this.state.startIndex = 0;
    }
    _recalcScrollBarSize() {
        const count = this.isRemote ? this.totalItemCount : (this.igxForOf ? this.igxForOf.length : 0);
        this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);
        const scrollable = this.isScrollable();
        if (this.igxForScrollOrientation === 'horizontal') {
            const totalWidth = this.igxForContainerSize ? this.initSizesCache(this.igxForOf) : 0;
            this.scrollComponent.nativeElement.style.width = this.igxForContainerSize + 'px';
            this.scrollComponent.size = totalWidth;
            if (totalWidth <= parseInt(this.igxForContainerSize, 10)) {
                this.resetScrollPosition();
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.scrollComponent.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';
            this.scrollComponent.size = this._calcHeight();
            if (this.scrollComponent.size <= parseInt(this.igxForContainerSize, 10)) {
                this.resetScrollPosition();
            }
        }
        if (scrollable !== this.isScrollable()) {
            // scrollbar visibility has changed
            this.onScrollbarVisibilityChanged.emit();
        }
    }
    _calcHeight() {
        let height;
        if (this.heightCache) {
            height = this.heightCache.reduce((acc, val) => acc + val, 0);
        }
        else {
            height = this.initSizesCache(this.igxForOf);
        }
        this._virtHeight = height;
        if (height > this._maxHeight) {
            this._virtHeightRatio = height / this._maxHeight;
            height = this._maxHeight;
        }
        return height;
    }
    _recalcOnContainerChange(changes) {
        this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
        this.dc.instance._viewContainer.element.nativeElement.style.left = '0px';
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (prevChunkSize !== this.state.chunkSize) {
            this.onChunkLoad.emit(this.state);
        }
        if (this.sizesCache && this.igxForScrollOrientation === 'horizontal') {
            // Updating horizontal chunks and offsets based on the new scrollLeft
            const scrollOffset = this.fixedUpdateAllElements(this.scrollPosition);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
    }
    /**
     * @hidden
     * Removes an elemenet from the embedded views and updates chunkSize.
     */
    removeLastElem() {
        const oldElem = this._embeddedViews.pop();
        this.onBeforeViewDestroyed.emit(oldElem);
        // also detach from ViewContainerRef to make absolutely sure this is removed from the view container.
        this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
        oldElem.destroy();
        this.state.chunkSize--;
    }
    /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     */
    addLastElem() {
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        const input = this.igxForOf[elemIndex];
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
        this._zone.run(() => {
            this.cdr.markForCheck();
        });
    }
    /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in @addLastElem() or @removeLastElem()
     */
    applyChunkSizeChange() {
        const chunkSize = this.isRemote ? (this.igxForOf ? this.igxForOf.length : 0) : this._calculateChunkSize();
        if (chunkSize > this.state.chunkSize) {
            const diff = chunkSize - this.state.chunkSize;
            for (let i = 0; i < diff; i++) {
                this.addLastElem();
            }
        }
        else if (chunkSize < this.state.chunkSize) {
            const diff = this.state.chunkSize - chunkSize;
            for (let i = 0; i < diff; i++) {
                this.removeLastElem();
            }
        }
    }
    _updateScrollOffset() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._updateHScrollOffset();
        }
        else {
            this._updateVScrollOffset();
        }
    }
    _updateVScrollOffset() {
        let scrollOffset = 0;
        let currentScrollTop = this.scrollPosition;
        if (this._virtHeightRatio !== 1) {
            this._calcVirtualScrollTop(this.scrollPosition);
            currentScrollTop = this._virtScrollTop;
        }
        const vScroll = this.scrollComponent.nativeElement;
        scrollOffset = vScroll && this.scrollComponent.size ?
            currentScrollTop - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
    }
    _calcVirtualScrollTop(scrollTop) {
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const maxRealScrollTop = this.scrollComponent.size - containerSize;
        const realPercentScrolled = maxRealScrollTop !== 0 ? scrollTop / maxRealScrollTop : 0;
        const maxVirtScrollTop = this._virtHeight - containerSize;
        this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
    }
    _updateHScrollOffset() {
        let scrollOffset = 0;
        scrollOffset = this.scrollComponent.nativeElement &&
            this.scrollComponent.size ?
            this.scrollPosition - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    }
    _getItemSize(item, dimension) {
        const dim = item[dimension];
        return typeof dim === 'number' ? dim : parseInt(this.igxForItemSize, 10) || 0;
    }
}
IgxForOfDirective.ɵfac = function IgxForOfDirective_Factory(t) { return new (t || IgxForOfDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(IgxForOfScrollSyncService)); };
IgxForOfDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxForOfDirective, selectors: [["", "igxFor", "", "igxForOf", ""]], inputs: { igxForScrollOrientation: "igxForScrollOrientation", igxForTotalItemCount: "igxForTotalItemCount", igxForSizePropName: "igxForSizePropName", igxForOf: "igxForOf", igxForTrackBy: "igxForTrackBy", igxForScrollContainer: "igxForScrollContainer", igxForContainerSize: "igxForContainerSize", igxForItemSize: "igxForItemSize" }, outputs: { onChunkLoad: "onChunkLoad", onScrollbarVisibilityChanged: "onScrollbarVisibilityChanged", onContentSizeChange: "onContentSizeChange", onDataChanged: "onDataChanged", onBeforeViewDestroyed: "onBeforeViewDestroyed", onChunkPreload: "onChunkPreload" }, features: [ɵngcc0.ɵɵProvidersFeature([IgxForOfScrollSyncService]), ɵngcc0.ɵɵNgOnChangesFeature] });
IgxForOfDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: IterableDiffers },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: IgxForOfScrollSyncService }
];
IgxForOfDirective.propDecorators = {
    igxForOf: [{ type: Input }],
    igxForSizePropName: [{ type: Input }],
    igxForScrollOrientation: [{ type: Input }],
    igxForScrollContainer: [{ type: Input }],
    igxForContainerSize: [{ type: Input }],
    igxForItemSize: [{ type: Input }],
    igxForTotalItemCount: [{ type: Input }],
    onChunkLoad: [{ type: Output }],
    onScrollbarVisibilityChanged: [{ type: Output }],
    onContentSizeChange: [{ type: Output }],
    onDataChanged: [{ type: Output }],
    onBeforeViewDestroyed: [{ type: Output }],
    onChunkPreload: [{ type: Output }],
    igxForTrackBy: [{ type: Input }]
};
function getTypeNameForDebugging(type) {
    const name = 'name';
    return type[name] || typeof type;
}
class IgxGridForOfDirective extends IgxForOfDirective {
    constructor(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService, syncService) {
        super(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService);
        this.syncScrollService = syncScrollService;
        this.syncService = syncService;
        /**
         * @hidden @internal
         * An event that is emitted after data has been changed but before the view is refreshed
         */
        this.onDataChanging = new EventEmitter();
    }
    set igxGridForOf(value) {
        this.igxForOf = value;
    }
    get igxGridForOf() {
        return this.igxForOf;
    }
    ngOnInit() {
        this.syncService.setMaster(this);
        super.ngOnInit();
        this.removeScrollEventListeners();
    }
    ngOnChanges(changes) {
        const forOf = 'igxGridForOf';
        this.syncService.setMaster(this);
        if (forOf in changes) {
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
        }
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
        }
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    }
    /**
     * @hidden
     * @internal
     */
    get sizesCache() {
        if (this.syncService.isMaster(this)) {
            return this._sizesCache;
        }
        return this.syncService.sizesCache(this.igxForScrollOrientation);
    }
    /**
     * @hidden
     * @internal
     */
    set sizesCache(value) {
        this._sizesCache = value;
    }
    get itemsDimension() {
        return this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
    }
    getItemSize(item) {
        let size = 0;
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        if (dimension === 'height') {
            size = parseInt(this.igxForItemSize, 10) || 0;
            if (item && item.summaries) {
                size = item.max;
            }
            else if (item && item.groups && item.height) {
                size = item.height;
            }
        }
        else {
            size = parseInt(item[dimension], 10) || 0;
        }
        return size;
    }
    initSizesCache(items) {
        if (!this.syncService.isMaster(this)) {
            const masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
            return masterSizesCache[masterSizesCache.length - 1];
        }
        let totalSize = 0;
        let size = 0;
        let i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            size = this.getItemSize(items[i]);
            if (this.itemsDimension === 'height') {
                this.heightCache.push(size);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    _updateSizeCache(changes = null) {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        const oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce((acc, val) => acc + val) : 0;
        let newHeight = oldHeight;
        if (changes && !this.isRemote) {
            newHeight = this.handleCacheChanges(changes);
        }
        else {
            return;
        }
        const diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0) {
            // TODO: This code can be removed. However tests need to be rewritten in a way that they wait for ResizeObserved to complete.
            // So leaving as is for the moment.
            requestAnimationFrame(() => {
                this.recalcUpdateSizes();
                const offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                if (this.scrollPosition !== 0) {
                    this.scrollPosition = this.sizesCache[this.state.startIndex] - offset;
                }
                else {
                    this._updateScrollOffset();
                }
            });
        }
    }
    handleCacheChanges(changes) {
        const identityChanges = [];
        const newHeightCache = [];
        const newSizesCache = [];
        newSizesCache.push(0);
        let newHeight = 0;
        // When there are more than one removed items the changes are not reliable so those with identity change should be default size.
        let numRemovedItems = 0;
        changes.forEachRemovedItem(() => numRemovedItems++);
        // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.
        changes.forEachIdentityChange((item) => {
            if (item.currentIndex !== item.previousIndex) {
                // Filter out ones that have not changed their index.
                identityChanges[item.currentIndex] = item;
            }
        });
        // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.
        changes.forEachItem((item) => {
            if (item.previousIndex !== null &&
                (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])) {
                // Reuse cache on those who have previousIndex.
                // When there are more than one removed items currently the changes are not readable so ones with identity change
                // should be racalculated.
                newHeightCache[item.currentIndex] = this.heightCache[item.previousIndex];
            }
            else {
                // Assign default item size.
                newHeightCache[item.currentIndex] = this.getItemSize(item.item);
            }
            newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];
            newHeight += newHeightCache[item.currentIndex];
        });
        this.heightCache = newHeightCache;
        this.sizesCache = newSizesCache;
        return newHeight;
    }
    /**
     * @hidden
     * @internal
     */
    assumeMaster() {
        this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
        this.syncService.setMaster(this, true);
    }
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                const args = {
                    containerSize: this.igxForContainerSize
                };
                this.onDataChanging.emit(args);
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                /* we need to reset the master dir if all rows are removed
                (e.g. because of filtering); if all columns are hidden, rows are
                still rendered empty, so we should not reset master */
                if (!this.igxForOf.length &&
                    this.igxForScrollOrientation === 'vertical') {
                    this.syncService.resetMaster();
                }
                this.syncService.setMaster(this);
                this.igxForContainerSize = args.containerSize;
                this._updateSizeCache(changes);
                this._applyChanges();
                this._updateScrollOffset();
                this.onDataChanged.emit();
            }
        }
    }
    onScroll(event) {
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollTop(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this._zone.onStable.pipe(first$1()).subscribe(() => {
            this.recalcUpdateSizes();
        });
        this.cdr.markForCheck();
    }
    onHScroll(scrollAmount) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!this.scrollComponent || !parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
        }
        // Updating horizontal chunks
        const scrollOffset = this.fixedUpdateAllElements(scrollAmount);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    }
    addLastElem() {
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        const input = this.igxForOf[elemIndex];
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
    }
    _updateViews(prevChunkSize) {
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            let startIndex;
            let endIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            else {
                startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);
                if (startIndex + this.state.chunkSize > this.igxForOf.length) {
                    startIndex = this.igxForOf.length - this.state.chunkSize;
                }
                this.state.startIndex = startIndex;
                endIndex = this.state.chunkSize + this.state.startIndex;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                const embView = embeddedViewCopy.shift();
                this.updateTemplateContext(embView.context, i);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
        }
    }
    _applyChanges() {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        this._updateViews(prevChunkSize);
    }
    /**
     * @hidden
     */
    _calcMaxChunkSize() {
        if (this.syncService.isMaster(this)) {
            return super._calcMaxChunkSize();
        }
        return this.syncService.chunkSize(this.igxForScrollOrientation);
    }
}
IgxGridForOfDirective.ɵfac = function IgxGridForOfDirective_Factory(t) { return new (t || IgxGridForOfDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(IgxForOfScrollSyncService), ɵngcc0.ɵɵdirectiveInject(IgxForOfSyncService)); };
IgxGridForOfDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridForOfDirective, selectors: [["", "igxGridFor", "", "igxGridForOf", ""]], inputs: { igxGridForOf: "igxGridForOf" }, outputs: { onDataChanging: "onDataChanging" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
IgxGridForOfDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: IterableDiffers },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: IgxForOfScrollSyncService },
    { type: IgxForOfSyncService }
];
IgxGridForOfDirective.propDecorators = {
    igxGridForOf: [{ type: Input }],
    onDataChanging: [{ type: Output }]
};
/**
 * @hidden
 */
class IgxForOfModule {
}
IgxForOfModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxForOfModule });
IgxForOfModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxForOfModule_Factory(t) { return new (t || IgxForOfModule)(); }, imports: [[IgxScrollInertiaModule, CommonModule]] });

/**
 * **Ignite UI for Angular DropDown** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/drop-down)
 *
 * The Ignite UI for Angular Drop Down displays a scrollable list of items which may be visually grouped and
 * supports selection of a single item. Clicking or tapping an item selects it and closes the Drop Down
 *
 * Example:
 * ```html
 * <igx-drop-down>
 *   <igx-drop-down-item *ngFor="let item of items" disabled={{item.disabled}} isHeader={{item.header}}>
 *     {{ item.value }}
 *   </igx-drop-down-item>
 * </igx-drop-down>
 * ```
 */
class IgxDropDownComponent extends IgxDropDownBaseDirective {
    constructor(elementRef, cdr, selection, _displayDensityOptions) {
        super(elementRef, cdr, _displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this._displayDensityOptions = _displayDensityOptions;
        this.destroy$ = new Subject();
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-drop-down (onOpening)='handleOpening()'></igx-drop-down>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-drop-down (onOpened)='handleOpened()'></igx-drop-down>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-drop-down (onClosing)='handleClosing()'></igx-drop-down>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-drop-down (onClosed)='handleClosed()'></igx-drop-down>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Gets/sets whether items take focus. Disabled by default.
         * When enabled, drop down items gain tab index and are focused when active -
         * this includes activating the selected item when opening the drop down and moving with keyboard navigation.
         *
         * Note: Keep that focus shift in mind when using the igxDropDownItemNavigation directive
         * and ensure it's placed either on each focusable item or a common ancestor to allow it to handle keyboard events.
         *
         * ```typescript
         * // get
         * let dropDownAllowsItemFocus = this.dropdown.allowItemsFocus;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-drop-down [allowItemsFocus]='true'></igx-drop-down>
         * ```
         */
        this.allowItemsFocus = false;
    }
    /**
     * @hidden @internal
     */
    get focusedItem() {
        if (this.virtDir) {
            return this._focusedItem && this._focusedItem.index !== -1 ?
                (this.children.find(e => e.index === this._focusedItem.index) || null) :
                null;
        }
        return this._focusedItem;
    }
    set focusedItem(value) {
        if (!value) {
            this.selection.clear(`${this.id}-active`);
            this._focusedItem = null;
            return;
        }
        this._focusedItem = value;
        if (this.virtDir) {
            this._focusedItem = {
                value: value.value,
                index: value.index
            };
        }
        this.selection.set(`${this.id}-active`, new Set([this._focusedItem]));
    }
    get id() {
        return this._id;
    }
    set id(value) {
        this.selection.set(value, this.selection.get(this.id));
        this.selection.clear(this.id);
        this.selection.set(value, this.selection.get(`${this.id}-active`));
        this.selection.clear(`${this.id}-active`);
        this._id = value;
    }
    /** Id of the internal listbox of the drop down */
    get listId() {
        return this.id + '-list';
    }
    /**
     * Get currently selected item
     *
     * ```typescript
     * let currentItem = this.dropdown.selectedItem;
     * ```
     */
    get selectedItem() {
        const selectedItem = this.selection.first_item(this.id);
        if (selectedItem) {
            return selectedItem;
        }
        return null;
    }
    /**
     * Gets if the dropdown is collapsed
     *
     * ```typescript
     * let isCollapsed = this.dropdown.collapsed;
     * ```
     */
    get collapsed() {
        return this.toggleDirective.collapsed;
    }
    /** @hidden @internal */
    get scrollContainer() {
        return this.scrollContainerRef.nativeElement;
    }
    get collectionLength() {
        if (this.virtDir) {
            return this.virtDir.totalItemCount || this.virtDir.igxForOf.length;
        }
    }
    /**
     * Opens the dropdown
     *
     * ```typescript
     * this.dropdown.open();
     * ```
     */
    open(overlaySettings) {
        this.toggleDirective.open(overlaySettings);
        this.updateScrollPosition();
    }
    /**
     * Closes the dropdown
     *
     * ```typescript
     * this.dropdown.close();
     * ```
     */
    close() {
        this.toggleDirective.close();
    }
    /**
     * Toggles the dropdown
     *
     * ```typescript
     * this.dropdown.toggle();
     * ```
     */
    toggle(overlaySettings) {
        if (this.collapsed || this.toggleDirective.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    }
    /**
     * Select an item by index
     * @param index of the item to select; If the drop down uses *igxFor, pass the index in data
     */
    setSelectedItem(index) {
        if (index < 0 || index >= this.items.length) {
            return;
        }
        let newSelection;
        if (this.virtDir) {
            newSelection = {
                value: this.virtDir.igxForOf[index],
                index
            };
        }
        else {
            newSelection = this.items[index];
        }
        this.selectItem(newSelection);
    }
    /**
     * Navigates to the item on the specified index
     * If the data in the drop-down is virtualized, pass the index of the item in the virtualized data.
     * @param newIndex number
     */
    navigateItem(index) {
        if (this.virtDir) {
            if (index === -1 || index >= this.collectionLength) {
                return;
            }
            const direction = index > (this.focusedItem ? this.focusedItem.index : -1) ? Navigate.Down : Navigate.Up;
            const subRequired = this.isIndexOutOfBounds(index, direction);
            this.focusedItem = {
                value: this.virtDir.igxForOf[index],
                index: index
            };
            if (subRequired) {
                this.virtDir.scrollTo(index);
            }
            if (subRequired) {
                this.virtDir.onChunkLoad.pipe(take(1)).subscribe(() => {
                    this.skipHeader(direction);
                });
            }
            else {
                this.skipHeader(direction);
            }
        }
        else {
            super.navigateItem(index);
        }
        if (this.allowItemsFocus && this.focusedItem) {
            this.focusedItem.element.nativeElement.focus();
            this.cdr.markForCheck();
        }
    }
    isIndexOutOfBounds(index, direction) {
        const virtState = this.virtDir.state;
        const currentPosition = this.virtDir.getScroll().scrollTop;
        const itemPosition = this.virtDir.getScrollForIndex(index, direction === Navigate.Down);
        const indexOutOfChunk = index < virtState.startIndex || index > virtState.chunkSize + virtState.startIndex;
        const scrollNeeded = direction === Navigate.Down ? currentPosition < itemPosition : currentPosition > itemPosition;
        const subRequired = indexOutOfChunk || scrollNeeded;
        return subRequired;
    }
    skipHeader(direction) {
        if (!this.focusedItem) {
            return;
        }
        if (this.focusedItem.isHeader || this.focusedItem.disabled) {
            if (direction === Navigate.Up) {
                this.navigatePrev();
            }
            else {
                this.navigateNext();
            }
        }
    }
    /**
     * @hidden @internal
     */
    updateScrollPosition() {
        if (!this.virtDir) {
            return;
        }
        if (!this.selectedItem) {
            this.virtDir.scrollTo(0);
            return;
        }
        let targetScroll = this.virtDir.getScrollForIndex(this.selectedItem.index);
        const itemsInView = this.virtDir.igxForContainerSize / this.virtDir.igxForItemSize;
        targetScroll -= (itemsInView / 2 - 1) * this.virtDir.igxForItemSize;
        this.virtDir.getScroll().scrollTop = targetScroll;
    }
    focusItem(value) {
        if (value || this._focusedItem) {
            this._focusedItem.focused = value;
        }
    }
    updateItemFocus() {
        if (this.selectedItem) {
            this.focusedItem = this.selectedItem;
            this.focusItem(true);
        }
        else if (this.allowItemsFocus) {
            this.navigateFirst();
        }
    }
    /**
     * @hidden @internal
     */
    onToggleOpening(e) {
        // do not mutate passed event args
        const eventArgs = Object.assign({}, e, { owner: this });
        this.onOpening.emit(eventArgs);
        e.cancel = eventArgs.cancel;
        if (e.cancel) {
            return;
        }
        if (this.virtDir) {
            this.virtDir.scrollPosition = this._scrollPosition;
        }
    }
    /**
     * @hidden @internal
     */
    onToggleContentAppended() {
        if (!this.virtDir && this.selectedItem) {
            this.scrollToItem(this.selectedItem);
        }
    }
    /**
     * @hidden @internal
     */
    onToggleOpened() {
        this.updateItemFocus();
        this.onOpened.emit();
    }
    /**
     * @hidden @internal
     */
    onToggleClosing(e) {
        const eventArgs = Object.assign({}, e, { owner: this });
        this.onClosing.emit(eventArgs);
        e.cancel = eventArgs.cancel;
        if (e.cancel) {
            return;
        }
        if (this.virtDir) {
            this._scrollPosition = this.virtDir.scrollPosition;
        }
    }
    /**
     * @hidden @internal
     */
    onToggleClosed() {
        this.focusItem(false);
        this.onClosed.emit();
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
        this.selection.clear(this.id);
        this.selection.clear(`${this.id}-active`);
    }
    scrollToItem(item) {
        const itemPosition = this.calculateScrollPosition(item);
        //  in IE11 setting sctrollTop is somehow slow and forces dropdown
        //  to appear on screen before animation start. As a result dropdown
        //  flickers badly. This is why we set scrollTop just a little later
        //  allowing animation to start and prevent dropdown flickering
        if (isIE()) {
            setTimeout(() => {
                this.scrollContainer.scrollTop = (itemPosition);
            }, 1);
        }
        else {
            this.scrollContainer.scrollTop = (itemPosition);
        }
    }
    /** @hidden @internal */
    calculateScrollPosition(item) {
        if (!item) {
            return 0;
        }
        const elementRect = item.element.nativeElement.getBoundingClientRect();
        const parentRect = this.scrollContainer.getBoundingClientRect();
        const scrollDelta = parentRect.top - elementRect.top;
        let scrollPosition = this.scrollContainer.scrollTop - scrollDelta;
        const dropDownHeight = this.scrollContainer.clientHeight;
        scrollPosition -= dropDownHeight / 2;
        scrollPosition += item.elementHeight / 2;
        return Math.floor(scrollPosition);
    }
    /**
     * @hidden @internal
     */
    ngOnChanges(changes) {
        if (changes.id) {
            // temp workaround until fix --> https://github.com/angular/angular/issues/34992
            this.toggleDirective.id = changes.id.currentValue;
        }
    }
    ngAfterViewInit() {
        if (this.virtDir) {
            this.virtDir.igxForItemSize = 28;
        }
    }
    /** Keydown Handler */
    onItemActionKey(key, event) {
        super.onItemActionKey(key, event);
        this.close();
    }
    /**
     * Virtual scroll implementation
     * @hidden @internal
     */
    navigateFirst() {
        if (this.virtDir) {
            this.navigateItem(0);
        }
        else {
            super.navigateFirst();
        }
    }
    /**
     * @hidden @internal
     */
    navigateLast() {
        if (this.virtDir) {
            this.navigateItem(this.virtDir.totalItemCount ? this.virtDir.totalItemCount - 1 : this.virtDir.igxForOf.length - 1);
        }
        else {
            super.navigateLast();
        }
    }
    /**
     * @hidden @internal
     */
    navigateNext() {
        if (this.virtDir) {
            this.navigateItem(this._focusedItem ? this._focusedItem.index + 1 : 0);
        }
        else {
            super.navigateNext();
        }
    }
    /**
     * @hidden @internal
     */
    navigatePrev() {
        if (this.virtDir) {
            this.navigateItem(this._focusedItem ? this._focusedItem.index - 1 : 0);
        }
        else {
            super.navigatePrev();
        }
    }
    /**
     * Handles the `onSelection` emit and the drop down toggle when selection changes
     * @hidden
     * @internal
     * @param newSelection
     * @param event
     */
    selectItem(newSelection, event) {
        const oldSelection = this.selectedItem;
        if (!newSelection) {
            newSelection = this.focusedItem;
        }
        if (newSelection === null) {
            return;
        }
        if (newSelection instanceof IgxDropDownItemBaseDirective && newSelection.isHeader) {
            return;
        }
        if (this.virtDir) {
            newSelection = {
                value: newSelection.value,
                index: newSelection.index
            };
        }
        const args = { oldSelection, newSelection, cancel: false };
        this.onSelection.emit(args);
        if (!args.cancel) {
            if (this.isSelectionValid(args.newSelection)) {
                this.selection.set(this.id, new Set([args.newSelection]));
                if (!this.virtDir) {
                    if (oldSelection) {
                        oldSelection.selected = false;
                    }
                    if (args.newSelection) {
                        args.newSelection.selected = true;
                    }
                }
                if (event) {
                    this.toggleDirective.close();
                }
            }
            else {
                throw new Error('Please provide a valid drop-down item for the selection!');
            }
        }
    }
    /**
     * Clears the selection of the dropdown
     * ```typescript
     * this.dropdown.clearSelection();
     * ```
     */
    clearSelection() {
        const oldSelection = this.selectedItem;
        const newSelection = null;
        const args = { oldSelection, newSelection, cancel: false };
        this.onSelection.emit(args);
        if (this.selectedItem && !args.cancel) {
            this.selectedItem.selected = false;
            this.selection.clear(this.id);
        }
    }
    /**
     * Checks whether the selection is valid
     * `null` - the selection should be emptied
     * Virtual? - the selection should at least have and `index` and `value` property
     * Non-virtual? - the selection should be a valid drop-down item and **not** be a header
     */
    isSelectionValid(selection) {
        return selection === null
            || (this.virtDir && selection.hasOwnProperty('value') && selection.hasOwnProperty('index'))
            || (selection instanceof IgxDropDownItemComponent && !selection.isHeader);
    }
}
IgxDropDownComponent.ɵfac = function IgxDropDownComponent_Factory(t) { return new (t || IgxDropDownComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxSelectionAPIService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxDropDownComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDropDownComponent, selectors: [["igx-drop-down"]], contentQueries: function IgxDropDownComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxForOfDirective, true, IgxForOfDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDropDownItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, viewQuery: function IgxDropDownComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(IgxToggleDirective, true);
        ɵngcc0.ɵɵstaticViewQuery(_c6, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.scrollContainerRef = _t.first);
    } }, inputs: { allowItemsFocus: "allowItemsFocus" }, outputs: { onOpening: "onOpening", onOpened: "onOpened", onClosing: "onClosing", onClosed: "onClosed" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IGX_DROPDOWN_BASE, useExisting: IgxDropDownComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c2, decls: 4, vars: 8, consts: [["igxToggle", "", 1, "igx-drop-down__list", 3, "onAppended", "onOpening", "onOpened", "onClosing", "onClosed"], ["role", "listbox", 1, "igx-drop-down__list-scroll"], ["scrollContainer", ""], [4, "ngIf"]], template: function IgxDropDownComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("onAppended", function IgxDropDownComponent_Template_div_onAppended_0_listener() { return ctx.onToggleContentAppended(); })("onOpening", function IgxDropDownComponent_Template_div_onOpening_0_listener($event) { return ctx.onToggleOpening($event); })("onOpened", function IgxDropDownComponent_Template_div_onOpened_0_listener() { return ctx.onToggleOpened(); })("onClosing", function IgxDropDownComponent_Template_div_onClosing_0_listener($event) { return ctx.onToggleClosing($event); })("onClosed", function IgxDropDownComponent_Template_div_onClosed_0_listener() { return ctx.onToggleClosed(); });
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵtemplate(3, IgxDropDownComponent_ng_container_3_Template, 2, 0, "ng-container", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.height)("max-height", ctx.maxHeight);
        ɵngcc0.ɵɵattribute("id", ctx.listId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.collapsed);
    } }, directives: [IgxToggleDirective, ɵngcc2.NgIf], encapsulation: 2 });
IgxDropDownComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxSelectionAPIService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxDropDownComponent.propDecorators = {
    virtDir: [{ type: ContentChild, args: [IgxForOfDirective, { read: IgxForOfDirective },] }],
    toggleDirective: [{ type: ViewChild, args: [IgxToggleDirective, { static: true },] }],
    scrollContainerRef: [{ type: ViewChild, args: ['scrollContainer', { static: true },] }],
    children: [{ type: ContentChildren, args: [forwardRef(() => IgxDropDownItemComponent), { descendants: true },] }],
    onOpening: [{ type: Output }],
    onOpened: [{ type: Output }],
    onClosing: [{ type: Output }],
    onClosed: [{ type: Output }],
    allowItemsFocus: [{ type: Input }]
};

/**
 * Navigation Directive that handles keyboard events on its host and controls a targeted IgxDropDownBaseDirective component
 */
class IgxDropDownItemNavigationDirective {
    constructor(dropdown) {
        this.dropdown = dropdown;
        this._target = null;
    }
    /**
     * Gets the target of the navigation directive;
     *
     * ```typescript
     * // Get
     * export class MyComponent {
     *  ...
     *  @ContentChild(IgxDropDownNavigationDirective)
     *  navDirective: IgxDropDownNavigationDirective = null
     *  ...
     *  const navTarget: IgxDropDownBaseDirective = navDirective.navTarget
     * }
     * ```
     */
    get target() {
        return this._target;
    }
    /**
     * Sets the target of the navigation directive;
     * If no valid target is passed, it falls back to the drop down context
     *
     * ```html
     * <!-- Set -->
     * <input [igxDropDownItemNavigation]="dropdown" />
     * ...
     * <igx-drop-down #dropdown>
     * ...
     * </igx-drop-down>
     * ```
     */
    set target(target) {
        this._target = target ? target : this.dropdown;
    }
    /**
     * Captures keydown events and calls the appropriate handlers on the target component
     */
    handleKeyDown(event) {
        if (event) {
            const key = event.key.toLowerCase();
            if (!this.target.collapsed) { // If dropdown is opened
                const navKeys = ['esc', 'escape', 'enter', 'space', 'spacebar', ' ',
                    'arrowup', 'up', 'arrowdown', 'down', 'home', 'end'];
                if (navKeys.indexOf(key) === -1) { // If key has appropriate function in DD
                    return;
                }
                event.preventDefault();
                event.stopPropagation();
            }
            else { // If dropdown is closed, do nothing
                return;
            }
            switch (key) {
                case 'esc':
                case 'escape':
                    this.target.onItemActionKey(DropDownActionKey.ESCAPE, event);
                    break;
                case 'enter':
                    this.target.onItemActionKey(DropDownActionKey.ENTER, event);
                    break;
                case 'space':
                case 'spacebar':
                case ' ':
                    this.target.onItemActionKey(DropDownActionKey.SPACE, event);
                    break;
                case 'arrowup':
                case 'up':
                    this.onArrowUpKeyDown();
                    break;
                case 'arrowdown':
                case 'down':
                    this.onArrowDownKeyDown();
                    break;
                case 'home':
                    this.onHomeKeyDown();
                    break;
                case 'end':
                    this.onEndKeyDown();
                    break;
                default:
                    return;
            }
        }
    }
    /**
     * Navigates to previous item
     */
    onArrowDownKeyDown() {
        this.target.navigateNext();
    }
    /**
     * Navigates to previous item
     */
    onArrowUpKeyDown() {
        this.target.navigatePrev();
    }
    /**
     * Navigates to target's last item
     */
    onEndKeyDown() {
        this.target.navigateLast();
    }
    /**
     * Navigates to target's first item
     */
    onHomeKeyDown() {
        this.target.navigateFirst();
    }
}
IgxDropDownItemNavigationDirective.ɵfac = function IgxDropDownItemNavigationDirective_Factory(t) { return new (t || IgxDropDownItemNavigationDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_DROPDOWN_BASE, 10)); };
IgxDropDownItemNavigationDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDropDownItemNavigationDirective, selectors: [["", "igxDropDownItemNavigation", ""]], hostBindings: function IgxDropDownItemNavigationDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function IgxDropDownItemNavigationDirective_keydown_HostBindingHandler($event) { return ctx.handleKeyDown($event); });
    } }, inputs: { target: ["igxDropDownItemNavigation", "target"] } });
IgxDropDownItemNavigationDirective.ctorParameters = () => [
    { type: IgxDropDownBaseDirective, decorators: [{ type: Self }, { type: Optional }, { type: Inject, args: [IGX_DROPDOWN_BASE,] }] }
];
IgxDropDownItemNavigationDirective.propDecorators = {
    target: [{ type: Input, args: ['igxDropDownItemNavigation',] }],
    handleKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * @hidden
 */
class IgxDropDownModule {
}
IgxDropDownModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDropDownModule });
IgxDropDownModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDropDownModule_Factory(t) { return new (t || IgxDropDownModule)(); }, imports: [[
            CommonModule,
            IgxToggleModule
        ]] });

var IgxHintPosition;
(function (IgxHintPosition) {
    IgxHintPosition[IgxHintPosition["START"] = 0] = "START";
    IgxHintPosition[IgxHintPosition["END"] = 1] = "END";
})(IgxHintPosition || (IgxHintPosition = {}));
class IgxHintDirective {
    constructor(_element) {
        this._element = _element;
        this._position = IgxHintPosition.START;
        /**
         * Sets/gets whether the hint position is at the start.
         * Default value is `false`.
         * ```typescript
         * @ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionStart = true;
         * ```
         * ```typescript
         * let isHintPositionStart = this.igxHint.isPositionStart;
         * ```
         * @memberof IgxHintDirective
         */
        this.isPositionStart = false;
        /**
         * Sets/gets whether the hint position is at the end.
         * Default value is `false`.
         * ```typescript
         * @ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionEnd = true;
         * ```
         * ```typescript
         * let isHintPositionEnd = this.igxHint.isPositionEnd;
         * ```
         * @memberof IgxHintDirective
         */
        this.isPositionEnd = false;
    }
    /**
     * Sets the position of the hint.
     * ```html
     * <igx-input-group>
     *  <input igxInput type="text"/>
     *  <igx-hint #hint [position]="'start'">IgxHint displayed at the start</igx-hint>
     * </igx-input-group>
     * ```
     * @memberof IgxHintDirective
     */
    set position(value) {
        const position = IgxHintPosition[value.toUpperCase()];
        if (position !== undefined) {
            this._position = position;
            this._applyPosition(this._position);
        }
    }
    /**
     * Gets the position of the hint.
     * ```typescript
     * @ViewChild('hint', {read: IgxHintDirective})
     * public igxHint: IgxHintDirective;
     * let hintPosition =  this.igxHint.position;
     * ```
     * @memberof IgxHintDirective
     */
    get position() {
        return this._position.toString();
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._applyPosition(this._position);
    }
    _applyPosition(position) {
        this.isPositionStart = this.isPositionEnd = false;
        switch (position) {
            case IgxHintPosition.START:
                this.isPositionStart = true;
                break;
            case IgxHintPosition.END:
                this.isPositionEnd = true;
                break;
            default: break;
        }
    }
}
IgxHintDirective.ɵfac = function IgxHintDirective_Factory(t) { return new (t || IgxHintDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxHintDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxHintDirective, selectors: [["igx-hint"], ["", "igxHint", ""]], hostVars: 4, hostBindings: function IgxHintDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-input-group__hint-item--start", ctx.isPositionStart)("igx-input-group__hint-item--end", ctx.isPositionEnd);
    } }, inputs: { position: "position" } });
IgxHintDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxHintDirective.propDecorators = {
    isPositionStart: [{ type: HostBinding, args: ['class.igx-input-group__hint-item--start',] }],
    isPositionEnd: [{ type: HostBinding, args: ['class.igx-input-group__hint-item--end',] }],
    position: [{ type: Input, args: ['position',] }]
};

/** @hidden */
class IgxInputGroupBase {
}

const nativeValidationAttributes = ['required', 'pattern', 'minlength', 'maxlength', 'min', 'max', 'step'];
var IgxInputState;
(function (IgxInputState) {
    IgxInputState[IgxInputState["INITIAL"] = 0] = "INITIAL";
    IgxInputState[IgxInputState["VALID"] = 1] = "VALID";
    IgxInputState[IgxInputState["INVALID"] = 2] = "INVALID";
})(IgxInputState || (IgxInputState = {}));
/**
 * The `igxInput` directive creates single- or multiline text elements, covering common scenarios when dealing with form inputs.
 *
 * @igxModule IgxInputGroupModule
 *
 * @igxParent Data Entry & Display
 *
 * @igxTheme igx-input-group-theme
 *
 * @igxKeywords input, input group, form, field, validation
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <input-group>
 *  <label for="address">Address</label>
 *  <input igxInput name="address" type="text" [(ngModel)]="customer.address">
 * </input-group>
 * ```
 */
class IgxInputDirective {
    constructor(inputGroup, ngModel, formControl, element, cdr) {
        this.inputGroup = inputGroup;
        this.ngModel = ngModel;
        this.formControl = formControl;
        this.element = element;
        this.cdr = cdr;
        this._valid = IgxInputState.INITIAL;
        /**
         * Sets/gets whether the `"igx-input-group__input"` class is added to the host element.
         * Default value is `false`.
         *
         * @example
         * ```typescript
         * this.igxInput.isInput = true;
         * ```
         *
         * @example
         * ```typescript
         * let isCLassAdded = this.igxInput.isInput;
         * ```
         */
        this.isInput = false;
        /**
         * Sets/gets whether the `"class.igx-input-group__textarea"` class is added to the host element.
         * Default value is `false`.
         *
         * @example
         * ```typescript
         * this.igxInput.isTextArea = true;
         * ```
         *
         * @example
         * ```typescript
         * let isCLassAdded = this.igxInput.isTextArea;
         * ```
         */
        this.isTextArea = false;
    }
    get ngControl() {
        return this.ngModel ? this.ngModel : this.formControl;
    }
    /**
     * Sets the `value` property.
     *
     * @example
     * ```html
     * <input-group>
     *  <input igxInput #igxInput [value]="'IgxInput Value'">
     * </input-group>
     * ```
     */
    set value(value) {
        this.nativeElement.value = value !== null && value !== void 0 ? value : '';
        this.checkValidity();
    }
    /**
     * Gets the `value` property.
     *
     * @example
     * ```typescript
     * @ViewChild('igxInput', {read: IgxInputDirective})
     *  public igxInput: IgxInputDirective;
     * let inputValue = this.igxInput.value;
     * ```
     */
    get value() {
        return this.nativeElement.value;
    }
    /**
     * Sets the `disabled` property.
     *
     * @example
     * ```html
     * <input-group>
     *  <input igxInput #igxInput [disabled]="true">
     * </input-group>
     * ```
     */
    set disabled(value) {
        this.nativeElement.disabled = value;
        this.inputGroup.disabled = value;
    }
    /**
     * Gets the `disabled` property
     *
     * @example
     * ```typescript
     * @ViewChild('igxInput', {read: IgxInputDirective})
     *  public igxInput: IgxInputDirective;
     * let isDisabled = this.igxInput.disabled;
     * ```
     */
    get disabled() {
        return this.nativeElement.hasAttribute('disabled');
    }
    /**
     * Sets the `required` property.
     *
     * @example
     * ```html
     * <input-group>
     *  <input igxInput #igxInput [required]="true">
     * </input-group>
     * ```
     */
    set required(value) {
        if (typeof value === 'boolean') {
            this.nativeElement.required = this.inputGroup.isRequired = value;
            if (value && !this.nativeElement.checkValidity()) {
                this._valid = IgxInputState.INVALID;
            }
            else {
                this._valid = IgxInputState.INITIAL;
            }
        }
    }
    /**
     * Gets whether the igxInput is required.
     *
     * @example
     * ```typescript
     * let isRequired = this.igxInput.required;
     * ```
     */
    get required() {
        return this.nativeElement.hasAttribute('required');
    }
    /**
     * @hidden
     * @internal
     */
    onFocus(event) {
        this.inputGroup.isFocused = true;
    }
    /**
     * @param event The event to invoke the handler
     *
     * @hidden
     * @internal
     */
    onBlur(event) {
        this.inputGroup.isFocused = false;
        this._valid = IgxInputState.INITIAL;
        if (this.ngControl) {
            if (!this.ngControl.valid) {
                this._valid = IgxInputState.INVALID;
            }
        }
        else if (this._hasValidators() && !this.nativeElement.checkValidity()) {
            this._valid = IgxInputState.INVALID;
        }
    }
    /**
     * @hidden
     * @internal
     */
    onInput() {
        this.checkValidity();
    }
    /**
     * @hidden
     * @internal
     */
    ngAfterViewInit() {
        this.inputGroup.hasPlaceholder = this.nativeElement.hasAttribute('placeholder');
        this.inputGroup.disabled = this.inputGroup.disabled || this.nativeElement.hasAttribute('disabled');
        this.inputGroup.isRequired = this.nativeElement.hasAttribute('required');
        // Make sure we do not invalidate the input on init
        if (!this.ngControl) {
            this._valid = IgxInputState.INITIAL;
        }
        // Also check the control's validators for required
        if (!this.inputGroup.isRequired && this.ngControl && this.ngControl.control.validator) {
            const validation = this.ngControl.control.validator({});
            this.inputGroup.isRequired = validation && validation.required;
        }
        const elTag = this.nativeElement.tagName.toLowerCase();
        if (elTag === 'textarea') {
            this.isTextArea = true;
        }
        else {
            this.isInput = true;
        }
        if (this.ngControl) {
            this._statusChanges$ = this.ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
        }
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        if (this._statusChanges$) {
            this._statusChanges$.unsubscribe();
        }
    }
    /**
     * Sets a focus on the igxInput.
     *
     * @example
     * ```typescript
     * this.igxInput.focus();
     * ```
     */
    focus() {
        this.nativeElement.focus();
    }
    /**
     * Gets the `nativeElement` of the igxInput.
     *
     * @example
     * ```typescript
     * let igxInputNativeElement = this.igxInput.nativeElement;
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @internal
     */
    onStatusChanged() {
        // Enable/Disable control based on ngControl #7086
        if (this.disabled !== this.ngControl.disabled) {
            this.disabled = this.ngControl.disabled;
        }
        if (this.ngControl.control.validator || this.ngControl.control.asyncValidator) {
            if (this.ngControl.control.touched || this.ngControl.control.dirty) {
                //  TODO: check the logic when control is touched or dirty
                if (this.inputGroup.isFocused) {
                    // the user is still typing in the control
                    this._valid = this.ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
                }
                else {
                    // the user had touched the control previously but now the value is changing due to changes in the form
                    this._valid = this.ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
                }
            }
            else {
                //  if control is untouched and pristine its state is initial. This is when user did not interact
                //  with the input or when form/control is reset
                this._valid = IgxInputState.INITIAL;
            }
        }
    }
    /**
     * Gets whether the igxInput has a placeholder.
     *
     * @example
     * ```typescript
     * let hasPlaceholder = this.igxInput.hasPlaceholder;
     * ```
     */
    get hasPlaceholder() {
        return this.nativeElement.hasAttribute('placeholder');
    }
    /**
     * Gets the placeholder element of the igxInput.
     *
     * @example
     * ```typescript
     * let igxInputPlaceholder = this.igxInput.placeholder;
     * ```
     */
    get placeholder() {
        return this.nativeElement.placeholder;
    }
    /**
     * @returns An indicator of whether the input has validator attributes or not
     *
     * @hidden
     * @internal
     */
    _hasValidators() {
        for (const nativeValidationAttribute of nativeValidationAttributes) {
            if (this.nativeElement.hasAttribute(nativeValidationAttribute)) {
                return true;
            }
        }
        return !!this.ngControl && (!!this.ngControl.control.validator || !!this.ngControl.control.asyncValidator);
    }
    /**
     * Gets whether the igxInput is focused.
     *
     * @example
     * ```typescript
     * let isFocused = this.igxInput.focused;
     * ```
     */
    get focused() {
        return this.inputGroup.isFocused;
    }
    /**
     * Gets the state of the igxInput.
     *
     * @example
     * ```typescript
     * let igxInputState = this.igxInput.valid;
     * ```
     */
    get valid() {
        return this._valid;
    }
    /**
     * Gets whether the igxInput is valid.
     *
     * @example
     * ```typescript
     * let valid = this.igxInput.isValid;
     * ```
     */
    get isValid() {
        return this.valid !== IgxInputState.INVALID;
    }
    /**
     * Sets the state of the igxInput.
     *
     * @example
     * ```typescript
     * this.igxInput.valid = IgxInputState.INVALID;
     * ```
     */
    set valid(value) {
        this._valid = value;
    }
    /**
     * A function to assign a validity property of an input.
     *
     * @hidden
     * @internal
     */
    checkValidity() {
        if (!this.ngControl && this._hasValidators()) {
            this._valid = this.nativeElement.checkValidity() ? IgxInputState.VALID : IgxInputState.INVALID;
        }
    }
}
IgxInputDirective.ɵfac = function IgxInputDirective_Factory(t) { return new (t || IgxInputDirective)(ɵngcc0.ɵɵdirectiveInject(IgxInputGroupBase), ɵngcc0.ɵɵdirectiveInject(NgModel, 10), ɵngcc0.ɵɵdirectiveInject(FormControlName, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxInputDirective, selectors: [["", "igxInput", ""]], hostVars: 4, hostBindings: function IgxInputDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function IgxInputDirective_focus_HostBindingHandler($event) { return ctx.onFocus($event); })("blur", function IgxInputDirective_blur_HostBindingHandler($event) { return ctx.onBlur($event); })("input", function IgxInputDirective_input_HostBindingHandler() { return ctx.onInput(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-input-group__input", ctx.isInput)("igx-input-group__textarea", ctx.isTextArea);
    } }, inputs: { value: "value", disabled: "disabled", required: "required" }, exportAs: ["igxInput"] });
IgxInputDirective.ctorParameters = () => [
    { type: IgxInputGroupBase },
    { type: NgModel, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NgModel,] }] },
    { type: FormControlName, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [FormControlName,] }] },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxInputDirective.propDecorators = {
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    required: [{ type: Input }],
    isInput: [{ type: HostBinding, args: ['class.igx-input-group__input',] }],
    isTextArea: [{ type: HostBinding, args: ['class.igx-input-group__textarea',] }],
    onFocus: [{ type: HostListener, args: ['focus', ['$event'],] }],
    onBlur: [{ type: HostListener, args: ['blur', ['$event'],] }],
    onInput: [{ type: HostListener, args: ['input',] }]
};

let NEXT_ID$3 = 0;
class IgxLabelDirective {
    constructor() {
        this.defaultClass = true;
        /**
         * @hidden
         */
        this.id = `igx-label-${NEXT_ID$3++}`;
    }
}
IgxLabelDirective.ɵfac = function IgxLabelDirective_Factory(t) { return new (t || IgxLabelDirective)(); };
IgxLabelDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxLabelDirective, selectors: [["", "igxLabel", ""]], hostVars: 3, hostBindings: function IgxLabelDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-input-group__label", ctx.defaultClass);
    } }, inputs: { id: "id" } });
IgxLabelDirective.propDecorators = {
    defaultClass: [{ type: HostBinding, args: ['class.igx-input-group__label',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }]
};

/**
 * @hidden
 */
class IgxPrefixDirective {
}
IgxPrefixDirective.ɵfac = function IgxPrefixDirective_Factory(t) { return new (t || IgxPrefixDirective)(); };
IgxPrefixDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxPrefixDirective, selectors: [["igx-prefix"], ["", "igxPrefix", ""]] });
/**
 * @hidden
 */
class IgxPrefixModule {
}
IgxPrefixModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxPrefixModule });
IgxPrefixModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxPrefixModule_Factory(t) { return new (t || IgxPrefixModule)(); } });

/**
 * @hidden
 */
class IgxSuffixDirective {
}
IgxSuffixDirective.ɵfac = function IgxSuffixDirective_Factory(t) { return new (t || IgxSuffixDirective)(); };
IgxSuffixDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSuffixDirective, selectors: [["igx-suffix"], ["", "igxSuffix", ""]] });
/**
 * @hidden
 */
class IgxSuffixModule {
}
IgxSuffixModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxSuffixModule });
IgxSuffixModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxSuffixModule_Factory(t) { return new (t || IgxSuffixModule)(); } });

var IgxInputGroupEnum;
(function (IgxInputGroupEnum) {
    IgxInputGroupEnum[IgxInputGroupEnum["line"] = 0] = "line";
    IgxInputGroupEnum[IgxInputGroupEnum["box"] = 1] = "box";
    IgxInputGroupEnum[IgxInputGroupEnum["border"] = 2] = "border";
    IgxInputGroupEnum[IgxInputGroupEnum["search"] = 3] = "search";
})(IgxInputGroupEnum || (IgxInputGroupEnum = {}));
/**
 * Defines the InputGroupType DI token.
 */
// Should this go trough Interface https://angular.io/api/core/InjectionToken
const IGX_INPUT_GROUP_TYPE = new InjectionToken('InputGroupType');

let NEXT_ID$4 = 0;
var IgxInputGroupThemeEnum;
(function (IgxInputGroupThemeEnum) {
    IgxInputGroupThemeEnum[IgxInputGroupThemeEnum["material"] = 0] = "material";
    IgxInputGroupThemeEnum[IgxInputGroupThemeEnum["fluent"] = 1] = "fluent";
    IgxInputGroupThemeEnum[IgxInputGroupThemeEnum["bootstrap"] = 2] = "bootstrap";
    IgxInputGroupThemeEnum[IgxInputGroupThemeEnum["indigo-design"] = 3] = "indigo-design";
})(IgxInputGroupThemeEnum || (IgxInputGroupThemeEnum = {}));
class IgxInputGroupComponent extends DisplayDensityBase {
    constructor(element, _displayDensityOptions, _inputGroupType, document) {
        super(_displayDensityOptions);
        this.element = element;
        this._displayDensityOptions = _displayDensityOptions;
        this._inputGroupType = _inputGroupType;
        this.document = document;
        this._type = null;
        this._filled = false;
        this._variant = 'material';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-input-group [id]="'igx-input-group-55'"></igx-input-group>
         * ```
         */
        this.id = `igx-input-group-${NEXT_ID$4++}`;
        /**
         * Property that enables/disables the autogenerated class of the `IgxInputGroupComponent`.
         * By default applied the class is applied.
         * ```typescript
         *  @ViewChild("MyInputGroup")
         *  public inputGroup: IgxInputGroupComponent;
         *  ngAfterViewInit(){
         *  this.inputGroup.defaultClass = false;
         * ```
         * }
         */
        this.defaultClass = true;
        /** @hidden */
        this.hasPlaceholder = false;
        /** @hidden */
        this.isRequired = false;
        /** @hidden */
        this.isFocused = false;
        /**
         * An @Input property that disables the `IgxInputGroupComponent`.
         * ```html
         * <igx-input-group [disabled]="'true'"></igx-input-group>
         * ```
         */
        this.disabled = false;
        /**
         * Prevents automatically focusing the input when clicking on other elements in the input group (e.g. prefix or suffix).
         * @remarks Automatic focus causes software keyboard to show on mobile devices.
         *
         * @example
         * ```html
         * <igx-input-group [suppressInputAutofocus]="true"></igx-input-group>
         * ```
         */
        this.suppressInputAutofocus = false;
        /** @hidden */
        this.hasWarning = false;
    }
    /** @hidden */
    get validClass() {
        return this.input.valid === IgxInputState.VALID;
    }
    /** @hidden */
    get invalidClass() {
        return this.input.valid === IgxInputState.INVALID;
    }
    /** @hidden */
    get isFilled() {
        return this._filled || (this.input && this.input.value);
    }
    /** @hidden */
    get isDisplayDensityCosy() {
        return this.displayDensity === DisplayDensity.cosy;
    }
    /** @hidden */
    get isDisplayDensityComfortable() {
        return this.displayDensity === DisplayDensity.comfortable;
    }
    /** @hidden */
    get isDisplayDensityCompact() {
        return this.displayDensity === DisplayDensity.compact;
    }
    /** @hidden */
    onClick(event) {
        if (!this.isFocused &&
            event.target !== this.input.nativeElement &&
            !this.suppressInputAutofocus) {
            this.input.focus();
        }
    }
    /** @hidden */
    onPointerDown(event) {
        if (this.isFocused && event.target !== this.input.nativeElement) {
            event.preventDefault();
        }
    }
    hintClickHandler(event) {
        event.stopPropagation();
    }
    /**
     * An @Input property that sets how the input will be styled.
     * Allowed values of type IgxInputGroupType.
     * ```html
     * <igx-input-group [type]="'search'">
     * ```
     */
    set type(value) {
        this._type = value;
    }
    /**
     * Returns the type of the `IgxInputGroupComponent`. How the input is styled.
     * The default is `line`.
     * ```typescript
     * @ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let inputType = this.inputGroup.type;
     * }
     * ```
     */
    get type() {
        return this._type || this._inputGroupType || 'line';
    }
    /** @hidden @internal */
    get theme() {
        return this._variant;
    }
    /**
     * @hidden
     * @deprecated Use 'suppressInputAutofocus' instead.
     */
    get supressInputAutofocus() {
        return this.suppressInputAutofocus;
    }
    /**
     * @hidden
     * @deprecated Use 'suppressInputAutofocus' instead.
     */
    set supressInputAutofocus(value) {
        this.suppressInputAutofocus = value;
    }
    ngAfterContentInit() {
        const variant = this.document.defaultView
            .getComputedStyle(this.element.nativeElement)
            .getPropertyValue('--igx-input-group-variant')
            .trim();
        this._variant = variant;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` has hints.
     * ```typescript
     * @ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let inputHints = this.inputGroup.hasHints;
     * }
     * ```
     */
    get hasHints() {
        return this.hints.length > 0;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` has border.
     * ```typescript
     * @ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let inputBorder = this.inputGroup.hasBorder;
     * }
     * ```
     */
    get hasBorder() {
        return ((this.type === 'line' || this.type === 'box') &&
            this._variant === 'material');
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is line.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeLine = this.inputGroup.isTypeLine;
     * }
     * ```
     */
    get isTypeLine() {
        return this.type === 'line' && this._variant === 'material';
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is box.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeBox = this.inputGroup.isTypeBox;
     * }
     * ```
     */
    get isTypeBox() {
        return this.type === 'box' && this._variant === 'material';
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is border.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeBorder = this.inputGroup.isTypeBorder;
     * }
     * ```
     */
    get isTypeBorder() {
        return this.type === 'border' && this._variant === 'material';
    }
    /**
     * Returns true if the `IgxInputGroupComponent` theme is Fluent.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeFluent = this.inputGroup.isTypeFluent;
     * }
     * ```
     */
    get isTypeFluent() {
        return this._variant === 'fluent';
    }
    /**
     * Returns true if the `IgxInputGroupComponent` theme is Bootstrap.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeBootstrap = this.inputGroup.isTypeBootstrap;
     * }
     * ```
     */
    get isTypeBootstrap() {
        return this._variant === 'bootstrap';
    }
    /**
     * Returns true if the `IgxInputGroupComponent` theme is Indigo.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeIndigo = this.inputGroup.isTypeIndigo;
     * }
     * ```
     */
    get isTypeIndigo() {
        return this._variant === 'indigo-design';
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is search.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeSearch = this.inputGroup.isTypeSearch;
     * }
     * ```
     */
    get isTypeSearch() {
        return this.type === 'search';
    }
    /** @hidden */
    get filled() {
        return this._filled;
    }
    /** @hidden */
    set filled(val) {
        this._filled = val;
    }
}
IgxInputGroupComponent.ɵfac = function IgxInputGroupComponent_Factory(t) { return new (t || IgxInputGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(IGX_INPUT_GROUP_TYPE, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };
IgxInputGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxInputGroupComponent, selectors: [["igx-input-group"]], contentQueries: function IgxInputGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, IgxInputDirective, true, IgxInputDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxHintDirective, false, IgxHintDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hints = _t);
    } }, hostVars: 37, hostBindings: function IgxInputGroupComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxInputGroupComponent_click_HostBindingHandler($event) { return ctx.onClick($event); })("pointerdown", function IgxInputGroupComponent_pointerdown_HostBindingHandler($event) { return ctx.onPointerDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-input-group", ctx.defaultClass)("igx-input-group--placeholder", ctx.hasPlaceholder)("igx-input-group--required", ctx.isRequired)("igx-input-group--focused", ctx.isFocused)("igx-input-group--disabled", ctx.disabled)("igx-input-group--warning", ctx.hasWarning)("igx-input-group--valid", ctx.validClass)("igx-input-group--invalid", ctx.invalidClass)("igx-input-group--filled", ctx.isFilled)("igx-input-group--cosy", ctx.isDisplayDensityCosy)("igx-input-group--comfortable", ctx.isDisplayDensityComfortable)("igx-input-group--compact", ctx.isDisplayDensityCompact)("igx-input-group--box", ctx.isTypeBox)("igx-input-group--border", ctx.isTypeBorder)("igx-input-group--fluent", ctx.isTypeFluent)("igx-input-group--bootstrap", ctx.isTypeBootstrap)("igx-input-group--indigo", ctx.isTypeIndigo)("igx-input-group--search", ctx.isTypeSearch);
    } }, inputs: { id: "id", disabled: "disabled", suppressInputAutofocus: "suppressInputAutofocus", type: "type", supressInputAutofocus: "supressInputAutofocus" }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: IgxInputGroupBase, useExisting: IgxInputGroupComponent }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c8, decls: 20, vars: 3, consts: [["class", "igx-input-group__wrapper", 4, "ngIf", "ngIfElse"], ["class", "igx-input-group__border", 4, "ngIf"], [1, "igx-input-group__hint", 3, "click"], ["label", ""], ["input", ""], ["prefix", ""], ["suffix", ""], ["materialBundle", ""], ["fluentBundle", ""], ["bootstrapBundle", ""], ["bundle", ""], [1, "igx-input-group__wrapper"], [4, "ngTemplateOutlet"], [1, "igx-input-group__border"], [1, "igx-input-group__bundle"], [1, "igx-input-group__bundle-main"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"]], template: function IgxInputGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵtemplate(0, IgxInputGroupComponent_div_0_Template, 2, 1, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_div_1_Template, 1, 0, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵlistener("click", function IgxInputGroupComponent_Template_div_click_2_listener($event) { return ctx.hintClickHandler($event); });
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, IgxInputGroupComponent_ng_template_4_Template, 1, 0, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxInputGroupComponent_ng_template_6_Template, 1, 0, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, IgxInputGroupComponent_ng_template_8_Template, 1, 0, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(10, IgxInputGroupComponent_ng_template_10_Template, 1, 0, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(12, IgxInputGroupComponent_ng_template_12_Template, 6, 4, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(14, IgxInputGroupComponent_ng_template_14_Template, 6, 4, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(16, IgxInputGroupComponent_ng_template_16_Template, 5, 4, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(18, IgxInputGroupComponent_ng_template_18_Template, 5, 4, "ng-template", null, 10, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r16 = ɵngcc0.ɵɵreference(19);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isTypeBox)("ngIfElse", _r16);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasBorder);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase, ɵngcc2.NgSwitchDefault], encapsulation: 2 });
IgxInputGroupComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [IGX_INPUT_GROUP_TYPE,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
IgxInputGroupComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    defaultClass: [{ type: HostBinding, args: ['class.igx-input-group',] }],
    hasPlaceholder: [{ type: HostBinding, args: ['class.igx-input-group--placeholder',] }],
    isRequired: [{ type: HostBinding, args: ['class.igx-input-group--required',] }],
    isFocused: [{ type: HostBinding, args: ['class.igx-input-group--focused',] }],
    disabled: [{ type: HostBinding, args: ['class.igx-input-group--disabled',] }, { type: Input }],
    suppressInputAutofocus: [{ type: Input }],
    validClass: [{ type: HostBinding, args: ['class.igx-input-group--valid',] }],
    invalidClass: [{ type: HostBinding, args: ['class.igx-input-group--invalid',] }],
    hasWarning: [{ type: HostBinding, args: ['class.igx-input-group--warning',] }],
    isFilled: [{ type: HostBinding, args: ['class.igx-input-group--filled',] }],
    isDisplayDensityCosy: [{ type: HostBinding, args: ['class.igx-input-group--cosy',] }],
    isDisplayDensityComfortable: [{ type: HostBinding, args: ['class.igx-input-group--comfortable',] }],
    isDisplayDensityCompact: [{ type: HostBinding, args: ['class.igx-input-group--compact',] }],
    hints: [{ type: ContentChildren, args: [IgxHintDirective, { read: IgxHintDirective },] }],
    input: [{ type: ContentChild, args: [IgxInputDirective, { read: IgxInputDirective, static: true },] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onPointerDown: [{ type: HostListener, args: ['pointerdown', ['$event'],] }],
    type: [{ type: Input, args: ['type',] }],
    supressInputAutofocus: [{ type: Input }],
    isTypeBox: [{ type: HostBinding, args: ['class.igx-input-group--box',] }],
    isTypeBorder: [{ type: HostBinding, args: ['class.igx-input-group--border',] }],
    isTypeFluent: [{ type: HostBinding, args: ['class.igx-input-group--fluent',] }],
    isTypeBootstrap: [{ type: HostBinding, args: ['class.igx-input-group--bootstrap',] }],
    isTypeIndigo: [{ type: HostBinding, args: ['class.igx-input-group--indigo',] }],
    isTypeSearch: [{ type: HostBinding, args: ['class.igx-input-group--search',] }]
};
__decorate([
    DeprecateProperty(`Deprecated. Use 'suppressInputAutofocus' instead.`)
], IgxInputGroupComponent.prototype, "supressInputAutofocus", null);
/** @hidden */
class IgxInputGroupModule {
}
IgxInputGroupModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxInputGroupModule });
IgxInputGroupModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxInputGroupModule_Factory(t) { return new (t || IgxInputGroupModule)(); }, imports: [[CommonModule, IgxPrefixModule, IgxSuffixModule], IgxPrefixModule, IgxSuffixModule] });

/**
 * **Ignite UI for Angular Autocomplete** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/autocomplete.html)
 *
 * The igxAutocomplete directive provides a way to enhance a text input
 * by showing a drop down of suggested options, provided by the developer.
 *
 * Example:
 * ```html
 * <input type="text" [igxAutocomplete]="townsPanel" />
 * <igx-drop-down #townsPanel>
 *     <igx-drop-down-item *ngFor="let town of towns | startsWith:townSelected" [value]="town">
 *         {{town}}
 *     </igx-drop-down-item>
 * </igx-drop-down>
 * ```
 */
class IgxAutocompleteDirective extends IgxDropDownItemNavigationDirective {
    constructor(ngModel, formControl, group, elementRef, cdr) {
        super(null);
        this.ngModel = ngModel;
        this.formControl = formControl;
        this.group = group;
        this.elementRef = elementRef;
        this.cdr = cdr;
        this._shouldBeOpen = false;
        this.destroy$ = new Subject();
        /**
         * Enables/disables autocomplete component
         *
         * ```typescript
         * // get
         * let disabled = this.autocomplete.disabled;
         * ```
         * ```html
         * <!--set-->
         * <input type="text" [igxAutocomplete]="townsPanel" [igxAutocompleteDisabled]="disabled"/>
         * ```
         * ```typescript
         * // set
         * public disabled = true;
         * ```
         */
        this.disabled = false;
        /**
         * Emitted after item from the drop down is selected
         *
         * ```html
         * <input igxInput [igxAutocomplete]="townsPanel" (onItemSelected)='itemSelected($event)' />
         * ```
         */
        this.onItemSelected = new EventEmitter();
        /** @hidden @internal */
        this.autofill = 'off';
        /** @hidden  @internal */
        this.role = 'combobox';
        this.select = (value) => {
            if (!value.newSelection) {
                return;
            }
            value.cancel = true; // Disable selection in the drop down, because in autocomplete we do not save selection.
            const newValue = value.newSelection.value;
            const args = { value: newValue, cancel: false };
            this.onItemSelected.emit(args);
            if (args.cancel) {
                return;
            }
            this.close();
            this.nativeElement.focus();
            // Update model after the input is re-focused, in order to have proper valid styling.
            // Otherwise when item is selected using mouse (and input is blurred), then valid style will be removed.
            this.model ? this.model.control.setValue(newValue) : this.nativeElement.value = newValue;
        };
        this.highlightFirstItem = () => {
            if (this.target.focusedItem) {
                this.target.focusedItem.focused = false;
                this.target.focusedItem = null;
            }
            this.target.navigateFirst();
            this.cdr.detectChanges();
        };
    }
    get model() {
        return this.ngModel || this.formControl;
    }
    /** @hidden @internal */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /** @hidden @internal */
    get parentElement() {
        return this.group ? this.group.element.nativeElement : this.nativeElement;
    }
    get settings() {
        const settings = Object.assign({}, this.defaultSettings, this.autocompleteSettings);
        const target = settings.target || settings.positionStrategy.settings.target;
        if (!target) {
            const positionStrategyClone = settings.positionStrategy.clone();
            settings.target = this.parentElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    }
    /**
     * Sets the target of the autocomplete directive
     *
     * ```html
     * <!-- Set -->
     * <input [igxAutocomplete]="dropdown" />
     * ...
     * <igx-drop-down #dropdown>
     * ...
     * </igx-drop-down>
     * ```
     */
    get target() {
        return this._target;
    }
    set target(v) {
        this._target = v;
    }
    /** @hidden  @internal */
    get ariaExpanded() {
        return !this.collapsed;
    }
    /** @hidden  @internal */
    get hasPopUp() {
        return 'listbox';
    }
    /** @hidden  @internal */
    get ariaOwns() {
        return this.target.listId;
    }
    /** @hidden  @internal */
    get ariaActiveDescendant() {
        return !this.target.collapsed && this.target.focusedItem ? this.target.focusedItem.id : null;
    }
    /** @hidden  @internal */
    get ariaAutocomplete() {
        return 'list';
    }
    /** @hidden  @internal */
    onInput() {
        this.open();
    }
    /** @hidden  @internal */
    onArrowDown(event) {
        event.preventDefault();
        this.open();
    }
    /** @hidden  @internal */
    onTab() {
        this.close();
    }
    /** @hidden  @internal */
    handleKeyDown(event) {
        if (!this.collapsed) {
            switch (event.key.toLowerCase()) {
                case 'space':
                case 'spacebar':
                case ' ':
                case 'home':
                case 'end':
                    return;
                default:
                    super.handleKeyDown(event);
            }
        }
    }
    /** @hidden  @internal */
    onArrowDownKeyDown() {
        super.onArrowDownKeyDown();
    }
    /** @hidden  @internal */
    onArrowUpKeyDown() {
        super.onArrowUpKeyDown();
    }
    /** @hidden  @internal */
    onEndKeyDown() {
        super.onEndKeyDown();
    }
    /** @hidden  @internal */
    onHomeKeyDown() {
        super.onHomeKeyDown();
    }
    /**
     * Closes autocomplete drop down
     */
    close() {
        this._shouldBeOpen = false;
        if (this.collapsed) {
            return;
        }
        this.target.close();
    }
    /**
     * Opens autocomplete drop down
     */
    open() {
        this._shouldBeOpen = true;
        if (this.disabled || !this.collapsed || this.target.children.length === 0) {
            return;
        }
        // if no drop-down width is set, the drop-down will be as wide as the autocomplete input;
        this.target.width = this.target.width || (this.parentElement.clientWidth + 'px');
        this.target.open(this.settings);
        this.highlightFirstItem();
    }
    get collapsed() {
        return this.target ? this.target.collapsed : true;
    }
    /** @hidden @internal */
    ngOnInit() {
        const targetElement = this.parentElement;
        this.defaultSettings = {
            target: targetElement,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy(),
            excludeFromOutsideClick: [targetElement]
        };
    }
    /** @hidden */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    ngAfterViewInit() {
        this.target.children.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (this.target.children.length) {
                if (!this.collapsed) {
                    this.highlightFirstItem();
                }
                else if (this._shouldBeOpen) {
                    this.open();
                }
            }
            else {
                this.close();
            }
        });
        this.target.onSelection.pipe(takeUntil(this.destroy$)).subscribe(this.select);
    }
}
IgxAutocompleteDirective.ɵfac = function IgxAutocompleteDirective_Factory(t) { return new (t || IgxAutocompleteDirective)(ɵngcc0.ɵɵdirectiveInject(NgModel, 10), ɵngcc0.ɵɵdirectiveInject(FormControlName, 10), ɵngcc0.ɵɵdirectiveInject(IgxInputGroupComponent, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxAutocompleteDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxAutocompleteDirective, selectors: [["", "igxAutocomplete", ""]], hostVars: 7, hostBindings: function IgxAutocompleteDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function IgxAutocompleteDirective_input_HostBindingHandler() { return ctx.onInput(); })("keydown.ArrowDown", function IgxAutocompleteDirective_keydown_ArrowDown_HostBindingHandler($event) { return ctx.onArrowDown($event); })("keydown.Alt.ArrowDown", function IgxAutocompleteDirective_keydown_Alt_ArrowDown_HostBindingHandler($event) { return ctx.onArrowDown($event); })("keydown.ArrowUp", function IgxAutocompleteDirective_keydown_ArrowUp_HostBindingHandler($event) { return ctx.onArrowDown($event); })("keydown.Alt.ArrowUp", function IgxAutocompleteDirective_keydown_Alt_ArrowUp_HostBindingHandler($event) { return ctx.onArrowDown($event); })("keydown.Tab", function IgxAutocompleteDirective_keydown_Tab_HostBindingHandler() { return ctx.onTab(); })("keydown.Shift.Tab", function IgxAutocompleteDirective_keydown_Shift_Tab_HostBindingHandler() { return ctx.onTab(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("autocomplete", ctx.autofill)("role", ctx.role)("aria-expanded", ctx.ariaExpanded)("aria-haspopup", ctx.hasPopUp)("aria-owns", ctx.ariaOwns)("aria-activedescendant", ctx.ariaActiveDescendant)("aria-autocomplete", ctx.ariaAutocomplete);
    } }, inputs: { disabled: ["igxAutocompleteDisabled", "disabled"], target: ["igxAutocomplete", "target"], autocompleteSettings: ["igxAutocompleteSettings", "autocompleteSettings"] }, outputs: { onItemSelected: "onItemSelected" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxAutocompleteDirective.ctorParameters = () => [
    { type: NgModel, decorators: [{ type: Self }, { type: Optional }, { type: Inject, args: [NgModel,] }] },
    { type: FormControlName, decorators: [{ type: Self }, { type: Optional }, { type: Inject, args: [FormControlName,] }] },
    { type: IgxInputGroupComponent, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxAutocompleteDirective.propDecorators = {
    target: [{ type: Input, args: ['igxAutocomplete',] }],
    disabled: [{ type: Input, args: ['igxAutocompleteDisabled',] }],
    autocompleteSettings: [{ type: Input, args: ['igxAutocompleteSettings',] }],
    onItemSelected: [{ type: Output }],
    autofill: [{ type: HostBinding, args: ['attr.autocomplete',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    ariaExpanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
    hasPopUp: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
    ariaOwns: [{ type: HostBinding, args: ['attr.aria-owns',] }],
    ariaActiveDescendant: [{ type: HostBinding, args: ['attr.aria-activedescendant',] }],
    ariaAutocomplete: [{ type: HostBinding, args: ['attr.aria-autocomplete',] }],
    onInput: [{ type: HostListener, args: ['input',] }],
    onArrowDown: [{ type: HostListener, args: ['keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['keydown.Alt.ArrowDown', ['$event'],] }, { type: HostListener, args: ['keydown.ArrowUp', ['$event'],] }, { type: HostListener, args: ['keydown.Alt.ArrowUp', ['$event'],] }],
    onTab: [{ type: HostListener, args: ['keydown.Tab',] }, { type: HostListener, args: ['keydown.Shift.Tab',] }]
};
/** @hidden */
class IgxAutocompleteModule {
}
IgxAutocompleteModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxAutocompleteModule });
IgxAutocompleteModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxAutocompleteModule_Factory(t) { return new (t || IgxAutocompleteModule)(); }, imports: [[IgxDropDownModule, CommonModule]] });

/**
 * The Button directive provides the Ignite UI Button functionality to every component that's intended to be used as a button.
 *
 * @igxModule IgxButtonModule
 *
 * @igxParent Data Entry & Display
 *
 * @igxTheme igx-button-theme
 *
 * @igxKeywords button, span, div, click
 *
 * @remarks
 * The Ignite UI Button directive is intended to be used by any button, span or div and turn it into a fully functional button.
 *
 * @example
 * ```html
 * <button igxButton="outlined">A Button</button>
 * ```
 */
class IgxButtonDirective extends DisplayDensityBase {
    constructor(element, _renderer, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.element = element;
        this._renderer = _renderer;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * @hidden
         * @internal
         */
        this._defaultType = 'flat';
        /**
         * @hidden
         * @internal
         */
        this._cssClassPrefix = 'igx-button';
        /**
         * Called when the button is clicked.
         */
        this.buttonClick = new EventEmitter();
        /**
         * Sets/gets the `role` attribute.
         *
         * @example
         * ```typescript
         * this.button.role = 'navbutton';
         * let buttonRole = this.button.role;
         * ```
         */
        this.role = 'button';
        /**
         * Gets or sets whether the button is selected.
         * Mainly used in the IgxButtonGroup component and it will have no effect if set separately.
         *
         * @example
         * ```html
         * <button igxButton="flat" [selected]="button.selected"></button>
         * ```
         */
        this.selected = false;
    }
    /**
     * Returns the underlying DOM element.
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * Sets the type of the button.
     *
     * @example
     * ```html
     * <button igxButton="icon"></button>
     * ```
     */
    set type(value) {
        const newValue = value ? value : this._defaultType;
        if (this._type !== newValue) {
            this._renderer.removeClass(this.nativeElement, `${this._cssClassPrefix}--${this._type}`);
            this._type = newValue;
            this._renderer.addClass(this.nativeElement, `${this._cssClassPrefix}--${this._type}`);
        }
    }
    /**
     * Sets the button text color.
     *
     * @example
     * ```html
     * <button igxButton="gradient" igxButtonColor="blue"></button>
     * ```
     */
    set color(value) {
        this._color = value || this.nativeElement.style.color;
        this._renderer.setStyle(this.nativeElement, 'color', this._color);
    }
    /**
     * Sets the background color of the button.
     *
     * @example
     *  ```html
     * <button igxButton="raised" igxButtonBackground="red"></button>
     * ```
     */
    set background(value) {
        this._backgroundColor = value || this._backgroundColor;
        this._renderer.setStyle(this.nativeElement, 'background', this._backgroundColor);
    }
    /**
     * Sets the `aria-label` attribute.
     *
     * @example
     *  ```html
     * <button igxButton= "flat" igxLabel="Label"></button>
     * ```
     */
    set label(value) {
        this._label = value || this._label;
        this._renderer.setAttribute(this.nativeElement, `aria-label`, this._label);
    }
    /**
     * Enables/disables the button.
     *
     * @example
     * ```html
     * <button igxButton= "fab" [disabled]="true"></button>
     * ```
     */
    set disabled(val) {
        val = !!val;
        this._disabled = val;
        if (val) {
            this._renderer.addClass(this.nativeElement, `${this._cssClassPrefix}--disabled`);
        }
        else {
            this._renderer.removeClass(this.nativeElement, `${this._cssClassPrefix}--disabled`);
        }
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCosy() {
        return (this._type === 'flat' || this._type === 'raised' || this._type === 'outlined') &&
            this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCompact() {
        return (this._type === 'flat' || this._type === 'raised' || this._type === 'outlined') &&
            this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCosyFab() {
        return this._type === 'fab' && this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCompactFab() {
        return this._type === 'fab' && this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @hidden
     * @internal
     */
    get disabledAttribute() {
        return this._disabled ? this._disabled : null;
    }
    /**
     * @hidden
     * @internal
     */
    onClick(ev) {
        this.buttonClick.emit(ev);
    }
}
IgxButtonDirective.ɵfac = function IgxButtonDirective_Factory(t) { return new (t || IgxButtonDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxButtonDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxButtonDirective, selectors: [["", "igxButton", ""]], hostVars: 10, hostBindings: function IgxButtonDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxButtonDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("disabled", ctx.disabledAttribute);
        ɵngcc0.ɵɵclassProp("igx-button--cosy", ctx.cssClassCosy)("igx-button--compact", ctx.cssClassCompact)("igx-button--fab-cosy", ctx.cssClassCosyFab)("igx-button--fab-compact", ctx.cssClassCompactFab);
    } }, inputs: { selected: "selected", type: ["igxButton", "type"], color: ["igxButtonColor", "color"], background: ["igxButtonBackground", "background"], label: ["igxLabel", "label"], disabled: "disabled" }, outputs: { buttonClick: "buttonClick" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxButtonDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxButtonDirective.propDecorators = {
    buttonClick: [{ type: Output }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    type: [{ type: Input, args: ['igxButton',] }],
    color: [{ type: Input, args: ['igxButtonColor',] }],
    background: [{ type: Input, args: ['igxButtonBackground',] }],
    label: [{ type: Input, args: ['igxLabel',] }],
    disabled: [{ type: Input }],
    cssClassCosy: [{ type: HostBinding, args: ['class.igx-button--cosy',] }],
    cssClassCompact: [{ type: HostBinding, args: ['class.igx-button--compact',] }],
    cssClassCosyFab: [{ type: HostBinding, args: ['class.igx-button--fab-cosy',] }],
    cssClassCompactFab: [{ type: HostBinding, args: ['class.igx-button--fab-compact',] }],
    disabledAttribute: [{ type: HostBinding, args: ['attr.disabled',] }],
    selected: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxButtonModule {
}
IgxButtonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxButtonModule });
IgxButtonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxButtonModule_Factory(t) { return new (t || IgxButtonModule)(); } });

const IgxDividerType = mkenum({
    SOLID: 'solid',
    DASHED: 'dashed'
});
let NEXT_ID$5 = 0;
class IgxDividerDirective {
    constructor() {
        /**
         * Sets/gets the `id` of the divider.
         * If not set, `id` will have value `"igx-divider-0"`;
         * ```html
         * <igx-divider id="my-divider"></igx-divider>
         * ```
         * ```typescript
         * let dividerId =  this.divider.id;
         * ```
         */
        this.id = `igx-divider-${NEXT_ID$5++}`;
        /**
         * An @Input property that sets the value of the `inset` attribute.
         * If not provided it will be set to `'0'`.
         * ```html
         * <igx-divider inset="16px"></igx-divider>
         * ```
         */
        this._inset = '0';
        /**
         * An @Input property that sets the value of `role` attribute.
         * If not the default value of `separator` will be used.
         */
        this.role = 'separator';
        /**
         * Sets the type of the divider. The default value
         * is `default`. The divider can also be `dashed`;
         * ```html
         * <igx-divider type="dashed"></igx-divider>
         * ```
         */
        this.type = IgxDividerType.SOLID;
        /**
         * An @Input that sets the `middle` attribute of the divider.
         * If set to `true` and an `inset` value has been provided,
         * the divider will start shrinking from both ends.
         * ```html
         * <igx-divider [middle]="true"></igx-divider>
         * ```
         */
        this.middle = false;
        /**
         * An @Input that sets the vertical attribute of the divider.
         * ```html
         * <igx-divider [vertical]="true"></igx-divider>
         * ```
         */
        this.vertical = false;
    }
    get isDashed() {
        return this.type === IgxDividerType.DASHED;
    }
    /**
     * A getter that returns `true` if the type of the divider is `default`;
     * ```typescript
     * const isDefault = this.divider.isDefault;
     * ```
     */
    get isSolid() {
        return this.type === IgxDividerType.SOLID;
    }
    /**
     * Sets the inset of the divider from the side(s).
     * If the divider attribute `middle` is set to `true`,
     * it will inset the divider on both sides.
     * ```typescript
     * this.divider.inset = '32px';
     * ```
     */
    set inset(value) {
        this._inset = value;
    }
    /**
     * Gets the current divider inset in terms of
     * margin representation as applied to the divider.
     * ```typescript
     * const inset = this.divider.inset;
     * ```
     */
    get inset() {
        const baseMargin = '0';
        if (this.middle) {
            if (this.vertical) {
                return `${this._inset} ${baseMargin}`;
            }
            return `${baseMargin} ${this._inset}`;
        }
        else {
            if (this.vertical) {
                return `${this._inset} ${baseMargin} 0 ${baseMargin}`;
            }
            return `${baseMargin} 0 ${baseMargin} ${this._inset}`;
        }
    }
}
IgxDividerDirective.ɵfac = function IgxDividerDirective_Factory(t) { return new (t || IgxDividerDirective)(); };
IgxDividerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDividerDirective, selectors: [["igx-divider"]], hostVars: 12, hostBindings: function IgxDividerDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role);
        ɵngcc0.ɵɵstyleProp("margin", ctx.inset);
        ɵngcc0.ɵɵclassProp("igx-divider", ctx.type)("igx-divider--inset", ctx.middle)("igx-divider--vertical", ctx.vertical)("igx-divider--dashed", ctx.isDashed);
    } }, inputs: { id: "id", _inset: ["inset", "_inset"], role: "role", type: "type", middle: "middle", vertical: "vertical" } });
IgxDividerDirective.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    _inset: [{ type: Input, args: ['inset',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    type: [{ type: HostBinding, args: ['class.igx-divider',] }, { type: Input }],
    isDashed: [{ type: HostBinding, args: ['class.igx-divider--dashed',] }],
    middle: [{ type: HostBinding, args: ['class.igx-divider--inset',] }, { type: Input }],
    vertical: [{ type: HostBinding, args: ['class.igx-divider--vertical',] }, { type: Input }],
    inset: [{ type: HostBinding, args: ['style.margin',] }]
};
class IgxDividerModule {
}
IgxDividerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDividerModule });
IgxDividerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDividerModule_Factory(t) { return new (t || IgxDividerModule)(); } });

// @dynamic
class IgxDefaultDropStrategy {
    dropAction(drag, drop, atIndex) { }
}
// @dynamic
class IgxAppendDropStrategy {
    constructor(_renderer) {
        this._renderer = _renderer;
    }
    dropAction(drag, drop, atIndex) {
        const dragElement = drag.element.nativeElement;
        const dropAreaElement = drop.element.nativeElement;
        this._renderer.removeChild(dragElement.parentNode, dragElement);
        this._renderer.appendChild(dropAreaElement, dragElement);
    }
}
// @dynamic
class IgxPrependDropStrategy {
    constructor(_renderer) {
        this._renderer = _renderer;
    }
    dropAction(drag, drop, atIndex) {
        const dragElement = drag.element.nativeElement;
        const dropAreaElement = drop.element.nativeElement;
        this._renderer.removeChild(dragElement.parentNode, dragElement);
        if (dropAreaElement.children.length) {
            this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[0]);
        }
        else {
            this._renderer.appendChild(dropAreaElement, dragElement);
        }
    }
}
// @dynamic
class IgxInsertDropStrategy {
    constructor(_renderer) {
        this._renderer = _renderer;
    }
    dropAction(drag, drop, atIndex) {
        if (drag.element.nativeElement.parentElement === drop.element.nativeElement && atIndex === -1) {
            return;
        }
        const dragElement = drag.element.nativeElement;
        const dropAreaElement = drop.element.nativeElement;
        this._renderer.removeChild(dragElement.parentNode, dragElement);
        if (atIndex !== -1 && dropAreaElement.children.length > atIndex) {
            this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[atIndex]);
        }
        else {
            this._renderer.appendChild(dropAreaElement, dragElement);
        }
    }
}

var DragDirection;
(function (DragDirection) {
    DragDirection[DragDirection["VERTICAL"] = 0] = "VERTICAL";
    DragDirection[DragDirection["HORIZONTAL"] = 1] = "HORIZONTAL";
    DragDirection[DragDirection["BOTH"] = 2] = "BOTH";
})(DragDirection || (DragDirection = {}));
class IgxDragLocation {
    constructor(_pageX, _pageY) {
        this._pageX = _pageX;
        this._pageY = _pageY;
        this.pageX = parseFloat(_pageX);
        this.pageY = parseFloat(_pageY);
    }
}
class IgxDragHandleDirective {
    constructor(element) {
        this.element = element;
        this.baseClass = true;
    }
}
IgxDragHandleDirective.ɵfac = function IgxDragHandleDirective_Factory(t) { return new (t || IgxDragHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxDragHandleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDragHandleDirective, selectors: [["", "igxDragHandle", ""]], hostVars: 2, hostBindings: function IgxDragHandleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-drag__handle", ctx.baseClass);
    } } });
IgxDragHandleDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxDragHandleDirective.propDecorators = {
    baseClass: [{ type: HostBinding, args: ['class.igx-drag__handle',] }]
};
class IgxDragIgnoreDirective {
    constructor(element) {
        this.element = element;
        this.baseClass = true;
    }
}
IgxDragIgnoreDirective.ɵfac = function IgxDragIgnoreDirective_Factory(t) { return new (t || IgxDragIgnoreDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxDragIgnoreDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDragIgnoreDirective, selectors: [["", "igxDragIgnore", ""]], hostVars: 2, hostBindings: function IgxDragIgnoreDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-drag__ignore", ctx.baseClass);
    } } });
IgxDragIgnoreDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxDragIgnoreDirective.propDecorators = {
    baseClass: [{ type: HostBinding, args: ['class.igx-drag__ignore',] }]
};
class IgxDragDirective {
    constructor(cdr, element, viewContainer, zone, renderer) {
        this.cdr = cdr;
        this.element = element;
        this.viewContainer = viewContainer;
        this.zone = zone;
        this.renderer = renderer;
        this.ghostContext = null;
        /**
         * An @Input property that indicates when the drag should start.
         * By default the drag starts after the draggable element is moved by 5px.
         * ```html
         * <div igxDrag [dragTolerance]="100">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * @memberof IgxDragDirective
         */
        this.dragTolerance = 5;
        /**
         * An @Input property that indicates the directions that the element can be dragged.
         * By default it is set to both horizontal and vertical directions.
         * ```html
         * <div igxDrag [dragDirection]="dragDir">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public dragDir = DragDirection.HORIZONTAL;
         * ```
         * @memberof IgxDragDirective
         */
        this.dragDirection = DragDirection.BOTH;
        /**
         * An @Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
         * By default it is set to `true`.
         * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
         * ```html
         * <div igxDrag [ghost]="false">
         *      <span>Drag Me!</span>
         * </div>
         * ```
         * @memberof IgxDragDirective
         */
        this.ghost = true;
        /**
         * Sets a custom class that will be added to the `ghostElement` element.
         * ```html
         * <div igxDrag [ghostClass]="'ghostElement'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * @memberof IgxDragDirective
         */
        this.ghostClass = '';
        /**
         * Event triggered when the draggable element drag starts.
         * ```html
         * <div igxDrag (dragStart)="onDragStart()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragStart(){
         *      alert("The drag has stared!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.dragStart = new EventEmitter();
        /**
         * Event triggered when the draggable element has been moved.
         * ```html
         * <div igxDrag  (dragMove)="onDragMove()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragMove(){
         *      alert("The element has moved!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.dragMove = new EventEmitter();
        /**
         * Event triggered when the draggable element is released.
         * ```html
         * <div igxDrag (dragEnd)="onDragEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragEnd(){
         *      alert("The drag has ended!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.dragEnd = new EventEmitter();
        /**
         * Event triggered when the draggable element is clicked.
         * ```html
         * <div igxDrag (dragClick)="onDragClick()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragClick(){
         *      alert("The element has been clicked!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.dragClick = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostCreate)="ghostCreated()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostCreated(){
         *      alert("The ghost has been created!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.ghostCreate = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostDestroy)="ghostDestroyed()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostDestroyed(){
         *      alert("The ghost has been destroyed!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.ghostDestroy = new EventEmitter();
        /**
         * Event triggered after the draggable element is released and after its animation has finished.
         * ```html
         * <div igxDrag (transitioned)="onMoveEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onMoveEnd(){
         *      alert("The move has ended!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.transitioned = new EventEmitter();
        /**
         * @hidden
         */
        this.baseClass = true;
        /**
         * @hidden
         */
        this.selectDisabled = false;
        /**
         * @hidden
         */
        this.defaultReturnDuration = '0.5s';
        /**
         * @hidden
         */
        this.animInProgress = false;
        this._startX = 0;
        this._startY = 0;
        this._lastX = 0;
        this._lastY = 0;
        this._dragStarted = false;
        this._ghostHostX = 0;
        this._ghostHostY = 0;
        this._pointerDownId = null;
        this._clicked = false;
        this._lastDropArea = null;
        this._destroy = new Subject();
        this._removeOnDestroy = true;
    }
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetX]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    set ghostOffsetX(value) {
        this._offsetX = parseInt(value, 10);
    }
    get ghostOffsetX() {
        return this._offsetX !== undefined ? this._offsetX : this._defaultOffsetX;
    }
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetY]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    set ghostOffsetY(value) {
        this._offsetY = parseInt(value, 10);
    }
    get ghostOffsetY() {
        return this._offsetY !== undefined ? this._offsetY : this._defaultOffsetY;
    }
    /**
     * Gets the current location of the element relative to the page.
     */
    get location() {
        return new IgxDragLocation(this.pageX, this.pageY);
    }
    /**
     * Gets the original location of the element before dragging started.
     */
    get originLocation() {
        return new IgxDragLocation(this.baseOriginLeft, this.baseOriginTop);
    }
    /**
     * @hidden
     */
    get pointerEventsEnabled() {
        return typeof PointerEvent !== 'undefined';
    }
    /**
     * @hidden
     */
    get touchEventsEnabled() {
        return 'ontouchstart' in window;
    }
    /**
     * @hidden
     */
    get pageX() {
        if (this.ghost && this.ghostElement) {
            return this.ghostLeft;
        }
        return this.baseLeft;
    }
    /**
     * @hidden
     */
    get pageY() {
        if (this.ghost && this.ghostElement) {
            return this.ghostTop;
        }
        return this.baseTop;
    }
    get baseLeft() {
        return this.element.nativeElement.getBoundingClientRect().left;
    }
    get baseTop() {
        return this.element.nativeElement.getBoundingClientRect().top;
    }
    get baseOriginLeft() {
        return this.baseLeft - this.getTransformX(this.element.nativeElement);
    }
    get baseOriginTop() {
        return this.baseTop - this.getTransformY(this.element.nativeElement);
    }
    set ghostLeft(pageX) {
        if (this.ghostElement) {
            // We need to take into account marginLeft, since top style does not include margin, but pageX includes the margin.
            const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
            // If ghost host is defined it needs to be taken into account.
            this.ghostElement.style.left = (pageX - ghostMarginLeft - this._ghostHostX) + 'px';
        }
    }
    get ghostLeft() {
        return parseInt(this.ghostElement.style.left, 10) + this._ghostHostX;
    }
    set ghostTop(pageY) {
        if (this.ghostElement) {
            // We need to take into account marginTop, since top style does not include margin, but pageY includes the margin.
            const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
            // If ghost host is defined it needs to be taken into account.
            this.ghostElement.style.top = (pageY - ghostMarginTop - this._ghostHostY) + 'px';
        }
    }
    get ghostTop() {
        return parseInt(this.ghostElement.style.top, 10) + this._ghostHostY;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (!this.dragHandles || !this.dragHandles.length) {
            // Set user select none to the whole draggable element if no drag handles are defined.
            this.selectDisabled = true;
        }
        // Bind events
        this.zone.runOutsideAngular(() => {
            const targetElements = this.dragHandles && this.dragHandles.length ?
                this.dragHandles.map((item) => item.element.nativeElement) : [this.element.nativeElement];
            targetElements.forEach((element) => {
                if (this.pointerEventsEnabled) {
                    fromEvent(element, 'pointerdown').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                    fromEvent(element, 'pointermove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                    fromEvent(element, 'pointerup').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerUp(res));
                    if (!this.ghost) {
                        // Do not bind `lostpointercapture` to the target, because we will bind it on the ghost later.
                        fromEvent(element, 'lostpointercapture').pipe(takeUntil(this._destroy))
                            .subscribe((res) => this.onPointerLost(res));
                    }
                }
                else if (this.touchEventsEnabled) {
                    fromEvent(element, 'touchstart').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
                else {
                    // We don't have pointer events and touch events. Use then mouse events.
                    fromEvent(element, 'mousedown').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
            });
            // We should bind to document events only once when there are no pointer events.
            if (!this.pointerEventsEnabled && this.touchEventsEnabled) {
                fromEvent(document.defaultView, 'touchmove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'touchend').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            else if (!this.pointerEventsEnabled) {
                fromEvent(document.defaultView, 'mousemove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'mouseup').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            this.element.nativeElement.addEventListener('transitionend', (args) => {
                this.onTransitionEnd(args);
            });
        });
        // Set transition duration to 0s. This also helps with setting `visibility: hidden` to the base to not lag.
        this.element.nativeElement.style.transitionDuration = '0.0s';
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
        if (this.ghost && this.ghostElement && this._removeOnDestroy) {
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
        }
    }
    /**
     * Sets desired location of the base element or ghost element if rended relative to the document.
     * @param newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
     */
    setLocation(newLocation) {
        // We do not subtract marginLeft and marginTop here because here we calculate deltas.
        if (this.ghost && this.ghostElement) {
            const offsetHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
            const offsetHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
            this.ghostLeft = newLocation.pageX - offsetHostX + this.getWindowScrollLeft();
            this.ghostTop = newLocation.pageY - offsetHostY + this.getWindowScrollTop();
        }
        else if (!this.ghost) {
            const deltaX = newLocation.pageX - this.pageX;
            const deltaY = newLocation.pageY - this.pageY;
            const transformX = this.getTransformX(this.element.nativeElement);
            const transformY = this.getTransformY(this.element.nativeElement);
            this.setTransformXY(transformX + deltaX, transformY + deltaY);
        }
        this._startX = this.baseLeft;
        this._startY = this.baseTop;
    }
    /**
     * Animates the base or ghost element depending on the `ghost` input to its initial location.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * If the base element has changed its DOM position its initial location will be changed accordingly.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionToOrigin(customAnimArgs, startLocation) {
        if ((!!startLocation && startLocation.pageX === this.baseOriginLeft && startLocation.pageY === this.baseOriginLeft) ||
            (!startLocation && this.ghost && !this.ghostElement)) {
            return;
        }
        if (!!startLocation && startLocation.pageX !== this.pageX && startLocation.pageY !== this.pageY) {
            if (this.ghost && !this.ghostElement) {
                this._startX = startLocation.pageX;
                this._startY = startLocation.pageY;
                this._ghostStartX = this._startX;
                this._ghostStartY = this._startY;
                this.createGhost(this._startX, this._startY);
            }
            this.setLocation(startLocation);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            if (this.ghost) {
                this.ghostElement.style.transitionProperty = 'top, left';
                this.ghostElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.ghostElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.ghostElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this.setLocation(new IgxDragLocation(this.baseLeft, this.baseTop));
            }
            else if (!this.ghost) {
                this.element.nativeElement.style.transitionProperty = 'transform';
                this.element.nativeElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.element.nativeElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.element.nativeElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this._startX = this.baseLeft;
                this._startY = this.baseTop;
                this.setTransformXY(0, 0);
            }
        }, 0);
    }
    /**
     * Animates the base or ghost element to a specific target location or other element using transition.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
     * @param target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionTo(target, customAnimArgs, startLocation) {
        if (!!startLocation && this.ghost && !this.ghostElement) {
            this._startX = startLocation.pageX;
            this._startY = startLocation.pageY;
            this._ghostStartX = this._startX;
            this._ghostStartY = this._startY;
        }
        else if (!!startLocation && (!this.ghost || this.ghostElement)) {
            this.setLocation(startLocation);
        }
        else if (this.ghost && !this.ghostElement) {
            this._startX = this.baseLeft;
            this._startY = this.baseTop;
            this._ghostStartX = this._startX + this.getWindowScrollLeft();
            this._ghostStartY = this._startY + this.getWindowScrollTop();
        }
        if (this.ghost && !this.ghostElement) {
            this.createGhost(this._startX, this._startY);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            const movedElem = this.ghost ? this.ghostElement : this.element.nativeElement;
            movedElem.style.transitionProperty = this.ghost && this.ghostElement ? 'left, top' : 'transform';
            movedElem.style.transitionDuration =
                customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
            movedElem.style.transitionTimingFunction =
                customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
            movedElem.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
            if (target instanceof IgxDragLocation) {
                this.setLocation(new IgxDragLocation(target.pageX, target.pageY));
            }
            else {
                const targetRects = target.nativeElement.getBoundingClientRect();
                this.setLocation(new IgxDragLocation(targetRects.left - this.getWindowScrollLeft(), targetRects.top - this.getWindowScrollTop()));
            }
        }, 0);
    }
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param event PointerDown event captured
     */
    onPointerDown(event) {
        const ignoredElement = this.dragIgnoredElems.find(elem => elem.element.nativeElement === event.target);
        if (ignoredElement) {
            return;
        }
        this._clicked = true;
        this._pointerDownId = event.pointerId;
        // Set pointer capture so we detect pointermove even if mouse is out of bounds until ghostElement is created.
        const handleFound = this.dragHandles.find(handle => handle.element.nativeElement === event.currentTarget);
        const targetElement = handleFound ? handleFound.element.nativeElement : this.element.nativeElement;
        if (this.pointerEventsEnabled) {
            targetElement.setPointerCapture(this._pointerDownId);
        }
        else {
            targetElement.focus();
            event.preventDefault();
        }
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            this._startX = event.pageX;
            this._startY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            this._startX = event.touches[0].pageX;
            this._startY = event.touches[0].pageY;
        }
        this._defaultOffsetX = this.baseLeft - this._startX + this.getWindowScrollLeft();
        this._defaultOffsetY = this.baseTop - this._startY + this.getWindowScrollTop();
        this._ghostStartX = this._startX + this.ghostOffsetX;
        this._ghostStartY = this._startY + this.ghostOffsetY;
        this._lastX = this._startX;
        this._lastY = this._startY;
    }
    /**
     * @hidden
     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
     * @param event PointerMove event captured
     */
    onPointerMove(event) {
        if (this._clicked) {
            let pageX, pageY;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            const totalMovedX = pageX - this._startX;
            const totalMovedY = pageY - this._startY;
            if (!this._dragStarted &&
                (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                const dragStartArgs = {
                    originalEvent: event,
                    owner: this,
                    startX: pageX - totalMovedX,
                    startY: pageY - totalMovedY,
                    pageX: pageX,
                    pageY: pageY,
                    cancel: false
                };
                this.zone.run(() => {
                    this.dragStart.emit(dragStartArgs);
                });
                if (!dragStartArgs.cancel) {
                    this._dragStarted = true;
                    if (this.ghost) {
                        // We moved enough so ghostElement can be rendered and actual dragging to start.
                        // When creating it will take into account any offset set by the user by default.
                        this.createGhost(pageX, pageY);
                    }
                    else if (this._offsetX !== undefined || this._offsetY !== undefined) {
                        // There is no need for ghost, but we will need to position initially the base element to reflect any offset.
                        const transformX = (this._offsetX !== undefined ? this._offsetX - this._defaultOffsetX : 0) +
                            this.getTransformX(this.element.nativeElement);
                        const transformY = (this._offsetY !== undefined ? this._offsetY - this._defaultOffsetY : 0) +
                            this.getTransformY(this.element.nativeElement);
                        this.setTransformXY(transformX, transformY);
                    }
                }
                else {
                    return;
                }
            }
            else if (!this._dragStarted) {
                return;
            }
            const moveArgs = {
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._lastX,
                pageY: this._lastY,
                nextPageX: pageX,
                nextPageY: pageY,
                cancel: false
            };
            this.dragMove.emit(moveArgs);
            const setPageX = moveArgs.nextPageX;
            const setPageY = moveArgs.nextPageY;
            if (!moveArgs.cancel) {
                if (this.ghost) {
                    const updatedTotalMovedX = this.dragDirection === DragDirection.VERTICAL ? 0 : setPageX - this._startX;
                    const updatedTotalMovedY = this.dragDirection === DragDirection.HORIZONTAL ? 0 : setPageY - this._startY;
                    this.ghostLeft = this._ghostStartX + updatedTotalMovedX;
                    this.ghostTop = this._ghostStartY + updatedTotalMovedY;
                }
                else {
                    const lastMovedX = this.dragDirection === DragDirection.VERTICAL ? 0 : setPageX - this._lastX;
                    const lastMovedY = this.dragDirection === DragDirection.HORIZONTAL ? 0 : setPageY - this._lastY;
                    const translateX = this.getTransformX(this.element.nativeElement) + lastMovedX;
                    const translateY = this.getTransformY(this.element.nativeElement) + lastMovedY;
                    this.setTransformXY(translateX, translateY);
                }
                this.dispatchDragEvents(pageX, pageY, event);
            }
            this._lastX = setPageX;
            this._lastY = setPageY;
        }
    }
    /**
     * @hidden
     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
     * @param event PointerUp event captured
     */
    onPointerUp(event) {
        if (!this._clicked) {
            return;
        }
        let pageX, pageY;
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            pageX = event.pageX;
            pageY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            pageX = event.touches[0].pageX;
            pageY = event.touches[0].pageY;
            // Prevent scrolling on touch while dragging
            event.preventDefault();
        }
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                this.dispatchDropEvent(event.pageX, event.pageY, event);
            }
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
        else {
            // Trigger our own click event because when there is no ghost, native click cannot be prevented when dragging.
            this.zone.run(() => {
                this.dragClick.emit(eventArgs);
            });
        }
    }
    /**
     * @hidden
     * Execute this method whe the pointer capture has been lost.
     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
     * @param event Event captured
     */
    onPointerLost(event) {
        if (!this._clicked) {
            return;
        }
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: event.pageX,
            pageY: event.pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
    }
    /**
     * @hidden
     * Create ghost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @param pageX Latest pointer position on the X axis relative to the page.
     * @param pageY Latest pointer position on the Y axis relative to the page.
     * @param node The Node object to be cloned.
     */
    createGhost(pageX, pageY, node = null) {
        if (!this.ghost) {
            return;
        }
        let dynamicGhostRef;
        if (this.ghostTemplate) {
            dynamicGhostRef = this.viewContainer.createEmbeddedView(this.ghostTemplate, this.ghostContext);
            this.ghostElement = dynamicGhostRef.rootNodes[0];
        }
        else {
            this.ghostElement = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);
        }
        const totalMovedX = pageX - this._startX;
        const totalMovedY = pageY - this._startY;
        this._ghostHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
        this._ghostHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
        this.ghostElement.style.transitionDuration = '0.0s';
        this.ghostElement.style.position = 'absolute';
        if (this.ghostClass) {
            this.renderer.addClass(this.ghostElement, this.ghostClass);
        }
        const createEventArgs = {
            owner: this,
            ghostElement: this.ghostElement,
            cancel: false
        };
        this.ghostCreate.emit(createEventArgs);
        if (createEventArgs.cancel) {
            this.ghostElement = null;
            if (this.ghostTemplate && dynamicGhostRef) {
                dynamicGhostRef.destroy();
            }
            return;
        }
        if (this.ghostHost) {
            this.ghostHost.appendChild(this.ghostElement);
        }
        else {
            document.body.appendChild(this.ghostElement);
        }
        const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
        const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
        this.ghostElement.style.left = (this._ghostStartX - ghostMarginLeft + totalMovedX - this._ghostHostX) + 'px';
        this.ghostElement.style.top = (this._ghostStartY - ghostMarginTop + totalMovedY - this._ghostHostX) + 'px';
        if (this.pointerEventsEnabled) {
            // The ghostElement takes control for moving and dragging after it has been rendered.
            if (this._pointerDownId !== null) {
                this.ghostElement.setPointerCapture(this._pointerDownId);
            }
            this.ghostElement.addEventListener('pointermove', (args) => {
                this.onPointerMove(args);
            });
            this.ghostElement.addEventListener('pointerup', (args) => {
                this.onPointerUp(args);
            });
            this.ghostElement.addEventListener('lostpointercapture', (args) => {
                this.onPointerLost(args);
            });
        }
        // Transition animation when the ghostElement is released and it returns to it's original position.
        this.ghostElement.addEventListener('transitionend', (args) => {
            this.onTransitionEnd(args);
        });
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     */
    dispatchDragEvents(pageX, pageY, originalEvent) {
        let topDropArea;
        const customEventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        const elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
        for (let i = 0; i < elementsFromPoint.length; i++) {
            if (elementsFromPoint[i].getAttribute('droppable') === 'true' &&
                elementsFromPoint[i] !== this.ghostElement && elementsFromPoint[i] !== this.element.nativeElement) {
                topDropArea = elementsFromPoint[i];
                break;
            }
        }
        if (topDropArea &&
            (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
            if (this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            }
            this._lastDropArea = topDropArea;
            this.dispatchEvent(this._lastDropArea, 'igxDragEnter', customEventArgs);
        }
        else if (!topDropArea && this._lastDropArea) {
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            this._lastDropArea = null;
            return;
        }
        if (topDropArea) {
            this.dispatchEvent(topDropArea, 'igxDragOver', customEventArgs);
        }
    }
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in @dispatchDragEvents method.
     */
    dispatchDropEvent(pageX, pageY, originalEvent) {
        const eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
        this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
        this._lastDropArea = null;
    }
    /**
     * @hidden
     */
    onTransitionEnd(event) {
        if ((!this._dragStarted && !this.animInProgress) || this._clicked) {
            // Return if no dragging started and there is no animation in progress.
            return;
        }
        if (this.ghost && this.ghostElement) {
            this._ghostStartX = this.baseLeft + this.getWindowScrollLeft();
            this._ghostStartY = this.baseTop + this.getWindowScrollTop();
            const ghostDestroyArgs = {
                owner: this,
                ghostElement: this.ghostElement,
                cancel: false
            };
            this.ghostDestroy.emit(ghostDestroyArgs);
            if (ghostDestroyArgs.cancel) {
                return;
            }
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
        }
        else if (!this.ghost) {
            this.element.nativeElement.style.transitionProperty = '';
            this.element.nativeElement.style.transitionDuration = '0.0s';
            this.element.nativeElement.style.transitionTimingFunction = '';
            this.element.nativeElement.style.transitionDelay = '';
        }
        this.animInProgress = false;
        this._dragStarted = false;
        // Execute transitioned after everything is reset so if the user sets new location on the base now it would work as expected.
        this.zone.run(() => {
            this.transitioned.emit({
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._startX,
                pageY: this._startY
            });
        });
    }
    /**
     * @hidden
     */
    getElementsAtPoint(pageX, pageY) {
        // correct the coordinates with the current scroll position, because
        // document.elementsFromPoint consider position within the current viewport
        // window.pageXOffset == window.scrollX; // always true
        // using window.pageXOffset for IE9 compatibility
        const viewPortX = pageX - window.pageXOffset;
        const viewPortY = pageY - window.pageYOffset;
        if (document['msElementsFromPoint']) {
            // Edge and IE special snowflakes
            const elements = document['msElementsFromPoint'](viewPortX, viewPortY);
            return elements === null ? [] : elements;
        }
        else {
            // Other browsers like Chrome, Firefox, Opera
            return document.elementsFromPoint(viewPortX, viewPortY);
        }
    }
    /**
     * @hidden
     */
    dispatchEvent(target, eventName, eventArgs) {
        // This way is IE11 compatible.
        const dragLeaveEvent = document.createEvent('CustomEvent');
        dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
        target.dispatchEvent(dragLeaveEvent);
        // Otherwise can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
    }
    getTransformX(elem) {
        let posX = 0;
        if (elem.style.transform) {
            const matrix = elem.style.transform;
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posX = values ? Number(values[1]) : 0;
        }
        return posX;
    }
    getTransformY(elem) {
        let posY = 0;
        if (elem.style.transform) {
            const matrix = elem.style.transform;
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posY = values ? Number(values[2]) : 0;
        }
        return posY;
    }
    /** Method setting transformation to the base draggable element. */
    setTransformXY(x, y) {
        this.element.nativeElement.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)';
    }
    getWindowScrollTop() {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    }
    getWindowScrollLeft() {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    }
    ghostHostOffsetLeft(ghostHost) {
        const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().left - this.getWindowScrollLeft();
        }
        return ghostHost.getBoundingClientRect().left - this.getWindowScrollLeft();
    }
    ghostHostOffsetTop(ghostHost) {
        const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().top - this.getWindowScrollTop();
        }
        return ghostHost.getBoundingClientRect().top - this.getWindowScrollTop();
    }
}
IgxDragDirective.ɵfac = function IgxDragDirective_Factory(t) { return new (t || IgxDragDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IgxDragDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDragDirective, selectors: [["", "igxDrag", ""]], contentQueries: function IgxDragDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDragHandleDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDragIgnoreDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragHandles = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragIgnoredElems = _t);
    } }, hostVars: 4, hostBindings: function IgxDragDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-drag", ctx.baseClass)("igx-drag--select-disabled", ctx.selectDisabled);
    } }, inputs: { dragTolerance: "dragTolerance", dragDirection: "dragDirection", ghost: "ghost", ghostClass: "ghostClass", ghostOffsetX: "ghostOffsetX", ghostOffsetY: "ghostOffsetY", data: ["igxDrag", "data"], dragChannel: "dragChannel", ghostTemplate: "ghostTemplate", ghostHost: "ghostHost" }, outputs: { dragStart: "dragStart", dragMove: "dragMove", dragEnd: "dragEnd", dragClick: "dragClick", ghostCreate: "ghostCreate", ghostDestroy: "ghostDestroy", transitioned: "transitioned" }, exportAs: ["drag"] });
IgxDragDirective.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: NgZone },
    { type: Renderer2 }
];
IgxDragDirective.propDecorators = {
    data: [{ type: Input, args: ['igxDrag',] }],
    dragTolerance: [{ type: Input }],
    dragDirection: [{ type: Input }],
    dragChannel: [{ type: Input }],
    ghost: [{ type: Input }],
    ghostClass: [{ type: Input }],
    ghostTemplate: [{ type: Input }],
    ghostHost: [{ type: Input }],
    ghostOffsetX: [{ type: Input }],
    ghostOffsetY: [{ type: Input }],
    dragStart: [{ type: Output }],
    dragMove: [{ type: Output }],
    dragEnd: [{ type: Output }],
    dragClick: [{ type: Output }],
    ghostCreate: [{ type: Output }],
    ghostDestroy: [{ type: Output }],
    transitioned: [{ type: Output }],
    dragHandles: [{ type: ContentChildren, args: [IgxDragHandleDirective, { descendants: true },] }],
    dragIgnoredElems: [{ type: ContentChildren, args: [IgxDragIgnoreDirective, { descendants: true },] }],
    baseClass: [{ type: HostBinding, args: ['class.igx-drag',] }],
    selectDisabled: [{ type: HostBinding, args: ['class.igx-drag--select-disabled',] }]
};
class IgxDropDirective {
    constructor(element, _renderer, _zone) {
        this.element = element;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         * @memberof IgxDropDirective
         */
        this.enter = new EventEmitter();
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         * @memberof IgxDropDirective
         */
        this.over = new EventEmitter();
        /**
         * Event triggered when dragged element leaves the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragLeave(){
         *     alert("A draggable element has left the chip area!");
         * }
         * ```
         * @memberof IgxDropDirective
         */
        this.leave = new EventEmitter();
        /**
         * Event triggered when dragged element is dropped in the area of the element.
         * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
         * To cancel the default logic the `cancel` property of the event needs to be set to true.
         * ```html
         * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragDrop(){
         *     alert("A draggable element has been dropped in the chip area!");
         * }
         * ```
         * @memberof IgxDropDirective
         */
        this.dropped = new EventEmitter();
        /**
         * @hidden
         */
        this.droppable = true;
        /**
         * @hidden
         */
        this.dragover = false;
        /**
         * @hidden
         */
        this._destroy = new Subject();
        this._dropStrategy = new IgxDefaultDropStrategy();
    }
    get data() {
        return this._data;
    }
    set data(v) {
        this._data = v;
    }
    /**
     * An @Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
     *  the current drop area. The provided strategies are:
     *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
     *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
     *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
     *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
     *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
     * ```html
     * <div igxDrag>
     *      <span>DragMe</span>
     * </div>
     * <div igxDrop [dropStrategy]="myDropStrategy">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * ```typescript
     * import { IgxAppendDropStrategy } from 'igniteui-angular';
     *
     * export class App {
     *      public myDropStrategy = IgxAppendDropStrategy;
     * }
     * ```
     * @memberof IgxDropDirective
     */
    set dropStrategy(classRef) {
        this._dropStrategy = new classRef(this._renderer);
    }
    get dropStrategy() {
        return this._dropStrategy;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            fromEvent(this.element.nativeElement, 'igxDragEnter').pipe(takeUntil(this._destroy))
                .subscribe((res) => this.onDragEnter(res));
            fromEvent(this.element.nativeElement, 'igxDragLeave').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragLeave(res));
            fromEvent(this.element.nativeElement, 'igxDragOver').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragOver(res));
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
    }
    /**
     * @hidden
     */
    onDragOver(event) {
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this.over.emit(eventArgs);
    }
    /**
     * @hidden
     */
    onDragEnter(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = true;
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(() => {
            this.enter.emit(eventArgs);
        });
    }
    /**
     * @hidden
     */
    onDragLeave(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = false;
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(() => {
            this.leave.emit(eventArgs);
        });
    }
    /**
     * @hidden
     */
    onDragDrop(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const args = {
            owner: this,
            originalEvent: event.detail.originalEvent,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY,
            cancel: false
        };
        this._zone.run(() => {
            this.dropped.emit(args);
        });
        if (this._dropStrategy && !args.cancel) {
            const elementsAtPoint = event.detail.owner.getElementsAtPoint(event.detail.pageX, event.detail.pageY);
            const insertIndex = this.getInsertIndexAt(event.detail.owner, elementsAtPoint);
            this._dropStrategy.dropAction(event.detail.owner, this, insertIndex);
        }
    }
    getWindowScrollTop() {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    }
    getWindowScrollLeft() {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    }
    isDragLinked(drag) {
        const dragLinkArray = drag.dragChannel instanceof Array;
        const dropLinkArray = this.dropChannel instanceof Array;
        if (!dragLinkArray && !dropLinkArray) {
            return this.dropChannel === drag.dragChannel;
        }
        else if (!dragLinkArray && dropLinkArray) {
            const dropLinks = this.dropChannel;
            for (let i = 0; i < dropLinks.length; i++) {
                if (dropLinks[i] === drag.dragChannel) {
                    return true;
                }
            }
        }
        else if (dragLinkArray && !dropLinkArray) {
            const dragLinks = drag.dragChannel;
            for (let i = 0; i < dragLinks.length; i++) {
                if (dragLinks[i] === this.dropChannel) {
                    return true;
                }
            }
        }
        else {
            const dragLinks = drag.dragChannel;
            const dropLinks = this.dropChannel;
            for (let i = 0; i < dragLinks.length; i++) {
                for (let j = 0; j < dropLinks.length; j++) {
                    if (dragLinks[i] === dropLinks[j]) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    getInsertIndexAt(draggedDir, elementsAtPoint) {
        let insertIndex = -1;
        const dropChildren = Array.prototype.slice.call(this.element.nativeElement.children);
        if (!dropChildren.length) {
            return insertIndex;
        }
        let i = 0;
        let childUnder = null;
        while (!childUnder && i < elementsAtPoint.length) {
            if (elementsAtPoint[i].parentElement === this.element.nativeElement) {
                childUnder = elementsAtPoint[i];
            }
            i++;
        }
        const draggedElemIndex = dropChildren.indexOf(draggedDir.element.nativeElement);
        insertIndex = dropChildren.indexOf(childUnder);
        if (draggedElemIndex !== -1 && draggedElemIndex < insertIndex) {
            insertIndex++;
        }
        return insertIndex;
    }
}
IgxDropDirective.ɵfac = function IgxDropDirective_Factory(t) { return new (t || IgxDropDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxDropDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDropDirective, selectors: [["", "igxDrop", ""]], hostVars: 3, hostBindings: function IgxDropDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("igxDrop", function IgxDropDirective_igxDrop_HostBindingHandler($event) { return ctx.onDragDrop($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("droppable", ctx.droppable);
        ɵngcc0.ɵɵclassProp("dragOver", ctx.dragover);
    } }, inputs: { _data: ["igxDrop", "_data"], dropStrategy: "dropStrategy", dropChannel: "dropChannel" }, outputs: { enter: "enter", over: "over", leave: "leave", dropped: "dropped" }, exportAs: ["drop"] });
IgxDropDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
IgxDropDirective.propDecorators = {
    _data: [{ type: Input, args: ['igxDrop',] }],
    dropChannel: [{ type: Input }],
    dropStrategy: [{ type: Input }],
    enter: [{ type: Output }],
    over: [{ type: Output }],
    leave: [{ type: Output }],
    dropped: [{ type: Output }],
    droppable: [{ type: HostBinding, args: ['attr.droppable',] }],
    dragover: [{ type: HostBinding, args: ['class.dragOver',] }],
    onDragDrop: [{ type: HostListener, args: ['igxDrop', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxDragDropModule {
}
IgxDragDropModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDragDropModule });
IgxDragDropModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDragDropModule_Factory(t) { return new (t || IgxDragDropModule)(); } });

class IgxFilterOptions {
    constructor() {
        // Input text value that will be used as a filtering pattern (matching condition is based on it)
        this.inputValue = '';
    }
    // Function - get value to be tested from the item
    // item - single item of the list to be filtered
    // key - property name of item, which value should be tested
    // Default behavior - returns "key"- named property value of item if key si provided,
    // otherwise textContent of the item's html element
    get_value(item, key) {
        let result = '';
        if (key && item[key]) {
            result = item[key].toString();
        }
        else if (item.element) {
            if (item.element.nativeElement) {
                result = item.element.nativeElement.textContent.trim();
                // Check if element doesn't return the DOM element directly
            }
            else if (item.element.textContent) {
                result = item.element.textContent.trim();
            }
        }
        return result;
    }
    // Function - formats the original text before matching process
    // Default behavior - returns text to lower case
    formatter(valueToTest) {
        return valueToTest.toLowerCase();
    }
    // Function - determines whether the item met the condition
    // valueToTest - text value that should be tested
    // inputValue - text value from input that condition is based on
    // Default behavior - "contains"
    matchFn(valueToTest, inputValue) {
        return valueToTest.indexOf(inputValue && inputValue.toLowerCase() || '') > -1;
    }
    // Function - executed after matching test for every matched item
    // Default behavior - shows the item
    metConditionFn(item) {
        if (item.hasOwnProperty('hidden')) {
            item.hidden = false;
        }
    }
    // Function - executed for every NOT matched item after matching test
    // Default behavior - hides the item
    overdueConditionFn(item) {
        if (item.hasOwnProperty('hidden')) {
            item.hidden = true;
        }
    }
}
class IgxFilterDirective {
    constructor(element, renderer) {
        this.element = element;
        this.filtering = new EventEmitter(false); // synchronous event emitter
        this.filtered = new EventEmitter();
    }
    ngOnChanges(changes) {
        // Detect only changes of input value
        if (changes.filterOptions &&
            changes.filterOptions.currentValue &&
            changes.filterOptions.currentValue.inputValue !== undefined &&
            changes.filterOptions.previousValue &&
            changes.filterOptions.currentValue.inputValue !== changes.filterOptions.previousValue.inputValue) {
            this.filter();
        }
    }
    filter() {
        if (!this.filterOptions.items) {
            return;
        }
        const args = { cancel: false, items: this.filterOptions.items };
        this.filtering.emit(args);
        if (args.cancel) {
            return;
        }
        const pipe = new IgxFilterPipe();
        const filtered = pipe.transform(this.filterOptions.items, this.filterOptions);
        this.filtered.emit({ filteredItems: filtered });
    }
}
IgxFilterDirective.ɵfac = function IgxFilterDirective_Factory(t) { return new (t || IgxFilterDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IgxFilterDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxFilterDirective, selectors: [["", "igxFilter", ""]], inputs: { filterOptions: ["igxFilter", "filterOptions"] }, outputs: { filtering: "filtering", filtered: "filtered" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
IgxFilterDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
IgxFilterDirective.propDecorators = {
    filtering: [{ type: Output }],
    filtered: [{ type: Output }],
    filterOptions: [{ type: Input, args: ['igxFilter',] }]
};
class IgxFilterPipe {
    transform(items, 
    // options - initial settings of filter functionality
    options) {
        let result = [];
        if (!items || !items.length || !options) {
            return;
        }
        if (options.items) {
            items = options.items;
        }
        result = items.filter((item) => {
            const match = options.matchFn(options.formatter(options.get_value(item, options.key)), options.inputValue);
            if (match) {
                if (options.metConditionFn) {
                    options.metConditionFn(item);
                }
            }
            else {
                if (options.overdueConditionFn) {
                    options.overdueConditionFn(item);
                }
            }
            return match;
        });
        return result;
    }
}
IgxFilterPipe.ɵfac = function IgxFilterPipe_Factory(t) { return new (t || IgxFilterPipe)(); };
IgxFilterPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxFilter", type: IgxFilterPipe, pure: false });
/**
 * @hidden
 */
class IgxFilterModule {
}
IgxFilterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxFilterModule });
IgxFilterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxFilterModule_Factory(t) { return new (t || IgxFilterModule)(); }, imports: [[CommonModule]] });

class IgxFocusDirective {
    constructor(element, comp) {
        this.element = element;
        this.comp = comp;
        this.focusState = true;
    }
    /**
     * Returns the state of the igxFocus.
     * ```typescript
     * @ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * let isFocusOn = this.igxFocus.focused;
     * ```
     * @memberof IgxFocusDirective
     */
    get focused() {
        return this.focusState;
    }
    /**
     * Sets the state of the igxFocus.
     * ```html
     * <igx-input-group >
     *  <input #focusContainer igxInput [igxFocus]="true"/>
     * </igx-input-group>
     * ```
     * @memberof IgxFocusDirective
     */
    set focused(val) {
        this.focusState = val;
        this.trigger();
    }
    /**
     * Gets the native element of the igxFocus.
     * ```typescript
     * @ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * let igxFocusNativeElement = this.igxFocus.nativeElement;
     * ```
     * @memberof IgxFocusDirective
     */
    get nativeElement() {
        if (this.comp && this.comp[0] && this.comp[0].getEditElement) {
            return this.comp[0].getEditElement();
        }
        return this.element.nativeElement;
    }
    /**
     * Triggers the igxFocus state.
     * ```typescript
     * @ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * this.igxFocus.trigger();
     * ```
     * @memberof IgxFocusDirective
     */
    trigger() {
        if (this.focusState) {
            requestAnimationFrame(() => this.nativeElement.focus({ preventScroll: true }));
        }
    }
}
IgxFocusDirective.ɵfac = function IgxFocusDirective_Factory(t) { return new (t || IgxFocusDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10)); };
IgxFocusDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxFocusDirective, selectors: [["", "igxFocus", ""]], inputs: { focused: ["igxFocus", "focused"] }, exportAs: ["igxFocus"] });
IgxFocusDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Array, decorators: [{ type: Inject, args: [NG_VALUE_ACCESSOR,] }, { type: Self }, { type: Optional }] }
];
IgxFocusDirective.propDecorators = {
    focused: [{ type: Input, args: ['igxFocus',] }]
};
/**
 * @hidden
 */
class IgxFocusModule {
}
IgxFocusModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxFocusModule });
IgxFocusModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxFocusModule_Factory(t) { return new (t || IgxFocusModule)(); } });

class IgxLayoutDirective {
    constructor() {
        /**
         * Sets the default flow direction of the container's children.
         *
         * Defaults to `rows`.
         *
         * ```html
         *  <div
         *   igxLayout
         *   igxLayoutDir="row">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         *  </div>
         * ```
         */
        this.dir = 'row';
        /**
         * Defines the direction flex children are placed in the flex container.
         *
         * When set to `true`, the `rows` direction goes right to left and `columns` goes bottom to top.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutReverse="true">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         * </div>
         * ```
         */
        this.reverse = false;
        /**
         * By default the immediate children will all try to fit onto one line.
         *
         * The default value `nowrap` sets this behavior.
         *
         * Other accepted values are `wrap` and `wrap-reverse`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="row"
         *   igxLayoutWrap="wrap">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */
        this.wrap = 'nowrap';
        /**
         * Defines the alignment along the main axis.
         *
         * Defaults to `flex-start` which packs the children toward the start line.
         *
         * Other possible values are `flex-end`, `center`, `space-between`, `space-around`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutJustify="space-between">
         *    <div>1</div>
         *    <div>2</div>
         *    <div>3</div>
         * </div>
         * ```
         */
        this.justify = 'flex-start';
        /**
         * Defines the default behavior for how children are laid out along the corss axis of the current line.
         *
         * Defaults to `flex-start`.
         *
         * Other possible values are `flex-end`, `center`, `baseline`, and `stretch`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutItemAlign="start">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */
        this.itemAlign = 'stretch';
        /**
         * @hidden
         */
        this.display = 'flex';
    }
    /**
     * @hidden
     */
    get flexwrap() { return this.wrap; }
    /**
     * @hidden
     */
    get justifycontent() { return this.justify; }
    /**
     * @hidden
     */
    get align() { return this.itemAlign; }
    /**
     * @hidden
     */
    get direction() {
        if (this.reverse) {
            return (this.dir === 'row') ? 'row-reverse' : 'column-reverse';
        }
        return (this.dir === 'row') ? 'row' : 'column';
    }
}
IgxLayoutDirective.ɵfac = function IgxLayoutDirective_Factory(t) { return new (t || IgxLayoutDirective)(); };
IgxLayoutDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxLayoutDirective, selectors: [["", "igxLayout", ""]], hostVars: 10, hostBindings: function IgxLayoutDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.display)("flex-wrap", ctx.flexwrap)("justify-content", ctx.justifycontent)("align-items", ctx.align)("flex-direction", ctx.direction);
    } }, inputs: { dir: ["igxLayoutDir", "dir"], reverse: ["igxLayoutReverse", "reverse"], wrap: ["igxLayoutWrap", "wrap"], justify: ["igxLayoutJustify", "justify"], itemAlign: ["igxLayoutItemAlign", "itemAlign"] } });
IgxLayoutDirective.propDecorators = {
    dir: [{ type: Input, args: ['igxLayoutDir',] }],
    reverse: [{ type: Input, args: ['igxLayoutReverse',] }],
    wrap: [{ type: Input, args: ['igxLayoutWrap',] }],
    justify: [{ type: Input, args: ['igxLayoutJustify',] }],
    itemAlign: [{ type: Input, args: ['igxLayoutItemAlign',] }],
    display: [{ type: HostBinding, args: ['style.display',] }],
    flexwrap: [{ type: HostBinding, args: ['style.flex-wrap',] }],
    justifycontent: [{ type: HostBinding, args: ['style.justify-content',] }],
    align: [{ type: HostBinding, args: ['style.align-items',] }],
    direction: [{ type: HostBinding, args: ['style.flex-direction',] }]
};
class IgxFlexDirective {
    constructor() {
        /**
         * Applies the `grow` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexGrow="0">Content1</div>
         *    <div igxFlex igxFlexGrow="1">Content2</div>
         *    <div igxFlex igxFlexGrow="0">Content3</div>
         * </div>
         * ```
         */
        this.grow = 1;
        /**
         * Applies the `shrink` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexShrink="1">Content1</div>
         *    <div igxFlex igxFlexShrink="0">Content2</div>
         *    <div igxFlex igxFlexShrink="1">Content3</div>
         * </div>
         * ```
         */
        this.shrink = 1;
        /**
         * Applies the directive to an element.
         *
         * Possible values include `igxFlexGrow`, `igxFlexShrink`, `igxFlexOrder`, `igxFlexBasis`.
         *
         * ```html
         * <div igxFlex>Content</div>
         * ```
         */
        this.flex = '';
        /**
         * Applies the `order` attribute to an element that uses the directive.
         *
         * Default value is `0`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexOrder="1">Content1</div>
         *    <div igxFlex igxFlexOrder="0">Content2</div>
         *    <div igxFlex igxFlexOrder="2">Content3</div>
         * </div>
         * ```
         */
        this.order = 0;
        /**
         * Applies the `flex-basis` attribute to an element that uses the directive.
         *
         * Default value is `auto`.
         *
         * Other possible values include `content`, `max-content`, `min-content`, `fit-content`.
         *
         * ```html
         * <div igxFlex igxFlexBasis="fit-content">Content</div>
         * ```
         */
        this.basis = 'auto';
    }
    /**
     * @hidden
     */
    get style() {
        if (this.flex) {
            return `${this.flex}`;
        }
        return `${this.grow} ${this.shrink} ${this.basis}`;
    }
    /**
     * @hidden
     */
    get itemorder() {
        return this.order || 0;
    }
}
IgxFlexDirective.ɵfac = function IgxFlexDirective_Factory(t) { return new (t || IgxFlexDirective)(); };
IgxFlexDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxFlexDirective, selectors: [["", "igxFlex", ""]], hostVars: 4, hostBindings: function IgxFlexDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("flex", ctx.style)("order", ctx.itemorder);
    } }, inputs: { grow: ["igxFlexGrow", "grow"], shrink: ["igxFlexShrink", "shrink"], flex: ["igxFlex", "flex"], order: ["igxFlexOrder", "order"], basis: ["igxFlexBasis", "basis"] } });
IgxFlexDirective.propDecorators = {
    grow: [{ type: Input, args: ['igxFlexGrow',] }],
    shrink: [{ type: Input, args: ['igxFlexShrink',] }],
    flex: [{ type: Input, args: ['igxFlex',] }],
    order: [{ type: Input, args: ['igxFlexOrder',] }],
    basis: [{ type: Input, args: ['igxFlexBasis',] }],
    style: [{ type: HostBinding, args: ['style.flex',] }],
    itemorder: [{ type: HostBinding, args: ['style.order',] }]
};
/**
 * @hidden
 */
class IgxLayoutModule {
}
IgxLayoutModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxLayoutModule });
IgxLayoutModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxLayoutModule_Factory(t) { return new (t || IgxLayoutModule)(); } });

/** @hidden */
const MASK_FLAGS = ['C', '&', 'a', 'A', '?', 'L', '9', '0', '#'];
/** @hidden */
class MaskParsingService {
    applyMask(inputVal, maskOptions) {
        let outputVal = '';
        let value = '';
        const mask = maskOptions.format;
        const literals = this.getMaskLiterals(mask);
        const literalKeys = Array.from(literals.keys());
        const nonLiteralIndices = this.getNonLiteralIndices(mask, literalKeys);
        const literalValues = Array.from(literals.values());
        if (inputVal != null) {
            value = inputVal.toString();
        }
        for (const maskSym of mask) {
            outputVal += maskOptions.promptChar;
        }
        literals.forEach((val, key) => {
            outputVal = this.replaceCharAt(outputVal, key, val);
        });
        if (!value) {
            return outputVal;
        }
        const nonLiteralValues = this.getNonLiteralValues(value, literalValues);
        for (let i = 0; i < nonLiteralValues.length; i++) {
            const char = nonLiteralValues[i];
            const isCharValid = this.validateCharOnPosition(char, nonLiteralIndices[i], mask);
            if (!isCharValid && char !== maskOptions.promptChar) {
                nonLiteralValues[i] = maskOptions.promptChar;
            }
        }
        if (nonLiteralValues.length > nonLiteralIndices.length) {
            nonLiteralValues.splice(nonLiteralIndices.length);
        }
        let pos = 0;
        for (const nonLiteralValue of nonLiteralValues) {
            const char = nonLiteralValue;
            outputVal = this.replaceCharAt(outputVal, nonLiteralIndices[pos++], char);
        }
        return outputVal;
    }
    parseValueFromMask(maskedValue, maskOptions) {
        let outputVal = '';
        const mask = maskOptions.format;
        const literals = this.getMaskLiterals(mask);
        const literalValues = Array.from(literals.values());
        for (const val of maskedValue) {
            if (literalValues.indexOf(val) === -1) {
                if (val !== maskOptions.promptChar) {
                    outputVal += val;
                }
            }
        }
        return outputVal;
    }
    replaceInMask(maskedValue, value, maskOptions, start, end) {
        const literalsPositions = Array.from(this.getMaskLiterals(maskOptions.format).keys());
        const chars = Array.from(value);
        let cursor = start;
        end = Math.min(end, maskedValue.length);
        for (let i = start; i < end || (chars.length && i < maskedValue.length); i++) {
            if (literalsPositions.indexOf(i) !== -1) {
                if (chars[0] === maskedValue[i]) {
                    cursor = i + 1;
                    chars.shift();
                }
                continue;
            }
            if (chars[0]
                && !this.validateCharOnPosition(chars[0], i, maskOptions.format)
                && chars[0] !== maskOptions.promptChar) {
                break;
            }
            let char = maskOptions.promptChar;
            if (chars.length) {
                cursor = i + 1;
                char = chars.shift();
            }
            maskedValue = this.replaceCharAt(maskedValue, i, char);
        }
        return { value: maskedValue, end: cursor };
    }
    replaceCharAt(strValue, index, char) {
        if (strValue !== undefined) {
            return strValue.substring(0, index) + char + strValue.substring(index + 1);
        }
    }
    /** Validates only non literal positions. */
    validateCharOnPosition(inputChar, position, mask) {
        let regex;
        let isValid;
        const letterOrDigitRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
        const letterDigitOrSpaceRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
        const letterRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
        const letterSpaceRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
        const digitRegEx = '[\\d]';
        const digitSpaceRegEx = '[\\d\\u0020]';
        const digitSpecialRegEx = '[\\d-\\+]';
        switch (mask.charAt(position)) {
            case 'C':
                isValid = inputChar !== '';
                break;
            case '&':
                regex = new RegExp('[\\u0020]');
                isValid = !regex.test(inputChar);
                break;
            case 'a':
                regex = new RegExp(letterDigitOrSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case 'A':
                regex = new RegExp(letterOrDigitRegEx);
                isValid = regex.test(inputChar);
                break;
            case '?':
                regex = new RegExp(letterSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case 'L':
                regex = new RegExp(letterRegEx);
                isValid = regex.test(inputChar);
                break;
            case '0':
                regex = new RegExp(digitRegEx);
                isValid = regex.test(inputChar);
                break;
            case '9':
                regex = new RegExp(digitSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case '#':
                regex = new RegExp(digitSpecialRegEx);
                isValid = regex.test(inputChar);
                break;
            default: {
                isValid = null;
            }
        }
        return isValid;
    }
    getMaskLiterals(mask) {
        const literals = new Map();
        for (let i = 0; i < mask.length; i++) {
            const char = mask.charAt(i);
            if (MASK_FLAGS.indexOf(char) === -1) {
                literals.set(i, char);
            }
        }
        return literals;
    }
    getNonLiteralIndices(mask, literalKeys) {
        const nonLiteralsIndices = new Array();
        for (let i = 0; i < mask.length; i++) {
            if (literalKeys.indexOf(i) === -1) {
                nonLiteralsIndices.push(i);
            }
        }
        return nonLiteralsIndices;
    }
    getNonLiteralValues(value, literalValues) {
        const nonLiteralValues = new Array();
        for (const val of value) {
            if (literalValues.indexOf(val) === -1) {
                nonLiteralValues.push(val);
            }
        }
        return nonLiteralValues;
    }
}
MaskParsingService.ɵfac = function MaskParsingService_Factory(t) { return new (t || MaskParsingService)(); };
MaskParsingService.ɵprov = ɵɵdefineInjectable({ factory: function MaskParsingService_Factory() { return new MaskParsingService(); }, token: MaskParsingService, providedIn: "root" });

const noop = () => { };
const ɵ0$1 = noop;
class IgxMaskDirective {
    constructor(elementRef, maskParser, renderer) {
        this.elementRef = elementRef;
        this.maskParser = maskParser;
        this.renderer = renderer;
        /**
         * Sets the character representing a fillable spot in the input mask.
         * Default value is "'_'".
         * ```html
         * <input [promptChar] = "'/'">
         * ```
         */
        this.promptChar = '_';
        /**
         * Emits an event each time the value changes.
         * Provides `rawValue: string` and `formattedValue: string` as event arguments.
         * ```html
         * <input (onValueChange) = "onValueChange(rawValue: string, formattedValue: string)">
         * ```
         */
        this.onValueChange = new EventEmitter();
        this._end = 0;
        this._start = 0;
        this._oldText = '';
        this._dataValue = '';
        this._focused = false;
        this._onTouchedCallback = noop;
        this._onChangeCallback = noop;
    }
    /**
     * Specifies a placeholder.
     * ```html
     * <input placeholder = "enter text...">
     * ```
     */
    set placeholder(val) {
        this.renderer.setAttribute(this.nativeElement, 'placeholder', val);
    }
    get placeholder() {
        return this.nativeElement.placeholder;
    }
    /** @hidden */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /** @hidden @internal; */
    get inputValue() {
        return this.nativeElement.value;
    }
    /** @hidden @internal */
    set inputValue(val) {
        this.nativeElement.value = val;
    }
    /** @hidden */
    get maskOptions() {
        const format = this.mask || 'CCCCCCCCCC';
        const promptChar = this.promptChar && this.promptChar.substring(0, 1);
        return { format, promptChar };
    }
    /** @hidden */
    get selectionStart() {
        // Edge(classic) and FF don't select text on drop
        return this.nativeElement.selectionStart === this.nativeElement.selectionEnd && this._hasDropAction ?
            this.nativeElement.selectionEnd - this._droppedData.length :
            this.nativeElement.selectionStart;
    }
    /** @hidden */
    get selectionEnd() {
        return this.nativeElement.selectionEnd;
    }
    /** @hidden */
    get start() {
        return this._start;
    }
    /** @hidden */
    get end() {
        return this._end;
    }
    /** @hidden */
    ngOnInit() {
        if (!this.nativeElement.placeholder) {
            this.renderer.setAttribute(this.nativeElement, 'placeholder', this.maskOptions.format);
        }
    }
    /**
     * TODO: Remove after date/time picker integration refactor
     * @hidden
     */
    ngAfterViewChecked() {
        this._oldText = this.inputValue;
    }
    /** @hidden */
    onKeyDown(event) {
        const key = event.keyCode || event.charCode;
        if (!key) {
            return;
        }
        if (isIE() && this._stopPropagation) {
            this._stopPropagation = false;
        }
        if ((key === 17 /* CTRL */ && key === 90 /* Z */) || (key === 17 /* CTRL */ && key === 89 /* Y */)) {
            event.preventDefault();
        }
        this._key = key;
        this._start = this.selectionStart;
        this._end = this.selectionEnd;
    }
    /** @hidden */
    onInputChanged() {
        /**
         * '!this._focused' is a fix for #8165
         * On page load IE triggers input events before focus events and
         * it does so for every single input on the page.
         * The mask needs to be prevented from doing anything while this is happening because
         * the end user will be unable to blur the input.
         * https://stackoverflow.com/questions/21406138/input-event-triggered-on-internet-explorer-when-placeholder-changed
         */
        if (isIE() && (this._stopPropagation || !this._focused)) {
            this._stopPropagation = false;
            return;
        }
        if (this._hasDropAction) {
            this._start = this.selectionStart;
        }
        if (this.inputValue.length < this._oldText.length && this._key === 229 /* INPUT_METHOD */) {
            // software keyboard input delete
            this._key = 8 /* BACKSPACE */;
        }
        let valueToParse = '';
        switch (this._key) {
            case 46 /* DELETE */:
                this._end = this._start === this._end ? ++this._end : this._end;
                break;
            case 8 /* BACKSPACE */:
                this._start = this.selectionStart;
                break;
            default:
                valueToParse = this.inputValue.substring(this._start, this.selectionEnd);
                break;
        }
        const replacedData = this.maskParser.replaceInMask(this._oldText, valueToParse, this.maskOptions, this._start, this._end);
        this.inputValue = replacedData.value;
        if (this._key === 8 /* BACKSPACE */) {
            replacedData.end = this._start;
        }
        this.setSelectionRange(replacedData.end);
        const rawVal = this.maskParser.parseValueFromMask(this.inputValue, this.maskOptions);
        this._dataValue = this.includeLiterals ? this.inputValue : rawVal;
        this._onChangeCallback(this._dataValue);
        this.onValueChange.emit({ rawValue: rawVal, formattedValue: this.inputValue });
        this.afterInput();
    }
    /** @hidden */
    onPaste() {
        this._oldText = this.inputValue;
        this._start = this.selectionStart;
    }
    /** @hidden */
    onFocus() {
        this._focused = true;
        this.showMask(this._dataValue);
    }
    /** @hidden */
    onBlur(value) {
        this._focused = false;
        this.showDisplayValue(value);
        this._onTouchedCallback();
    }
    /** @hidden */
    onDragEnter() {
        if (!this._focused) {
            this.showMask(this._dataValue);
        }
    }
    /** @hidden */
    onDragLeave() {
        if (!this._focused) {
            this.showDisplayValue(this.inputValue);
        }
    }
    /** @hidden */
    onDrop(event) {
        this._hasDropAction = true;
        this._droppedData = event.dataTransfer.getData('text');
    }
    /** @hidden */
    showMask(value) {
        if (this.focusedValuePipe) {
            if (isIE()) {
                this._stopPropagation = true;
            }
            // TODO(D.P.): focusedValuePipe should be deprecated or force-checked to match mask format
            this.inputValue = this.focusedValuePipe.transform(value);
        }
        else {
            this.inputValue = this.maskParser.applyMask(this.inputValue, this.maskOptions);
        }
        this._oldText = this.inputValue;
    }
    /** @hidden */
    setSelectionRange(start, end = start) {
        this.nativeElement.setSelectionRange(start, end);
    }
    /** @hidden */
    afterInput() {
        this._oldText = this.inputValue;
        this._hasDropAction = false;
        this._start = 0;
        this._end = 0;
        this._key = null;
    }
    showDisplayValue(value) {
        if (this.displayValuePipe) {
            this.inputValue = this.displayValuePipe.transform(value);
        }
        else if (value === this.maskParser.applyMask(null, this.maskOptions)) {
            this.inputValue = '';
        }
    }
    /** @hidden */
    writeValue(value) {
        if (this.promptChar && this.promptChar.length > 1) {
            this.maskOptions.promptChar = this.promptChar.substring(0, 1);
        }
        this.inputValue = value ? this.maskParser.applyMask(value, this.maskOptions) : '';
        if (this.displayValuePipe) {
            this.inputValue = this.displayValuePipe.transform(this.inputValue);
        }
        this._dataValue = this.includeLiterals ? this.inputValue : value;
        this.onValueChange.emit({ rawValue: value, formattedValue: this.inputValue });
    }
    /** @hidden */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /** @hidden */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
}
IgxMaskDirective.ɵfac = function IgxMaskDirective_Factory(t) { return new (t || IgxMaskDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MaskParsingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IgxMaskDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxMaskDirective, selectors: [["", "igxMask", ""]], hostBindings: function IgxMaskDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function IgxMaskDirective_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); })("input", function IgxMaskDirective_input_HostBindingHandler() { return ctx.onInputChanged(); })("paste", function IgxMaskDirective_paste_HostBindingHandler() { return ctx.onPaste(); })("focus", function IgxMaskDirective_focus_HostBindingHandler() { return ctx.onFocus(); })("blur", function IgxMaskDirective_blur_HostBindingHandler($event) { return ctx.onBlur($event.target.value); })("dragenter", function IgxMaskDirective_dragenter_HostBindingHandler() { return ctx.onDragEnter(); })("dragleave", function IgxMaskDirective_dragleave_HostBindingHandler() { return ctx.onDragLeave(); })("drop", function IgxMaskDirective_drop_HostBindingHandler($event) { return ctx.onDrop($event); });
    } }, inputs: { promptChar: "promptChar", mask: ["igxMask", "mask"], includeLiterals: "includeLiterals", displayValuePipe: "displayValuePipe", focusedValuePipe: "focusedValuePipe" }, outputs: { onValueChange: "onValueChange" }, exportAs: ["igxMask"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxMaskDirective, multi: true }])] });
IgxMaskDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: MaskParsingService },
    { type: Renderer2 }
];
IgxMaskDirective.propDecorators = {
    mask: [{ type: Input, args: ['igxMask',] }],
    promptChar: [{ type: Input }],
    includeLiterals: [{ type: Input }],
    displayValuePipe: [{ type: Input }],
    focusedValuePipe: [{ type: Input }],
    onValueChange: [{ type: Output }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onInputChanged: [{ type: HostListener, args: ['input',] }],
    onPaste: [{ type: HostListener, args: ['paste',] }],
    onFocus: [{ type: HostListener, args: ['focus',] }],
    onBlur: [{ type: HostListener, args: ['blur', ['$event.target.value'],] }],
    onDragEnter: [{ type: HostListener, args: ['dragenter',] }],
    onDragLeave: [{ type: HostListener, args: ['dragleave',] }],
    onDrop: [{ type: HostListener, args: ['drop', ['$event'],] }]
};
__decorate([
    DeprecateProperty('"placeholder" is deprecated, use native placeholder instead.')
], IgxMaskDirective.prototype, "placeholder", null);
/** @hidden */
class IgxMaskModule {
}
IgxMaskModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxMaskModule });
IgxMaskModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxMaskModule_Factory(t) { return new (t || IgxMaskModule)(); }, imports: [[CommonModule]] });

const RadioLabelPosition = mkenum({
    BEFORE: 'before',
    AFTER: 'after'
});
let nextId = 0;
const noop$1 = () => { };
const ɵ0$2 = noop$1;
/**
 * **Ignite UI for Angular Radio Button** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/radio_button.html)
 *
 * The Ignite UI Radio Button allows the user to select a single option from an available set of options that are listed side by side.
 *
 * Example:
 * ```html
 * <igx-radio>
 *   Simple radio button
 * </igx-radio>
 * ```
 */
class IgxRadioComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the radio component.
         * If not set, the `id` of the first radio component will be `"igx-radio-0"`.
         * ```html
         * <igx-radio id = "my-first-radio"></igx-radio>
         * ```
         * ```typescript
         * let radioId =  this.radio.id;
         * ```
         * @memberof IgxRadioComponent
         */
        this.id = `igx-radio-${nextId++}`;
        /**
         * Sets/gets the id of the `label` element in the radio component.
         * If not set, the id of the `label` in the first radio component will be `"igx-radio-0-label"`.
         * ```html
         * <igx-radio labelId = "Label1"></igx-radio>
         * ```
         * ```typescript
         * let labelId =  this.radio.labelId;
         * ```
         * @memberof IgxRadioComponent
         */
        this.labelId = `${this.id}-label`;
        /**
         * Sets/gets the position of the `label` in the radio component.
         * If not set, `labelPosition` will have value `"after"`.
         * ```html
         * <igx-radio labelPosition = "before"></igx-radio>
         * ```
         * ```typescript
         * let labelPosition =  this.radio.labelPosition;
         * ```
         * @memberof IgxRadioComponent
         */
        this.labelPosition = 'after';
        /**
         * Sets the value of the `tabindex` attribute.
         * ```html
         * <igx-radio [tabindex] = "1"></igx-radio>
         * ```
         * ```typescript
         * let tabIndex =  this.radio.tabindex;
         * ```
         * @memberof IgxRadioComponent
         */
        this.tabindex = null;
        /**
         * Enables/disables the ripple effect on the radio button..
         * If not set, the `disableRipple` will have value `false`.
         * ```html
         * <igx-radio [disableRipple] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isDisabledRipple =  this.radio.disableRipple;
         * ```
         * @memberof IgxRadioComponent
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether the radio button is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-radio [required] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isRequired =  this.radio.required;
         * ```
         * @memberof IgxRadioComponent
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledby` attribute of the radio component.
         * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
         * ```html
         * <igx-radio aria-labelledby = "Radio1"></igx-radio>
         * ```
         * ```typescript
         * let ariaLabelledBy = this.radio.ariaLabelledBy;
         * ```
         * @memberof IgxRadioComponent
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the `aria-label` attribute of the radio component.
         * ```html
         * <igx-radio aria-label = "Radio1"></igx-radio>
         * ```
         * ```typescript
         * let ariaLabel =  this.radio.ariaLabel;
         * ```
         * @memberof IgxRadioComponent
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the radio `value` is changed.
         * Provides references to the `IgxRadioComponent` and the `value` property as event arguments.
         * @memberof IgxRadioComponent
         */
        this.change = new EventEmitter();
        /**
         * Returns the class of the radio component.
         * ```typescript
         * let radioClass = this.radio.cssClass;
         * ```
         * @memberof IgxRadioComponent
         */
        this.cssClass = 'igx-radio';
        /**
         * Sets/gets  the `checked` attribute.
         * Default value is `false`.
         * ```html
         * <igx-radio [checked] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isChecked =  this.radio.checked;
         * ```
         * @memberof IgxRadioComponent
         */
        this.checked = false;
        /**
         * Sets/gets  the `disabled` attribute.
         * Default value is `false`.
         * ```html
         * <igx-radio [disabled] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isDisabled =  this.radio.disabled;
         * ```
         * @memberof IgxRadioComponent
         */
        this.disabled = false;
        /**
         * Sets/gets whether the radio component is on focus.
         * Default value is `false`.
         * ```typescript
         * this.radio.focus = true;
         * ```
         * ```typescript
         * let isFocused =  this.radio.focused;
         * ```
         * @memberof IgxRadioComponent
         */
        this.focused = false;
        /**
         * @hidden
         */
        this.inputId = `${this.id}-input`;
        /**
         * @hidden
         */
        this._value = null;
        /**
         * @hidden
         */
        this._onTouchedCallback = noop$1;
        /**
         * @hidden
         */
        this._onChangeCallback = noop$1;
    }
    /**
     * @hidden
     */
    _onRadioChange(event) {
        event.stopPropagation();
    }
    /**
     * @hidden
     */
    _onRadioClick(event) {
        event.stopPropagation();
        this.select();
        if (isIE()) {
            this.nativeRadio.nativeElement.blur();
        }
    }
    /**
     * @hidden
     */
    _onLabelClick() {
        this.select();
    }
    /**
     * Selects the current radio button.
     * ```typescript
     * this.radio.select();
     * ```
     * @memberof IgxRadioComponent
     */
    select() {
        if (this.disabled) {
            return;
        }
        this.checked = true;
        this.focused = false;
        this.change.emit({ value: this.value, radio: this });
        this._onChangeCallback(this.value);
    }
    /**
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true`;
     * ```typescript
     * this.radio.writeValue('radioButtonValue');
     * ```
     */
    writeValue(value) {
        this._value = value;
        this.checked = (this._value === this.value);
    }
    /** @hidden */
    getEditElement() {
        return this.nativeRadio.nativeElement;
    }
    /**
     * @hidden
     */
    get labelClass() {
        switch (this.labelPosition) {
            case RadioLabelPosition.BEFORE:
                return `${this.cssClass}__label--before`;
            case RadioLabelPosition.AFTER:
            default:
                return `${this.cssClass}__label`;
        }
    }
    /**
     * @hidden
     */
    onFocus() {
        this.focused = true;
    }
    /**
     * @hidden
     */
    onBlur() {
        this.focused = false;
        this._onTouchedCallback();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /**
     * @hidden
     */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
}
IgxRadioComponent.ɵfac = function IgxRadioComponent_Factory(t) { return new (t || IgxRadioComponent)(); };
IgxRadioComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxRadioComponent, selectors: [["igx-radio"]], viewQuery: function IgxRadioComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c9, true);
        ɵngcc0.ɵɵstaticViewQuery(_c10, true);
        ɵngcc0.ɵɵstaticViewQuery(_c11, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nativeRadio = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nativeLabel = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.placeholderLabel = _t.first);
    } }, hostVars: 9, hostBindings: function IgxRadioComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-radio", ctx.cssClass)("igx-radio--checked", ctx.checked)("igx-radio--disabled", ctx.disabled)("igx-radio--focused", ctx.focused);
    } }, inputs: { id: "id", labelId: "labelId", labelPosition: "labelPosition", tabindex: "tabindex", disableRipple: "disableRipple", required: "required", ariaLabelledBy: ["aria-labelledby", "ariaLabelledBy"], ariaLabel: ["aria-label", "ariaLabel"], checked: "checked", disabled: "disabled", value: "value", name: "name" }, outputs: { change: "change" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxRadioComponent, multi: true }])], ngContentSelectors: _c2, decls: 8, vars: 17, consts: [["type", "radio", 1, "igx-radio__input", 3, "id", "name", "value", "tabindex", "disabled", "checked", "required", "click", "change", "focus", "blur"], ["radio", ""], ["igxRipple", "", "igxRippleTarget", ".igx-radio__ripple", 1, "igx-radio__composite", 3, "igxRippleDisabled", "igxRippleCentered", "igxRippleDuration", "for"], ["nativeLabel", ""], [1, "igx-radio__ripple"], [3, "id", "click"], ["placeholderLabel", ""]], template: function IgxRadioComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("click", function IgxRadioComponent_Template_input_click_0_listener($event) { return ctx._onRadioClick($event); })("change", function IgxRadioComponent_Template_input_change_0_listener($event) { return ctx._onRadioChange($event); })("focus", function IgxRadioComponent_Template_input_focus_0_listener() { return ctx.onFocus(); })("blur", function IgxRadioComponent_Template_input_blur_0_listener() { return ctx.onBlur(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "label", 2, 3);
        ɵngcc0.ɵɵelement(4, "div", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "span", 5, 6);
        ɵngcc0.ɵɵlistener("click", function IgxRadioComponent_Template_span_click_5_listener() { return ctx._onLabelClick(); });
        ɵngcc0.ɵɵprojection(7);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.inputId)("name", ctx.name)("value", ctx.value)("tabindex", ctx.tabindex)("disabled", ctx.disabled)("checked", ctx.checked)("required", ctx.required);
        ɵngcc0.ɵɵattribute("aria-checked", ctx.checked)("aria-labelledby", ctx.ariaLabelledBy)("aria-label", ctx.ariaLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("igxRippleDisabled", ctx.disableRipple)("igxRippleCentered", true)("igxRippleDuration", 300)("for", ctx.inputId);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵclassMap(ctx.labelClass);
        ɵngcc0.ɵɵproperty("id", ctx.labelId);
    } }, directives: function () { return [IgxRippleDirective]; }, encapsulation: 2 });
IgxRadioComponent.ctorParameters = () => [];
IgxRadioComponent.propDecorators = {
    nativeRadio: [{ type: ViewChild, args: ['radio', { static: true },] }],
    nativeLabel: [{ type: ViewChild, args: ['nativeLabel', { static: true },] }],
    placeholderLabel: [{ type: ViewChild, args: ['placeholderLabel', { static: true },] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    labelId: [{ type: Input }],
    labelPosition: [{ type: Input }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    tabindex: [{ type: Input }],
    disableRipple: [{ type: Input }],
    required: [{ type: Input }],
    ariaLabelledBy: [{ type: Input, args: ['aria-labelledby',] }],
    ariaLabel: [{ type: Input, args: ['aria-label',] }],
    change: [{ type: Output }],
    cssClass: [{ type: HostBinding, args: ['class.igx-radio',] }],
    checked: [{ type: HostBinding, args: ['class.igx-radio--checked',] }, { type: Input }],
    disabled: [{ type: HostBinding, args: ['class.igx-radio--disabled',] }, { type: Input }],
    focused: [{ type: HostBinding, args: ['class.igx-radio--focused',] }]
};

class IgxRippleDirective {
    constructor(builder, elementRef, renderer, zone) {
        this.builder = builder;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        /**
         * Sets/gets the ripple target.
         * ```html
         * <div  #rippleContainer class="div-1" igxRipple [igxRippleTarget] = "'.div-1'"></div>
         * ```
         * ```typescript
         * @ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let rippleTarget = this.ripple.rippleTarget;
         * ```
         * Can set the ripple to activate on a child element inside the parent where igxRipple is defined.
         * ```html
         * <div #rippleContainer [igxRippleTarget] = "'#child"'>
         *  <button id="child">Click</button>
         * </div>
         * ```
         * @memberof IgxRippleDirective
         */
        this.rippleTarget = '';
        /**
         * Sets/gets the ripple duration(in milliseconds).
         * Default value is `600`.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleDuration] = "800"></button>
         * ```
         * ```typescript
         * @ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let rippleDuration = this.ripple.rippleDuration;
         * ```
         * @memberof IgxRippleDirective
         */
        this.rippleDuration = 600;
        /**
         * Sets/gets whether the ripple is disabled.
         * Default value is `false`.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleDisabled] = "true"></button>
         * ```
         * ```typescript
         * @ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let isRippleDisabled = this.ripple.rippleDisabled;
         * ```
         * @memberof IgxRippleDirective
         */
        this.rippleDisabled = false;
        this.rippleElementClass = 'igx-ripple__inner';
        this.rippleHostClass = 'igx-ripple';
        this._centered = false;
        this.animationQueue = [];
    }
    /**
     * Enables/disables the ripple to be centered.
     * ```html
     * <button #rippleContainer igxRipple [igxRippleCentered] = "true"></button>
     * ```
     * @memberof IgxRippleDirective
     */
    set centered(value) {
        this._centered = value || this.centered;
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    onMouseDown(event) {
        this.zone.runOutsideAngular(() => this._ripple(event));
    }
    setStyles(rippleElement, styleParams) {
        this.renderer.addClass(rippleElement, this.rippleElementClass);
        this.renderer.setStyle(rippleElement, 'width', `${styleParams.radius}px`);
        this.renderer.setStyle(rippleElement, 'height', `${styleParams.radius}px`);
        this.renderer.setStyle(rippleElement, 'top', `${styleParams.top}px`);
        this.renderer.setStyle(rippleElement, 'left', `${styleParams.left}px`);
        if (this.rippleColor) {
            this.renderer.setStyle(rippleElement, 'background', this.rippleColor);
        }
    }
    _ripple(event) {
        if (this.rippleDisabled) {
            return;
        }
        const target = (this.rippleTarget ? this.nativeElement.querySelector(this.rippleTarget) || this.nativeElement : this.nativeElement);
        const rectBounds = target.getBoundingClientRect();
        const radius = Math.max(rectBounds.width, rectBounds.height);
        let left = Math.round(event.clientX - rectBounds.left - radius / 2);
        let top = Math.round(event.clientY - rectBounds.top - radius / 2);
        if (this._centered) {
            left = top = 0;
        }
        const dimensions = {
            radius,
            top,
            left
        };
        const rippleElement = this.renderer.createElement('span');
        this.setStyles(rippleElement, dimensions);
        this.renderer.addClass(target, this.rippleHostClass);
        this.renderer.appendChild(target, rippleElement);
        const animation = this.builder.build([
            style({ opacity: 0.5, transform: 'scale(.3)' }),
            animate(this.rippleDuration, style({ opacity: 0, transform: 'scale(2)' }))
        ]).create(rippleElement);
        this.animationQueue.push(animation);
        animation.onDone(() => {
            this.animationQueue.splice(this.animationQueue.indexOf(animation), 1);
            target.removeChild(rippleElement);
            if (this.animationQueue.length < 1) {
                this.renderer.removeClass(target, this.rippleHostClass);
            }
        });
        animation.play();
    }
}
IgxRippleDirective.ɵfac = function IgxRippleDirective_Factory(t) { return new (t || IgxRippleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AnimationBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxRippleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRippleDirective, selectors: [["", "igxRipple", ""]], hostBindings: function IgxRippleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function IgxRippleDirective_mousedown_HostBindingHandler($event) { return ctx.onMouseDown($event); });
    } }, inputs: { rippleTarget: ["igxRippleTarget", "rippleTarget"], rippleDuration: ["igxRippleDuration", "rippleDuration"], rippleDisabled: ["igxRippleDisabled", "rippleDisabled"], centered: ["igxRippleCentered", "centered"], rippleColor: ["igxRipple", "rippleColor"] } });
IgxRippleDirective.ctorParameters = () => [
    { type: AnimationBuilder },
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
IgxRippleDirective.propDecorators = {
    rippleTarget: [{ type: Input, args: ['igxRippleTarget',] }],
    rippleColor: [{ type: Input, args: ['igxRipple',] }],
    rippleDuration: [{ type: Input, args: ['igxRippleDuration',] }],
    centered: [{ type: Input, args: ['igxRippleCentered',] }],
    rippleDisabled: [{ type: Input, args: ['igxRippleDisabled',] }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxRippleModule {
}
IgxRippleModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxRippleModule });
IgxRippleModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxRippleModule_Factory(t) { return new (t || IgxRippleModule)(); } });

const noop$2 = () => { };
const ɵ0$3 = noop$2;
let nextId$1 = 0;
/**
 * Radio group directive renders set of radio buttons.
 *
 * @igxModule IgxRadioModule
 *
 * @igxTheme igx-radio-theme
 *
 * @igxKeywords radiogroup, radio, button, input
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 * The Ignite UI Radio Group allows the user to select a single option from an available set of options that are listed side by side.
 *
 * @example:
 * ```html
 * <igx-radio-group name="radioGroup">
 *   <igx-radio *ngFor="let item of ['Foo', 'Bar', 'Baz']" value="{{item}}">
 *      {{item}}
 *   </igx-radio>
 * </igx-radio-group>
 * ```
 */
class IgxRadioGroupDirective {
    constructor() {
        /**
         * An event that is emitted after the radio group `value` is changed.
         *
         * @remarks
         * Provides references to the selected `IgxRadioComponent` and the `value` property as event arguments.
         *
         * @example
         * ```html
         * <igx-radio-group (change)="handler($event)"></igx-radio-group>
         * ```
         */
        this.change = new EventEmitter();
        /**
         * The css class applied to the component.
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-radio-group';
        /**
         * @hidden
         * @internal
         */
        this._onChangeCallback = noop$2;
        /**
         * @hidden
         * @internal
         */
        this._name = `igx-radio-group-${nextId$1++}`;
        /**
         * @hidden
         * @internal
         */
        this._value = null;
        /**
         * @hidden
         * @internal
         */
        this._selected = null;
        /**
         * @hidden
         * @internal
         */
        this._isInitialized = false;
        /**
         * @hidden
         * @internal
         */
        this._labelPosition = 'after';
        /**
         * @hidden
         * @internal
         */
        this._disabled = false;
        /**
         * @hidden
         * @internal
         */
        this._required = false;
        /**
         * @hidden
         * @internal
         */
        this.destroy$ = new Subject();
    }
    /**
     * Sets/gets the `value` attribute.
     *
     * @example
     * ```html
     * <igx-radio-group [value] = "'radioButtonValue'"></igx-radio-group>
     * ```
     */
    get value() { return this._value; }
    set value(newValue) {
        if (this._value !== newValue) {
            this._value = newValue;
            this._selectRadioButton();
        }
    }
    /**
     * Sets/gets the `name` attribute of the radio group component. All child radio buttons inherits this name.
     *
     * @example
     * ```html
     * <igx-radio-group name = "Radio1"></igx-radio-group>
     *  ```
     */
    get name() { return this._name; }
    set name(newValue) {
        if (this._name !== newValue) {
            this._name = newValue;
            this._setRadioButtonNames();
        }
    }
    /**
     * Sets/gets whether the radio group is required.
     *
     * @remarks
     * If not set, `required` will have value `false`.
     *
     * @example
     * ```html
     * <igx-radio-group [required] = "true"></igx-radio-group>
     * ```
     */
    get required() { return this._required; }
    set required(newValue) {
        if (this._required !== newValue) {
            this._required = newValue;
            this._setRadioButtonsRequired();
        }
    }
    /**
     * An @Input property that allows you to disable the radio group. By default it's false.
     *
     * @example
     *  ```html
     * <igx-radio-group [disabled]="true"></igx-radio-group>
     * ```
     */
    get disabled() { return this._disabled; }
    set disabled(newValue) {
        if (this._disabled !== newValue) {
            this._disabled = newValue;
            this._disableRadioButtons();
        }
    }
    /**
     * Sets/gets the position of the `label` in the child radio buttons.
     *
     * @remarks
     * If not set, `labelPosition` will have value `"after"`.
     *
     * @example
     * ```html
     * <igx-radio-group labelPosition = "before"></igx-radio-group>
     * ```
     */
    get labelPosition() { return this._labelPosition; }
    set labelPosition(newValue) {
        if (this._labelPosition !== newValue) {
            this._labelPosition = newValue === RadioLabelPosition.BEFORE ? RadioLabelPosition.BEFORE : RadioLabelPosition.AFTER;
            this._setRadioButtonLabelPosition();
        }
    }
    /**
     * Sets/gets the selected child radio button.
     *
     * @example
     * ```typescript
     * let selectedButton = this.radioGroup.selected;
     * this.radioGroup.selected = selectedButton;
     * ```
     */
    get selected() { return this._selected; }
    set selected(selected) {
        if (this._selected !== selected) {
            this._selected = selected;
            this.value = selected ? selected.value : null;
        }
    }
    ngAfterContentInit() {
        // The initial value can possibly be set by NgModel and it is possible that
        // the OnInit of the NgModel occurs after the OnInit of this class.
        this._isInitialized = true;
        setTimeout(() => { this._initRadioButtons(); });
    }
    /**
     * Sets the "checked" property value on the radio input element.
     *
     * @remarks
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true` and selected property will contain the selected `IgxRadioComponent`.
     *
     * @example
     * ```typescript
     * this.radioGroup.writeValue('radioButtonValue');
     * ```
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * Registers a function called when the control value changes.
     *
     * @hidden
     * @internal
     */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /**
     * Registers a function called when the control is touched.
     *
     * @hidden
     * @internal
     */
    registerOnTouched(fn) {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.registerOnTouched(fn);
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     * @internal
     */
    _initRadioButtons() {
        if (this.radioButtons) {
            const props = { name: this._name, labelPosition: this._labelPosition, disabled: this._disabled, required: this._required };
            this.radioButtons.forEach((button) => {
                Object.assign(button, props);
                if (button.value === this._value) {
                    button.checked = true;
                    this._selected = button;
                }
                button.change.pipe(takeUntil(this.destroy$)).subscribe((ev) => this._selectedRadioButtonChanged(ev));
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _selectedRadioButtonChanged(args) {
        if (this._selected !== args.radio) {
            if (this._selected) {
                this._selected.checked = false;
            }
            this._selected = args.radio;
        }
        this._value = args.value;
        if (this._isInitialized) {
            this.change.emit(args);
            this._onChangeCallback(this.value);
        }
    }
    /**
     * @hidden
     * @internal
     */
    _setRadioButtonNames() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.name = this._name;
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _selectRadioButton() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                if (!this._value) {
                    // no value - uncheck all radio buttons
                    if (button.checked) {
                        button.checked = false;
                    }
                }
                else {
                    if (this._value === button.value) {
                        // selected button
                        if (this._selected !== button) {
                            this._selected = button;
                        }
                        if (!button.checked) {
                            button.select();
                        }
                    }
                    else {
                        // non-selected button
                        if (button.checked) {
                            button.checked = false;
                        }
                    }
                }
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _setRadioButtonLabelPosition() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.labelPosition = this._labelPosition;
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _disableRadioButtons() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.disabled = this._disabled;
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _setRadioButtonsRequired() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.required = this._required;
            });
        }
    }
}
IgxRadioGroupDirective.ɵfac = function IgxRadioGroupDirective_Factory(t) { return new (t || IgxRadioGroupDirective)(); };
IgxRadioGroupDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRadioGroupDirective, selectors: [["igx-radio-group"], ["", "igxRadioGroup", ""]], contentQueries: function IgxRadioGroupDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRadioComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.radioButtons = _t);
    } }, hostVars: 2, hostBindings: function IgxRadioGroupDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-radio-group", ctx.cssClass);
    } }, inputs: { value: "value", name: "name", required: "required", disabled: "disabled", labelPosition: "labelPosition", selected: "selected" }, outputs: { change: "change" }, exportAs: ["igxRadioGroup"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxRadioGroupDirective, multi: true }])] });
IgxRadioGroupDirective.propDecorators = {
    radioButtons: [{ type: ContentChildren, args: [IgxRadioComponent, { descendants: true },] }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    required: [{ type: Input }],
    disabled: [{ type: Input }],
    labelPosition: [{ type: Input }],
    selected: [{ type: Input }],
    change: [{ type: Output }],
    cssClass: [{ type: HostBinding, args: ['class.igx-radio-group',] }]
};
/**
 * @hidden
 */
class IgxRadioModule {
}
IgxRadioModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxRadioModule });
IgxRadioModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxRadioModule_Factory(t) { return new (t || IgxRadioModule)(); }, imports: [[IgxRippleModule]] });

class IgxTextHighlightDirective {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this._div = null;
        this._observer = null;
        this._nodeWasRemoved = false;
        this._forceEvaluation = false;
        this._activeElementIndex = -1;
        this._defaultCssClass = 'igx-highlight';
        this._defaultActiveCssClass = 'igx-highlight--active';
        /**
         * Identifies the highlight within a unique group.
         * This allows it to have several different highlight groups,
         * with each of them having their own active highlight.
         *
         * ```html
         * <div
         *   igxTextHighlight
         *   [groupName]="myGroupName">
         * </div>
         * ```
         */
        this.groupName = '';
        this._value = '';
        this.destroy$ = new Subject();
        IgxTextHighlightDirective.onActiveElementChanged.pipe(takeUntil(this.destroy$)).subscribe((groupName) => {
            if (this.groupName === groupName) {
                if (this._activeElementIndex !== -1) {
                    this.deactivate();
                }
                this.activateIfNecessary();
            }
        });
    }
    /**
     * The underlying value of the element that will be highlighted.
     *
     * ```typescript
     * // get
     * const elementValue = this.textHighlight.value;
     * ```
     *
     * ```html
     * <!--set-->
     * <div
     *   igxTextHighlight
     *   [value]="newValue">
     * </div>
     * ```
     */
    get value() {
        return this._value;
    }
    set value(value) {
        if (value === undefined || value === null) {
            this._value = '';
        }
        else {
            this._value = value;
        }
    }
    /**
     * @hidden
     */
    get lastSearchInfo() {
        return this._lastSearchInfo;
    }
    /**
     * Activates the highlight at a given index.
     * (if such index exists)
     */
    static setActiveHighlight(groupName, highlight) {
        IgxTextHighlightDirective.highlightGroupsMap.set(groupName, highlight);
        IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);
    }
    /**
     * Clears any existing highlight.
     */
    static clearActiveHighlight(groupName) {
        IgxTextHighlightDirective.highlightGroupsMap.set(groupName, {
            index: -1
        });
        IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.clearHighlight();
        if (this._observer !== null) {
            this._observer.disconnect();
        }
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (changes.value && !changes.value.firstChange) {
            this._valueChanged = true;
        }
        else if ((changes.row !== undefined && !changes.row.firstChange) ||
            (changes.column !== undefined && !changes.column.firstChange) ||
            (changes.page !== undefined && !changes.page.firstChange)) {
            if (this._activeElementIndex !== -1) {
                this.deactivate();
            }
            this.activateIfNecessary();
        }
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.parentElement = this.renderer.parentNode(this.element.nativeElement);
        if (IgxTextHighlightDirective.highlightGroupsMap.has(this.groupName) === false) {
            IgxTextHighlightDirective.highlightGroupsMap.set(this.groupName, {
                index: -1
            });
        }
        this._lastSearchInfo = {
            searchedText: '',
            content: this.value,
            matchCount: 0,
            caseSensitive: false,
            exactMatch: false
        };
        this._container = this.parentElement.firstElementChild;
    }
    /**
     * @hidden
     */
    ngAfterViewChecked() {
        if (this._valueChanged) {
            this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
            this.activateIfNecessary();
            this._valueChanged = false;
        }
    }
    /**
     * Clears the existing highlight and highlights the searched text.
     * Returns how many times the element contains the searched text.
     */
    highlight(text, caseSensitive, exactMatch) {
        const caseSensitiveResolved = caseSensitive ? true : false;
        const exactMatchResolved = exactMatch ? true : false;
        if (this.searchNeedsEvaluation(text, caseSensitiveResolved, exactMatchResolved)) {
            this._lastSearchInfo.searchedText = text;
            this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
            this._lastSearchInfo.exactMatch = exactMatchResolved;
            this._lastSearchInfo.content = this.value;
            if (text === '' || text === undefined || text === null) {
                this.clearHighlight();
            }
            else {
                this.clearChildElements(true);
                this._lastSearchInfo.matchCount = this.getHighlightedText(text, caseSensitive, exactMatch);
            }
        }
        else if (this._nodeWasRemoved) {
            this._lastSearchInfo.searchedText = text;
            this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
            this._lastSearchInfo.exactMatch = exactMatchResolved;
        }
        return this._lastSearchInfo.matchCount;
    }
    /**
     * Clears any existing highlight.
     */
    clearHighlight() {
        this.clearChildElements(false);
        this._lastSearchInfo.searchedText = '';
        this._lastSearchInfo.matchCount = 0;
    }
    /**
     * Activates the highlight if it is on the currently active row and column.
     */
    activateIfNecessary() {
        const group = IgxTextHighlightDirective.highlightGroupsMap.get(this.groupName);
        if (group.column === this.column && group.row === this.row && compareMaps(this.metadata, group.metadata)) {
            this.activate(group.index);
        }
    }
    /**
     * Attaches a MutationObserver to the parentElement and watches for when the container element is removed/readded to the DOM.
     * Should be used only when necessary as using many observers may lead to performance degradation.
     */
    observe() {
        if (this._observer === null) {
            const callback = (mutationList) => {
                mutationList.forEach((mutation) => {
                    const removedNodes = Array.from(mutation.removedNodes);
                    removedNodes.forEach((n) => {
                        if (n === this._container) {
                            this._nodeWasRemoved = true;
                            this.clearChildElements(false);
                        }
                    });
                    const addedNodes = Array.from(mutation.addedNodes);
                    addedNodes.forEach((n) => {
                        if (n === this.parentElement.firstElementChild && this._nodeWasRemoved) {
                            this._container = this.parentElement.firstElementChild;
                            this._nodeWasRemoved = false;
                            this._forceEvaluation = true;
                            this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
                            this._forceEvaluation = false;
                            this.activateIfNecessary();
                            this._observer.disconnect();
                            this._observer = null;
                        }
                    });
                });
            };
            this._observer = new MutationObserver(callback);
            this._observer.observe(this.parentElement, { childList: true });
        }
    }
    activate(index) {
        this.deactivate();
        if (this._div !== null) {
            const spans = this._div.querySelectorAll('span');
            this._activeElementIndex = index;
            if (spans.length <= index) {
                return;
            }
            const elementToActivate = spans[index];
            this.renderer.addClass(elementToActivate, this._defaultActiveCssClass);
            this.renderer.addClass(elementToActivate, this.activeCssClass);
        }
    }
    deactivate() {
        if (this._activeElementIndex === -1) {
            return;
        }
        const spans = this._div.querySelectorAll('span');
        if (spans.length <= this._activeElementIndex) {
            this._activeElementIndex = -1;
            return;
        }
        const elementToDeactivate = spans[this._activeElementIndex];
        this.renderer.removeClass(elementToDeactivate, this._defaultActiveCssClass);
        this.renderer.removeClass(elementToDeactivate, this.activeCssClass);
        this._activeElementIndex = -1;
    }
    clearChildElements(originalContentHidden) {
        this.renderer.setProperty(this.element.nativeElement, 'hidden', originalContentHidden);
        if (this._div !== null) {
            this.renderer.removeChild(this.parentElement, this._div);
            this._div = null;
            this._activeElementIndex = -1;
        }
    }
    getHighlightedText(searchText, caseSensitive, exactMatch) {
        this.appendDiv();
        const stringValue = String(this.value);
        const contentStringResolved = !caseSensitive ? stringValue.toLowerCase() : stringValue;
        const searchTextResolved = !caseSensitive ? searchText.toLowerCase() : searchText;
        let matchCount = 0;
        if (exactMatch) {
            if (contentStringResolved === searchTextResolved) {
                // tslint:disable-next-line:max-line-length
                this.appendSpan(`<span class="${this._defaultCssClass} ${this.cssClass ? this.cssClass : ''}">${stringValue}</span>`);
                matchCount++;
            }
            else {
                this.appendText(stringValue);
            }
        }
        else {
            let foundIndex = contentStringResolved.indexOf(searchTextResolved, 0);
            let previousMatchEnd = 0;
            while (foundIndex !== -1) {
                const start = foundIndex;
                const end = foundIndex + searchTextResolved.length;
                this.appendText(stringValue.substring(previousMatchEnd, start));
                // tslint:disable-next-line:max-line-length
                this.appendSpan(`<span class="${this._defaultCssClass} ${this.cssClass ? this.cssClass : ''}">${stringValue.substring(start, end)}</span>`);
                previousMatchEnd = end;
                matchCount++;
                foundIndex = contentStringResolved.indexOf(searchTextResolved, end);
            }
            this.appendText(stringValue.substring(previousMatchEnd, stringValue.length));
        }
        return matchCount;
    }
    appendText(text) {
        const textElement = this.renderer.createText(text);
        this.renderer.appendChild(this._div, textElement);
    }
    appendSpan(outerHTML) {
        const span = this.renderer.createElement('span');
        this.renderer.appendChild(this._div, span);
        this.renderer.setProperty(span, 'outerHTML', outerHTML);
    }
    appendDiv() {
        this._div = this.renderer.createElement('div');
        if (this.containerClass) {
            this.renderer.addClass(this._div, this.containerClass);
        }
        this.renderer.appendChild(this.parentElement, this._div);
    }
    searchNeedsEvaluation(text, caseSensitive, exactMatch) {
        const searchedText = this._lastSearchInfo.searchedText;
        return !this._nodeWasRemoved &&
            (searchedText === null ||
                searchedText !== text ||
                this._lastSearchInfo.content !== this.value ||
                this._lastSearchInfo.caseSensitive !== caseSensitive ||
                this._lastSearchInfo.exactMatch !== exactMatch ||
                this._forceEvaluation);
    }
}
IgxTextHighlightDirective.ɵfac = function IgxTextHighlightDirective_Factory(t) { return new (t || IgxTextHighlightDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IgxTextHighlightDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTextHighlightDirective, selectors: [["", "igxTextHighlight", ""]], inputs: { groupName: "groupName", value: "value", cssClass: "cssClass", activeCssClass: "activeCssClass", containerClass: "containerClass", row: "row", column: "column", metadata: "metadata" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
IgxTextHighlightDirective.onActiveElementChanged = new EventEmitter();
IgxTextHighlightDirective.highlightGroupsMap = new Map();
IgxTextHighlightDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
IgxTextHighlightDirective.propDecorators = {
    cssClass: [{ type: Input, args: ['cssClass',] }],
    activeCssClass: [{ type: Input, args: ['activeCssClass',] }],
    containerClass: [{ type: Input, args: ['containerClass',] }],
    groupName: [{ type: Input, args: ['groupName',] }],
    value: [{ type: Input, args: ['value',] }],
    row: [{ type: Input, args: ['row',] }],
    column: [{ type: Input, args: ['column',] }],
    metadata: [{ type: Input }]
};
/**
 * @hidden
 */
class IgxTextHighlightModule {
}
IgxTextHighlightModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTextHighlightModule });
IgxTextHighlightModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTextHighlightModule_Factory(t) { return new (t || IgxTextHighlightModule)(); } });

class IgxTextSelectionDirective {
    constructor(element) {
        this.element = element;
        this.selectionState = true;
    }
    /**
     * Returns whether the input element is selectable through the directive.
     *
     * ```typescript
     * // get
     * @ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public firstName: IgxTextSelectionDirective;
     *
     * public getFirstNameSelectionStatus() {
     *  return this.firstName.selected;
     * }
     * ```
     */
    get selected() {
        return this.selectionState;
    }
    /**
     *  Determines whether the input element could be selected through the directive.
     *
     * ```html
     * <!--set-->
     * <input
     *   type="text"
     *   id="firstName"
     *   [igxTextSelection]="true">
     * </input>
     *
     * <input
     *   type="text"
     *   id="lastName"
     *   igxTextSelection
     *   [selected]="true">
     * </input>
     * ```
     */
    set selected(val) {
        this.selectionState = val;
    }
    /**
     * Returns the nativeElement of the element where the directive was applied.
     *
     * ```html
     * <input
     *   type="text"
     *   id="firstName"
     *   igxTextSelection>
     * </input>
     * ```
     *
     * ```typescript
     * @ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public inputElement: IgxTextSelectionDirective;
     *
     * public getNativeElement() {
     *  return this.inputElement.nativeElement;
     * }
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     */
    onFocus() {
        this.trigger();
    }
    /**
     * Triggers the selection of the element if it is marked as selectable.
     *
     * ```html
     * <input
     *   type="text"
     *   id="firstName"
     *   igxTextSelection>
     * </input>
     * ```
     *
     * ```typescript
     * @ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public inputElement: IgxTextSelectionDirective;
     *
     * public triggerElementSelection() {
     *  this.inputElement.trigger();
     * }
     * ```
     */
    trigger() {
        if (this.selected && this.nativeElement.value.length) {
            requestAnimationFrame(() => this.nativeElement.setSelectionRange(0, this.nativeElement.value.length));
        }
    }
}
IgxTextSelectionDirective.ɵfac = function IgxTextSelectionDirective_Factory(t) { return new (t || IgxTextSelectionDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxTextSelectionDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTextSelectionDirective, selectors: [["", "igxTextSelection", ""]], hostBindings: function IgxTextSelectionDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function IgxTextSelectionDirective_focus_HostBindingHandler() { return ctx.onFocus(); });
    } }, inputs: { selected: ["igxTextSelection", "selected"] }, exportAs: ["igxTextSelection"] });
IgxTextSelectionDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxTextSelectionDirective.propDecorators = {
    selected: [{ type: Input, args: ['igxTextSelection',] }],
    onFocus: [{ type: HostListener, args: ['focus',] }]
};
/**
 * @hidden
 */
class IgxTextSelectionModule {
}
IgxTextSelectionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTextSelectionModule });
IgxTextSelectionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTextSelectionModule_Factory(t) { return new (t || IgxTextSelectionModule)(); } });

/**
 * **Ignite UI for Angular Tooltip Target** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip)
 *
 * The Ignite UI for Angular Tooltip Target directive is used to mark an HTML element in the markup as one that has a tooltip.
 * The tooltip target is used in combination with the Ignite UI for Angular Tooltip by assigning the exported tooltip reference to the
 * target's selector property.
 *
 * Example:
 * ```html
 * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
 * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
 * ```
 */
class IgxTooltipTargetDirective extends IgxToggleActionDirective {
    constructor(_element, _navigationService) {
        super(_element, _navigationService);
        this._element = _element;
        this._navigationService = _navigationService;
        this.destroy$ = new Subject();
        /**
         * Gets/sets the amount of milliseconds that should pass before showing the tooltip.
         *
         * ```typescript
         * // get
         * let tooltipShowDelay = this.tooltipTarget.showDelay;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" showDelay="1500">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.showDelay = 500;
        /**
         * Gets/sets the amount of milliseconds that should pass before hiding the tooltip.
         *
         * ```typescript
         * // get
         * let tooltipHideDelay = this.tooltipTarget.hideDelay;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" hideDelay="1500">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.hideDelay = 500;
        /**
         * Specifies if the tooltip should not show when hovering its target with the mouse. (defaults to false)
         * While setting this property to 'true' will disable the user interactions that shows/hides the tooltip,
         * the developer will still be able to show/hide the tooltip through the API.
         *
         * ```typescript
         * // get
         * let tooltipDisabledValue = this.tooltipTarget.tooltipDisabled;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" [tooltipDisabled]="true">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.tooltipDisabled = false;
        /**
         * Emits an event when the tooltip that is associated with this target starts showing.
         * This event is fired before the start of the countdown to showing the tooltip.
         *
         * ```typescript
         * tooltipShowing(args: ITooltipShowEventArgs) {
         *    alert("Tooltip started showing!");
         * }
         * ```
         *
         * ```html
         * <button [igxTooltipTarget]="tooltipRef"
         *         (onTooltipShow)='tooltipShowing($event)'>Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.onTooltipShow = new EventEmitter();
        /**
         * Emits an event when the tooltip that is associated with this target starts hiding.
         * This event is fired before the start of the countdown to hiding the tooltip.
         *
         * ```typescript
         * tooltipHiding(args: ITooltipHideEventArgs) {
         *    alert("Tooltip started hiding!");
         * }
         * ```
         *
         * ```html
         * <button [igxTooltipTarget]="tooltipRef"
         *         (onTooltipHide)='tooltipHiding($event)'>Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.onTooltipHide = new EventEmitter();
    }
    /**
     * @hidden
     */
    set target(target) {
        if (target !== null && target !== '') {
            this._target = target;
        }
    }
    /**
     * @hidden
     */
    get target() {
        if (typeof this._target === 'string') {
            return this._navigationService.get(this._target);
        }
        return this._target;
    }
    /**
     * Gets the respective native element of the directive.
     *
     * ```typescript
     * let tooltipTargetElement = this.tooltipTarget.nativeElement;
     * ```
     */
    get nativeElement() {
        return this._element.nativeElement;
    }
    /**
     * Indicates if the tooltip that is is associated with this target is currently hidden.
     *
     * ```typescript
     * let tooltipHiddenValue = this.tooltipTarget.tooltipHidden;
     * ```
     */
    get tooltipHidden() {
        return !this.target || this.target.collapsed;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        const positionSettings = {
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            openAnimation: useAnimation(scaleInCenter, { params: { duration: '150ms' } }),
            closeAnimation: useAnimation(fadeOut, { params: { duration: '75ms' } })
        };
        this._overlayDefaults.positionStrategy = new AutoPositionStrategy(positionSettings);
        this._overlayDefaults.closeOnOutsideClick = false;
        this._overlayDefaults.closeOnEscape = true;
        this.target.onClosing.pipe(takeUntil(this.destroy$)).subscribe((event) => {
            const hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                event.cancel = true;
            }
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    checkOutletAndOutsideClick() {
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
    }
    get mergedOverlaySettings() {
        return Object.assign({}, this._overlayDefaults, this.overlaySettings);
    }
    // Return true if the execution in onMouseEnter should be terminated after this method
    preMouseEnterCheck() {
        // If tooltip is about to be opened
        if (this.target.toBeShown) {
            clearTimeout(this.target.timeoutId);
            this.target.toBeShown = false;
        }
        // If Tooltip is opened or about to be hidden
        if (!this.target.collapsed || this.target.toBeHidden) {
            clearTimeout(this.target.timeoutId);
            //  if close animation has started finish it, or close the tooltip with no animation
            this.target.forceClose(this.mergedOverlaySettings);
            this.target.toBeHidden = false;
        }
        return false;
    }
    // Return true if the execution in onMouseLeave should be terminated after this method
    preMouseLeaveCheck() {
        clearTimeout(this.target.timeoutId);
        // If tooltip is about to be opened
        if (this.target.toBeShown) {
            this.target.toBeShown = false;
            this.target.toBeHidden = false;
            return true;
        }
        return false;
    }
    /**
     * @hidden
     */
    onClick() {
        if (!this.target.collapsed) {
            this.target.forceClose(this.mergedOverlaySettings);
        }
    }
    /**
     * @hidden
     */
    onMouseEnter() {
        if (this.tooltipDisabled) {
            return;
        }
        this.checkOutletAndOutsideClick();
        const shouldReturn = this.preMouseEnterCheck();
        if (shouldReturn) {
            return;
        }
        const showingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipShow.emit(showingArgs);
        if (showingArgs.cancel) {
            return;
        }
        this.target.toBeShown = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.open(this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
            this.target.toBeShown = false;
        }, this.showDelay);
    }
    /**
     * @hidden
     */
    onMouseLeave() {
        if (this.tooltipDisabled) {
            return;
        }
        this.checkOutletAndOutsideClick();
        const shouldReturn = this.preMouseLeaveCheck();
        if (shouldReturn || this.target.collapsed) {
            return;
        }
        this.target.toBeHidden = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.close(); // Call close() of IgxTooltipDirective
            this.target.toBeHidden = false;
        }, this.hideDelay);
    }
    /**
     * @hidden
     */
    onTouchStart(event) {
        if (this.tooltipDisabled) {
            return;
        }
        this.showTooltip();
    }
    /**
     * @hidden
     */
    onDocumentTouchStart(event) {
        if (this.tooltipDisabled) {
            return;
        }
        if (this.nativeElement !== event.target &&
            !this.nativeElement.contains(event.target)) {
            this.hideTooltip();
        }
    }
    /**
     * Shows the tooltip by respecting the 'showDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.showTooltip();
     * ```
     */
    showTooltip() {
        clearTimeout(this.target.timeoutId);
        if (!this.target.collapsed) {
            //  if close animation has started finish it, or close the tooltip with no animation
            this.target.forceClose(this.mergedOverlaySettings);
            this.target.toBeHidden = false;
        }
        const showingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipShow.emit(showingArgs);
        if (showingArgs.cancel) {
            return;
        }
        this.target.toBeShown = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.open(this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
            this.target.toBeShown = false;
        }, this.showDelay);
    }
    /**
     * Hides the tooltip by respecting the 'hideDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.hideTooltip();
     * ```
     */
    hideTooltip() {
        if (this.target.collapsed && this.target.toBeShown) {
            clearTimeout(this.target.timeoutId);
        }
        if (this.target.collapsed || this.target.toBeHidden) {
            return;
        }
        this.target.toBeHidden = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.close(); // Call close() of IgxTooltipDirective
            this.target.toBeHidden = false;
        }, this.hideDelay);
    }
}
IgxTooltipTargetDirective.ɵfac = function IgxTooltipTargetDirective_Factory(t) { return new (t || IgxTooltipTargetDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8)); };
IgxTooltipTargetDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTooltipTargetDirective, selectors: [["", "igxTooltipTarget", ""]], hostBindings: function IgxTooltipTargetDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxTooltipTargetDirective_click_HostBindingHandler() { return ctx.onClick(); })("mouseenter", function IgxTooltipTargetDirective_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function IgxTooltipTargetDirective_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); })("touchstart", function IgxTooltipTargetDirective_touchstart_HostBindingHandler($event) { return ctx.onTouchStart($event); })("touchstart", function IgxTooltipTargetDirective_touchstart_HostBindingHandler($event) { return ctx.onDocumentTouchStart($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { showDelay: "showDelay", hideDelay: "hideDelay", tooltipDisabled: "tooltipDisabled", target: ["igxTooltipTarget", "target"] }, outputs: { onTooltipShow: "onTooltipShow", onTooltipHide: "onTooltipHide" }, exportAs: ["tooltipTarget"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxTooltipTargetDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
IgxTooltipTargetDirective.propDecorators = {
    showDelay: [{ type: Input, args: ['showDelay',] }],
    hideDelay: [{ type: Input, args: ['hideDelay',] }],
    tooltipDisabled: [{ type: Input, args: ['tooltipDisabled',] }],
    target: [{ type: Input, args: ['igxTooltipTarget',] }],
    onTooltipShow: [{ type: Output }],
    onTooltipHide: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }],
    onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }],
    onTouchStart: [{ type: HostListener, args: ['touchstart', ['$event'],] }],
    onDocumentTouchStart: [{ type: HostListener, args: ['document:touchstart', ['$event'],] }]
};
let NEXT_ID$6 = 0;
/**
 * **Ignite UI for Angular Tooltip** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip)
 *
 * The Ignite UI for Angular Tooltip directive is used to mark an HTML element in the markup as one that should behave as a tooltip.
 * The tooltip is used in combination with the Ignite UI for Angular Tooltip Target by assigning the exported tooltip reference to the
 * respective target's selector property.
 *
 * Example:
 * ```html
 * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
 * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
 * ```
 */
class IgxTooltipDirective extends IgxToggleDirective {
    /** @hidden */
    constructor(elementRef, cdr, overlayService, navigationService) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        super(elementRef, cdr, overlayService, navigationService);
        /**
         * @hidden
         * Returns whether close time out has started
         */
        this.toBeHidden = false;
        /**
         * @hidden
         * Returns whether open time out has started
         */
        this.toBeShown = false;
        /**
         * Identifier for the tooltip.
         * If this is property is not explicitly set, it will be automatically generated.
         *
         * ```typescript
         * let tooltipId = this.tooltip.id;
         * ```
         */
        this.id = `igx-tooltip-${NEXT_ID$6++}`;
    }
    /**
     * @hidden
     */
    get hiddenClass() {
        return this.collapsed;
    }
    /**
     * @hidden
     */
    get defaultClass() {
        return !this.collapsed;
    }
    /**
     * Get the role attribute of the tooltip.
     *
     * ```typescript
     * let tooltipRole = this.tooltip.role;
     * ```
     */
    get role() {
        return 'tooltip';
    }
    /**
     * If there is open animation in progress this method will finish is.
     * If there is no open animation in progress this method will open the toggle with no animation.
     * @param overlaySettings setting to use for opening the toggle
     */
    forceOpen(overlaySettings) {
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasOpenAnimation = info ? info.openAnimationPlayer : false;
        if (hasOpenAnimation) {
            info.openAnimationPlayer.finish();
            info.openAnimationPlayer.reset();
            info.openAnimationPlayer = null;
        }
        else if (this.collapsed) {
            const animation = overlaySettings.positionStrategy.settings.openAnimation;
            overlaySettings.positionStrategy.settings.openAnimation = null;
            this.open(overlaySettings);
            overlaySettings.positionStrategy.settings.openAnimation = animation;
        }
    }
    /**
     * If there is close animation in progress this method will finish is.
     * If there is no close animation in progress this method will close the toggle with no animation.
     * @param overlaySettings settings to use for closing the toggle
     */
    forceClose(overlaySettings) {
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (hasCloseAnimation) {
            info.closeAnimationPlayer.finish();
            info.closeAnimationPlayer.reset();
            info.closeAnimationPlayer = null;
        }
        else if (!this.collapsed) {
            const animation = overlaySettings.positionStrategy.settings.closeAnimation;
            overlaySettings.positionStrategy.settings.closeAnimation = null;
            this.close();
            overlaySettings.positionStrategy.settings.closeAnimation = animation;
        }
    }
}
IgxTooltipDirective.ɵfac = function IgxTooltipDirective_Factory(t) { return new (t || IgxTooltipDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxOverlayService), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8)); };
IgxTooltipDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTooltipDirective, selectors: [["", "igxTooltip", ""]], hostVars: 6, hostBindings: function IgxTooltipDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-tooltip--hidden", ctx.hiddenClass)("igx-tooltip--desktop", ctx.defaultClass);
    } }, inputs: { id: "id", context: "context" }, exportAs: ["tooltip"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxTooltipDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
IgxTooltipDirective.propDecorators = {
    hiddenClass: [{ type: HostBinding, args: ['class.igx-tooltip--hidden',] }],
    defaultClass: [{ type: HostBinding, args: ['class.igx-tooltip--desktop',] }],
    context: [{ type: Input, args: ['context',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }]
};
/**
 * @hidden
 */
class IgxTooltipModule {
}
IgxTooltipModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTooltipModule });
IgxTooltipModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTooltipModule_Factory(t) { return new (t || IgxTooltipModule)(); }, providers: [IgxOverlayService], imports: [[CommonModule]] });

/**
 * Specify a particular date, time or AmPm part.
 */
var DatePart;
(function (DatePart) {
    DatePart["Date"] = "date";
    DatePart["Month"] = "month";
    DatePart["Year"] = "year";
    DatePart["Hours"] = "hour";
    DatePart["Minutes"] = "minute";
    DatePart["Seconds"] = "second";
    DatePart["AmPm"] = "ampm";
    DatePart["Literal"] = "literal";
})(DatePart || (DatePart = {}));

const DATE_CHARS = ['h', 'H', 'm', 's', 'S', 't', 'T'];
const TIME_CHARS = ['d', 'D', 'M', 'y', 'Y'];
/** @hidden */
class DatePickerUtil {
    /**
     *  TODO: (in issue #6483) Unit tests and docs for all public methods.
     */
    /**
     * Parse a Date value from masked string input based on determined date parts
     * @param inputData masked value to parse
     * @param dateTimeParts Date parts array for the mask
     */
    static parseValueFromMask(inputData, dateTimeParts, promptChar) {
        const parts = {};
        dateTimeParts.forEach(dp => {
            let value = parseInt(this.getCleanVal(inputData, dp, promptChar), 10);
            if (!value) {
                value = dp.type === DatePart.Date || dp.type === DatePart.Month ? 1 : 0;
            }
            parts[dp.type] = value;
        });
        parts[DatePart.Month] -= 1;
        if (parts[DatePart.Month] < 0 || 11 < parts[DatePart.Month]) {
            return null;
        }
        // TODO: Century threshold
        if (parts[DatePart.Year] < 50) {
            parts[DatePart.Year] += 2000;
        }
        if (parts[DatePart.Date] > DatePickerUtil.daysInMonth(parts[DatePart.Year], parts[DatePart.Month])) {
            return null;
        }
        if (parts[DatePart.Hours] > 23 || parts[DatePart.Minutes] > 59 || parts[DatePart.Seconds] > 59) {
            return null;
        }
        return new Date(parts[DatePart.Year] || 2000, parts[DatePart.Month] || 0, parts[DatePart.Date] || 1, parts[DatePart.Hours] || 0, parts[DatePart.Minutes] || 0, parts[DatePart.Seconds] || 0);
    }
    /**
     * Parse the mask into date/time and literal parts
     */
    static parseDateTimeFormat(mask, locale = DatePickerUtil.DEFAULT_LOCALE) {
        const format = mask || DatePickerUtil.getDefaultInputFormat(locale);
        const dateTimeParts = [];
        const formatArray = Array.from(format);
        let currentPart = null;
        let position = 0;
        for (let i = 0; i < formatArray.length; i++, position++) {
            const type = DatePickerUtil.determineDatePart(formatArray[i]);
            if (currentPart) {
                if (currentPart.type === type) {
                    currentPart.format += formatArray[i];
                    if (i < formatArray.length - 1) {
                        continue;
                    }
                }
                DatePickerUtil.ensureLeadingZero(currentPart);
                currentPart.end = currentPart.start + currentPart.format.length;
                position = currentPart.end;
                dateTimeParts.push(currentPart);
            }
            currentPart = {
                start: position,
                end: position + formatArray[i].length,
                type: type,
                format: formatArray[i]
            };
        }
        return dateTimeParts;
    }
    static getDefaultInputFormat(locale) {
        if (!Intl || !Intl.DateTimeFormat || !Intl.DateTimeFormat.prototype.formatToParts) {
            // TODO: fallback with Intl.format for IE?
            return DatePickerUtil.SHORT_DATE_MASK;
        }
        const parts = DatePickerUtil.getDefaultLocaleMask(locale);
        parts.forEach(p => {
            if (p.type !== DatePart.Year && p.type !== DatePickerUtil.SEPARATOR) {
                p.formatType = "2-digit" /* TwoDigits */;
            }
        });
        return DatePickerUtil.getMask(parts);
    }
    static formatDate(value, format, locale, timezone) {
        let formattedDate;
        try {
            formattedDate = formatDate(value, format, locale, timezone);
        }
        catch (_a) {
            this.logMissingLocaleSettings(locale);
            const formatter = new Intl.DateTimeFormat(locale);
            formattedDate = formatter.format(value);
        }
        return formattedDate;
    }
    static getLocaleDateFormat(locale, displayFormat) {
        const formatKeys = Object.keys(FormatWidth);
        const targetKey = formatKeys.find(k => k.toLowerCase() === (displayFormat === null || displayFormat === void 0 ? void 0 : displayFormat.toLowerCase().replace('date', '')));
        if (!targetKey) {
            // if displayFormat is not shortDate, longDate, etc.
            // or if it is not set by the user
            return displayFormat;
        }
        let format;
        try {
            format = getLocaleDateFormat(locale, FormatWidth[targetKey]);
        }
        catch (_a) {
            this.logMissingLocaleSettings(locale);
            format = DatePickerUtil.getDefaultInputFormat(locale);
        }
        return format;
    }
    static isDateOrTimeChar(char) {
        return DATE_CHARS.indexOf(char) !== -1 || TIME_CHARS.indexOf(char) !== -1;
    }
    static spinDate(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth());
        let date = newDate.getDate() + delta;
        if (date > maxDate) {
            date = isSpinLoop ? date % maxDate : maxDate;
        }
        else if (date < 1) {
            date = isSpinLoop ? maxDate + (date % maxDate) : 1;
        }
        newDate.setDate(date);
    }
    static spinMonth(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth() + delta);
        if (newDate.getDate() > maxDate) {
            newDate.setDate(maxDate);
        }
        const maxMonth = 11;
        const minMonth = 0;
        let month = newDate.getMonth() + delta;
        if (month > maxMonth) {
            month = isSpinLoop ? (month % maxMonth) - 1 : maxMonth;
        }
        else if (month < minMonth) {
            month = isSpinLoop ? maxMonth + (month % maxMonth) + 1 : minMonth;
        }
        newDate.setMonth(month);
    }
    static spinYear(delta, newDate) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear() + delta, newDate.getMonth());
        if (newDate.getDate() > maxDate) {
            // clip to max to avoid leap year change shifting the entire value
            newDate.setDate(maxDate);
        }
        newDate.setFullYear(newDate.getFullYear() + delta);
    }
    static spinHours(delta, newDate, isSpinLoop) {
        const maxHour = 23;
        const minHour = 0;
        let hours = newDate.getHours() + delta;
        if (hours > maxHour) {
            hours = isSpinLoop ? hours % maxHour - 1 : maxHour;
        }
        else if (hours < minHour) {
            hours = isSpinLoop ? maxHour + (hours % maxHour) + 1 : minHour;
        }
        newDate.setHours(hours);
    }
    static spinMinutes(delta, newDate, isSpinLoop) {
        const maxMinutes = 59;
        const minMinutes = 0;
        let minutes = newDate.getMinutes() + delta;
        if (minutes > maxMinutes) {
            minutes = isSpinLoop ? minutes % maxMinutes - 1 : maxMinutes;
        }
        else if (minutes < minMinutes) {
            minutes = isSpinLoop ? maxMinutes + (minutes % maxMinutes) + 1 : minMinutes;
        }
        newDate.setMinutes(minutes);
    }
    static spinSeconds(delta, newDate, isSpinLoop) {
        const maxSeconds = 59;
        const minSeconds = 0;
        let seconds = newDate.getSeconds() + delta;
        if (seconds > maxSeconds) {
            seconds = isSpinLoop ? seconds % maxSeconds - 1 : maxSeconds;
        }
        else if (seconds < minSeconds) {
            seconds = isSpinLoop ? maxSeconds + (seconds % maxSeconds) + 1 : minSeconds;
        }
        newDate.setSeconds(seconds);
    }
    static spinAmPm(newDate, currentDate, amPmFromMask) {
        switch (amPmFromMask) {
            case 'AM':
                newDate = new Date(newDate.setHours(newDate.getHours() + 12));
                break;
            case 'PM':
                newDate = new Date(newDate.setHours(newDate.getHours() - 12));
                break;
        }
        if (newDate.getDate() !== currentDate.getDate()) {
            return currentDate;
        }
        return newDate;
    }
    /**
     * Determines whether the provided value is greater than the provided max value.
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is greater than provided maxValue
     */
    static greaterThanMaxValue(value, maxValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if maxValue is Invalid Date and value is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() > maxValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _maxValue = new Date(maxValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _maxValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _maxValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() > _maxValue.getTime();
    }
    /**
     * Determines whether the provided value is less than the provided min value.
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is less than provided minValue
     */
    static lessThanMinValue(value, minValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if value is Invalid Date and minValue is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() < minValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _minValue = new Date(minValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _minValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _minValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() < _minValue.getTime();
    }
    static logMissingLocaleSettings(locale) {
        console.warn(`Missing locale data for the locale ${locale}. Please refer to https://angular.io/guide/i18n#i18n-pipes`);
        console.warn('Using default browser locale settings.');
    }
    static ensureLeadingZero(part) {
        switch (part.type) {
            case DatePart.Date:
            case DatePart.Month:
            case DatePart.Hours:
            case DatePart.Minutes:
            case DatePart.Seconds:
                if (part.format.length === 1) {
                    part.format = part.format.repeat(2);
                }
                break;
        }
    }
    static getCleanVal(inputData, datePart, promptChar) {
        return DatePickerUtil.trimEmptyPlaceholders(inputData.substring(datePart.start, datePart.end), promptChar);
    }
    static determineDatePart(char) {
        switch (char) {
            case 'd':
            case 'D':
                return DatePart.Date;
            case 'M':
                return DatePart.Month;
            case 'y':
            case 'Y':
                return DatePart.Year;
            case 'h':
            case 'H':
                return DatePart.Hours;
            case 'm':
                return DatePart.Minutes;
            case 's':
            case 'S':
                return DatePart.Seconds;
            case 't':
            case 'T':
                return DatePart.AmPm;
            default:
                return DatePart.Literal;
        }
    }
    /**
     * This method generates date parts structure based on editor mask and locale.
     * @param maskValue: string
     * @param locale: string
     * @returns array containing information about date parts - type, position, format
     */
    static parseDateFormat(maskValue, locale = DatePickerUtil.DEFAULT_LOCALE) {
        let dateStruct = [];
        if (maskValue === undefined && !isIE()) {
            dateStruct = DatePickerUtil.getDefaultLocaleMask(locale);
        }
        else {
            const mask = (maskValue) ? maskValue : DatePickerUtil.SHORT_DATE_MASK;
            const maskArray = Array.from(mask);
            const monthInitPosition = mask.indexOf("M" /* MonthChar */);
            const dayInitPosition = mask.indexOf("d" /* DayChar */);
            const yearInitPosition = mask.indexOf("y" /* YearChar */);
            if (yearInitPosition !== -1) {
                dateStruct.push({
                    type: "year" /* Year */,
                    initialPosition: yearInitPosition,
                    formatType: DatePickerUtil.getYearFormatType(mask)
                });
            }
            if (monthInitPosition !== -1) {
                dateStruct.push({
                    type: "month" /* Month */,
                    initialPosition: monthInitPosition,
                    formatType: DatePickerUtil.getMonthFormatType(mask)
                });
            }
            if (dayInitPosition !== -1) {
                dateStruct.push({
                    type: "day" /* Day */,
                    initialPosition: dayInitPosition,
                    formatType: DatePickerUtil.getDayFormatType(mask)
                });
            }
            for (let i = 0; i < maskArray.length; i++) {
                if (!DatePickerUtil.isDateChar(maskArray[i])) {
                    dateStruct.push({
                        type: DatePickerUtil.SEPARATOR,
                        initialPosition: i,
                        value: maskArray[i]
                    });
                }
            }
            dateStruct.sort((a, b) => a.initialPosition - b.initialPosition);
            DatePickerUtil.fillDatePartsPositions(dateStruct);
        }
        return dateStruct;
    }
    /**
     * This method generates input mask based on date parts.
     * @param dateStruct array
     * @returns input mask
     */
    static getInputMask(dateStruct) {
        const inputMask = [];
        for (let i = 0; i < dateStruct.length; i++) {
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                inputMask.push(dateStruct[i].value);
            }
            else if (dateStruct[i].type === "day" /* Day */ || dateStruct[i].type === "month" /* Month */) {
                inputMask.push('00');
            }
            else if (dateStruct[i].type === "year" /* Year */) {
                switch (dateStruct[i].formatType) {
                    case "numeric" /* Numeric */: {
                        inputMask.push('0000');
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        inputMask.push('00');
                        break;
                    }
                }
            }
        }
        return inputMask.join('');
    }
    /**
     * This method generates editor mask.
     * @param dateStruct
     * @returns editor mask
     */
    static getMask(dateStruct) {
        const mask = [];
        for (let i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].formatType) {
                case "numeric" /* Numeric */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('d');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('M');
                    }
                    else {
                        mask.push('yyyy');
                    }
                    break;
                }
                case "2-digit" /* TwoDigits */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('dd');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('MM');
                    }
                    else {
                        mask.push('yy');
                    }
                }
            }
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                mask.push(dateStruct[i].value);
            }
        }
        return mask.join('');
    }
    /**
     * This method parses an input string base on date parts and returns a date and its validation state.
     * @param dateFormatParts
     * @param prevDateValue
     * @param inputValue
     * @returns object containing a date and its validation state
     */
    static parseDateArray(dateFormatParts, prevDateValue, inputValue) {
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, inputValue);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue);
        const yearStr = DatePickerUtil.getYearValueFromInput(dateFormatParts, inputValue);
        const yearFormat = DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType;
        const day = (dayStr !== '') ? parseInt(dayStr, 10) : 1;
        const month = (monthStr !== '') ? parseInt(monthStr, 10) - 1 : 0;
        let year;
        if (yearStr === '') {
            year = (yearFormat === "2-digit" /* TwoDigits */) ? '00' : '2000';
        }
        else {
            year = yearStr;
        }
        let yearPrefix;
        if (prevDateValue) {
            const originalYear = prevDateValue.getFullYear().toString();
            if (originalYear.length === 4) {
                yearPrefix = originalYear.substring(0, 2);
            }
        }
        else {
            yearPrefix = '20';
        }
        const fullYear = (yearFormat === "2-digit" /* TwoDigits */) ? yearPrefix.concat(year) : year;
        if ((month < 0) || (month > 11) || (month === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        if ((day < 1) || (day > DatePickerUtil.daysInMonth(fullYear, month)) || (day === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        return { state: "valid" /* Valid */, date: new Date(fullYear, month, day) };
    }
    static maskToPromptChars(mask) {
        const result = mask.replace(/0|L/g, DatePickerUtil.PROMPT_CHAR);
        return result;
    }
    /**
     * This method replaces prompt chars with empty string.
     * @param value
     */
    static trimEmptyPlaceholders(value, promptChar) {
        const result = value.replace(new RegExp(promptChar || '_', 'g'), '');
        return result;
    }
    /**
     * This method is used for spinning date parts.
     * @param dateFormatParts
     * @param inputValue
     * @param position
     * @param delta
     * @param isSpinLoop
     * @return modified text input
     */
    static getModifiedDateInput(dateFormatParts, inputValue, position, delta, isSpinLoop) {
        const datePart = DatePickerUtil.getDatePartOnPosition(dateFormatParts, position);
        const datePartType = datePart.type;
        const datePartFormatType = datePart.formatType;
        let newValue;
        const datePartValue = DatePickerUtil.getDateValueFromInput(dateFormatParts, datePartType, inputValue);
        newValue = parseInt(datePartValue, 10);
        let maxValue, minValue;
        const minMax = DatePickerUtil.getMinMaxValue(dateFormatParts, datePart, inputValue);
        minValue = minMax.min;
        maxValue = minMax.max;
        if (isNaN(newValue)) {
            if (minValue === 'infinite') {
                newValue = 2000;
            }
            else {
                newValue = minValue;
            }
        }
        let tempValue = newValue;
        tempValue += delta;
        // Infinite loop for full years
        if (maxValue === 'infinite' && minValue === 'infinite') {
            newValue = tempValue;
        }
        if (isSpinLoop) {
            if (tempValue > maxValue) {
                tempValue = minValue;
            }
            if (tempValue < minValue) {
                tempValue = maxValue;
            }
            newValue = tempValue;
        }
        else {
            if (tempValue <= maxValue && tempValue >= minValue) {
                newValue = tempValue;
            }
        }
        const startIdx = datePart.position[0];
        const endIdx = datePart.position[1];
        const start = inputValue.slice(0, startIdx);
        const end = inputValue.slice(endIdx, inputValue.length);
        let changedPart;
        const prefix = DatePickerUtil.getNumericFormatPrefix(datePartFormatType);
        changedPart = (newValue < 10) ? `${prefix}${newValue}` : `${newValue}`;
        return `${start}${changedPart}${end}`;
    }
    /**
     * This method returns date input with prompt chars.
     * @param dateFormatParts
     * @param date
     * @param inputValue
     * @returns date input including prompt chars
     */
    static addPromptCharsEditMode(dateFormatParts, date, inputValue) {
        const dateArray = Array.from(inputValue);
        for (let i = 0; i < dateFormatParts.length; i++) {
            if (dateFormatParts[i].formatType === "numeric" /* Numeric */) {
                if ((dateFormatParts[i].type === "day" /* Day */ && date.getDate() < 10)
                    || (dateFormatParts[i].type === "month" /* Month */ && date.getMonth() + 1 < 10)) {
                    dateArray.splice(dateFormatParts[i].position[0], 0, DatePickerUtil.PROMPT_CHAR);
                    dateArray.join('');
                }
            }
        }
        return dateArray.join('');
    }
    /**
     * This method checks if date input is done.
     * @param dateFormatParts
     * @param input
     * @returns input completeness
     */
    static checkForCompleteDateInput(dateFormatParts, input) {
        const dayValue = DatePickerUtil.getDayValueFromInput(dateFormatParts, input);
        const monthValue = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input);
        const yearValue = DatePickerUtil.getYearValueFromInput(dateFormatParts, input);
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, input, false);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input, false);
        if (DatePickerUtil.isFullInput(dayValue, dayStr)
            && DatePickerUtil.isFullInput(monthValue, monthStr)
            && DatePickerUtil.isFullYearInput(dateFormatParts, yearValue)) {
            return 'complete';
        }
        else if (dayValue === '' && monthValue === '' && yearValue === '') {
            return 'empty';
        }
        else if (dayValue === '' || monthValue === '' || yearValue === '') {
            return 'partial';
        }
        return '';
    }
    static daysInMonth(fullYear, month) {
        return new Date(fullYear, month + 1, 0).getDate();
    }
    /**
     * Parse provided input to Date.
     * @param value input to parse
     * @returns Date if parse succeed or null
     */
    static parseDate(value) {
        if (typeof value === 'number') {
            return new Date(value);
        }
        // if value is Invalid Date we should return null
        if (this.isDate(value)) {
            return this.isValidDate(value) ? value : null;
        }
        return value ? new Date(Date.parse(value)) : null;
    }
    /**
     * Returns whether provided input is date
     * @param value input to check
     * @returns true if provided input is date
     */
    static isDate(value) {
        return Object.prototype.toString.call(value) === '[object Date]';
    }
    /**
     * Returns whether the input is valid date
     * @param value input to check
     * @returns true if provided input is a valid date
     */
    static isValidDate(value) {
        if (this.isDate(value)) {
            return !isNaN(value.getTime());
        }
        return false;
    }
    static getYearFormatType(format) {
        switch (format.match(new RegExp("y" /* YearChar */, 'g')).length) {
            case 1: {
                // y (2020)
                return "numeric" /* Numeric */;
            }
            case 4: {
                // yyyy (2020)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // yy (20)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getMonthFormatType(format) {
        switch (format.match(new RegExp("M" /* MonthChar */, 'g')).length) {
            case 1: {
                // M (8)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // MM (08)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDayFormatType(format) {
        switch (format.match(new RegExp("d" /* DayChar */, 'g')).length) {
            case 1: {
                // d (6)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // dd (06)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDefaultLocaleMask(locale) {
        const dateStruct = [];
        const formatter = new Intl.DateTimeFormat(locale);
        const formatToParts = formatter.formatToParts(new Date());
        for (let i = 0; i < formatToParts.length; i++) {
            if (formatToParts[i].type === DatePickerUtil.SEPARATOR) {
                dateStruct.push({
                    type: DatePickerUtil.SEPARATOR,
                    value: formatToParts[i].value
                });
            }
            else {
                dateStruct.push({
                    type: formatToParts[i].type
                });
            }
        }
        const formatterOptions = formatter.resolvedOptions();
        for (let i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].type) {
                case "day" /* Day */: {
                    dateStruct[i].formatType = formatterOptions.day;
                    break;
                }
                case "month" /* Month */: {
                    dateStruct[i].formatType = formatterOptions.month;
                    break;
                }
                case "year" /* Year */: {
                    dateStruct[i].formatType = formatterOptions.year;
                    break;
                }
            }
        }
        DatePickerUtil.fillDatePartsPositions(dateStruct);
        return dateStruct;
    }
    static isDateChar(char) {
        return (char === "y" /* YearChar */ || char === "M" /* MonthChar */ || char === "d" /* DayChar */);
    }
    static getNumericFormatPrefix(formatType) {
        switch (formatType) {
            case "2-digit" /* TwoDigits */: {
                return '0';
            }
            case "numeric" /* Numeric */: {
                return DatePickerUtil.PROMPT_CHAR;
            }
        }
    }
    static getMinMaxValue(dateFormatParts, datePart, inputValue) {
        let maxValue, minValue;
        switch (datePart.type) {
            case "month" /* Month */: {
                minValue = 1;
                maxValue = DatePickerUtil.NUMBER_OF_MONTHS;
                break;
            }
            case "day" /* Day */: {
                minValue = 1;
                maxValue = DatePickerUtil.daysInMonth(DatePickerUtil.getFullYearFromString(DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */), inputValue), parseInt(DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue), 10));
                break;
            }
            case "year" /* Year */: {
                if (datePart.formatType === "2-digit" /* TwoDigits */) {
                    minValue = 0;
                    maxValue = 99;
                }
                else {
                    // Infinite loop
                    minValue = 'infinite';
                    maxValue = 'infinite';
                }
                break;
            }
        }
        return { min: minValue, max: maxValue };
    }
    static getDateValueFromInput(dateFormatParts, type, inputValue, trim = true) {
        const partPosition = DatePickerUtil.getDateFormatPart(dateFormatParts, type).position;
        const result = inputValue.substring(partPosition[0], partPosition[1]);
        return (trim) ? DatePickerUtil.trimEmptyPlaceholders(result) : result;
    }
    static getDayValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "day" /* Day */, inputValue, trim);
    }
    static getMonthValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "month" /* Month */, inputValue, trim);
    }
    static getYearValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "year" /* Year */, inputValue, trim);
    }
    static getDateFormatPart(dateFormatParts, type) {
        const result = dateFormatParts.filter((datePart) => (datePart.type === type))[0];
        return result;
    }
    static isFullInput(value, input) {
        return (value !== '' && input.length === 2 && input.charAt(1) !== DatePickerUtil.PROMPT_CHAR);
    }
    static isFullYearInput(dateFormatParts, value) {
        switch (DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType) {
            case "numeric" /* Numeric */: {
                return (value !== '' && value.length === 4);
            }
            case "2-digit" /* TwoDigits */: {
                return (value !== '' && value.length === 2);
            }
            default: {
                return false;
            }
        }
    }
    static getDatePartOnPosition(dateFormatParts, position) {
        const result = dateFormatParts.filter((element) => element.position[0] <= position && position <= element.position[1] && element.type !== DatePickerUtil.SEPARATOR)[0];
        return result;
    }
    static getFullYearFromString(yearPart, inputValue) {
        return parseInt(inputValue.substring(yearPart.position[0], yearPart.position[1]), 10);
    }
    static fillDatePartsPositions(dateArray) {
        let currentPos = 0;
        for (let i = 0; i < dateArray.length; i++) {
            // Day|Month part positions
            if (dateArray[i].type === "day" /* Day */ || dateArray[i].type === "month" /* Month */) {
                // Offset 2 positions for number
                dateArray[i].position = [currentPos, currentPos + 2];
                currentPos += 2;
            }
            else if (dateArray[i].type === "year" /* Year */) {
                // Year part positions
                switch (dateArray[i].formatType) {
                    case "numeric" /* Numeric */: {
                        // Offset 4 positions for full year
                        dateArray[i].position = [currentPos, currentPos + 4];
                        currentPos += 4;
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        // Offset 2 positions for short year
                        dateArray[i].position = [currentPos, currentPos + 2];
                        currentPos += 2;
                        break;
                    }
                }
            }
            else if (dateArray[i].type === DatePickerUtil.SEPARATOR) {
                // Separator positions
                dateArray[i].position = [currentPos, currentPos + 1];
                currentPos++;
            }
        }
    }
}
DatePickerUtil.DEFAULT_INPUT_FORMAT = 'MM/dd/yyyy';
// TODO: this is the def mask for the date-picker, should remove it during refactoring
DatePickerUtil.SHORT_DATE_MASK = 'MM/dd/yy';
DatePickerUtil.SEPARATOR = 'literal';
DatePickerUtil.NUMBER_OF_MONTHS = 12;
DatePickerUtil.PROMPT_CHAR = '_';
DatePickerUtil.DEFAULT_LOCALE = 'en';

/**
 * Date Time Editor provides a functionality to input, edit and format date and time.
 *
 * @igxModule IgxDateTimeEditorModule
 *
 * @igxParent IgxInputGroup
 *
 * @igxTheme igx-input-theme
 *
 * @igxKeywords date, time, editor
 *
 * @igxGroup Scheduling
 *
 * @remarks
 *
 * The Ignite UI Date Time Editor Directive makes it easy for developers to manipulate date/time user input.
 * It requires input in a specified or default input format which is visible in the input element as a placeholder.
 * It allows the input of only date (ex: 'dd/MM/yyyy'), only time (ex:'HH:mm tt') or both at once, if needed.
 * Supports display format that may differ from the input format.
 * Provides methods to increment and decrement any specific/targeted `DatePart`.
 *
 * @example
 * ```html
 * <igx-input-group>
 *   <input type="text" igxInput [igxDateTimeEditor]="'dd/MM/yyyy'" [displayFormat]="'shortDate'" [(ngModel)]="date"/>
 * </igx-input-group>
 * ```
 */
class IgxDateTimeEditorDirective extends IgxMaskDirective {
    constructor(renderer, elementRef, maskParser, _document, _locale) {
        super(elementRef, maskParser, renderer);
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.maskParser = maskParser;
        this._document = _document;
        this._locale = _locale;
        /**
         * Specify if the currently spun date segment should loop over.
         * @example
         * ```html
         * <input igxDateTimeEditor [isSpinLoop]="false">
         * ```
         */
        this.isSpinLoop = true;
        /**
         * Emitted when the editor's value has changed.
         * @example
         * ```html
         * <input igxDateTimeEditor (valueChange)="onValueChanged($event)"/>
         * ```
         */
        this.valueChange = new EventEmitter();
        /**
         * Emitted when the editor is not within a specified range or when the editor's value is in an invalid state.
         * @example
         * ```html
         * <input igxDateTimeEditor [minValue]="minDate" [maxValue]="maxDate" (validationFailed)="onValidationFailed($event)"/>
         * ```
         */
        this.validationFailed = new EventEmitter();
        this.onTouchCallback = (...args) => { };
        this.onChangeCallback = (...args) => { };
        this.onValidatorChange = (...args) => { };
        this.document = this._document;
        this.locale = this.locale || this._locale;
    }
    /**
     * Minimum value required for the editor to remain valid.
     *
     * @remarks
     * If a `string` value is passed, it must be in the defined input format.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [minValue]="minDate">
     * ```
     */
    get minValue() {
        return this._minValue;
    }
    set minValue(value) {
        this._minValue = value;
        this.onValidatorChange();
    }
    /**
     * Maximum value required for the editor to remain valid.
     *
     * @remarks
     * If a `string` value is passed in, it must be in the defined input format.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [maxValue]="maxDate">
     * ```
     */
    get maxValue() {
        return this._maxValue;
    }
    set maxValue(value) {
        this._maxValue = value;
        this.onValidatorChange();
    }
    /**
     * Expected user input format (and placeholder).
     * @example
     * ```html
     * <input [igxDateTimeEditor]="'dd/MM/yyyy'">
     * ```
     */
    set inputFormat(value) {
        if (value) {
            this._format = value;
        }
        const mask = (this.inputFormat || DatePickerUtil.DEFAULT_INPUT_FORMAT)
            .replace(new RegExp(/(?=[^t])[\w]/, 'g'), '0');
        this.mask = mask.indexOf('tt') !== -1 ? mask.replace(new RegExp('tt', 'g'), 'LL') : mask;
    }
    get inputFormat() {
        return this._format;
    }
    /**
     * Editor value.
     * @example
     * ```html
     * <input igxDateTimeEditor [value]="date">
     * ```
     */
    set value(value) {
        this._value = value;
        this.onChangeCallback(value);
        this.updateMask();
    }
    get value() {
        return this._value;
    }
    get emptyMask() {
        return this.maskParser.applyMask(null, this.maskOptions);
    }
    get targetDatePart() {
        var _a;
        if (this.document.activeElement === this.nativeElement) {
            return (_a = this._inputDateParts
                .find(p => p.start <= this.selectionStart && this.selectionStart <= p.end && p.type !== DatePart.Literal)) === null || _a === void 0 ? void 0 : _a.type;
        }
        else {
            if (this._inputDateParts.some(p => p.type === DatePart.Date)) {
                return DatePart.Date;
            }
            else if (this._inputDateParts.some(p => p.type === DatePart.Hours)) {
                return DatePart.Hours;
            }
        }
    }
    get hasDateParts() {
        return this._inputDateParts.some(p => p.type === DatePart.Date
            || p.type === DatePart.Month
            || p.type === DatePart.Year);
    }
    get hasTimeParts() {
        return this._inputDateParts.some(p => p.type === DatePart.Hours
            || p.type === DatePart.Minutes
            || p.type === DatePart.Seconds);
    }
    /** @hidden @internal */
    ngOnChanges(changes) {
        if (changes['inputFormat'] || changes['locale']) {
            this.updateInputFormat();
        }
    }
    /** @hidden @internal */
    ngDoCheck() {
        if (this._inputFormat !== this.inputFormat) {
            this.updateInputFormat();
        }
    }
    /** Clear the input element value. */
    clear() {
        this.updateValue(null);
    }
    /**
     * Increment specified DatePart.
     * @param datePart The optional DatePart to increment. Defaults to Date or Hours(when Date is absent from the inputFormat - ex:'HH:mm').
     */
    increment(datePart) {
        const targetDatePart = this.targetDatePart;
        if (!targetDatePart) {
            return;
        }
        const newValue = datePart
            ? this.spinValue(datePart, 1)
            : this.spinValue(targetDatePart, 1);
        this.updateValue(newValue ? newValue : new Date());
    }
    /**
     * Decrement specified DatePart.
     *
     * @param datePart The optional DatePart to decrement. Defaults to Date or Hours(when Date is absent from the inputFormat - ex:'HH:mm').
     */
    decrement(datePart) {
        const targetDatePart = this.targetDatePart;
        if (!targetDatePart) {
            return;
        }
        const newValue = datePart
            ? this.spinValue(datePart, -1)
            : this.spinValue(targetDatePart, -1);
        this.updateValue(newValue ? newValue : new Date());
    }
    /** @hidden @internal */
    writeValue(value) {
        this._value = value;
        this.updateMask();
    }
    /** @hidden @internal */
    validate(control) {
        if (!this.inputIsComplete() || !control.value) {
            return { 'value': true };
        }
        const maxValueAsDate = this.isDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);
        const minValueAsDate = this.isDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);
        if (minValueAsDate
            && DatePickerUtil.lessThanMinValue(control.value, minValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return { 'minValue': true };
        }
        if (maxValueAsDate
            && DatePickerUtil.greaterThanMaxValue(control.value, maxValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return { 'maxValue': true };
        }
        return null;
    }
    /** @hidden @internal */
    registerOnValidatorChange(fn) { this.onValidatorChange = fn; }
    /** @hidden @internal */
    registerOnChange(fn) { this.onChangeCallback = fn; }
    /** @hidden @internal */
    registerOnTouched(fn) { this.onTouchCallback = fn; }
    /** @hidden @internal */
    setDisabledState(isDisabled) { }
    /** @hidden @internal */
    onInputChanged() {
        var _a;
        super.onInputChanged();
        if (this.inputIsComplete()) {
            const parsedDate = this.parseDate(this.inputValue);
            if (this.isValidDate(parsedDate)) {
                this.updateValue(parsedDate);
            }
            else {
                const oldValue = this.value && new Date(this.value.getTime());
                const args = { oldValue: oldValue, newValue: parsedDate, userInput: this.inputValue };
                this.validationFailed.emit(args);
                if (((_a = args.newValue) === null || _a === void 0 ? void 0 : _a.getTime) && args.newValue.getTime() !== oldValue.getTime()) {
                    this.updateValue(args.newValue);
                }
                else {
                    this.updateValue(null);
                }
            }
        }
        else {
            this.updateValue(null);
        }
    }
    /** @hidden @internal */
    onKeyDown(event) {
        super.onKeyDown(event);
        if (event.altKey) {
            return;
        }
        if (event.key === "ArrowUp" /* UP_ARROW */ || event.key === "Up" /* UP_ARROW_IE */ ||
            event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */) {
            this.spin(event);
            return;
        }
        if (event.ctrlKey && event.key === ";" /* SEMICOLON */) {
            this.updateValue(new Date());
        }
        this.moveCursor(event);
    }
    /** @hidden @internal */
    onFocus() {
        this._isFocused = true;
        this.onTouchCallback();
        this.updateMask();
        super.onFocus();
    }
    /** @hidden @internal */
    onBlur(value) {
        this._isFocused = false;
        if (!this.inputIsComplete() && this.inputValue !== this.emptyMask) {
            this.updateValue(this.parseDate(this.inputValue));
        }
        else {
            this.updateMask();
        }
        super.onBlur(value);
    }
    /** @hidden @internal */
    updateMask() {
        if (this._isFocused) {
            if (!this.value) {
                return;
            }
            // store the cursor position as it will be moved during masking
            const cursor = this.selectionEnd;
            this.inputValue = this.getMaskedValue();
            this.setSelectionRange(cursor);
        }
        else {
            if (!this.value || !this.isValidDate(this.value)) {
                this.inputValue = '';
                return;
            }
            const format = this.displayFormat || this.inputFormat;
            if (format) {
                this.inputValue = DatePickerUtil.formatDate(this.value, format.replace('tt', 'aa'), this.locale);
            }
            else {
                // TODO: formatter function?
                this.inputValue = this.value.toLocaleString();
            }
        }
    }
    getMaskedValue() {
        let mask = this.emptyMask;
        for (const part of this._inputDateParts) {
            if (part.type === DatePart.Literal) {
                continue;
            }
            const targetValue = this.getPartValue(part, part.format.length);
            mask = this.maskParser.replaceInMask(mask, targetValue, this.maskOptions, part.start, part.end).value;
        }
        return mask;
    }
    updateInputFormat() {
        const defPlaceholder = this.inputFormat || DatePickerUtil.getDefaultInputFormat(this.locale);
        this._inputDateParts = DatePickerUtil.parseDateTimeFormat(this.inputFormat);
        this.inputFormat = this._inputDateParts.map(p => p.format).join('');
        if (!this.nativeElement.placeholder || this._inputFormat !== this.inputFormat) {
            this.renderer.setAttribute(this.nativeElement, 'placeholder', defPlaceholder);
        }
        // TODO: fill in partial dates?
        this.updateMask();
        this._inputFormat = this.inputFormat;
    }
    // TODO: move isDate to utils
    isDate(value) {
        return value instanceof Date && typeof value === 'object';
    }
    valueInRange(value) {
        if (!value) {
            return false;
        }
        const maxValueAsDate = this.isDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);
        const minValueAsDate = this.isDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);
        if (minValueAsDate
            && DatePickerUtil.lessThanMinValue(value, minValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return false;
        }
        if (maxValueAsDate
            && DatePickerUtil.greaterThanMaxValue(value, maxValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return false;
        }
        return true;
    }
    spinValue(datePart, delta) {
        if (!this.value || !this.isValidDate(this.value)) {
            return null;
        }
        const newDate = new Date(this.value.getTime());
        switch (datePart) {
            case DatePart.Date:
                DatePickerUtil.spinDate(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Month:
                DatePickerUtil.spinMonth(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Year:
                DatePickerUtil.spinYear(delta, newDate);
                break;
            case DatePart.Hours:
                DatePickerUtil.spinHours(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Minutes:
                DatePickerUtil.spinMinutes(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Seconds:
                DatePickerUtil.spinSeconds(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.AmPm:
                const formatPart = this._inputDateParts.find(dp => dp.type === DatePart.AmPm);
                const amPmFromMask = this.inputValue.substring(formatPart.start, formatPart.end);
                return DatePickerUtil.spinAmPm(newDate, this.value, amPmFromMask);
        }
        return newDate;
    }
    updateValue(newDate) {
        this._oldValue = this.value;
        this.value = newDate;
        if (this.value && !this.valueInRange(this.value)) {
            this.validationFailed.emit({ oldValue: this._oldValue, newValue: this.value, userInput: this.inputValue });
        }
        if (this.inputIsComplete() || this.inputValue === this.emptyMask) {
            this.valueChange.emit(this.value);
        }
    }
    toTwelveHourFormat(value) {
        let hour = parseInt(value.replace(new RegExp(this.promptChar, 'g'), '0'), 10);
        if (hour > 12) {
            hour -= 12;
        }
        else if (hour === 0) {
            hour = 12;
        }
        return hour;
    }
    getPartValue(datePartInfo, partLength) {
        let maskedValue;
        const datePart = datePartInfo.type;
        switch (datePart) {
            case DatePart.Date:
                maskedValue = this.value.getDate();
                break;
            case DatePart.Month:
                // months are zero based
                maskedValue = this.value.getMonth() + 1;
                break;
            case DatePart.Year:
                if (partLength === 2) {
                    maskedValue = this.prependValue(parseInt(this.value.getFullYear().toString().slice(-2), 10), partLength, '0');
                }
                else {
                    maskedValue = this.value.getFullYear();
                }
                break;
            case DatePart.Hours:
                if (datePartInfo.format.indexOf('h') !== -1) {
                    maskedValue = this.prependValue(this.toTwelveHourFormat(this.value.getHours().toString()), partLength, '0');
                }
                else {
                    maskedValue = this.value.getHours();
                }
                break;
            case DatePart.Minutes:
                maskedValue = this.value.getMinutes();
                break;
            case DatePart.Seconds:
                maskedValue = this.value.getSeconds();
                break;
            case DatePart.AmPm:
                maskedValue = this.value.getHours() >= 12 ? 'PM' : 'AM';
                break;
        }
        if (datePartInfo.type !== DatePart.AmPm) {
            return this.prependValue(maskedValue, partLength, '0');
        }
        return maskedValue;
    }
    prependValue(value, partLength, prependChar) {
        return (prependChar + value.toString()).slice(-partLength);
    }
    spin(event) {
        event.preventDefault();
        switch (event.key) {
            case "ArrowUp" /* UP_ARROW */:
            case "Up" /* UP_ARROW_IE */:
                this.increment();
                break;
            case "ArrowDown" /* DOWN_ARROW */:
            case "Down" /* DOWN_ARROW_IE */:
                this.decrement();
                break;
        }
    }
    inputIsComplete() {
        return this.inputValue.indexOf(this.promptChar) === -1;
    }
    isValidDate(date) {
        return date && date.getTime && !isNaN(date.getTime());
    }
    // TODO: move parseDate to utils
    parseDate(val) {
        if (!val) {
            return null;
        }
        return DatePickerUtil.parseValueFromMask(val, this._inputDateParts, this.promptChar);
    }
    moveCursor(event) {
        const value = event.target.value;
        switch (event.key) {
            case "ArrowLeft" /* LEFT_ARROW */:
            case "Left" /* LEFT_ARROW_IE */:
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.setSelectionRange(this.getNewPosition(value));
                }
                break;
            case "ArrowRight" /* RIGHT_ARROW */:
            case "Right" /* RIGHT_ARROW_IE */:
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.setSelectionRange(this.getNewPosition(value, 1));
                }
                break;
        }
    }
    /**
     * Move the cursor in a specific direction until it reaches a date/time separator.
     * Then return its index.
     *
     * @param value The string it operates on.
     * @param direction 0 is left, 1 is right. Default is 0.
     */
    getNewPosition(value, direction = 0) {
        const literals = this._inputDateParts.filter(p => p.type === DatePart.Literal);
        let cursorPos = this.selectionStart;
        if (!direction) {
            do {
                cursorPos = cursorPos > 0 ? --cursorPos : cursorPos;
            } while (!literals.some(l => l.end === cursorPos) && cursorPos > 0);
            return cursorPos;
        }
        else {
            do {
                cursorPos++;
            } while (!literals.some(l => l.start === cursorPos) && cursorPos < value.length);
            return cursorPos;
        }
    }
}
IgxDateTimeEditorDirective.ɵfac = function IgxDateTimeEditorDirective_Factory(t) { return new (t || IgxDateTimeEditorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MaskParsingService), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID)); };
IgxDateTimeEditorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDateTimeEditorDirective, selectors: [["", "igxDateTimeEditor", ""]], inputs: { isSpinLoop: "isSpinLoop", locale: "locale", minValue: "minValue", maxValue: "maxValue", inputFormat: ["igxDateTimeEditor", "inputFormat"], value: "value", displayFormat: "displayFormat" }, outputs: { valueChange: "valueChange", validationFailed: "validationFailed" }, exportAs: ["igxDateTimeEditor"], features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NG_VALUE_ACCESSOR, useExisting: IgxDateTimeEditorDirective, multi: true },
            { provide: NG_VALIDATORS, useExisting: IgxDateTimeEditorDirective, multi: true }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
IgxDateTimeEditorDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: MaskParsingService },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
IgxDateTimeEditorDirective.propDecorators = {
    locale: [{ type: Input }],
    minValue: [{ type: Input }],
    maxValue: [{ type: Input }],
    isSpinLoop: [{ type: Input }],
    displayFormat: [{ type: Input }],
    inputFormat: [{ type: Input, args: [`igxDateTimeEditor`,] }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    validationFailed: [{ type: Output }]
};
class IgxDateTimeEditorModule {
}
IgxDateTimeEditorModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDateTimeEditorModule });
IgxDateTimeEditorModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDateTimeEditorModule_Factory(t) { return new (t || IgxDateTimeEditorModule)(); } });

/**
 * Provides base filtering operations
 * Implementations should be Singleton
 *
 * @export
 */
class IgxFilteringOperand {
    constructor() {
        this.operations = [{
                name: 'null',
                isUnary: true,
                iconName: 'is-null',
                logic: (target) => {
                    return target === null;
                }
            }, {
                name: 'notNull',
                isUnary: true,
                iconName: 'is-not-null',
                logic: (target) => {
                    return target !== null;
                }
            }, {
                name: 'in',
                isUnary: false,
                iconName: 'is-in',
                hidden: true,
                logic: (target, searchVal) => {
                    return this.findValueInSet(target, searchVal);
                }
            }];
    }
    static instance() {
        return this._instance || (this._instance = new this());
    }
    /**
     * @hidden
     */
    findValueInSet(target, searchVal) {
        return searchVal.has(target);
    }
    /**
     * Returns an array of names of the conditions which are visible in the UI
     */
    conditionList() {
        return this.operations.filter(f => !f.hidden).map((element) => element.name);
    }
    /**
     * Returns an instance of the condition with the specified name.
     * @param name The name of the condition.
     */
    condition(name) {
        return this.operations.find((element) => element.name === name);
    }
    /**
     * Adds a new condition to the filtering operations.
     * @param operation The filtering operation.
     */
    append(operation) {
        this.operations.push(operation);
    }
}
IgxFilteringOperand._instance = null;
/**
 * Provides filtering operations for booleans
 *
 * @export
 */
class IgxBooleanFilteringOperand extends IgxFilteringOperand {
    constructor() {
        super();
        this.operations = [{
                name: 'all',
                isUnary: true,
                iconName: 'select-all',
                logic: (target) => {
                    return true;
                }
            }, {
                name: 'true',
                isUnary: true,
                iconName: 'is-true',
                logic: (target) => {
                    return !!(target && target !== null && target !== undefined);
                }
            }, {
                name: 'false',
                isUnary: true,
                iconName: 'is-false',
                logic: (target) => {
                    return !target && target !== null && target !== undefined;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'is-empty',
                logic: (target) => {
                    return target === null || target === undefined;
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not-empty',
                logic: (target) => {
                    return target !== null && target !== undefined;
                }
            }].concat(this.operations);
    }
}
/**
 * Provides filtering operations for Dates
 *
 * @export
 */
class IgxDateFilteringOperand extends IgxFilteringOperand {
    constructor() {
        super();
        this.operations = [{
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: (target, searchVal) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    const searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                    return targetp.year === searchp.year &&
                        targetp.month === searchp.month &&
                        targetp.day === searchp.day;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not-equal',
                logic: (target, searchVal) => {
                    if (!target) {
                        return true;
                    }
                    this.validateInputData(target);
                    const targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    const searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                    return targetp.year !== searchp.year ||
                        targetp.month !== searchp.month ||
                        targetp.day !== searchp.day;
                }
            }, {
                name: 'before',
                isUnary: false,
                iconName: 'is-before',
                logic: (target, searchVal) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    return target < searchVal;
                }
            }, {
                name: 'after',
                isUnary: false,
                iconName: 'is-after',
                logic: (target, searchVal) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    return target > searchVal;
                }
            }, {
                name: 'today',
                isUnary: true,
                iconName: 'today',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yMd');
                    return d.year === now.year &&
                        d.month === now.month &&
                        d.day === now.day;
                }
            }, {
                name: 'yesterday',
                isUnary: true,
                iconName: 'yesterday',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const td = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    const y = ((d) => new Date(d.setDate(d.getDate() - 1)))(new Date());
                    const yesterday = IgxDateFilteringOperand.getDateParts(y, 'yMd');
                    return td.year === yesterday.year &&
                        td.month === yesterday.month &&
                        td.day === yesterday.day;
                }
            }, {
                name: 'thisMonth',
                isUnary: true,
                iconName: 'this-month',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'lastMonth',
                isUnary: true,
                iconName: 'last-month',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    if (!now.month) {
                        now.month = 11;
                        now.year -= 1;
                    }
                    else {
                        now.month--;
                    }
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'nextMonth',
                isUnary: true,
                iconName: 'next-month',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    if (now.month === 11) {
                        now.month = 0;
                        now.year += 1;
                    }
                    else {
                        now.month++;
                    }
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'thisYear',
                isUnary: true,
                iconName: 'this-year',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year;
                }
            }, {
                name: 'lastYear',
                isUnary: true,
                iconName: 'last-year',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year - 1;
                }
            }, {
                name: 'nextYear',
                isUnary: true,
                iconName: 'next-year',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year + 1;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'is-empty',
                logic: (target) => {
                    return target === null || target === undefined;
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not-empty',
                logic: (target) => {
                    return target !== null && target !== undefined;
                }
            }].concat(this.operations);
    }
    /**
     * Splits a Date object into parts
     *
     * @memberof IgxDateFilteringOperand
     */
    static getDateParts(date, dateFormat) {
        const res = {
            day: null,
            hours: null,
            milliseconds: null,
            minutes: null,
            month: null,
            seconds: null,
            year: null
        };
        if (!date || !dateFormat) {
            return res;
        }
        if (dateFormat.indexOf('y') >= 0) {
            res.year = date.getFullYear();
        }
        if (dateFormat.indexOf('M') >= 0) {
            res.month = date.getMonth();
        }
        if (dateFormat.indexOf('d') >= 0) {
            res.day = date.getDate();
        }
        if (dateFormat.indexOf('h') >= 0) {
            res.hours = date.getHours();
        }
        if (dateFormat.indexOf('m') >= 0) {
            res.minutes = date.getMinutes();
        }
        if (dateFormat.indexOf('s') >= 0) {
            res.seconds = date.getSeconds();
        }
        if (dateFormat.indexOf('f') >= 0) {
            res.milliseconds = date.getMilliseconds();
        }
        return res;
    }
    validateInputData(target) {
        if (!(target instanceof Date)) {
            throw new Error('Could not perform filtering on \'date\' column because the datasource object type is not \'Date\'.');
        }
    }
    findValueInSet(target, searchVal) {
        if (!target) {
            return false;
        }
        return searchVal.has(target.toISOString());
    }
}
/**
 * Provides filtering operations for numbers
 *
 * @export
 */
class IgxNumberFilteringOperand extends IgxFilteringOperand {
    constructor() {
        super();
        this.operations = [{
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: (target, searchVal) => {
                    return target === searchVal;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not-equal',
                logic: (target, searchVal) => {
                    return target !== searchVal;
                }
            }, {
                name: 'greaterThan',
                isUnary: false,
                iconName: 'greater-than',
                logic: (target, searchVal) => {
                    return target > searchVal;
                }
            }, {
                name: 'lessThan',
                isUnary: false,
                iconName: 'less-than',
                logic: (target, searchVal) => {
                    return target < searchVal;
                }
            }, {
                name: 'greaterThanOrEqualTo',
                isUnary: false,
                iconName: 'greater-than-or-equal',
                logic: (target, searchVal) => {
                    return target >= searchVal;
                }
            }, {
                name: 'lessThanOrEqualTo',
                isUnary: false,
                iconName: 'less-than-or-equal',
                logic: (target, searchVal) => {
                    return target <= searchVal;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'is-empty',
                logic: (target) => {
                    return target === null || target === undefined || isNaN(target);
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not-empty',
                logic: (target) => {
                    return target !== null && target !== undefined && !isNaN(target);
                }
            }].concat(this.operations);
    }
}
/**
 * Provides filtering operations for strings
 *
 * @export
 */
class IgxStringFilteringOperand extends IgxFilteringOperand {
    constructor() {
        super();
        this.operations = [{
                name: 'contains',
                isUnary: false,
                iconName: 'contains',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.indexOf(search) !== -1;
                }
            }, {
                name: 'doesNotContain',
                isUnary: false,
                iconName: 'does-not-contain',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.indexOf(search) === -1;
                }
            }, {
                name: 'startsWith',
                isUnary: false,
                iconName: 'starts-with',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.startsWith(search);
                }
            }, {
                name: 'endsWith',
                isUnary: false,
                iconName: 'ends-with',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.endsWith(search);
                }
            }, {
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target === search;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not-equal',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target !== search;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'is-empty',
                logic: (target) => {
                    return target === null || target === undefined || target.length === 0;
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not-empty',
                logic: (target) => {
                    return target !== null && target !== undefined && target.length > 0;
                }
            }].concat(this.operations);
    }
    /**
     * Applies case sensitivity on strings if provided
     *
     * @memberof IgxStringFilteringOperand
     */
    static applyIgnoreCase(a, ignoreCase) {
        a = a || '';
        // bulletproof
        return ignoreCase ? ('' + a).toLowerCase() : a;
    }
}

const filteringStateDefaults = {
    strategy: new FilteringStrategy()
};

/**
 * @hidden
 */
class GroupedRecords extends Array {
}

class IgxGridActionButtonComponent {
    constructor() {
        /**
         * Event emitted when action button is clicked.
         * @example
         * ```html
         *  <igx-grid-action-button (onActionClick)="startEdit($event)"></igx-grid-action-button>
         * ```
         */
        this.onActionClick = new EventEmitter();
        /**
         * Whether button action is rendered in menu and should container text label.
         */
        this.asMenuItem = false;
    }
    /** @hidden @internal */
    get containerClass() {
        return 'igx-action-strip__menu-button ' + (this.classNames || '');
    }
    /**
     * @hidden
     * @internal
     */
    handleClick(event) {
        this.onActionClick.emit(event);
    }
    /**
     * @hidden @internal
     */
    preventEvent(event) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
    }
}
IgxGridActionButtonComponent.ɵfac = function IgxGridActionButtonComponent_Factory(t) { return new (t || IgxGridActionButtonComponent)(); };
IgxGridActionButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridActionButtonComponent, selectors: [["igx-grid-action-button"]], viewQuery: function IgxGridActionButtonComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c5, true);
        ɵngcc0.ɵɵviewQuery(TemplateRef, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    } }, inputs: { asMenuItem: "asMenuItem", iconName: "iconName", classNames: "classNames", iconSet: "iconSet", labelText: "labelText" }, outputs: { onActionClick: "onActionClick" }, decls: 1, vars: 1, consts: [[4, "ngIf"], ["igxButton", "icon", "igxRipple", "", 3, "click", "mousedown"], [3, "fontSet", "name", 4, "ngIf"], [3, "fontSet", "name"], [3, "className"], ["container", ""], ["igxLabel", "", 4, "ngIf"], ["igxLabel", ""]], template: function IgxGridActionButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridActionButtonComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.asMenuItem);
    } }, directives: function () { return [ɵngcc2.NgIf, IgxButtonDirective, IgxRippleDirective, IgxIconComponent]; }, encapsulation: 2 });
IgxGridActionButtonComponent.propDecorators = {
    container: [{ type: ViewChild, args: ['container',] }],
    onActionClick: [{ type: Output }],
    templateRef: [{ type: ViewChild, args: [TemplateRef,] }],
    asMenuItem: [{ type: Input }],
    iconName: [{ type: Input }],
    classNames: [{ type: Input }],
    iconSet: [{ type: Input }],
    labelText: [{ type: Input }]
};

const LabelPosition = mkenum({
    BEFORE: 'before',
    AFTER: 'after'
});
const noop$3 = () => { };
const ɵ0$4 = noop$3;
let nextId$2 = 0;
/**
 * Allows users to make a binary choice for a certain condition.
 *
 * @igxModule IgxCheckboxModule
 *
 * @igxTheme igx-checkbox-theme
 *
 * @igxKeywords checkbox, label
 *
 * @igxGroup Data entry and display
 *
 * @remarks
 * The Ignite UI Checkbox is a selection control that allows users to make a binary choice for a certain condition.It behaves similarly
 * to the native browser checkbox.
 *
 * @example
 * ```html
 * <igx-checkbox checked="true">
 *   simple checkbox
 * </igx-checkbox>
 * ```
 */
class IgxCheckboxComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the checkbox component.
         * If not set, the `id` of the first checkbox component will be `"igx-checkbox-0"`.
         *
         * @example
         * ```html
         * <igx-checkbox id="my-first-checkbox"></igx-checkbox>
         * ```
         * ```typescript
         * let checkboxId =  this.checkbox.id;
         * ```
         */
        this.id = `igx-checkbox-${nextId$2++}`;
        /**
         * Sets/gets the id of the `label` element.
         * If not set, the id of the `label` in the first checkbox component will be `"igx-checkbox-0-label"`.
         *
         * @example
         * ```html
         * <igx-checkbox labelId = "Label1"></igx-checkbox>
         * ```
         * ```typescript
         * let labelId =  this.checkbox.labelId;
         * ```
         */
        this.labelId = `${this.id}-label`;
        /**
         * Sets/gets the value of the `tabindex` attribute.
         *
         * @example
         * ```html
         * <igx-checkbox [tabindex] = "1"></igx-checkbox>
         * ```
         * ```typescript
         * let tabIndex =  this.checkbox.tabindex;
         * ```
         */
        this.tabindex = null;
        /**
         *  Sets/gets the position of the `label`.
         *  If not set, the `labelPosition` will have value `"after"`.
         *
         * @example
         * ```html
         * <igx-checkbox labelPosition = "before"></igx-checkbox>
         * ```
         * ```typescript
         * let labelPosition =  this.checkbox.labelPosition;
         * ```
         */
        this.labelPosition = LabelPosition.AFTER;
        /**
         * Enables/Disables the ripple effect.
         * If not set, `disableRipple` will have value `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [disableRipple] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isRippleDisabled = this.checkbox.desableRipple;
         * ```
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether the checkbox is required.
         * If not set, `required` will have value `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [required] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isRequired =  this.checkbox.required;
         * ```
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledby` attribute.
         * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
         *
         * @example
         * ```html
         * <igx-checkbox aria-labelledby = "Checkbox1"></igx-checkbox>
         * ```
         * ```typescript
         * let ariaLabelledBy =  this.checkbox.ariaLabelledBy;
         * ```
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the value of the `aria-label` attribute.
         *
         * @example
         * ```html
         * <igx-checkbox aria-label = "Checkbox1"></igx-checkbox>
         * ```
         * ```typescript
         * let ariaLabel = this.checkbox.ariaLabel;
         * ```
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the checkbox state is changed.
         * Provides references to the `IgxCheckboxComponent` and the `checked` property as event arguments.
         */
        this.change = new EventEmitter();
        /**
         * Returns the class of the checkbox component.
         *
         * @example
         * ```typescript
         * let class =  this.checkbox.cssClass;
         * ```
         */
        this.cssClass = 'igx-checkbox';
        /**
         * Sets/gets whether the checkbox component is on focus.
         * Default value is `false`.
         *
         * @example
         * ```typescript
         * this.checkbox.focused =  true;
         * ```
         * ```typescript
         * let isFocused =  this.checkbox.focused;
         * ```
         */
        this.focused = false;
        /**
         * Sets/gets the checkbox indeterminate visual state.
         * Default value is `false`;
         *
         * @example
         * ```html
         * <igx-checkbox [indeterminate] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isIndeterminate = this.checkbox.indeterminate;
         * ```
         */
        this.indeterminate = false;
        /**
         * Sets/gets whether the checkbox is checked.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [checked] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isChecked =  this.checkbox.checked;
         * ```
         */
        this.checked = false;
        /**
         * Sets/gets whether the checkbox is disabled.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [disabled] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isDisabled = this.checkbox.disabled;
         * ```
         */
        this.disabled = false;
        /**
         * Sets/gets whether the checkbox is readonly.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [readonly]="true"></igx-checkbox>
         * ```
         * ```typescript
         * let readonly = this.checkbox.readonly;
         * ```
         */
        this.readonly = false;
        /**
         * Sets/gets whether the checkbox should disable all css transitions.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [disableTransitions]="true"></igx-checkbox>
         * ```
         * ```typescript
         * let disableTransitions = this.checkbox.disableTransitions;
         * ```
         */
        this.disableTransitions = false;
        /** @hidden @internal */
        this.inputId = `${this.id}-input`;
        /**
         * @hidden
         */
        this._onTouchedCallback = noop$3;
        /**
         * @hidden
         */
        this._onChangeCallback = noop$3;
    }
    /**
     * If `disabled` is `false`, switches the `checked` state.
     *
     * @example
     * ```typescript
     * this.checkbox.toggle();
     * ```
     */
    toggle() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.indeterminate = false;
        this.focused = false;
        this.checked = !this.checked;
        this.change.emit({ checked: this.checked, checkbox: this });
        this._onChangeCallback(this.checked);
    }
    /** @hidden @internal */
    _onCheckboxChange(event) {
        // We have to stop the original checkbox change event
        // from bubbling up since we emit our own change event
        event.stopPropagation();
    }
    /** @hidden @internal */
    _onCheckboxClick(event) {
        // Since the original checkbox is hidden and the label
        // is used for styling and to change the checked state of the checkbox,
        // we need to prevent the checkbox click event from bubbling up
        // as it gets triggered on label click
        event.stopPropagation();
        if (this.readonly) {
            // readonly prevents the component from changing state (see toggle() method).
            // However, the native checkbox can still be activated through user interaction (focus + space, label click)
            // Prevent the native change so the input remains in sync
            event.preventDefault();
        }
        if (isIE()) {
            this.nativeCheckbox.nativeElement.blur();
        }
        this.toggle();
    }
    /** @hidden @internal */
    _onLabelClick(event) {
        // We use a span element as a placeholder label
        // in place of the native label, we need to emit
        // the change event separately here alongside
        // the click event emitted on click
        this.toggle();
    }
    /** @hidden @internal */
    onFocus(event) {
        this.focused = true;
    }
    /** @hidden @internal */
    onBlur(event) {
        this.focused = false;
        this._onTouchedCallback();
    }
    /** @hidden @internal */
    writeValue(value) {
        this._value = value;
        this.checked = !!this._value;
    }
    /** @hidden @internal */
    get labelClass() {
        switch (this.labelPosition) {
            case LabelPosition.BEFORE:
                return `${this.cssClass}__label--before`;
            case LabelPosition.AFTER:
            default:
                return `${this.cssClass}__label`;
        }
    }
    /** @hidden @internal */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /** @hidden @internal */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
    /** @hidden @internal */
    getEditElement() {
        return this.nativeCheckbox.nativeElement;
    }
}
IgxCheckboxComponent.ɵfac = function IgxCheckboxComponent_Factory(t) { return new (t || IgxCheckboxComponent)(); };
IgxCheckboxComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCheckboxComponent, selectors: [["igx-checkbox"]], viewQuery: function IgxCheckboxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c12, true);
        ɵngcc0.ɵɵstaticViewQuery(_c13, true);
        ɵngcc0.ɵɵstaticViewQuery(_c11, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nativeCheckbox = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nativeLabel = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.placeholderLabel = _t.first);
    } }, hostVars: 13, hostBindings: function IgxCheckboxComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-checkbox", ctx.cssClass)("igx-checkbox--focused", ctx.focused)("igx-checkbox--indeterminate", ctx.indeterminate)("igx-checkbox--checked", ctx.checked)("igx-checkbox--disabled", ctx.disabled)("igx-checkbox--plain", ctx.disableTransitions);
    } }, inputs: { id: "id", labelId: "labelId", tabindex: "tabindex", labelPosition: "labelPosition", disableRipple: "disableRipple", required: "required", ariaLabelledBy: ["aria-labelledby", "ariaLabelledBy"], ariaLabel: ["aria-label", "ariaLabel"], indeterminate: "indeterminate", checked: "checked", disabled: "disabled", readonly: "readonly", disableTransitions: "disableTransitions", value: "value", name: "name" }, outputs: { change: "change" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxCheckboxComponent, multi: true }])], ngContentSelectors: _c2, decls: 11, vars: 18, consts: [["type", "checkbox", 1, "igx-checkbox__input", 3, "id", "name", "value", "tabindex", "disabled", "indeterminate", "checked", "required", "change", "click", "focus", "blur"], ["checkbox", ""], ["igxRipple", "", "igxRippleTarget", ".igx-checkbox__ripple", 1, "igx-checkbox__composite-wrapper", 3, "igxRippleDisabled", "igxRippleCentered", "igxRippleDuration"], [1, "igx-checkbox__composite"], ["label", ""], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 24 24", 1, "igx-checkbox__composite-mark"], ["d", "M4.1,12.7 9,17.6 20.3,6.3"], [1, "igx-checkbox__ripple"], [3, "id", "click"], ["placeholderLabel", ""]], template: function IgxCheckboxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("change", function IgxCheckboxComponent_Template_input_change_0_listener($event) { return ctx._onCheckboxChange($event); })("click", function IgxCheckboxComponent_Template_input_click_0_listener($event) { return ctx._onCheckboxClick($event); })("focus", function IgxCheckboxComponent_Template_input_focus_0_listener($event) { return ctx.onFocus($event); })("blur", function IgxCheckboxComponent_Template_input_blur_0_listener($event) { return ctx.onBlur($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "label", 3, 4);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(5, "svg", 5);
        ɵngcc0.ɵɵelement(6, "path", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelement(7, "div", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "span", 8, 9);
        ɵngcc0.ɵɵlistener("click", function IgxCheckboxComponent_Template_span_click_8_listener($event) { return ctx._onLabelClick($event); });
        ɵngcc0.ɵɵprojection(10);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.inputId)("name", ctx.name)("value", ctx.value)("tabindex", ctx.tabindex)("disabled", ctx.disabled)("indeterminate", ctx.indeterminate)("checked", ctx.checked)("required", ctx.required);
        ɵngcc0.ɵɵattribute("aria-checked", ctx.checked)("aria-labelledby", ctx.ariaLabelledBy)("aria-label", ctx.ariaLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("igxRippleDisabled", ctx.disableRipple)("igxRippleCentered", true)("igxRippleDuration", 300);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("for", ctx.inputId);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵclassMap(ctx.labelClass);
        ɵngcc0.ɵɵproperty("id", ctx.labelId);
    } }, directives: [IgxRippleDirective], encapsulation: 2 });
IgxCheckboxComponent.propDecorators = {
    nativeCheckbox: [{ type: ViewChild, args: ['checkbox', { static: true },] }],
    nativeLabel: [{ type: ViewChild, args: ['label', { static: true },] }],
    placeholderLabel: [{ type: ViewChild, args: ['placeholderLabel', { static: true },] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    labelId: [{ type: Input }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    tabindex: [{ type: Input }],
    labelPosition: [{ type: Input }],
    disableRipple: [{ type: Input }],
    required: [{ type: Input }],
    ariaLabelledBy: [{ type: Input, args: ['aria-labelledby',] }],
    ariaLabel: [{ type: Input, args: ['aria-label',] }],
    change: [{ type: Output }],
    cssClass: [{ type: HostBinding, args: ['class.igx-checkbox',] }],
    focused: [{ type: HostBinding, args: ['class.igx-checkbox--focused',] }],
    indeterminate: [{ type: HostBinding, args: ['class.igx-checkbox--indeterminate',] }, { type: Input }],
    checked: [{ type: HostBinding, args: ['class.igx-checkbox--checked',] }, { type: Input }],
    disabled: [{ type: HostBinding, args: ['class.igx-checkbox--disabled',] }, { type: Input }],
    readonly: [{ type: Input }],
    disableTransitions: [{ type: HostBinding, args: ['class.igx-checkbox--plain',] }, { type: Input }]
};
const IGX_CHECKBOX_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => IgxCheckboxRequiredDirective),
    multi: true
};
/* tslint:disable directive-selector */
class IgxCheckboxRequiredDirective extends CheckboxRequiredValidator {
}
IgxCheckboxRequiredDirective.ɵfac = function IgxCheckboxRequiredDirective_Factory(t) { return ɵIgxCheckboxRequiredDirective_BaseFactory(t || IgxCheckboxRequiredDirective); };
IgxCheckboxRequiredDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCheckboxRequiredDirective, selectors: [["igx-checkbox", "required", "", "formControlName", ""], ["igx-checkbox", "required", "", "formControl", ""], ["igx-checkbox", "required", "", "ngModel", ""]], features: [ɵngcc0.ɵɵProvidersFeature([IGX_CHECKBOX_REQUIRED_VALIDATOR]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @hidden
 */
class IgxCheckboxModule {
}
IgxCheckboxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxCheckboxModule });
IgxCheckboxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxCheckboxModule_Factory(t) { return new (t || IgxCheckboxModule)(); }, imports: [[IgxRippleModule]] });

// TODO: Refactor - export in a separate file
class IgxRow {
    constructor(id, index, data, grid) {
        this.id = id;
        this.index = index;
        this.data = data;
        this.grid = grid;
    }
    createEditEventArgs(includeNewValue = true) {
        const args = {
            rowID: this.id,
            rowData: this.data,
            oldValue: this.data,
            cancel: false,
            owner: this.grid,
            isAddRow: this.isAddRow || false
        };
        if (includeNewValue) {
            args.newValue = this.newData;
        }
        return args;
    }
    createDoneEditEventArgs(cachedRowData) {
        const updatedData = this.grid.transactions.enabled ?
            this.grid.transactions.getAggregatedValue(this.id, true) : this.grid.gridAPI.getRowData(this.id);
        const rowData = updatedData === null ? this.grid.gridAPI.getRowData(this.id) : updatedData;
        const args = {
            rowID: this.id,
            rowData: rowData,
            oldValue: cachedRowData,
            newValue: updatedData,
            owner: this.grid,
            isAddRow: this.isAddRow || false
        };
        return args;
    }
}
class IgxCell {
    constructor(id, rowIndex, column, value, editValue, rowData, grid) {
        this.id = id;
        this.rowIndex = rowIndex;
        this.column = column;
        this.value = value;
        this.editValue = editValue;
        this.rowData = rowData;
        this.grid = grid;
    }
    castToNumber(value) {
        if (this.column.dataType === 'number' && !this.column.inlineEditorTemplate) {
            const v = parseFloat(value);
            return !isNaN(v) && isFinite(v) ? v : 0;
        }
        return value;
    }
    createEditEventArgs(includeNewValue = true) {
        const args = {
            rowID: this.id.rowID,
            cellID: this.id,
            rowData: this.rowData,
            oldValue: this.value,
            cancel: false,
            column: this.column,
            owner: this.grid
        };
        if (includeNewValue) {
            args.newValue = this.castToNumber(this.editValue);
        }
        return args;
    }
    createDoneEditEventArgs(value) {
        const updatedData = this.grid.transactions.enabled ?
            this.grid.transactions.getAggregatedValue(this.id.rowID, true) : this.rowData;
        const rowData = updatedData === null ? this.grid.gridAPI.getRowData(this.id.rowID) : updatedData;
        const args = {
            rowID: this.id.rowID,
            cellID: this.id,
            // rowData - should be the updated/committed rowData - this effectively should be the newValue
            // the only case we use this.rowData directly, is when there is no rowEditing or transactions enabled
            rowData: rowData,
            oldValue: this.value,
            newValue: value,
            column: this.column,
            owner: this.grid,
        };
        return args;
    }
}
class IgxGridCRUDService {
    constructor() {
        this.cell = null;
        this.row = null;
        this.isInCompositionMode = false;
        this._cellEditingBlocked = false;
        this._rowEditingBlocked = false;
    }
    createCell(cell) {
        return new IgxCell(cell.cellID, cell.rowIndex, cell.column, cell.value, cell.value, cell.row.rowData, cell.grid);
    }
    createRow(cell) {
        return new IgxRow(cell.id.rowID, cell.rowIndex, cell.rowData, cell.grid);
    }
    sameRow(rowID) {
        return this.row && this.row.id === rowID;
    }
    sameCell(cell) {
        return (this.cell.id.rowID === cell.id.rowID &&
            this.cell.id.columnID === cell.id.columnID);
    }
    get cellInEditMode() {
        return !!this.cell;
    }
    get rowInEditMode() {
        return !!this.row;
    }
    get rowEditing() {
        return this.grid.rowEditable;
    }
    get primaryKey() {
        return this.grid.primaryKey;
    }
    get cellEditingBlocked() {
        return this._cellEditingBlocked;
    }
    set cellEditingBlocked(val) {
        this._cellEditingBlocked = val;
    }
    get rowEditingBlocked() {
        return this._rowEditingBlocked;
    }
    set rowEditingBlocked(val) {
        this._rowEditingBlocked = val;
    }
    enterEditMode(cell) {
        if (this.isInCompositionMode) {
            return;
        }
        if (this.cellInEditMode) {
            // TODO: case solely for f2/enter nav that uses enterEditMode as toggle. Refactor.
            const canceled = this.grid.endEdit(true);
            if (!canceled || !this.cell) {
                this.grid.tbody.nativeElement.focus();
            }
        }
        else {
            if (cell === null || cell === void 0 ? void 0 : cell.row.addRow) {
                this.beginAddRow(cell);
                return;
            }
            /** Changing the reference with the new editable cell */
            const newCell = this.createCell(cell);
            if (this.rowEditing) {
                const canceled = this.beginRowEdit(newCell);
                if (!canceled) {
                    this.beginCellEdit(newCell);
                }
            }
            else {
                this.beginCellEdit(newCell);
            }
        }
    }
    /** Enters row edit mode */
    beginRowEdit(newCell) {
        if (this.row && !this.sameRow(newCell.id.rowID)) {
            this._rowEditingBlocked = this.grid.endEdit(true);
            if (this.rowEditingBlocked) {
                return true;
            }
            this.cell = newCell;
            this._rowEditingBlocked = false;
            this.endRowEdit();
        }
        if (this.grid.rowEditable && (this.grid.primaryKey === undefined || this.grid.primaryKey === null)) {
            console.warn('The grid must have a `primaryKey` specified when using `rowEditable`!');
        }
        if (!this.row) {
            this.cell = newCell;
            this.row = this.createRow(this.cell);
            const rowArgs = this.row.createEditEventArgs(false);
            this.grid.rowEditEnter.emit(rowArgs);
            if (rowArgs.cancel) {
                this.endEditMode();
                return true;
            }
            this.row.transactionState = this.grid.transactions.getAggregatedValue(this.row.id, true);
            this.grid.transactions.startPending();
            this.grid.openRowOverlay(this.row.id);
        }
    }
    /** Exit row edit mode */
    exitRowEdit(commit) {
        if (!this.grid.rowEditable ||
            this.grid.rowEditingOverlay &&
                this.grid.rowEditingOverlay.collapsed || !this.row) {
            return false;
        }
        if (this.rowEditingBlocked && this.cellEditingBlocked) {
            return true;
        }
        const canceled = this.grid.endRowTransaction(commit, this.row);
        if (canceled) {
            return true;
        }
    }
    /** Enters cell edit mode */
    beginAddRow(cell) {
        const newCell = this.createCell(cell);
        newCell.primaryKey = this.primaryKey;
        cell.enterAddMode = true;
        this.cell = newCell;
        if (!this.sameRow(newCell.id.rowID)) {
            this.row = this.createRow(this.cell);
            this.row.isAddRow = true;
            const rowArgs = this.row.createEditEventArgs(false);
            this.grid.rowEditEnter.emit(rowArgs);
            if (rowArgs.cancel) {
                this.endEditMode();
                this.grid.endAddRow();
                return;
            }
            this.grid.openRowOverlay(this.row.id);
        }
        const args = newCell.createEditEventArgs(false);
        this.grid.cellEditEnter.emit(args);
        if (args.cancel) {
            this.endCellEdit();
            return;
        }
    }
    beginCellEdit(newCell) {
        const args = newCell.createEditEventArgs(false);
        this.grid.cellEditEnter.emit(args);
        this._cellEditingBlocked = args.cancel;
        if (args.cancel) {
            this.endCellEdit();
        }
        else {
            this.cell = newCell;
        }
    }
    /** Exit cell edit mode */
    exitCellEdit() {
        var _a;
        if (!this.cell) {
            return false;
        }
        const newValue = this.cell.castToNumber(this.cell.editValue);
        const args = (_a = this.cell) === null || _a === void 0 ? void 0 : _a.createDoneEditEventArgs(newValue);
        this.cell.value = newValue;
        this.grid.cellEditExit.emit(args);
        this.endCellEdit();
        return false;
    }
    /** Clears cell editing state */
    endCellEdit() {
        this.cell = null;
        this.cellEditingBlocked = false;
    }
    /** Clears row editing state */
    endRowEdit() {
        this.row = null;
        this.rowEditingBlocked = false;
    }
    /** Clears cell and row editing state and closes row editing template if it is open */
    endEditMode() {
        this.endCellEdit();
        if (this.grid.rowEditable) {
            this.endRowEdit();
            this.grid.closeRowEditingOverlay();
        }
    }
    /** Returns whether the targeted cell is in edit mode */
    targetInEdit(rowIndex, columnIndex) {
        if (!this.cell) {
            return false;
        }
        const res = this.cell.column.index === columnIndex && this.cell.rowIndex === rowIndex;
        return res;
    }
}
IgxGridCRUDService.ɵfac = function IgxGridCRUDService_Factory(t) { return new (t || IgxGridCRUDService)(); };
IgxGridCRUDService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxGridCRUDService, factory: IgxGridCRUDService.ɵfac });
class IgxGridSelectionService {
    constructor(zone) {
        this.zone = zone;
        this.dragMode = false;
        this.keyboardState = {};
        this.pointerState = {};
        this.columnsState = {};
        this.selection = new Map();
        this.temp = new Map();
        this._ranges = new Set();
        this.rowSelection = new Set();
        this.columnSelection = new Set();
        this.initPointerState();
        this.initKeyboardState();
        this.initColumnsState();
    }
    /**
     * Returns the current selected ranges in the grid from both
     * keyboard and pointer interactions
     */
    get ranges() {
        // The last action was keyboard + shift selection -> add it
        this.addKeyboardRange();
        const ranges = Array.from(this._ranges).map(range => JSON.parse(range));
        // No ranges but we have a focused cell -> add it
        if (!ranges.length && this.activeElement && this.grid.isCellSelectable) {
            ranges.push(this.generateRange(this.activeElement));
        }
        return ranges;
    }
    get primaryButton() {
        return this.pointerState.primaryButton;
    }
    set primaryButton(value) {
        this.pointerState.primaryButton = value;
    }
    /**
     * Resets the keyboard state
     */
    initKeyboardState() {
        this.keyboardState.node = null;
        this.keyboardState.shift = false;
        this.keyboardState.range = null;
        this.keyboardState.active = false;
    }
    /**
     * Resets the pointer state
     */
    initPointerState() {
        this.pointerState.node = null;
        this.pointerState.ctrl = false;
        this.pointerState.shift = false;
        this.pointerState.range = null;
        this.pointerState.primaryButton = true;
    }
    /**
     * Resets the columns state
     */
    initColumnsState() {
        this.columnsState.field = null;
        this.columnsState.range = [];
    }
    /**
     * Adds a single node.
     * Single clicks | Ctrl + single clicks on cells is the usual case.
     */
    add(node, addToRange = true) {
        this.selection.has(node.row) ? this.selection.get(node.row).add(node.column) :
            this.selection.set(node.row, new Set()).get(node.row).add(node.column);
        if (addToRange) {
            this._ranges.add(JSON.stringify(this.generateRange(node)));
        }
    }
    /**
     * Adds the active keyboard range selection (if any) to the `ranges` meta.
     */
    addKeyboardRange() {
        if (this.keyboardState.range) {
            this._ranges.add(JSON.stringify(this.keyboardState.range));
        }
    }
    remove(node) {
        if (this.selection.has(node.row)) {
            this.selection.get(node.row).delete(node.column);
        }
        if (this.isActiveNode(node)) {
            this.activeElement = null;
        }
        this._ranges.delete(JSON.stringify(this.generateRange(node)));
    }
    isInMap(node) {
        return (this.selection.has(node.row) && this.selection.get(node.row).has(node.column)) ||
            (this.temp.has(node.row) && this.temp.get(node.row).has(node.column));
    }
    selected(node) {
        return (this.isActiveNode(node) && this.grid.isCellSelectable) || this.isInMap(node);
    }
    isActiveNode(node) {
        if (this.activeElement) {
            const isActive = this.activeElement.column === node.column && this.activeElement.row === node.row;
            if (this.grid.hasColumnLayouts) {
                const layout = this.activeElement.layout;
                return isActive && this.isActiveLayout(layout, node.layout);
            }
            return isActive;
        }
        return false;
    }
    isActiveLayout(current, target) {
        return current.columnVisibleIndex === target.columnVisibleIndex;
    }
    addRangeMeta(node, state) {
        this._ranges.add(JSON.stringify(this.generateRange(node, state)));
    }
    removeRangeMeta(node, state) {
        this._ranges.delete(JSON.stringify(this.generateRange(node, state)));
    }
    /**
     * Generates a new selection range from the given `node`.
     * If `state` is passed instead it will generate the range based on the passed `node`
     * and the start node of the `state`.
     */
    generateRange(node, state) {
        if (!state) {
            return {
                rowStart: node.row,
                rowEnd: node.row,
                columnStart: node.column,
                columnEnd: node.column
            };
        }
        const { row, column } = state.node;
        const rowStart = Math.min(node.row, row);
        const rowEnd = Math.max(node.row, row);
        const columnStart = Math.min(node.column, column);
        const columnEnd = Math.max(node.column, column);
        return { rowStart, rowEnd, columnStart, columnEnd };
    }
    /**
     *
     */
    keyboardStateOnKeydown(node, shift, shiftTab) {
        this.keyboardState.active = true;
        this.initPointerState();
        this.keyboardState.shift = shift && !shiftTab;
        if (!this.grid.navigation.isDataRow(node.row)) {
            return;
        }
        // Kb navigation with shift and no previous node.
        // Clear the current selection init the start node.
        if (this.keyboardState.shift && !this.keyboardState.node) {
            this.clear();
            this.keyboardState.node = Object.assign({}, node);
        }
    }
    keyboardStateOnFocus(node, emitter, dom) {
        const kbState = this.keyboardState;
        // Focus triggered by keyboard navigation
        if (kbState.active) {
            if (isChromium()) {
                this._moveSelectionChrome(dom);
            }
            // Start generating a range if shift is hold
            if (kbState.shift) {
                this.dragSelect(node, kbState);
                kbState.range = this.generateRange(node, kbState);
                emitter.emit(this.generateRange(node, kbState));
                return;
            }
            this.initKeyboardState();
            this.clear();
            this.add(node);
        }
    }
    pointerDown(node, shift, ctrl) {
        this.addKeyboardRange();
        this.initKeyboardState();
        this.pointerState.ctrl = ctrl;
        this.pointerState.shift = shift;
        // No ctrl key pressed - no multiple selection
        if (!ctrl) {
            this.clear();
        }
        if (shift) {
            // No previously 'clicked' node. Use the last active node.
            if (!this.pointerState.node) {
                this.pointerState.node = this.activeElement || node;
            }
            this.pointerDownShiftKey(node);
            this.clearTextSelection();
            return;
        }
        this.removeRangeMeta(node);
        this.pointerState.node = node;
    }
    pointerDownShiftKey(node) {
        this.clear();
        this.selectRange(node, this.pointerState);
    }
    mergeMap(target, source) {
        const iterator = source.entries();
        let pair = iterator.next();
        let key;
        let value;
        while (!pair.done) {
            [key, value] = pair.value;
            if (target.has(key)) {
                const newValue = target.get(key);
                value.forEach(record => newValue.add(record));
                target.set(key, newValue);
            }
            else {
                target.set(key, value);
            }
            pair = iterator.next();
        }
    }
    pointerEnter(node, event) {
        // https://www.w3.org/TR/pointerevents/#the-button-property
        this.dragMode = event.buttons === 1 && (event.button === -1 || event.button === 0);
        if (!this.dragMode) {
            return false;
        }
        this.clearTextSelection();
        // If the users triggers a drag-like event by first clicking outside the grid cells
        // and then enters in the grid body we may not have a initial pointer starting node.
        // Assume the first pointerenter node is where we start.
        if (!this.pointerState.node) {
            this.pointerState.node = node;
        }
        this.pointerState.ctrl ? this.selectRange(node, this.pointerState, this.temp) :
            this.dragSelect(node, this.pointerState);
        return true;
    }
    pointerUp(node, emitter) {
        if (this.dragMode) {
            this.restoreTextSelection();
            this.addRangeMeta(node, this.pointerState);
            this.mergeMap(this.selection, this.temp);
            this.zone.runTask(() => emitter.emit(this.generateRange(node, this.pointerState)));
            this.temp.clear();
            this.dragMode = false;
            return true;
        }
        if (this.pointerState.shift) {
            this.clearTextSelection();
            this.restoreTextSelection();
            this.addRangeMeta(node, this.pointerState);
            emitter.emit(this.generateRange(node, this.pointerState));
            return true;
        }
        this.add(node);
        return false;
    }
    selectRange(node, state, collection = this.selection) {
        if (collection === this.temp) {
            collection.clear();
        }
        const { rowStart, rowEnd, columnStart, columnEnd } = this.generateRange(node, state);
        for (let i = rowStart; i <= rowEnd; i++) {
            for (let j = columnStart; j <= columnEnd; j++) {
                collection.has(i) ? collection.get(i).add(j) :
                    collection.set(i, new Set()).get(i).add(j);
            }
        }
    }
    dragSelect(node, state) {
        if (!this.pointerState.ctrl) {
            this.selection.clear();
        }
        this.selectRange(node, state);
    }
    clear(clearAcriveEl = false) {
        if (clearAcriveEl) {
            this.activeElement = null;
        }
        this.selection.clear();
        this.temp.clear();
        this._ranges.clear();
    }
    clearTextSelection() {
        const selection = window.getSelection();
        if (selection.rangeCount) {
            this._selectionRange = selection.getRangeAt(0);
            this._selectionRange.collapse(true);
            selection.removeAllRanges();
        }
    }
    restoreTextSelection() {
        const selection = window.getSelection();
        if (!selection.rangeCount) {
            selection.addRange(this._selectionRange || document.createRange());
        }
    }
    /**
     * (╯°□°）╯︵ ┻━┻
     * Chrome and Chromium don't care about the active
     * range after keyboard navigation, thus this.
     */
    _moveSelectionChrome(node) {
        const selection = window.getSelection();
        selection.removeAllRanges();
        const range = new Range();
        range.selectNode(node);
        range.collapse(true);
        selection.addRange(range);
    }
    /** Returns array of the selected row id's. */
    getSelectedRows() {
        return this.rowSelection.size ? Array.from(this.rowSelection.keys()) : [];
    }
    /** Clears row selection, if filtering is applied clears only selected rows from filtered data. */
    clearRowSelection(event) {
        const removedRec = this.isFilteringApplied() ?
            this.getRowIDs(this.allData).filter(rID => this.isRowSelected(rID)) : this.getSelectedRows();
        const newSelection = this.isFilteringApplied() ? this.getSelectedRows().filter(x => !removedRec.includes(x)) : [];
        this.emitRowSelectionEvent(newSelection, [], removedRec, event);
    }
    /** Select all rows, if filtering is applied select only from filtered data. */
    selectAllRows(event) {
        const allRowIDs = this.getRowIDs(this.allData);
        const addedRows = allRowIDs.filter((rID) => !this.isRowSelected(rID));
        const newSelection = this.rowSelection.size ? this.getSelectedRows().concat(addedRows) : addedRows;
        this.emitRowSelectionEvent(newSelection, addedRows, [], event);
    }
    /** Select the specified row and emit event. */
    selectRowById(rowID, clearPrevSelection, event) {
        if (!this.grid.isRowSelectable || this.isRowDeleted(rowID)) {
            return;
        }
        clearPrevSelection = !this.grid.isMultiRowSelectionEnabled || clearPrevSelection;
        const newSelection = clearPrevSelection ? [rowID] : this.getSelectedRows().indexOf(rowID) !== -1 ?
            this.getSelectedRows() : [...this.getSelectedRows(), rowID];
        const removed = clearPrevSelection ? this.getSelectedRows() : [];
        this.emitRowSelectionEvent(newSelection, [rowID], removed, event);
    }
    /** Deselect the specified row and emit event. */
    deselectRow(rowID, event) {
        if (!this.isRowSelected(rowID)) {
            return;
        }
        const newSelection = this.getSelectedRows().filter(r => r !== rowID);
        if (this.rowSelection.size && this.rowSelection.has(rowID)) {
            this.emitRowSelectionEvent(newSelection, [], [rowID], event);
        }
    }
    /** Select specified rows. No event is emitted. */
    selectRowsWithNoEvent(rowIDs, clearPrevSelection) {
        if (clearPrevSelection) {
            this.rowSelection.clear();
        }
        rowIDs.forEach(rowID => this.rowSelection.add(rowID));
        this.allRowsSelected = undefined;
    }
    /** Deselect specified rows. No event is emitted. */
    deselectRowsWithNoEvent(rowIDs) {
        rowIDs.forEach(rowID => this.rowSelection.delete(rowID));
        this.allRowsSelected = undefined;
    }
    isRowSelected(rowID) {
        return this.rowSelection.size > 0 && this.rowSelection.has(rowID);
    }
    /** Select range from last selected row to the current specified row. */
    selectMultipleRows(rowID, rowData, event) {
        this.allRowsSelected = undefined;
        if (!this.rowSelection.size || this.isRowDeleted(rowID)) {
            this.selectRowById(rowID);
            return;
        }
        const gridData = this.allData;
        const lastRowID = this.getSelectedRows()[this.rowSelection.size - 1];
        const currIndex = gridData.indexOf(this.getRowDataById(lastRowID));
        const newIndex = gridData.indexOf(rowData);
        const rows = gridData.slice(Math.min(currIndex, newIndex), Math.max(currIndex, newIndex) + 1);
        const added = this.getRowIDs(rows).filter(rID => !this.isRowSelected(rID));
        const newSelection = this.getSelectedRows().concat(added);
        this.emitRowSelectionEvent(newSelection, added, [], event);
    }
    areAllRowSelected() {
        if (!this.grid.data) {
            return false;
        }
        if (this.allRowsSelected !== undefined) {
            return this.allRowsSelected;
        }
        const dataItemsID = this.getRowIDs(this.allData);
        return this.allRowsSelected = Math.min(this.rowSelection.size, dataItemsID.length) > 0 &&
            new Set(Array.from(this.rowSelection.values()).concat(dataItemsID)).size === this.rowSelection.size;
    }
    hasSomeRowSelected() {
        const filteredData = this.isFilteringApplied() ?
            this.getRowIDs(this.grid.filteredData).some(rID => this.isRowSelected(rID)) : true;
        return this.rowSelection.size > 0 && filteredData && !this.areAllRowSelected();
    }
    get filteredSelectedRowIds() {
        return this.isFilteringApplied() ?
            this.getRowIDs(this.allData).filter(rowID => this.isRowSelected(rowID)) :
            this.getSelectedRows().filter(rowID => !this.isRowDeleted(rowID));
    }
    emitRowSelectionEvent(newSelection, added, removed, event) {
        const currSelection = this.getSelectedRows();
        if (this.areEqualCollections(currSelection, newSelection)) {
            return;
        }
        const args = {
            oldSelection: currSelection, newSelection: newSelection,
            added: added, removed: removed, event: event, cancel: false
        };
        this.grid.onRowSelectionChange.emit(args);
        if (args.cancel) {
            return;
        }
        this.selectRowsWithNoEvent(args.newSelection, true);
    }
    getRowDataById(rowID) {
        if (!this.grid.primaryKey) {
            return rowID;
        }
        const rowIndex = this.getRowIDs(this.grid.gridAPI.get_all_data(true)).indexOf(rowID);
        return rowIndex < 0 ? {} : this.grid.gridAPI.get_all_data(true)[rowIndex];
    }
    getRowIDs(data) {
        return this.grid.primaryKey && data.length ? data.map(rec => rec[this.grid.primaryKey]) : data;
    }
    clearHeaderCBState() {
        this.allRowsSelected = undefined;
    }
    /** Clear rowSelection and update checkbox state */
    clearAllSelectedRows() {
        this.rowSelection.clear();
        this.clearHeaderCBState();
    }
    /** Returns all data in the grid, with applied filtering and sorting and without deleted rows. */
    get allData() {
        let allData;
        if (this.isFilteringApplied() || this.grid.sortingExpressions.length) {
            allData = this.grid.pinnedRecordsCount ? this.grid._filteredSortedUnpinnedData : this.grid.filteredSortedData;
        }
        else {
            allData = this.grid.gridAPI.get_all_data(true);
        }
        return allData.filter(rData => !this.isRowDeleted(this.grid.gridAPI.get_row_id(rData)));
    }
    areEqualCollections(first, second) {
        return first.length === second.length && new Set(first.concat(second)).size === first.length;
    }
    isFilteringApplied() {
        const grid = this.grid;
        return !FilteringExpressionsTree.empty(grid.filteringExpressionsTree) ||
            !FilteringExpressionsTree.empty(grid.advancedFilteringExpressionsTree);
    }
    isRowDeleted(rowID) {
        return this.grid.gridAPI.row_deleted_transaction(rowID);
    }
    /** Returns array of the selected columns fields. */
    getSelectedColumns() {
        return this.columnSelection.size ? Array.from(this.columnSelection.keys()) : [];
    }
    isColumnSelected(field) {
        return this.columnSelection.size > 0 && this.columnSelection.has(field);
    }
    /** Select the specified column and emit event. */
    selectColumn(field, clearPrevSelection, selectColumnsRange, event) {
        const stateColumn = this.columnsState.field ? this.grid.getColumnByName(this.columnsState.field) : null;
        if (!event || !stateColumn || stateColumn.visibleIndex < 0 || !selectColumnsRange) {
            this.columnsState.field = field;
            this.columnsState.range = [];
            const newSelection = clearPrevSelection ? [field] : this.getSelectedColumns().indexOf(field) !== -1 ?
                this.getSelectedColumns() : [...this.getSelectedColumns(), field];
            const removed = clearPrevSelection ? this.getSelectedColumns().filter(colField => colField !== field) : [];
            const added = this.isColumnSelected(field) ? [] : [field];
            this.emitColumnSelectionEvent(newSelection, added, removed, event);
        }
        else if (selectColumnsRange) {
            this.selectColumnsRange(field, event);
        }
    }
    /** Select specified columns. And emit event. */
    selectColumns(fields, clearPrevSelection, selectColumnsRange, event) {
        const columns = fields.map(f => this.grid.getColumnByName(f)).sort((a, b) => a.visibleIndex - b.visibleIndex);
        const stateColumn = this.columnsState.field ? this.grid.getColumnByName(this.columnsState.field) : null;
        if (!stateColumn || stateColumn.visibleIndex < 0 || !selectColumnsRange) {
            this.columnsState.field = columns[0] ? columns[0].field : null;
            this.columnsState.range = [];
            const added = fields.filter(colField => !this.isColumnSelected(colField));
            const removed = clearPrevSelection ? this.getSelectedColumns().filter(colField => fields.indexOf(colField) === -1) : [];
            const newSelection = clearPrevSelection ? fields : this.getSelectedColumns().concat(added);
            this.emitColumnSelectionEvent(newSelection, added, removed, event);
        }
        else {
            const filedStart = stateColumn.visibleIndex >
                columns[columns.length - 1].visibleIndex ? columns[0].field : columns[columns.length - 1].field;
            this.selectColumnsRange(filedStart, event);
        }
    }
    /** Select range from last clicked column to the current specified column. */
    selectColumnsRange(field, event) {
        const currIndex = this.grid.getColumnByName(this.columnsState.field).visibleIndex;
        const newIndex = this.grid.columnToVisibleIndex(field);
        const columnsFields = this.grid.visibleColumns
            .filter(c => !c.columnGroup)
            .sort((a, b) => a.visibleIndex - b.visibleIndex)
            .slice(Math.min(currIndex, newIndex), Math.max(currIndex, newIndex) + 1)
            .filter(col => col.selectable).map(col => col.field);
        const removed = [];
        const oldAdded = [];
        const added = columnsFields.filter(colField => !this.isColumnSelected(colField));
        this.columnsState.range.forEach(f => {
            if (columnsFields.indexOf(f) === -1) {
                removed.push(f);
            }
            else {
                oldAdded.push(f);
            }
        });
        this.columnsState.range = columnsFields.filter(colField => !this.isColumnSelected(colField) || oldAdded.indexOf(colField) > -1);
        const newSelection = this.getSelectedColumns().concat(added).filter(c => removed.indexOf(c) === -1);
        this.emitColumnSelectionEvent(newSelection, added, removed, event);
    }
    /** Select specified columns. No event is emitted. */
    selectColumnsWithNoEvent(fields, clearPrevSelection) {
        if (clearPrevSelection) {
            this.columnSelection.clear();
        }
        fields.forEach(field => { this.columnSelection.add(field); });
    }
    /** Deselect the specified column and emit event. */
    deselectColumn(field, event) {
        this.initColumnsState();
        const newSelection = this.getSelectedColumns().filter(c => c !== field);
        this.emitColumnSelectionEvent(newSelection, [], [field], event);
    }
    /** Deselect specified columns. No event is emitted. */
    deselectColumnsWithNoEvent(fields) {
        fields.forEach(field => this.columnSelection.delete(field));
    }
    /** Deselect specified columns. And emit event. */
    deselectColumns(fields, event) {
        const removed = this.getSelectedColumns().filter(colField => fields.indexOf(colField) > -1);
        const newSelection = this.getSelectedColumns().filter(colField => fields.indexOf(colField) === -1);
        this.emitColumnSelectionEvent(newSelection, [], removed, event);
    }
    emitColumnSelectionEvent(newSelection, added, removed, event) {
        const currSelection = this.getSelectedColumns();
        if (this.areEqualCollections(currSelection, newSelection)) {
            return;
        }
        const args = {
            oldSelection: currSelection, newSelection: newSelection,
            added: added, removed: removed, event: event, cancel: false
        };
        this.grid.onColumnSelectionChange.emit(args);
        if (args.cancel) {
            return;
        }
        this.selectColumnsWithNoEvent(args.newSelection, true);
    }
    /** Clear columnSelection */
    clearAllSelectedColumns() {
        this.columnSelection.clear();
    }
}
IgxGridSelectionService.ɵfac = function IgxGridSelectionService_Factory(t) { return new (t || IgxGridSelectionService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
IgxGridSelectionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxGridSelectionService, factory: IgxGridSelectionService.ɵfac });
IgxGridSelectionService.ctorParameters = () => [
    { type: NgZone }
];
function isChromium() {
    return (/Chrom|e?ium/g.test(navigator.userAgent) || /Google Inc/g.test(navigator.vendor)) && !/Edge/g.test(navigator.userAgent);
}

class IgxRowDirective {
    constructor(gridAPI, crudService, selectionService, element, cdr) {
        this.gridAPI = gridAPI;
        this.crudService = crudService;
        this.selectionService = selectionService;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */
        this.animateAdd = false;
        /**
         * @hidden
         */
        this.onAnimationEnd = new EventEmitter();
        /**
         * Sets whether this specific row has disabled functionality for editing and row selection.
         * Default value is `false`.
         * ```typescript
         * this.grid.selectedRows[0].pinned = true;
         * ```
         */
        this.disabled = false;
        /**
         * @hidden
         */
        this.role = 'row';
        /**
         * @hidden
         */
        this.focused = false;
        /**
         * @hidden
         * @internal
         */
        this.defaultCssClass = 'igx-grid__tr';
    }
    /**
     *  The data passed to the row component.
     *
     * ```typescript
     * // get the row data for the first selected row
     * let selectedRowData = this.grid.selectedRows[0].rowData;
     * ```
     */
    get rowData() {
        if (this.inEditMode) {
            return merge(Object.assign({}, this._rowData), this.grid.transactions.getAggregatedValue(this.rowID, false));
        }
        return this._rowData;
    }
    set rowData(v) {
        this._rowData = v;
    }
    /**
     * Gets whether the row is pinned.
     * ```typescript
     * let isPinned = row.pinned;
     * ```
     */
    get pinned() {
        return this.grid.isRecordPinned(this.rowData);
    }
    get addRow() {
        return this._addRow;
    }
    set addRow(v) {
        this._addRow = v;
    }
    get rowHeight() {
        let height = this.grid.rowHeight || 32;
        if (this.grid.hasColumnLayouts) {
            const maxRowSpan = this.grid.multiRowLayoutRowSize;
            height = height * maxRowSpan;
        }
        return this.addRow ? height : null;
    }
    get cellHeight() {
        return this.addRow && !this.inEditMode ? null : this.grid.rowHeight || 32;
    }
    /**
     * Sets whether the row is pinned.
     * Default value is `false`.
     * ```typescript
     * this.grid.selectedRows[0].pinned = true;
     * ```
     */
    set pinned(value) {
        if (value) {
            this.grid.pinRow(this.rowID);
        }
        else {
            this.grid.unpinRow(this.rowID);
        }
    }
    /**
     * Gets the rendered cells in the row component.
     *
     * ```typescript
     * // get the cells of the third selected row
     * let selectedRowCells = this.grid.selectedRows[2].cells;
     * ```
     */
    get cells() {
        const res = new QueryList();
        if (!this._cells) {
            return res;
        }
        const cList = this._cells.filter((item) => item.nativeElement.parentElement !== null)
            .sort((item1, item2) => item1.column.visibleIndex - item2.column.visibleIndex);
        res.reset(cList);
        return res;
    }
    set cells(cells) {
    }
    get dataRowIndex() {
        return this.index;
    }
    /**
     * @hidden
     */
    get styleClasses() {
        return this.resolveClasses();
    }
    /**
     * @hidden
     */
    get selected() {
        return this.selectionService.isRowSelected(this.rowID);
    }
    set selected(value) {
        value ? this.selectionService.selectRowsWithNoEvent([this.rowID]) :
            this.selectionService.deselectRowsWithNoEvent([this.rowID]);
        this.grid.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    get columns() {
        return this.grid.visibleColumns;
    }
    /**
     * @hidden
     * @internal
     */
    get viewIndex() {
        if (this.grid.groupingExpressions.length) {
            return this.grid.filteredSortedData.indexOf(this.rowData);
        }
        return this.index + this.grid.page * this.grid.perPage;
    }
    /**
     * @hidden
     */
    get pinnedColumns() {
        return this.grid.pinnedColumns;
    }
    /**
     * @hidden
     */
    get isRoot() {
        return true;
    }
    /**
     * @hidden
     */
    get hasChildren() {
        return false;
    }
    /**
     * @hidden
     */
    get unpinnedColumns() {
        return this.grid.unpinnedColumns;
    }
    /**
     * @hidden
     */
    get showRowSelectors() {
        return this.grid.showRowSelectors;
    }
    /** @hidden */
    get dirty() {
        const row = this.grid.transactions.getState(this.rowID);
        if (row) {
            return row.type === TransactionType.ADD || row.type === TransactionType.UPDATE;
        }
        return false;
    }
    /**
     * @hidden
     */
    get rowDraggable() {
        return this.grid.rowDraggable;
    }
    /** @hidden */
    get added() {
        const row = this.grid.transactions.getState(this.rowID);
        if (row) {
            return row.type === TransactionType.ADD;
        }
        return false;
    }
    /** @hidden */
    get deleted() {
        return this.gridAPI.row_deleted_transaction(this.rowID);
    }
    /**
     * @hidden
     */
    get dragging() {
        return this.grid.dragRowID === this.rowID;
    }
    // TODO: Refactor
    get inEditMode() {
        if (this.grid.rowEditable) {
            const editRowState = this.crudService.row;
            return (editRowState && editRowState.id === this.rowID) || false;
        }
        else {
            return false;
        }
    }
    /**
     * Get a reference to the grid that contains the selected row.
     *
     * ```typescript
     * handleRowSelection(event) {
     *  // the grid on which the onRowSelectionChange event was triggered
     *  const grid = event.row.grid;
     * }
     * ```
     *
     * ```html
     *  <igx-grid
     *    [data]="data"
     *    (onRowSelectionChange)="handleRowSelection($event)">
     *  </igx-grid>
     * ```
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Gets the ID of the row.
     * A row in the grid is identified either by:
     * - primaryKey data value,
     * - the whole rowData, if the primaryKey is omitted.
     *
     * ```typescript
     * let rowID = this.grid.selectedRows[2].rowID;
     * ```
     */
    get rowID() {
        const primaryKey = this.grid.primaryKey;
        return primaryKey ? this._rowData[primaryKey] : this._rowData;
    }
    /**
     * The native DOM element representing the row. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second selected row
     * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @internal
     */
    onClick(event) {
        if (this.grid.rowSelection === 'none' || this.deleted) {
            return;
        }
        if (event.shiftKey && this.grid.rowSelection === 'multiple') {
            this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
            return;
        }
        this.selectionService.selectRowById(this.rowID, !event.ctrlKey, event);
    }
    /**
     * @hidden
     * @internal
     */
    showActionStrip(event) {
        if (this.grid.actionStrip) {
            this.grid.actionStrip.show(this);
        }
    }
    /**
     * @hidden
     */
    onRowSelectorClick(event) {
        event.stopPropagation();
        if (event.shiftKey && this.grid.rowSelection === 'multiple') {
            this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
            return;
        }
        this.selected ? this.selectionService.deselectRow(this.rowID, event) :
            this.selectionService.selectRowById(this.rowID, false, event);
    }
    /**
     * Updates the specified row object and the data source record with the passed value.
     * This method emits `onEditDone` event.
     *
     * ```typescript
     * // update the second selected row's value
     * let newValue = "Apple";
     * this.grid.selectedRows[1].update(newValue);
     * ```
     */
    update(value) {
        const crudService = this.crudService;
        if (crudService.cellInEditMode && crudService.cell.id.rowID === this.rowID) {
            this.grid.endEdit(false);
        }
        const row = new IgxRow(this.rowID, this.index, this.rowData, this.grid);
        this.gridAPI.update_row(row, value);
        this.cdr.markForCheck();
    }
    /**
     * Removes the specified row from the grid's data source.
     * This method emits `onRowDeleted` event.
     *
     * ```typescript
     * // delete the third selected row from the grid
     * this.grid.selectedRows[2].delete();
     * ```
     */
    delete() {
        this.grid.deleteRowById(this.rowID);
    }
    isCellActive(visibleColumnIndex) {
        const node = this.grid.navigation.activeNode;
        return node ? node.row === this.index && node.column === visibleColumnIndex : false;
    }
    /**
     * Pins the specified row.
     * This method emits `onRowPinning` event.
     *
     * ```typescript
     * // pin the selected row from the grid
     * this.grid.selectedRows[0].pin();
     * ```
     */
    pin() {
        return this.grid.pinRow(this.rowID);
    }
    /**
     * Unpins the specified row.
     * This method emits `onRowPinning` event.
     *
     * ```typescript
     * // unpin the selected row from the grid
     * this.grid.selectedRows[0].unpin();
     * ```
     */
    unpin() {
        return this.grid.unpinRow(this.rowID);
    }
    /**
     * @hidden
     */
    get rowCheckboxAriaLabel() {
        return this.grid.primaryKey ?
            this.selected ? 'Deselect row with key ' + this.rowID : 'Select row with key ' + this.rowID :
            this.selected ? 'Deselect row' : 'Select row';
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    shouldDisplayPinnedChip(visibleColumnIndex) {
        return this.pinned && this.disabled && visibleColumnIndex === 0;
    }
    animationEndHandler() {
        this.onAnimationEnd.emit(this);
    }
    /**
     * @hidden
     */
    resolveClasses() {
        const indexClass = this.index % 2 ? this.grid.evenRowCSS : this.grid.oddRowCSS;
        const selectedClass = this.selected ? 'igx-grid__tr--selected' : '';
        const editClass = this.inEditMode ? 'igx-grid__tr--edit' : '';
        const dirtyClass = this.dirty ? 'igx-grid__tr--edited' : '';
        const deletedClass = this.deleted ? 'igx-grid__tr--deleted' : '';
        const mrlClass = this.grid.hasColumnLayouts ? 'igx-grid__tr--mrl' : '';
        const dragClass = this.dragging ? 'igx-grid__tr--drag' : '';
        return `${this.defaultCssClass} ${indexClass} ${selectedClass} ${editClass} ${dirtyClass}
         ${deletedClass} ${mrlClass} ${dragClass}`.trim();
    }
    /**
     * @hidden
     */
    get resolveDragIndicatorClasses() {
        const defaultDragIndicatorCssClass = 'igx-grid__drag-indicator';
        const dragIndicatorOff = this.grid.rowDragging && !this.dragging ? 'igx-grid__drag-indicator--off' : '';
        return `${defaultDragIndicatorCssClass} ${dragIndicatorOff}`;
    }
    /**
     * Spawns the add row UI for the specific row.
     * @example
     * ```typescript
     * const row = this.grid1.getRowByIndex(1);
     * row.beginAddRow();
     * ```
     */
    beginAddRow() {
        this.grid.beginAddRowByIndex(this.rowID, this.index);
    }
}
IgxRowDirective.ɵfac = function IgxRowDirective_Factory(t) { return new (t || IgxRowDirective)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxRowDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowDirective, selectors: [["", "igxRowBaseComponent", ""]], viewQuery: function IgxRowDirective_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c14, true, IgxGridForOfDirective);
        ɵngcc0.ɵɵviewQuery(IgxCheckboxComponent, true, IgxCheckboxComponent);
        ɵngcc0.ɵɵviewQuery(_c15, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtDirRow = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.checkboxElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._cells = _t);
    } }, hostVars: 10, hostBindings: function IgxRowDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxRowDirective_click_HostBindingHandler($event) { return ctx.onClick($event); })("mouseenter", function IgxRowDirective_mouseenter_HostBindingHandler($event) { return ctx.showActionStrip($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.disabled)("role", ctx.role)("data-rowIndex", ctx.dataRowIndex)("aria-selected", ctx.selected);
        ɵngcc0.ɵɵclassMap(ctx.styleClasses);
        ɵngcc0.ɵɵstyleProp("min-height", ctx.rowHeight, "px");
        ɵngcc0.ɵɵclassProp("igx-grid__tr--disabled", ctx.disabled);
    } }, inputs: { disabled: "disabled", rowData: "rowData", addRow: "addRow", selected: "selected", index: "index", gridID: "gridID" }, outputs: { onAnimationEnd: "onAnimationEnd" } });
IgxRowDirective.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxGridCRUDService },
    { type: IgxGridSelectionService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxRowDirective.propDecorators = {
    onAnimationEnd: [{ type: Output }],
    rowData: [{ type: Input }],
    index: [{ type: Input }],
    disabled: [{ type: Input }, { type: HostBinding, args: ['attr.aria-disabled',] }, { type: HostBinding, args: ['class.igx-grid__tr--disabled',] }],
    addRow: [{ type: Input }],
    rowHeight: [{ type: HostBinding, args: ['style.min-height.px',] }],
    gridID: [{ type: Input }],
    virtDirRow: [{ type: ViewChild, args: ['igxDirRef', { read: IgxGridForOfDirective },] }],
    checkboxElement: [{ type: ViewChild, args: [forwardRef(() => IgxCheckboxComponent), { read: IgxCheckboxComponent },] }],
    _cells: [{ type: ViewChildren, args: ['cell',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    dataRowIndex: [{ type: HostBinding, args: ['attr.data-rowIndex',] }],
    styleClasses: [{ type: HostBinding, args: ['class',] }],
    selected: [{ type: Input }, { type: HostBinding, args: ['attr.aria-selected',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    showActionStrip: [{ type: HostListener, args: ['mouseenter', ['$event'],] }]
};

/**
 * **Ignite UI for Angular Icon Service** -
 *
 * The Ignite UI Icon Service makes it easy for developers to include custom SVG images and use them with IgxIconComponent.
 * In addition it could be used to associate a custom class to be applied on IgxIconComponent according to given fontSet.
 *
 * Example:
 * ```typescript
 * this.iconService.registerFontSetAlias('material', 'material-icons');
 * this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
 * ```
 */
class IgxIconService {
    constructor(_sanitizer, _document) {
        this._sanitizer = _sanitizer;
        this._document = _document;
        this._fontSet = 'material-icons';
        this._fontSetAliases = new Map();
        this._cachedSvgIcons = new Set();
        this._iconLoaded = new Subject();
        /**
         * Observable that emits when an icon is successfully loaded
         * through a HTTP request.
         * @example
         * ```typescript
         * this.service.iconLoaded.subscribe((ev: IgxIconLoadedEvent) => ...);
         * ```
         */
        this.iconLoaded = this._iconLoaded.asObservable();
    }
    /**
     *  Returns the default font set.
     * ```typescript
     *   const defaultFontSet = this.iconService.defaultFontSet;
     * ```
     */
    get defaultFontSet() {
        return this._fontSet;
    }
    /**
     *  Sets the default font set.
     * ```typescript
     *   this.iconService.defaultFontSet = 'svg-flags';
     * ```
     */
    set defaultFontSet(className) {
        this._fontSet = className;
    }
    /**
     *  Registers a custom class to be applied to IgxIconComponent for a given fontSet.
     * ```typescript
     *   this.iconService.registerFontSetAlias('material', 'material-icons');
     * ```
     */
    registerFontSetAlias(alias, className = alias) {
        this._fontSetAliases.set(alias, className);
        return this;
    }
    /**
     *  Returns the custom class, if any, associated to a given fontSet.
     * ```typescript
     *   const fontSetClass = this.iconService.fontSetClassName('material');
     * ```
     */
    fontSetClassName(alias) {
        return this._fontSetAliases.get(alias) || alias;
    }
    /**
     *  Adds an SVG image to the cache. SVG source is an url.
     * ```typescript
     *   this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
     * ```
     */
    addSvgIcon(iconName, url, fontSet = '') {
        if (iconName && url) {
            const safeUrl = this._sanitizer.bypassSecurityTrustResourceUrl(url);
            if (!safeUrl) {
                throw new Error(`The provided URL could not be processed as trusted resource URL by Angular's DomSanitizer: "${url}".`);
            }
            const sanitizedUrl = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);
            if (!sanitizedUrl) {
                throw new Error(`The URL provided was not trusted as a resource URL: "${url}".`);
            }
            this.fetchSvg(iconName, url, fontSet);
        }
        else {
            throw new Error('You should provide at least `iconName` and `url` to register an svg icon.');
        }
    }
    /**
     *  Adds an SVG image to the cache. SVG source is its text.
     * ```typescript
     *   this.iconService.addSvgIcon('simple', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
     *   <path d="M74 74h54v54H74" /></svg>', 'svg-flags');
     * ```
     */
    addSvgIconFromText(iconName, iconText, fontSet = '') {
        if (iconName && iconText) {
            this.cacheSvgIcon(iconName, iconText, fontSet);
        }
        else {
            throw new Error('You should provide at least `iconName` and `iconText` to register an svg icon.');
        }
    }
    /**
     *  Returns whether a given SVG image is present in the cache.
     * ```typescript
     *   const isSvgCached = this.iconService.isSvgIconCached('aruba', 'svg-flags');
     * ```
     */
    isSvgIconCached(iconName, fontSet = '') {
        const iconKey = this.getSvgIconKey(iconName, fontSet);
        return this._cachedSvgIcons.has(iconKey);
    }
    /**
     *  Returns the key of a cached SVG image.
     * ```typescript
     *   const svgIconKey = this.iconService.getSvgIconKey('aruba', 'svg-flags');
     * ```
     */
    getSvgIconKey(iconName, fontSet = '') {
        return fontSet + '_' + iconName;
    }
    /**
     * @hidden
     */
    fetchSvg(iconName, url, fontSet = '') {
        const instance = this;
        const httpRequest = new XMLHttpRequest();
        httpRequest.open('GET', url, true);
        httpRequest.responseType = 'text';
        // load – when the result is ready, that includes HTTP errors like 404.
        httpRequest.onload = function (event) {
            if (event) {
                const request = event.target;
                if (request.status === 200) {
                    instance.cacheSvgIcon(iconName, request.responseText, fontSet);
                    instance._iconLoaded.next({ name: iconName, value: request.responseText, fontSet });
                }
                else {
                    throw new Error(`Could not fetch SVG from url: ${url}; error: ${request.status} (${request.statusText})`);
                }
            }
            else {
                throw new Error(`Could not fetch SVG from url: ${url};`);
            }
        };
        // error – when the request couldn’t be made, e.g.network down or invalid URL.
        httpRequest.onerror = function (event) {
            if (event) {
                const request = event.target;
                throw new Error(`Could not fetch SVG from url: ${url}; error status code: ${request.status} (${request.statusText})`);
            }
            throw new Error(`Could not fetch SVG from url: ${url};`);
        };
        httpRequest.send();
    }
    /**
     * @hidden
     */
    cacheSvgIcon(iconName, value, fontSet = '') {
        if (iconName && value) {
            this.ensureSvgContainerCreated();
            const div = this._document.createElement('DIV');
            div.innerHTML = value;
            const svg = div.querySelector('svg');
            if (svg) {
                const iconKey = this.getSvgIconKey(iconName, fontSet);
                svg.setAttribute('id', iconKey);
                svg.setAttribute('fit', '');
                svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
                if (this._cachedSvgIcons.has(iconKey)) {
                    const oldChild = this._svgContainer.querySelector(`svg[id='${iconKey}']`);
                    this._svgContainer.removeChild(oldChild);
                }
                this._svgContainer.appendChild(svg);
                this._cachedSvgIcons.add(iconKey);
            }
        }
    }
    /**
     * @hidden
     */
    ensureSvgContainerCreated() {
        if (!this._svgContainer) {
            this._svgContainer = this._document.documentElement.querySelector('.igx-svg-container');
            if (!this._svgContainer) {
                this._svgContainer = this._document.createElement('DIV');
                this._svgContainer.classList.add('igx-svg-container');
                this._document.documentElement.appendChild(this._svgContainer);
            }
        }
    }
}
IgxIconService.ɵfac = function IgxIconService_Factory(t) { return new (t || IgxIconService)(ɵngcc0.ɵɵinject(ɵngcc4.DomSanitizer), ɵngcc0.ɵɵinject(DOCUMENT)); };
IgxIconService.ɵprov = ɵɵdefineInjectable({ factory: function IgxIconService_Factory() { return new IgxIconService(ɵɵinject(DomSanitizer), ɵɵinject(DOCUMENT)); }, token: IgxIconService, providedIn: "root" });
IgxIconService.ctorParameters = () => [
    { type: DomSanitizer },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];

class IgxGridActionsBaseDirective {
    constructor(iconService, differs) {
        this.iconService = iconService;
        this.differs = differs;
        /**
         * Gets/Sets if the action buttons will be rendered as menu items. When in menu, items will be rendered with text label.
         * @example
         * ```html
         *  <igx-grid-pinning-actions [asMenuItems]='true'></igx-grid-pinning-actions>
         *  <igx-grid-editing-actions [asMenuItems]='true'></igx-grid-editing-actions>
         * ```
         */
        this.asMenuItems = false;
    }
    /**
     * @hidden
     * @internal
     */
    get grid() {
        return this.strip.context.grid;
    }
    /**
     * @hidden
     * @internal
     */
    ngAfterViewInit() {
        if (this.asMenuItems) {
            this.buttons.changes.subscribe((change) => {
                this.strip.cdr.detectChanges();
            });
        }
    }
    /**
     * Getter to be used in template
     * @hidden
     * @internal
     */
    get isRowContext() {
        return this.isRow(this.strip.context) && !this.strip.context.inEditMode;
    }
    /**
     * Check if the param is a row from a grid
     * @hidden
     * @internal
     * @param context
     */
    isRow(context) {
        return context && context instanceof IgxRowDirective;
    }
}
IgxGridActionsBaseDirective.ɵfac = function IgxGridActionsBaseDirective_Factory(t) { return new (t || IgxGridActionsBaseDirective)(ɵngcc0.ɵɵdirectiveInject(IgxIconService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers)); };
IgxGridActionsBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridActionsBaseDirective, selectors: [["", "igxGridActionsBase", ""]], viewQuery: function IgxGridActionsBaseDirective_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxGridActionButtonComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.buttons = _t);
    } }, inputs: { asMenuItems: "asMenuItems" } });
IgxGridActionsBaseDirective.ctorParameters = () => [
    { type: IgxIconService },
    { type: IterableDiffers }
];
IgxGridActionsBaseDirective.propDecorators = {
    buttons: [{ type: ViewChildren, args: [IgxGridActionButtonComponent,] }],
    asMenuItems: [{ type: Input }]
};

class IgxGridEditingActionsComponent extends IgxGridActionsBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Host `class.igx-action-strip` binding.
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-action-strip__editing-actions';
        this.isMessageShown = false;
        this._addRow = false;
        this.iconsRendered = false;
        /**
         * An input to enable/disable action strip child row adding button
         */
        this.addChild = false;
    }
    /**
     * An input to enable/disable action strip row adding button
     */
    set addRow(value) {
        this._addRow = value;
    }
    get addRow() {
        if (!this.iconsRendered) {
            this.registerIcons();
            this.iconsRendered = true;
        }
        return this._addRow;
    }
    /**
     * Enter row or cell edit mode depending the grid rowEditable option
     * @example
     * ```typescript
     * this.gridEditingActions.startEdit();
     * ```
     */
    startEdit(event) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const row = this.strip.context;
        const firstEditable = row.cells.filter(cell => cell.editable)[0];
        const grid = row.grid;
        if (!grid.hasEditableColumns) {
            this.isMessageShown = showMessage('The grid should be editable in order to use IgxGridEditingActionsComponent', this.isMessageShown);
            return;
        }
        // be sure row is in view
        if (grid.rowList.filter(r => r === row).length !== 0) {
            grid.crudService.enterEditMode(firstEditable);
        }
        this.strip.hide();
    }
    /**
     * Delete a row according to the context
     * @example
     * ```typescript
     * this.gridEditingActions.deleteRow();
     * ```
     */
    deleteRow(event) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        const grid = context.grid;
        grid.deleteRow(context.rowID);
        this.strip.hide();
    }
    addRowHandler(event, asChild) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        const grid = context.grid;
        if (!grid.rowEditable) {
            console.warn('The grid must use row edit mode to perform row adding! Please set rowEditable to true.');
            return;
        }
        grid.beginAddRowByIndex(context.rowID, context.index, asChild);
        this.strip.hide();
    }
    /**
     * Getter if the row is disabled
     * @hidden
     * @internal
     */
    get disabled() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        return this.strip.context.disabled;
    }
    /**
     * Getter if the row is root.
     * @hidden
     * @internal
     */
    get isRootRow() {
        if (!this.isRow(this.strip.context)) {
            return false;
        }
        return this.strip.context.isRoot;
    }
    get hasChildren() {
        if (!this.isRow(this.strip.context)) {
            return false;
        }
        return this.strip.context.hasChildren;
    }
    /**
     * @hidden
     * @internal
     */
    registerIcons() {
        this.iconService.addSvgIconFromText(addRow.name, addRow.value, 'imx-icons');
        this.iconService.addSvgIconFromText(addChild.name, addChild.value, 'imx-icons');
    }
}
IgxGridEditingActionsComponent.ɵfac = function IgxGridEditingActionsComponent_Factory(t) { return ɵIgxGridEditingActionsComponent_BaseFactory(t || IgxGridEditingActionsComponent); };
IgxGridEditingActionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridEditingActionsComponent, selectors: [["igx-grid-editing-actions"]], hostVars: 2, hostBindings: function IgxGridEditingActionsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-action-strip__editing-actions", ctx.cssClass);
    } }, inputs: { addChild: "addChild", addRow: "addRow" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxGridActionsBaseDirective, useExisting: IgxGridEditingActionsComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 1, consts: [[4, "ngIf"], ["iconName", "edit", 3, "asMenuItem", "labelText", "onActionClick", 4, "ngIf"], ["iconName", "add-row", "iconSet", "imx-icons", 3, "asMenuItem", "labelText", "onActionClick", 4, "ngIf"], ["iconName", "add-child", "iconSet", "imx-icons", 3, "asMenuItem", "labelText", "onActionClick", 4, "ngIf"], ["class", "igx-action-strip__delete", "classNames", "igx-action-strip__menu-item--danger", "iconName", "delete", 3, "asMenuItem", "labelText", "onActionClick", 4, "ngIf"], ["iconName", "edit", 3, "asMenuItem", "labelText", "onActionClick"], ["iconName", "add-row", "iconSet", "imx-icons", 3, "asMenuItem", "labelText", "onActionClick"], ["iconName", "add-child", "iconSet", "imx-icons", 3, "asMenuItem", "labelText", "onActionClick"], ["classNames", "igx-action-strip__menu-item--danger", "iconName", "delete", 1, "igx-action-strip__delete", 3, "asMenuItem", "labelText", "onActionClick"]], template: function IgxGridEditingActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridEditingActionsComponent_ng_container_0_Template, 5, 4, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isRowContext);
    } }, directives: [ɵngcc2.NgIf, IgxGridActionButtonComponent], encapsulation: 2 });
IgxGridEditingActionsComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-action-strip__editing-actions',] }],
    addRow: [{ type: Input }],
    addChild: [{ type: Input }]
};

class IgxGridPinningActionsComponent extends IgxGridActionsBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Host `class.igx-action-strip` binding.
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-action-strip__pinning-actions';
        this.iconsRendered = false;
    }
    /**
     * Getter to know if the row is pinned
     * @hidden
     * @internal
     */
    get pinned() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        if (context && !this.iconsRendered) {
            this.registerSVGIcons();
            this.iconsRendered = true;
        }
        return context && context.pinned;
    }
    /**
     * Getter to know if the row is in pinned and ghost
     * @hidden
     * @internal
     */
    get inPinnedArea() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        return this.pinned && !context.disabled;
    }
    /**
     * Getter to know if the row pinning is set to top or bottom
     * @hidden
     * @internal
     */
    get pinnedTop() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        return this.strip.context.grid.isRowPinningToTop;
    }
    /**
     * Pin the row according to the context.
     * @example
     * ```typescript
     * this.gridPinningActions.pin();
     * ```
     */
    pin(event) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const row = this.strip.context;
        const grid = row.grid;
        grid.pinRow(row.rowID);
        this.strip.hide();
    }
    /**
     * Unpin the row according to the context.
     * @example
     * ```typescript
     * this.gridPinningActions.unpin();
     * ```
     */
    unpin(event) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const row = this.strip.context;
        const grid = row.grid;
        grid.unpinRow(row.rowID);
        this.strip.hide();
    }
    scrollToRow(event) {
        if (event) {
            event.stopPropagation();
        }
        const context = this.strip.context;
        const grid = context.grid;
        grid.scrollTo(context.rowData, 0);
        this.strip.hide();
    }
    registerSVGIcons() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        const grid = context.grid;
        if (grid) {
            this.iconService.addSvgIconFromText(pinLeft.name, pinLeft.value, 'imx-icons');
            this.iconService.addSvgIconFromText(unpinLeft.name, unpinLeft.value, 'imx-icons');
            this.iconService.addSvgIconFromText(jumpDown.name, jumpDown.value, 'imx-icons');
            this.iconService.addSvgIconFromText(jumpUp.name, jumpDown.value, 'imx-icons');
        }
    }
}
IgxGridPinningActionsComponent.ɵfac = function IgxGridPinningActionsComponent_Factory(t) { return ɵIgxGridPinningActionsComponent_BaseFactory(t || IgxGridPinningActionsComponent); };
IgxGridPinningActionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridPinningActionsComponent, selectors: [["igx-grid-pinning-actions"]], hostVars: 2, hostBindings: function IgxGridPinningActionsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-action-strip__pinning-actions", ctx.cssClass);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxGridActionsBaseDirective, useExisting: IgxGridPinningActionsComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 1, consts: [[4, "ngIf"], ["iconSet", "imx-icons", "iconName", "jump-down", 3, "asMenuItem", "labelText", "onActionClick", 4, "ngIf"], ["iconSet", "imx-icons", "iconName", "jump-up", 3, "asMenuItem", "labelText", "onActionClick", 4, "ngIf"], ["iconSet", "imx-icons", "iconName", "pin-left", 3, "asMenuItem", "labelText", "onActionClick", 4, "ngIf"], ["iconSet", "imx-icons", "iconName", "unpin-left", 3, "asMenuItem", "labelText", "onActionClick", 4, "ngIf"], ["iconSet", "imx-icons", "iconName", "jump-down", 3, "asMenuItem", "labelText", "onActionClick"], ["iconSet", "imx-icons", "iconName", "jump-up", 3, "asMenuItem", "labelText", "onActionClick"], ["iconSet", "imx-icons", "iconName", "pin-left", 3, "asMenuItem", "labelText", "onActionClick"], ["iconSet", "imx-icons", "iconName", "unpin-left", 3, "asMenuItem", "labelText", "onActionClick"]], template: function IgxGridPinningActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridPinningActionsComponent_ng_container_0_Template, 5, 4, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isRowContext);
    } }, directives: [ɵngcc2.NgIf, IgxGridActionButtonComponent], encapsulation: 2 });
IgxGridPinningActionsComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-action-strip__pinning-actions',] }]
};

class IgxActionStripMenuItemDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
IgxActionStripMenuItemDirective.ɵfac = function IgxActionStripMenuItemDirective_Factory(t) { return new (t || IgxActionStripMenuItemDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxActionStripMenuItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxActionStripMenuItemDirective, selectors: [["", "igxActionStripMenuItem", ""]] });
IgxActionStripMenuItemDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * Action Strip provides templatable area for one or more actions.
 *
 * @igxModule IgxActionStripModule
 *
 * @igxTheme igx-action-strip-theme
 *
 * @igxKeywords action, strip, actionStrip, pinning, editing
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 * The Ignite UI Action Strip is a container, overlaying its parent container,
 * and displaying action buttons with action applicable to the parent component the strip is instantiated or shown for.
 *
 * @example
 * ```html
 * <igx-action-strip #actionStrip>
 *     <igx-icon (click)="doSomeAction()"></igx-icon>
 * </igx-action-strip>
 */
class IgxActionStripComponent extends DisplayDensityBase {
    constructor(_viewContainer, renderer, _displayDensityOptions, cdr) {
        super(_displayDensityOptions);
        this._viewContainer = _viewContainer;
        this.renderer = renderer;
        this._displayDensityOptions = _displayDensityOptions;
        this.cdr = cdr;
        this._hidden = false;
        /**
         * Getter for menu overlay settings
         * @hidden
         * @internal
         */
        this.menuOverlaySettings = { scrollStrategy: new CloseScrollStrategy() };
    }
    /**
     * Getter for the 'display' property of the current `IgxActionStrip`
     * @hidden
     * @internal
     */
    get display() {
        return this._hidden ? 'none' : 'flex';
    }
    /**
     * An @Input property that set the visibility of the Action Strip.
     * Could be used to set if the Action Strip will be initially hidden.
     * @example
     * ```html
     *  <igx-action-strip [hidden]="false">
     * ```
     */
    set hidden(value) {
        this._hidden = value;
    }
    get hidden() {
        return this._hidden;
    }
    /**
     * Host `attr.class` binding.
     * @hidden
     * @internal
     */
    get hostClasses() {
        const classes = [this.getComponentDensityClass('igx-action-strip')];
        // The custom classes should be at the end.
        if (!classes.includes('igx-action-strip')) {
            classes.push('igx-action-strip');
        }
        classes.push(this.hostClass);
        return classes.join(' ');
    }
    /**
     * Menu Items list.
     * @hidden
     * @internal
     */
    get menuItems() {
        const actions = [];
        this.actionButtons.forEach(button => {
            if (button.asMenuItems) {
                const children = button.buttons;
                if (children) {
                    children.toArray().forEach(x => actions.push(x));
                }
            }
        });
        return [...this._menuItems.toArray(), ...actions];
    }
    /**
     * @hidden
     * @internal
     */
    ngAfterContentInit() {
        this.actionButtons.forEach(button => {
            button.strip = this;
        });
        this.actionButtons.changes.subscribe(change => {
            this.actionButtons.forEach(button => {
                button.strip = this;
            });
        });
    }
    ngAfterViewInit() {
        this.menu.onSelection.subscribe(($event) => {
            const newSelection = $event.newSelection.elementRef.nativeElement;
            let allButtons = [];
            this.actionButtons.forEach(actionButtons => {
                if (actionButtons.asMenuItems) {
                    allButtons = [...allButtons, ...actionButtons.buttons.toArray()];
                }
            });
            const button = allButtons.find(x => newSelection.contains(x.container.nativeElement));
            if (button) {
                button.onActionClick.emit();
            }
        });
    }
    /**
     * Showing the Action Strip and appending it the specified context element.
     * @param context
     * @example
     * ```typescript
     * this.actionStrip.show(row);
     * ```
     */
    show(context) {
        this.hidden = false;
        if (!context) {
            return;
        }
        // when shown for different context make sure the menu won't stay opened
        if (this.context !== context) {
            this.closeMenu();
        }
        this.context = context;
        if (this.context && this.context.element) {
            this.renderer.appendChild(context.element.nativeElement, this._viewContainer.element.nativeElement);
        }
        this.cdr.detectChanges();
    }
    /**
     * Hiding the Action Strip and removing it from its current context element.
     * @example
     * ```typescript
     * this.actionStrip.hide();
     * ```
     */
    hide() {
        this.hidden = true;
        this.closeMenu();
        if (this.context && this.context.element) {
            this.renderer.removeChild(this.context.element.nativeElement, this._viewContainer.element.nativeElement);
        }
    }
    /**
     * Close the menu if opened
     * @hidden
     * @internal
     */
    closeMenu() {
        if (this.menu && !this.menu.collapsed) {
            this.menu.close();
        }
    }
}
IgxActionStripComponent.ɵfac = function IgxActionStripComponent_Factory(t) { return new (t || IgxActionStripComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxActionStripComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxActionStripComponent, selectors: [["igx-action-strip"]], contentQueries: function IgxActionStripComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxActionStripMenuItemDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxGridActionsBaseDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._menuItems = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.actionButtons = _t);
    } }, viewQuery: function IgxActionStripComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c16, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.menu = _t.first);
    } }, hostVars: 3, hostBindings: function IgxActionStripComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.hostClasses);
        ɵngcc0.ɵɵstyleProp("display", ctx.display);
    } }, inputs: { hidden: "hidden", context: "context", hostClass: ["class", "hostClass"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 6, vars: 3, consts: [[1, "igx-action-strip__actions"], [4, "ngIf"], [3, "displayDensity"], ["dropdown", ""], ["class", "igx-action-strip__menu-item", 4, "ngFor", "ngForOf"], ["igxButton", "icon", "igxRipple", "", 3, "igxToggleAction", "overlaySettings", "igxDropDownItemNavigation", "click"], [1, "igx-action-strip__menu-item"], [1, "igx-drop-down__item-template"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function IgxActionStripComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1, 0, ["#content", ""]);
        ɵngcc0.ɵɵtemplate(2, IgxActionStripComponent_ng_container_2_Template, 4, 3, "ng-container", 1);
        ɵngcc0.ɵɵelementStart(3, "igx-drop-down", 2, 3);
        ɵngcc0.ɵɵtemplate(5, IgxActionStripComponent_igx_drop_down_item_5_Template, 3, 4, "igx-drop-down-item", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.menuItems.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.menuItems);
    } }, directives: function () { return [ɵngcc2.NgIf, IgxDropDownComponent, ɵngcc2.NgForOf, IgxButtonDirective, IgxRippleDirective, IgxToggleActionDirective, IgxDropDownItemNavigationDirective, IgxIconComponent, IgxDropDownItemComponent, ɵngcc2.NgTemplateOutlet]; }, encapsulation: 2 });
IgxActionStripComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: ChangeDetectorRef }
];
IgxActionStripComponent.propDecorators = {
    display: [{ type: HostBinding, args: ['style.display',] }],
    hidden: [{ type: Input }],
    hostClass: [{ type: Input, args: ['class',] }],
    hostClasses: [{ type: HostBinding, args: ['attr.class',] }],
    context: [{ type: Input }],
    _menuItems: [{ type: ContentChildren, args: [IgxActionStripMenuItemDirective,] }],
    actionButtons: [{ type: ContentChildren, args: [IgxGridActionsBaseDirective,] }],
    menu: [{ type: ViewChild, args: ['dropdown',] }]
};

/**
 * Icon provides a way to include material icons to markup
 *
 * @igxModule IgxIconModule
 *
 * @igxTheme igx-icon-theme
 *
 * @igxKeywords icon, picture
 *
 * @igxGroup Display
 *
 * @remarks
 *
 * The Ignite UI Icon makes it easy for developers to include material design icons directly in their markup. The icons
 * support custom colors and can be marked as active or disabled using the `isActive` property. This will change the appearance
 * of the icon.
 *
 * @example
 * ```html
 * <igx-icon color="#00ff00" isActive="true">home</igx-icon>
 * ```
 */
let NEXT_ID$7 = 0;
class IgxIconComponent {
    constructor(_el, iconService, ref) {
        this._el = _el;
        this.iconService = iconService;
        this.ref = ref;
        this.destroy$ = new Subject();
        /**
         *  This allows you to change the value of `class.igx-icon`. By default it's `igx-icon`.
         *
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-icon';
        /**
         *  This allows you to disable the `aria-hidden` attribute. By default it's applied.
         * @example
         * ```typescript
         * @ViewChild("MyIcon") public icon: IgxIconComponent;
         * constructor(private cdRef:ChangeDetectorRef) {}
         * ngAfterViewInit() {
         *     this.icon.ariaHidden = false;
         *     this.cdRef.detectChanges();
         * }
         * ```
         */
        this.ariaHidden = true;
        /**
         * An @Input property that sets the value of the `id` attribute.
         * @example
         * ```html
         * <igx-icon id="igx-icon-1" fontSet="material">settings</igx-icon>
         * ```
         */
        this.id = `igx-icon-${NEXT_ID$7++}`;
        /**
         * An @Input property that allows you to disable the `active` property. By default it's applied.
         * @example
         * ```html
         * <igx-icon [isActive]="false">settings</igx-icon>
         * ```
         */
        this.active = true;
        this.el = _el;
        this.font = this.iconService.defaultFontSet;
        this.iconService.registerFontSetAlias('material', 'material-icons');
        this.iconService.iconLoaded.pipe(first$1(e => e.name === this.iconName && e.fontSet === this.font), takeUntil(this.destroy$))
            .subscribe(_ => this.ref.detectChanges());
    }
    /**
     * @hidden
     * @internal
     */
    ngOnInit() {
        this.updateIconClass();
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     *  An accessor that returns the value of the font property.
     * @example
     * ```typescript
     *  @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconFont = this.icon.getFontSet;
     * }
     * ```
     */
    get getFontSet() {
        return this.font;
    }
    /**
     *  An accessor that returns the value of the active property.
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconActive = this.icon.getActive;
     * }
     * ```
     */
    get getActive() {
        return this.active;
    }
    /**
     *  An accessor that returns inactive property.
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconActive = this.icon.getInactive;
     * }
     * ```
     */
    get getInactive() {
        return !this.active;
    }
    /**
     * An accessor that returns the opposite value of the `iconColor` property.
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconColor = this.icon.getIconColor;
     * }
     * ```
     */
    get getIconColor() {
        return this.iconColor;
    }
    /**
     * An accessor that returns the value of the iconName property.
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconName = this.icon.getIconName;
     * }
     * ```
     */
    get getIconName() {
        return this.iconName;
    }
    /**
     *  An accessor that returns the key of the SVG image.
     *  The key consists of the fontSet and the iconName separated by underscore.
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let svgKey = this.icon.getSvgKey;
     * }
     * ```
     */
    get getSvgKey() {
        if (this.iconService.isSvgIconCached(this.iconName, this.font)) {
            return '#' + this.iconService.getSvgIconKey(this.iconName, this.font);
        }
        return null;
    }
    /**
     *   An accessor that returns a TemplateRef to explicit, svg or no ligature.
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconTemplate = this.icon.template;
     * }
     * ```
     */
    get template() {
        if (this.iconName) {
            if (this.iconService.isSvgIconCached(this.iconName, this.font)) {
                return this.svgImage;
            }
            return this.noLigature;
        }
        return this.explicitLigature;
    }
    /**
     * @hidden
     * @internal
     */
    updateIconClass() {
        const className = this.iconService.fontSetClassName(this.font);
        this.el.nativeElement.classList.add(className);
        if (this.iconName && !this.iconService.isSvgIconCached(this.iconName, this.font)) {
            this.el.nativeElement.classList.add(this.iconName);
        }
    }
}
IgxIconComponent.ɵfac = function IgxIconComponent_Factory(t) { return new (t || IgxIconComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxIconService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxIconComponent, selectors: [["igx-icon"]], viewQuery: function IgxIconComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c18, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c19, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c20, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.noLigature = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.explicitLigature = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.svgImage = _t.first);
    } }, hostVars: 8, hostBindings: function IgxIconComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-hidden", ctx.ariaHidden)("id", ctx.id);
        ɵngcc0.ɵɵstyleProp("color", ctx.getIconColor);
        ɵngcc0.ɵɵclassProp("igx-icon", ctx.cssClass)("igx-icon--inactive", ctx.getInactive);
    } }, inputs: { id: "id", active: ["isActive", "active"], font: ["fontSet", "font"], iconColor: ["color", "iconColor"], iconName: ["name", "iconName"] }, ngContentSelectors: _c2, decls: 7, vars: 1, consts: [["noLigature", ""], ["explicitLigature", ""], ["svgImage", ""], [4, "ngTemplateOutlet"]], template: function IgxIconComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, IgxIconComponent_ng_template_0_Template, 0, 0, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxIconComponent_ng_template_2_Template, 1, 0, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxIconComponent_ng_template_4_Template, 2, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxIconComponent_ng_container_6_Template, 1, 0, "ng-container", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template);
    } }, directives: [ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
IgxIconComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxIconService },
    { type: ChangeDetectorRef }
];
IgxIconComponent.propDecorators = {
    noLigature: [{ type: ViewChild, args: ['noLigature', { read: TemplateRef, static: true },] }],
    explicitLigature: [{ type: ViewChild, args: ['explicitLigature', { read: TemplateRef, static: true },] }],
    svgImage: [{ type: ViewChild, args: ['svgImage', { read: TemplateRef, static: true },] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-icon',] }],
    ariaHidden: [{ type: HostBinding, args: ['attr.aria-hidden',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    font: [{ type: Input, args: ['fontSet',] }],
    active: [{ type: Input, args: ['isActive',] }],
    iconColor: [{ type: Input, args: ['color',] }],
    iconName: [{ type: Input, args: ['name',] }],
    getInactive: [{ type: HostBinding, args: ['class.igx-icon--inactive',] }],
    getIconColor: [{ type: HostBinding, args: ['style.color',] }]
};

/**
 * @hidden
 */
class IgxIconModule {
}
IgxIconModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxIconModule });
IgxIconModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxIconModule_Factory(t) { return new (t || IgxIconModule)(); }, imports: [[CommonModule]] });

/**
 * @hidden
 */
class IgxActionStripModule {
}
IgxActionStripModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxActionStripModule });
IgxActionStripModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxActionStripModule_Factory(t) { return new (t || IgxActionStripModule)(); }, imports: [[CommonModule, IgxDropDownModule, IgxToggleModule, IgxButtonModule, IgxIconModule, IgxRippleModule]] });

let NEXT_ID$8 = 0;
const IgxAvatarSize = mkenum({
    SMALL: 'small',
    MEDIUM: 'medium',
    LARGE: 'large'
});
const IgxAvatarType = mkenum({
    INITIALS: 'initials',
    IMAGE: 'image',
    ICON: 'icon',
    CUSTOM: 'custom'
});
/**
 * Avatar provides a way to display an image, icon or initials to the user.
 *
 * @igxModule IgxAvatarModule
 *
 * @igxTheme igx-avatar-theme, igx-icon-theme
 *
 * @igxKeywords avatar, profile, picture, initials
 *
 * @igxGroup Layouts
 *
 * @remarks
 *
 * The Ignite UI Avatar provides an easy way to add an avatar icon to your application.  This icon can be an
 * image, someone's initials or a material icon from the Google Material icon set.
 *
 * @example
 * ```html
 * <igx-avatar initials="MS" [roundShape]="true" size="large">
 * </igx-avatar>
 * ```
 */
class IgxAvatarComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Returns the `aria-label` attribute of the avatar.
         *
         * @example
         * ```typescript
         * let ariaLabel = this.avatar.ariaLabel;
         * ```
         *
         */
        this.ariaLabel = 'avatar';
        /**
         * Returns the `role` attribute of the avatar.
         *
         * @example
         * ```typescript
         * let avatarRole = this.avatar.role;
         * ```
         */
        this.role = 'img';
        /**
         * Host `class.igx-avatar` binding.
         *
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-avatar';
        /**
         * Sets the `id` of the avatar. If not set, the first avatar component will have `id` = `"igx-avatar-0"`.
         *
         * @example
         * ```html
         * <igx-avatar id="my-first-avatar"></igx-avatar>
         * ```
         */
        this.id = `igx-avatar-${NEXT_ID$8++}`;
        /**
         * Sets a round shape to the avatar, if `[roundShape]` is set to `true`.
         * By default the shape of the avatar is a square.
         *
         * @example
         * ```html
         * <igx-avatar [roundShape]="true" ></igx-avatar>
         * ```
         */
        this.roundShape = false;
        /**
         * @hidden
         * @internal
         */
        this._size = IgxAvatarSize.SMALL;
    }
    /**
     * Returns the size of the avatar.
     *
     * @example
     * ```typescript
     * let avatarSize = this.avatar.size;
     * ```
     */
    get size() {
        return this._size;
    }
    /**
     * Sets the size  of the avatar.
     * By default, the size is `"small"`. It can be set to `"medium"` or `"large"`.
     *
     * @example
     * ```html
     * <igx-avatar size="large"></igx-avatar>
     * ```
     */
    set size(value) {
        switch (value) {
            case 'small':
            case 'medium':
            case 'large':
                this._size = value;
                break;
            default:
                this._size = 'small';
        }
    }
    /** @hidden @internal */
    get _isSmallSize() {
        return this.size === 'small';
    }
    /** @hidden @internal */
    get _isMediumSize() {
        return this.size === 'medium';
    }
    /** @hidden @internal */
    get _isLargeSize() {
        return this.size === 'large';
    }
    /**
     * Returns the type of the avatar.
     *
     * @example
     * ```typescript
     * let avatarType = this.avatar.type;
     * ```
     */
    get type() {
        if (this.src) {
            return IgxAvatarType.IMAGE;
        }
        if (this.icon) {
            return IgxAvatarType.ICON;
        }
        if (this.initials) {
            return IgxAvatarType.INITIALS;
        }
        return IgxAvatarType.CUSTOM;
    }
    /** @hidden @internal */
    get _isImageType() {
        return this.type === IgxAvatarType.IMAGE;
    }
    /** @hidden @internal */
    get _isIconType() {
        return this.type === IgxAvatarType.ICON;
    }
    /** @hidden @internal */
    get _isInitialsType() {
        return this.type === IgxAvatarType.INITIALS;
    }
    /**
     * Returns the template of the avatar.
     *
     * @hidden
     * @internal
     */
    get template() {
        switch (this.type) {
            case IgxAvatarType.IMAGE:
                return this.imageTemplate;
            case IgxAvatarType.INITIALS:
                return this.initialsTemplate;
            case IgxAvatarType.ICON:
                return this.iconTemplate;
            default:
                return this.defaultTemplate;
        }
    }
    /** @hidden @internal */
    ngOnInit() {
        this.roleDescription = this.getRole();
    }
    /** @hidden @internal */
    getRole() {
        switch (this.type) {
            case IgxAvatarType.IMAGE:
                return 'image avatar';
            case IgxAvatarType.ICON:
                return 'icon avatar';
            case IgxAvatarType.INITIALS:
                return 'initials avatar';
            default:
                return 'custom avatar';
        }
    }
    /**
     * Returns the css url of the image.
     *
     * @hidden
     * @internal
     */
    getSrcUrl() {
        return `url(${this.src})`;
    }
}
IgxAvatarComponent.ɵfac = function IgxAvatarComponent_Factory(t) { return new (t || IgxAvatarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxAvatarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxAvatarComponent, selectors: [["igx-avatar"]], viewQuery: function IgxAvatarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c21, true);
        ɵngcc0.ɵɵstaticViewQuery(_c22, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c23, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c24, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c25, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.image = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.imageTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.initialsTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.iconTemplate = _t.first);
    } }, hostVars: 24, hostBindings: function IgxAvatarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-label", ctx.ariaLabel)("role", ctx.role)("id", ctx.id)("aria-roledescription", ctx.roleDescription);
        ɵngcc0.ɵɵstyleProp("color", ctx.color)("background", ctx.bgColor);
        ɵngcc0.ɵɵclassProp("igx-avatar", ctx.cssClass)("igx-avatar--rounded", ctx.roundShape)("igx-avatar--small", ctx._isSmallSize)("igx-avatar--medium", ctx._isMediumSize)("igx-avatar--large", ctx._isLargeSize)("igx-avatar--image", ctx._isImageType)("igx-avatar--icon", ctx._isIconType)("igx-avatar--initials", ctx._isInitialsType);
    } }, inputs: { id: "id", roundShape: "roundShape", size: "size", color: "color", bgColor: "bgColor", initials: "initials", icon: "icon", src: "src" }, ngContentSelectors: _c2, decls: 9, vars: 1, consts: [["defaultTemplate", ""], ["imageTemplate", ""], ["initialsTemplate", ""], ["iconTemplate", ""], [4, "ngTemplateOutlet"], [1, "igx-avatar__image"], ["image", ""]], template: function IgxAvatarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, IgxAvatarComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxAvatarComponent_ng_template_2_Template, 2, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxAvatarComponent_ng_template_4_Template, 2, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxAvatarComponent_ng_template_6_Template, 2, 1, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, IgxAvatarComponent_ng_container_8_Template, 1, 0, "ng-container", 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(8);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template);
    } }, directives: [ɵngcc2.NgTemplateOutlet, IgxIconComponent], encapsulation: 2 });
IgxAvatarComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxAvatarComponent.propDecorators = {
    image: [{ type: ViewChild, args: ['image',] }],
    defaultTemplate: [{ type: ViewChild, args: ['defaultTemplate', { read: TemplateRef, static: true },] }],
    imageTemplate: [{ type: ViewChild, args: ['imageTemplate', { read: TemplateRef, static: true },] }],
    initialsTemplate: [{ type: ViewChild, args: ['initialsTemplate', { read: TemplateRef, static: true },] }],
    iconTemplate: [{ type: ViewChild, args: ['iconTemplate', { read: TemplateRef, static: true },] }],
    ariaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-avatar',] }],
    roleDescription: [{ type: HostBinding, args: ['attr.aria-roledescription',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    roundShape: [{ type: HostBinding, args: ['class.igx-avatar--rounded',] }, { type: Input }],
    color: [{ type: HostBinding, args: ['style.color',] }, { type: Input }],
    bgColor: [{ type: HostBinding, args: ['style.background',] }, { type: Input }],
    initials: [{ type: Input }],
    icon: [{ type: Input }],
    src: [{ type: Input }],
    size: [{ type: Input }],
    _isSmallSize: [{ type: HostBinding, args: ['class.igx-avatar--small',] }],
    _isMediumSize: [{ type: HostBinding, args: ['class.igx-avatar--medium',] }],
    _isLargeSize: [{ type: HostBinding, args: ['class.igx-avatar--large',] }],
    _isImageType: [{ type: HostBinding, args: ['class.igx-avatar--image',] }],
    _isIconType: [{ type: HostBinding, args: ['class.igx-avatar--icon',] }],
    _isInitialsType: [{ type: HostBinding, args: ['class.igx-avatar--initials',] }]
};
/**
 * @hidden
 */
class IgxAvatarModule {
}
IgxAvatarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxAvatarModule });
IgxAvatarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxAvatarModule_Factory(t) { return new (t || IgxAvatarModule)(); }, imports: [[CommonModule, IgxIconModule]] });

let NEXT_ID$9 = 0;
/**
 * Determines the igxBadge type
 */
const IgxBadgeType = mkenum({
    PRIMARY: 'primary',
    INFO: 'info',
    SUCCESS: 'success',
    WARNING: 'warning',
    ERROR: 'error'
});
/**
 * Badge provides visual notifications used to decorate avatars, menus, etc.
 *
 * @igxModule IgxBadgeModule
 *
 * @igxTheme igx-badge-theme
 *
 * @igxKeywords badge, icon, notification
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 * The Ignite UI Badge is used to decorate avatars, navigation menus, or other components in the
 * application when visual notification is needed. They are usually designed as icons with a predefined
 * style to communicate information, success, warnings, or errors.
 *
 * @example
 * ```html
 * <igx-avatar>
 *   <igx-badge icon="check" type="success"></igx-badge>
 * </igx-avatar>
 */
class IgxBadgeComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the badge.
         *
         * @remarks
         * If not set, the `id` will have value `"igx-badge-0"`.
         *
         * @example
         * ```html
         * <igx-badge id="igx-badge-2"></igx-badge>
         * ```
         */
        this.id = `igx-badge-${NEXT_ID$9++}`;
        /**
         * Sets/gets the type of the badge.
         *
         * @remarks
         * Allowed values are `primary`, `info`, `success`, `warning`, `error`.
         * Providing an invalid value won't display a badge.
         *
         * @example
         * ```html
         * <igx-badge type="success"></igx-badge>
         * ```
         */
        this.type = IgxBadgeType.PRIMARY;
        /**
         * Sets/gets the value to be displayed inside the badge.
         *
         * @remarks
         * If an `icon` property is already set the `icon` will be displayed.
         * If neither a `value` nor an `icon` is set the content of the badge will be empty.
         *
         * @example
         * ```html
         * <igx-badge value="11"></igx-badge>
         * ```
         */
        this.value = '';
        /**
         * Sets/gets the role attribute value.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.role = 'status';
         * ```
         */
        this.role = 'status';
        /**
         * Sets/gets the the css class to use on the badge.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.cssClass = 'my-badge-class';
         * ```
         */
        this.cssClass = 'igx-badge';
        /**
         * Sets/gets the aria-label attribute value.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.label = 'badge';
         * ```
         */
        this.label = 'badge';
    }
    /**
     * Defines a human-readable, accessor, author-localized description for
     * the `type` and the `icon` or `value` of the element.
     * @hidden
     * @internal
     */
    get roleDescription() {
        // tslint:disable-next-line:prefer-conditional-expression
        if (this.icon) {
            return this.type + ' type badge with icon type ' + this.icon;
        }
        else if (this.value || this.value === 0) {
            return this.type + ' badge type with value ' + this.value;
        }
        return this.type + ' badge type without value';
    }
    /**
     * Method which makes the name of the class more descriptive.
     * This helps the styling of the badges.
     * @hidden
     * @internal
     */
    setClasses() {
        let classes = {};
        switch (IgxBadgeType[this.type.toUpperCase()]) {
            case IgxBadgeType.INFO:
                classes = {
                    [`${this.cssClass}__circle--info`]: true
                };
                break;
            case IgxBadgeType.SUCCESS:
                classes = {
                    [`${this.cssClass}__circle--success`]: true
                };
                break;
            case IgxBadgeType.WARNING:
                classes = {
                    [`${this.cssClass}__circle--warning`]: true
                };
                break;
            case IgxBadgeType.ERROR:
                classes = {
                    [`${this.cssClass}__circle--error`]: true
                };
                break;
            default:
                classes = {
                    [`${this.cssClass}__circle--default`]: true
                };
        }
        return classes;
    }
}
IgxBadgeComponent.ɵfac = function IgxBadgeComponent_Factory(t) { return new (t || IgxBadgeComponent)(); };
IgxBadgeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxBadgeComponent, selectors: [["igx-badge"]], hostVars: 5, hostBindings: function IgxBadgeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role)("aria-label", ctx.label);
        ɵngcc0.ɵɵclassProp("igx-badge", ctx.cssClass);
    } }, inputs: { id: "id", type: "type", value: "value", icon: "icon" }, decls: 3, vars: 4, consts: [[1, "igx-badge__circle", 3, "ngClass"], ["class", "igx-badge__circle-value", 4, "ngIf"], ["fontSet", "material", 4, "ngIf"], [1, "igx-badge__circle-value"], ["fontSet", "material"]], template: function IgxBadgeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxBadgeComponent_span_1_Template, 2, 1, "span", 1);
        ɵngcc0.ɵɵtemplate(2, IgxBadgeComponent_igx_icon_2_Template, 2, 1, "igx-icon", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.setClasses());
        ɵngcc0.ɵɵattribute("aria-roledescription", ctx.roleDescription);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.icon);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.icon);
    } }, directives: [ɵngcc2.NgClass, ɵngcc2.NgIf, IgxIconComponent], encapsulation: 2 });
IgxBadgeComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    type: [{ type: Input }],
    value: [{ type: Input }],
    icon: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-badge',] }],
    label: [{ type: HostBinding, args: ['attr.aria-label',] }]
};
/**
 * @hidden
 */
class IgxBadgeModule {
}
IgxBadgeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxBadgeModule });
IgxBadgeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxBadgeModule_Factory(t) { return new (t || IgxBadgeModule)(); }, imports: [[CommonModule, IgxIconModule]] });

/** @hidden */
const IGX_EXPANSION_PANEL_COMPONENT = new InjectionToken('IgxExpansionPanelToken');

class IgxExpansionPanelBodyComponent {
    constructor(panel, element, cdr) {
        this.panel = panel;
        this.element = element;
        this.cdr = cdr;
        this._labelledBy = '';
        this._label = '';
        /**
         * @hidden
         */
        this.cssClass = `igx-expansion-panel__body`;
        /**
         * Gets/sets the `role` attribute of the panel body
         * Default is 'region';
         * Get
         * ```typescript
         *  const currentRole = this.panel.body.role;
         * ```
         * Set
         * ```typescript
         *  this.panel.body.role = 'content';
         * ```
         * ```html
         *  <igx-expansion-panel-body [role]="'custom'"></igx-expansion-panel-body>
         * ```
         */
        this.role = 'region';
    }
    /**
     * Gets the `aria-label` attribute of the panel body
     * Defaults to the panel id with '-region' in the end;
     * Get
     * ```typescript
     *  const currentLabel = this.panel.body.label;
     * ```
     */
    get label() {
        return this._label || this.panel.id + '-region';
    }
    /**
     * Sets the `aria-label` attribute of the panel body
     * ```typescript
     *  this.panel.body.label = 'my-custom-label';
     * ```
     * ```html
     *  <igx-expansion-panel-body [label]="'my-custom-label'"></igx-expansion-panel-body>
     * ```
     */
    set label(val) {
        this._label = val;
    }
    /**
     * Gets the `aria-labelledby` attribute of the panel body
     * Defaults to the panel header id;
     * Get
     * ```typescript
     *  const currentLabel = this.panel.body.labelledBy;
     * ```
     */
    get labelledBy() {
        return this._labelledBy;
    }
    /**
     * Sets the `aria-labelledby` attribute of the panel body
     * ```typescript
     *  this.panel.body.labelledBy = 'my-custom-id';
     * ```
     * ```html
     *  <igx-expansion-panel-body [labelledBy]="'my-custom-id'"></igx-expansion-panel-body>
     * ```
     */
    set labelledBy(val) {
        this._labelledBy = val;
    }
}
IgxExpansionPanelBodyComponent.ɵfac = function IgxExpansionPanelBodyComponent_Factory(t) { return new (t || IgxExpansionPanelBodyComponent)(ɵngcc0.ɵɵdirectiveInject(IGX_EXPANSION_PANEL_COMPONENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxExpansionPanelBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExpansionPanelBodyComponent, selectors: [["igx-expansion-panel-body"]], hostVars: 5, hostBindings: function IgxExpansionPanelBodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("aria-label", ctx.label)("aria-labelledby", ctx.labelledBy);
        ɵngcc0.ɵɵclassProp("igx-expansion-panel__body", ctx.cssClass);
    } }, inputs: { role: "role", label: "label", labelledBy: "labelledBy" }, ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxExpansionPanelBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
IgxExpansionPanelBodyComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxExpansionPanelBodyComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel__body',] }],
    label: [{ type: Input }, { type: HostBinding, args: ['attr.aria-label',] }],
    labelledBy: [{ type: Input }, { type: HostBinding, args: ['attr.aria-labelledby',] }],
    role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }]
};

/**
 * @hidden @internal
 */
class IgxExpansionPanelTitleDirective {
    constructor() {
        this.cssClass = `igx-expansion-panel__header-title`;
    }
}
IgxExpansionPanelTitleDirective.ɵfac = function IgxExpansionPanelTitleDirective_Factory(t) { return new (t || IgxExpansionPanelTitleDirective)(); };
IgxExpansionPanelTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExpansionPanelTitleDirective, selectors: [["igx-expansion-panel-title"]], hostVars: 2, hostBindings: function IgxExpansionPanelTitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-expansion-panel__header-title", ctx.cssClass);
    } } });
IgxExpansionPanelTitleDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel__header-title',] }]
};
/**
 * @hidden @internal
 */
class IgxExpansionPanelDescriptionDirective {
    constructor() {
        this.cssClass = `igx-expansion-panel__header-description`;
    }
}
IgxExpansionPanelDescriptionDirective.ɵfac = function IgxExpansionPanelDescriptionDirective_Factory(t) { return new (t || IgxExpansionPanelDescriptionDirective)(); };
IgxExpansionPanelDescriptionDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExpansionPanelDescriptionDirective, selectors: [["igx-expansion-panel-description"]], hostVars: 2, hostBindings: function IgxExpansionPanelDescriptionDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-expansion-panel__header-description", ctx.cssClass);
    } } });
IgxExpansionPanelDescriptionDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel__header-description',] }]
};
/**
 * @hidden @internal
 */
class IgxExpansionPanelIconDirective {
}
IgxExpansionPanelIconDirective.ɵfac = function IgxExpansionPanelIconDirective_Factory(t) { return new (t || IgxExpansionPanelIconDirective)(); };
IgxExpansionPanelIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExpansionPanelIconDirective, selectors: [["igx-expansion-panel-icon"]] });

/**
 * @hidden
 */
const ICON_POSITION = mkenum({
    LEFT: 'left',
    NONE: 'none',
    RIGHT: 'right'
});
class IgxExpansionPanelHeaderComponent {
    constructor(panel, cdr, elementRef) {
        this.panel = panel;
        this.cdr = cdr;
        this.elementRef = elementRef;
        // properties section
        this._iconTemplate = false;
        /**
         * Sets/gets the `id` of the expansion panel header.
         * ```typescript
         * let panelHeaderId =  this.panel.header.id;
         * ```
         * @memberof IgxExpansionPanelComponent
         */
        this.id = '';
        /**
         * Gets/sets the `aria-level` attribute of the header
         * Get
         * ```typescript
         *  const currentAriaLevel = this.panel.header.lv;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.lv = '5';
         * ```
         * ```html
         *  <igx-expansion-panel-header [lv]="myCustomLevel"></igx-expansion-panel-header>
         * ```
         */
        this.lv = '3';
        /**
         * Gets/sets the `role` attribute of the header
         * Get
         * ```typescript
         *  const currentRole = this.panel.header.role;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.role = '5';
         * ```
         * ```html
         *  <igx-expansion-panel-header [role]="'custom'"></igx-expansion-panel-header>
         * ```
         */
        this.role = 'heading';
        /**
         * Gets/sets the position of the expansion-panel-header expand/collapse icon
         * Accepts `left`, `right` or `none`
         * ```typescript
         *  const currentIconPosition = this.panel.header.iconPosition;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.iconPosition = 'left';
         * ```
         * ```html
         *  <igx-expansion-panel-header [iconPosition]="'right'"></igx-expansion-panel-header>
         * ```
         */
        this.iconPosition = ICON_POSITION.LEFT;
        /**
         * Emitted whenever a user interacts with the header host
         * ```typescript
         *  handleInteraction(event: IExpansionPanelCancelableEventArgs) {
         *  ...
         * }
         * ```
         * ```html
         *  <igx-expansion-panel-header (onInteraction)="handleInteraction($event)">
         *      ...
         *  </igx-expansion-panel-header>
         * ```
         */
        this.onInteraction = new EventEmitter();
        /**
         * @hidden
         */
        this.cssClass = 'igx-expansion-panel__header';
        /**
         * Gets/sets the whether the header is disabled
         * When disabled, the header will not handle user events and will stop their propagation
         *
         * ```typescript
         *  const isDisabled = this.panel.header.disabled;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.disabled = true;
         * ```
         * ```html
         *  <igx-expansion-panel-header [disabled]="true">
         *     ...
         *  </igx-expansion-panel-header>
         * ```
         */
        this.disabled = false;
        this.id = `${this.panel.id}-header`;
    }
    /**
     * Returns a reference to the `igx-expansion-panel-icon` element;
     * If `iconPosition` is `NONE` - return null;
     */
    get iconRef() {
        var _a;
        const renderedTemplate = (_a = this.customIconRef) !== null && _a !== void 0 ? _a : this.defaultIconRef;
        return this.iconPosition !== ICON_POSITION.NONE ? renderedTemplate : null;
    }
    /**
     * @hidden
     */
    set iconTemplate(val) {
        this._iconTemplate = val;
    }
    /**
     * @hidden
     */
    get iconTemplate() {
        return this._iconTemplate;
    }
    /**
     * @hidden
     */
    get controls() {
        return this.panel.id;
    }
    /**
     * @hidden
     */
    get isExpanded() {
        return !this.panel.collapsed;
    }
    /**
     * @hidden
     */
    onAction(evt) {
        if (this.disabled) {
            evt.stopPropagation();
            return;
        }
        const eventArgs = { event: evt, panel: this.panel, owner: this.panel, cancel: false };
        this.onInteraction.emit(eventArgs);
        if (eventArgs.cancel === true) {
            return;
        }
        this.panel.toggle(evt);
        evt.preventDefault();
    }
    /** @hidden @internal */
    openPanel(event) {
        if (event.altKey) {
            const eventArgs = { event, panel: this.panel, owner: this.panel, cancel: false };
            this.onInteraction.emit(eventArgs);
            if (eventArgs.cancel === true) {
                return;
            }
            this.panel.expand(event);
        }
    }
    /** @hidden @internal */
    closePanel(event) {
        if (event.altKey) {
            const eventArgs = { event, panel: this.panel, owner: this.panel, cancel: false };
            this.onInteraction.emit(eventArgs);
            if (eventArgs.cancel === true) {
                return;
            }
            this.panel.collapse(event);
        }
    }
    /**
     * @hidden
     */
    get iconPositionClass() {
        switch (this.iconPosition) {
            case (ICON_POSITION.LEFT):
                return `igx-expansion-panel__header-icon--start`;
            case (ICON_POSITION.RIGHT):
                return `igx-expansion-panel__header-icon--end`;
            case (ICON_POSITION.NONE):
                return `igx-expansion-panel__header-icon--none`;
            default:
                return '';
        }
    }
}
IgxExpansionPanelHeaderComponent.ɵfac = function IgxExpansionPanelHeaderComponent_Factory(t) { return new (t || IgxExpansionPanelHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(IGX_EXPANSION_PANEL_COMPONENT, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxExpansionPanelHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExpansionPanelHeaderComponent, selectors: [["igx-expansion-panel-header"]], contentQueries: function IgxExpansionPanelHeaderComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExpansionPanelIconDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExpansionPanelIconDirective, true, ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.iconTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customIconRef = _t.first);
    } }, viewQuery: function IgxExpansionPanelHeaderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxIconComponent, true, ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultIconRef = _t.first);
    } }, hostVars: 8, hostBindings: function IgxExpansionPanelHeaderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.Enter", function IgxExpansionPanelHeaderComponent_keydown_Enter_HostBindingHandler($event) { return ctx.onAction($event); })("keydown.Space", function IgxExpansionPanelHeaderComponent_keydown_Space_HostBindingHandler($event) { return ctx.onAction($event); })("keydown.Spacebar", function IgxExpansionPanelHeaderComponent_keydown_Spacebar_HostBindingHandler($event) { return ctx.onAction($event); })("click", function IgxExpansionPanelHeaderComponent_click_HostBindingHandler($event) { return ctx.onAction($event); })("keydown.Alt.ArrowDown", function IgxExpansionPanelHeaderComponent_keydown_Alt_ArrowDown_HostBindingHandler($event) { return ctx.openPanel($event); })("keydown.Alt.ArrowUp", function IgxExpansionPanelHeaderComponent_keydown_Alt_ArrowUp_HostBindingHandler($event) { return ctx.closePanel($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-level", ctx.lv)("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-expansion-panel__header", ctx.cssClass)("igx-expansion-panel--disabled", ctx.disabled)("igx-expansion-panel__header--expanded", ctx.isExpanded);
    } }, inputs: { lv: "lv", role: "role", iconPosition: "iconPosition", disabled: "disabled" }, outputs: { onInteraction: "onInteraction" }, ngContentSelectors: _c27, decls: 8, vars: 8, consts: [["tabindex", "0", "role", "button", 1, "igx-expansion-panel__header-inner"], [1, "igx-expansion-panel__title-wrapper"], [4, "ngIf"], ["fontSet", "material", 4, "ngIf"], ["fontSet", "material"]], template: function IgxExpansionPanelHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c26);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵprojection(3, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(4, 2);
        ɵngcc0.ɵɵelementStart(5, "div");
        ɵngcc0.ɵɵtemplate(6, IgxExpansionPanelHeaderComponent_ng_content_6_Template, 1, 0, "ng-content", 2);
        ɵngcc0.ɵɵtemplate(7, IgxExpansionPanelHeaderComponent_igx_icon_7_Template, 2, 1, "igx-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("aria-disabled", ctx.disabled)("aria-expanded", ctx.isExpanded)("aria-controls", ctx.controls);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵclassMap(ctx.iconPositionClass);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.iconTemplate);
    } }, directives: [ɵngcc2.NgIf, IgxIconComponent], encapsulation: 2 });
IgxExpansionPanelHeaderComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Host }, { type: Inject, args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
IgxExpansionPanelHeaderComponent.propDecorators = {
    customIconRef: [{ type: ContentChild, args: [IgxExpansionPanelIconDirective, { read: ElementRef },] }],
    defaultIconRef: [{ type: ViewChild, args: [IgxIconComponent, { read: ElementRef },] }],
    iconTemplate: [{ type: ContentChild, args: [IgxExpansionPanelIconDirective,] }],
    lv: [{ type: HostBinding, args: ['attr.aria-level',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    iconPosition: [{ type: Input }],
    onInteraction: [{ type: Output }],
    cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel__header',] }],
    isExpanded: [{ type: HostBinding, args: ['class.igx-expansion-panel__header--expanded',] }],
    disabled: [{ type: Input }, { type: HostBinding, args: ['class.igx-expansion-panel--disabled',] }],
    onAction: [{ type: HostListener, args: ['keydown.Enter', ['$event'],] }, { type: HostListener, args: ['keydown.Space', ['$event'],] }, { type: HostListener, args: ['keydown.Spacebar', ['$event'],] }, { type: HostListener, args: ['click', ['$event'],] }],
    openPanel: [{ type: HostListener, args: ['keydown.Alt.ArrowDown', ['$event'],] }],
    closePanel: [{ type: HostListener, args: ['keydown.Alt.ArrowUp', ['$event'],] }]
};

let NEXT_ID$a = 0;
class IgxExpansionPanelComponent {
    constructor(cdr, builder) {
        this.cdr = cdr;
        this.builder = builder;
        this._collapsed = true;
        /**
         * Sets/gets the animation settings of the expansion panel component
         * Open and Close animation should be passed
         *
         * Get
         * ```typescript
         *  const currentAnimations = this.panel.animationSettings;
         * ```
         * Set
         * ```typescript
         *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
         *  ...
         *  this.panel.animationsSettings = {
         *      openAnimation: slideInLeft,
         *      closeAnimation: slideOutRight
         * };
         * ```
         * or via template
         * ```typescript
         *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
         *  ...
         *  myCustomAnimationObject = {
         *      openAnimation: slideInLeft,
         *      closeAnimation: slideOutRight
         * };
         * ```html
         *  <igx-expansion-panel [animationSettings]='myCustomAnimationObject'>
         *  ...
         *  </igx-expansion-panel>
         * ```
         */
        this.animationSettings = {
            openAnimation: growVerIn,
            closeAnimation: growVerOut
        };
        /**
         * Sets/gets the `id` of the expansion panel component.
         * If not set, `id` will have value `"igx-expansion-panel-0"`;
         * ```html
         * <igx-expansion-panel id = "my-first-expansion-panel"></igx-expansion-panel>
         * ```
         * ```typescript
         * let panelId =  this.panel.id;
         * ```
         * @memberof IgxExpansionPanelComponent
         */
        this.id = `igx-expansion-panel-${NEXT_ID$a++}`;
        /**
         * @hidden
         */
        this.cssClass = 'igx-expansion-panel';
        /**
         * @hidden
         */
        this.collapsedChange = new EventEmitter();
        /**
         * Emitted when the expansion panel finishes collapsing
         * ```typescript
         *  handleCollapsed(event: IExpansionPanelEventArgs)
         * ```
         * ```html
         *  <igx-expansion-panel (onCollapsed)="handleCollapsed($event)">
         *      ...
         *  </igx-expansion-panel>
         * ```
         */
        this.onCollapsed = new EventEmitter();
        /**
         * Emitted when the expansion panel finishes expanding
         * ```typescript
         *  handleExpanded(event: IExpansionPanelEventArgs)
         * ```
         * ```html
         *  <igx-expansion-panel (onExpanded)="handleExpanded($event)">
         *      ...
         *  </igx-expansion-panel>
         * ```
         */
        this.onExpanded = new EventEmitter();
    }
    /**
     * Gets/sets whether the component is collapsed (its content is hidden)
     * Get
     * ```typescript
     *  const myPanelState: boolean = this.panel.collapsed;
     * ```
     * Set
     * ```html
     *  this.panel.collapsed = true;
     * ```
     *
     * Two-way data binding:
     * ```html
     * <igx-expansion-panel [(collapsed)]="model.isCollapsed"></igx-expansion-panel>
     * ```
     */
    get collapsed() {
        return this._collapsed;
    }
    set collapsed(value) {
        this._collapsed = value;
        this.collapsedChange.emit(this._collapsed);
    }
    /**
     * @hidden
     */
    get headerId() {
        return this.header ? `${this.id}-header` : '';
    }
    /** @hidden */
    ngAfterContentInit() {
        if (this.body && this.header) {
            // schedule at end of turn:
            Promise.resolve().then(() => {
                this.body.labelledBy = this.body.labelledBy || this.headerId;
                this.body.label = this.body.label || this.id + '-region';
            });
        }
    }
    playOpenAnimation(cb) {
        if (!this.body) { // if not body element is passed, there is nothing to animate
            return;
        }
        const animation = useAnimation(this.animationSettings.openAnimation);
        const animationBuilder = this.builder.build(animation);
        const openAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
        openAnimationPlayer.onDone(() => {
            cb();
            openAnimationPlayer.reset();
        });
        openAnimationPlayer.play();
    }
    playCloseAnimation(cb) {
        if (!this.body) { // if not body element is passed, there is nothing to animate
            return;
        }
        const animation = useAnimation(this.animationSettings.closeAnimation);
        const animationBuilder = this.builder.build(animation);
        const closeAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
        closeAnimationPlayer.onDone(() => {
            cb();
            closeAnimationPlayer.reset();
        });
        closeAnimationPlayer.play();
    }
    /**
     * Collapses the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.collapse($event)">Collpase Panel</button>
     * ```
     */
    collapse(evt) {
        if (this.collapsed) { // If expansion panel is already collapsed, do nothing
            return;
        }
        this.playCloseAnimation(() => {
            this.onCollapsed.emit({ event: evt, panel: this, owner: this });
            this.collapsed = true;
        });
    }
    /**
     * Expands the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.expand($event)">Expand Panel</button>
     * ```
     */
    expand(evt) {
        if (!this.collapsed) { // If the panel is already opened, do nothing
            return;
        }
        this.collapsed = false;
        this.cdr.detectChanges();
        this.playOpenAnimation(() => {
            this.onExpanded.emit({ event: evt, panel: this, owner: this });
        });
    }
    /**
     * Toggles the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.toggle($event)">Expand Panel</button>
     * ```
     */
    toggle(evt) {
        if (this.collapsed) {
            this.open(evt);
        }
        else {
            this.close(evt);
        }
    }
    open(evt) {
        this.expand(evt);
    }
    close(evt) {
        this.collapse(evt);
    }
}
IgxExpansionPanelComponent.ɵfac = function IgxExpansionPanelComponent_Factory(t) { return new (t || IgxExpansionPanelComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AnimationBuilder)); };
IgxExpansionPanelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExpansionPanelComponent, selectors: [["igx-expansion-panel"]], contentQueries: function IgxExpansionPanelComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExpansionPanelBodyComponent, true, IgxExpansionPanelBodyComponent);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExpansionPanelHeaderComponent, true, IgxExpansionPanelHeaderComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.body = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.header = _t.first);
    } }, hostVars: 3, hostBindings: function IgxExpansionPanelComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-expansion-panel", ctx.cssClass);
    } }, inputs: { animationSettings: "animationSettings", id: "id", collapsed: "collapsed" }, outputs: { collapsedChange: "collapsedChange", onCollapsed: "onCollapsed", onExpanded: "onExpanded" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IGX_EXPANSION_PANEL_COMPONENT, useExisting: IgxExpansionPanelComponent }])], ngContentSelectors: _c29, decls: 2, vars: 1, consts: [[4, "ngIf"]], template: function IgxExpansionPanelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c28);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, IgxExpansionPanelComponent_ng_content_1_Template, 1, 0, "ng-content", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.collapsed);
    } }, directives: [ɵngcc2.NgIf], encapsulation: 2 });
IgxExpansionPanelComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: AnimationBuilder }
];
IgxExpansionPanelComponent.propDecorators = {
    animationSettings: [{ type: Input }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel',] }],
    collapsed: [{ type: Input }],
    collapsedChange: [{ type: Output }],
    onCollapsed: [{ type: Output }],
    onExpanded: [{ type: Output }],
    body: [{ type: ContentChild, args: [IgxExpansionPanelBodyComponent, { read: IgxExpansionPanelBodyComponent },] }],
    header: [{ type: ContentChild, args: [IgxExpansionPanelHeaderComponent, { read: IgxExpansionPanelHeaderComponent },] }]
};

/**
 * @hidden
 */
class IgxExpansionPanelModule {
}
IgxExpansionPanelModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxExpansionPanelModule });
IgxExpansionPanelModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxExpansionPanelModule_Factory(t) { return new (t || IgxExpansionPanelModule)(); }, imports: [[
            CommonModule,
            IgxRippleModule,
            IgxIconModule,
            IgxButtonModule,
            IgxAvatarModule
        ]] });

// tslint:disable:directive-selector
class IgxBannerActionsDirective {
}
IgxBannerActionsDirective.ɵfac = function IgxBannerActionsDirective_Factory(t) { return new (t || IgxBannerActionsDirective)(); };
IgxBannerActionsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxBannerActionsDirective, selectors: [["igx-banner-actions"]] });

/**
 * **Ignite UI for Angular Banner** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/banner.html)
 *
 * The Ignite UI Banner provides a highly templateable and easy to use banner that can be shown in your application.
 *
 * Usage:
 *
 * ```html
 * <igx-banner #banner>
 *   Our privacy settings have changed.
 *  <igx-banner-actions>
 *      <button igxButton="raised">Read More</button>
 *      <button igxButton="raised">Accept and Continue</button>
 *  </igx-banner-actions>
 * </igx-banner>
 * ```
 */
class IgxBannerComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Fires after the banner shows up
         * ```typescript
         * public handleOpened(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onOpened)="handleOpened($event)"></igx-banner>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Fires before the banner shows up
         * ```typescript
         * public handleOpening(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onOpening)="handleOpening($event)"></igx-banner>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Fires after the banner hides
         * ```typescript
         * public handleClosed(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onClosed)="handleClosed($event)"></igx-banner>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Fires before the banner hides
         * ```typescript
         * public handleClosing(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onClosing)="handleClosing($event)"></igx-banner>
         * ```
         */
        this.onClosing = new EventEmitter();
    }
    /** @hidden */
    get useDefaultTemplate() {
        return !this._bannerActionTemplate;
    }
    /**
     * Get the animation settings used by the banner open/close methods
     * ```typescript
     * let currentAnimations: AnimationSettings = banner.animationSettings
     * ```
     */
    get animationSettings() {
        return this._animationSettings ? this._animationSettings : this._expansionPanel.animationSettings;
    }
    /**
     * Set the animation settings used by the banner open/close methods
     * ```typescript
     * import { slideInLeft, slideOutRight } from 'igniteui-angular';
     * ...
     * banner.animationSettings: AnimationSettings = { openAnimation: slideInLeft, closeAnimation: slideOutRight };
     * ```
     */
    set animationSettings(settings) {
        this._animationSettings = settings;
    }
    /**
     * Gets whether banner is collapsed
     *
     * ```typescript
     * const isCollapsed: boolean = banner.collapsed;
     * ```
     */
    get collapsed() {
        return this._expansionPanel.collapsed;
    }
    /**
     * Returns the native element of the banner component
     * ```typescript
     *  const myBannerElement: HTMLElement = banner.element;
     * ```
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get displayStyle() {
        return this.collapsed ? '' : 'block';
    }
    /**
     * Opens the banner
     *
     * ```typescript
     *  myBanner.open();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.open()">Open Banner</button>
     * ```
     */
    open(event) {
        this._bannerEvent = { banner: this, event };
        const openingArgs = {
            banner: this,
            event,
            cancel: false
        };
        this.onOpening.emit(openingArgs);
        if (openingArgs.cancel) {
            return;
        }
        this._expansionPanel.open(event);
    }
    /**
     * Closes the banner
     *
     * ```typescript
     *  myBanner.close();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.close()">Close Banner</button>
     * ```
     */
    close(event) {
        this._bannerEvent = { banner: this, event };
        const closingArgs = {
            banner: this,
            event,
            cancel: false
        };
        this.onClosing.emit(closingArgs);
        if (closingArgs.cancel) {
            return;
        }
        this._expansionPanel.close(event);
    }
    /**
     * Toggles the banner
     *
     * ```typescript
     *  myBanner.toggle();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.toggle()">Toggle Banner</button>
     * ```
     */
    toggle(event) {
        if (this.collapsed) {
            this.open(event);
        }
        else {
            this.close(event);
        }
    }
    /** @hidden */
    onExpansionPanelOpen() {
        this.onOpened.emit(this._bannerEvent);
    }
    /** @hidden */
    onExpansionPanelClose() {
        this.onClosed.emit(this._bannerEvent);
    }
}
IgxBannerComponent.ɵfac = function IgxBannerComponent_Factory(t) { return new (t || IgxBannerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxBannerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxBannerComponent, selectors: [["igx-banner"]], contentQueries: function IgxBannerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxBannerActionsDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxIconComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._bannerActionTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.bannerIcon = _t.first);
    } }, viewQuery: function IgxBannerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c30, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._expansionPanel = _t.first);
    } }, hostVars: 2, hostBindings: function IgxBannerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.displayStyle);
    } }, inputs: { animationSettings: "animationSettings" }, outputs: { onOpened: "onOpened", onOpening: "onOpening", onClosed: "onClosed", onClosing: "onClosing" }, ngContentSelectors: _c32, decls: 12, vars: 6, consts: [["aria-live", "polite", 3, "animationSettings", "collapsed", "onCollapsed", "onExpanded"], ["expansionPanel", ""], [1, "igx-banner"], [1, "igx-banner__message"], ["class", "igx-banner__illustration", 4, "ngIf"], [1, "igx-banner__text"], [1, "igx-banner__actions"], [1, "igx-banner__row"], [4, "ngIf"], [1, "igx-banner__illustration"], ["igxButton", "flat", "igxRipple", "", 3, "click"]], template: function IgxBannerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c31);
        ɵngcc0.ɵɵelementStart(0, "igx-expansion-panel", 0, 1);
        ɵngcc0.ɵɵlistener("onCollapsed", function IgxBannerComponent_Template_igx_expansion_panel_onCollapsed_0_listener() { return ctx.onExpansionPanelClose(); })("onExpanded", function IgxBannerComponent_Template_igx_expansion_panel_onExpanded_0_listener() { return ctx.onExpansionPanelOpen(); });
        ɵngcc0.ɵɵelementStart(2, "igx-expansion-panel-body");
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵtemplate(5, IgxBannerComponent_div_5_Template, 2, 0, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "span", 5);
        ɵngcc0.ɵɵprojection(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div", 6);
        ɵngcc0.ɵɵelementStart(9, "div", 7);
        ɵngcc0.ɵɵtemplate(10, IgxBannerComponent_ng_container_10_Template, 3, 0, "ng-container", 8);
        ɵngcc0.ɵɵtemplate(11, IgxBannerComponent_ng_container_11_Template, 2, 0, "ng-container", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("animationSettings", ctx.animationSettings)("collapsed", ctx.collapsed);
        ɵngcc0.ɵɵattribute("aria-hidden", ctx.collapsed);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.bannerIcon);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.useDefaultTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.useDefaultTemplate);
    } }, directives: [IgxExpansionPanelComponent, IgxExpansionPanelBodyComponent, ɵngcc2.NgIf, IgxButtonDirective, IgxRippleDirective], encapsulation: 2 });
IgxBannerComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxBannerComponent.propDecorators = {
    _expansionPanel: [{ type: ViewChild, args: ['expansionPanel', { static: true },] }],
    _bannerActionTemplate: [{ type: ContentChild, args: [IgxBannerActionsDirective,] }],
    bannerIcon: [{ type: ContentChild, args: [IgxIconComponent,] }],
    onOpened: [{ type: Output }],
    onOpening: [{ type: Output }],
    onClosed: [{ type: Output }],
    onClosing: [{ type: Output }],
    animationSettings: [{ type: Input }],
    displayStyle: [{ type: HostBinding, args: ['style.display',] }]
};
/**
 * @hidden
 */
class IgxBannerModule {
}
IgxBannerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxBannerModule });
IgxBannerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxBannerModule_Factory(t) { return new (t || IgxBannerModule)(); }, imports: [[CommonModule, IgxExpansionPanelModule, IgxIconModule, IgxButtonModule, IgxRippleModule]] });

var ButtonGroupAlignment;
(function (ButtonGroupAlignment) {
    ButtonGroupAlignment[ButtonGroupAlignment["horizontal"] = 0] = "horizontal";
    ButtonGroupAlignment[ButtonGroupAlignment["vertical"] = 1] = "vertical";
})(ButtonGroupAlignment || (ButtonGroupAlignment = {}));
let NEXT_ID$b = 0;
/**
 * **Ignite UI for Angular Button Group** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/buttongroup.html)
 *
 * The Ignite UI Button Group displays a group of buttons either vertically or horizontally.  The group supports
 * single, multiple and toggle selection.
 *
 * Example:
 * ```html
 * <igx-buttongroup multiSelection="true" [values]="fontOptions">
 * </igx-buttongroup>
 * ```
 * The `fontOptions` value shown above is defined as:
 * ```typescript
 * this.fontOptions = [
 *   { icon: 'format_bold', selected: false },
 *   { icon: 'format_italic', selected: false },
 *   { icon: 'format_underlined', selected: false }];
 * ```
 */
class IgxButtonGroupComponent extends DisplayDensityBase {
    constructor(_cdr, _renderer, _displayDensityOptions) {
        super(_displayDensityOptions);
        this._cdr = _cdr;
        this._renderer = _renderer;
        this._displayDensityOptions = _displayDensityOptions;
        this._disabled = false;
        this.buttonClickNotifier$ = new Subject();
        this.queryListNotifier$ = new Subject();
        /**
         * An @Input property that sets the value of the `id` attribute. If not set it will be automatically generated.
         * ```html
         *  <igx-buttongroup [id]="'igx-dialog-56'" [multiSelection]="!multi" [values]="alignOptions">
         * ```
         */
        this.id = `igx-buttongroup-${NEXT_ID$b++}`;
        /**
         * @hidden
         */
        this.zIndex = 0;
        /**
         * An @Input property that enables selecting multiple buttons. By default, multi-selection is false.
         * ```html
         * <igx-buttongroup [multiSelection]="false" [alignment]="alignment"></igx-buttongroup>
         * ```
         */
        this.multiSelection = false;
        /**
         * @hidden
         */
        this.selectedIndexes = [];
        /**
         * An @Ouput property that emits an event when a button is selected.
         * ```typescript
         * @ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onSelect(buttongroup){
         *     this.toast.show()
         * }
         *  //...
         * ```
         * ```html
         * <igx-buttongroup #MyChild [multiSelection]="!multi" (onSelect)="onSelect($event)"></igx-buttongroup>
         * <igx-toast #toast message="You have made a selection!"></igx-toast>
         * ```
         */
        this.onSelect = new EventEmitter();
        /**
         * An @Ouput property that emits an event when a button is deselected.
         * ```typescript
         *  @ViewChild("toast")
         *  private toast: IgxToastComponent;
         *  public onUnselect(buttongroup){
         *     this.toast.show()
         * }
         *  //...
         * ```
         * ```html
         * <igx-buttongroup> #MyChild [multiSelection]="multi" (onUnselect)="onUnselect($event)"></igx-buttongroup>
         * <igx-toast #toast message="You have deselected a button!"></igx-toast>
         * ```
         */
        this.onUnselect = new EventEmitter();
    }
    /**
     * A collection containing all buttons inside the button group.
     */
    get buttons() {
        return [...this.viewButtons.toArray(), ...this.templateButtons.toArray()];
    }
    /**
     * Allows you to set a style using the `itemContentCssClass` input.
     * The value should be the CSS class name that will be applied to the button group.
     * ```typescript
     * public style1 = "styleClass";
     *  //..
     * ```
     *  ```html
     * <igx-buttongroup [itemContentCssClass]="style1" [multiSelection]="!multi" [values]="alignOptions">
     * ```
     */
    set itemContentCssClass(value) {
        this._itemContentCssClass = value || this._itemContentCssClass;
    }
    /**
     * Returns the CSS class of the item content of the `IgxButtonGroup`.
     * ```typescript
     *  @ViewChild("MyChild")
     * public buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let buttonSelect = this.buttonG.itemContentCssClass;
     * }
     * ```
     */
    get itemContentCssClass() {
        return this._itemContentCssClass;
    }
    /**
     * An @Input property that allows you to disable the `igx-buttongroup` component. By default it's false.
     * ```html
     * <igx-buttongroup [disabled]="true" [multiSelection]="multi" [values]="fontOptions"></igx-buttongroup>
     * ```
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        if (this._disabled !== value) {
            this._disabled = value;
            if (this.viewButtons && this.templateButtons) {
                this.buttons.forEach((b) => b.disabled = this._disabled);
            }
        }
    }
    /**
     * Allows you to set the button group alignment.
     * Available options are `ButtonGroupAlignment.horizontal` (default) and `ButtonGroupAlignment.vertical`.
     * ```typescript
     * public alignment = ButtonGroupAlignment.vertical;
     * //..
     * ```
     * ```html
     * <igx-buttongroup [multiSelection]="false" [values]="cities" [alignment]="alignment"></igx-buttongroup>
     * ```
     */
    set alignment(value) {
        this._isVertical = value === ButtonGroupAlignment.vertical;
    }
    /**
     * Returns the alignment of the `igx-buttongroup`.
     * ```typescript
     * @ViewChild("MyChild")
     * public buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let buttonAlignment = this.buttonG.alignment;
     * }
     * ```
     */
    get alignment() {
        return this._isVertical ? ButtonGroupAlignment.vertical : ButtonGroupAlignment.horizontal;
    }
    /**
     * Returns true if the `igx-buttongroup` alignment is vertical.
     * Note that in order for the accessor to work correctly the property should be set explicitly.
     * ```html
     * <igx-buttongroup #MyChild [alignment]="alignment" [values]="alignOptions">
     * ```
     * ```typescript
     * //...
     * @ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let orientation = this.buttonG.isVertical;
     * }
     * ```
     */
    get isVertical() {
        return this._isVertical;
    }
    /**
     * Gets the selected button/buttons.
     * ```typescript
     * @ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let selectedButton = this.buttonG.selectedButtons;
     * }
     * ```
     */
    get selectedButtons() {
        return this.buttons.filter((b, i) => {
            return this.selectedIndexes.indexOf(i) !== -1;
        });
    }
    /**
     * Selects a button by its index.
     * ```typescript
     * @ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    this.buttonG.selectButton(2);
     *    this.cdr.detectChanges();
     * }
     * ```
     * @memberOf {@link IgxButtonGroupComponent}
     */
    selectButton(index) {
        if (index >= this.buttons.length || index < 0) {
            return;
        }
        const button = this.buttons[index];
        const buttonElement = button.nativeElement;
        this.selectedIndexes.push(index);
        button.selected = true;
        this._renderer.setAttribute(buttonElement, 'aria-pressed', 'true');
        this._renderer.addClass(buttonElement, 'igx-button-group__item--selected');
        this.onSelect.emit({ button: button, index: index });
        const indexInViewButtons = this.viewButtons.toArray().indexOf(button);
        if (indexInViewButtons !== -1) {
            this.values[indexInViewButtons].selected = true;
        }
        // deselect other buttons if multiSelection is not enabled
        if (!this.multiSelection && this.selectedIndexes.length > 1) {
            this.buttons.forEach((b, i) => {
                if (i !== index && this.selectedIndexes.indexOf(i) !== -1) {
                    this.deselectButton(i);
                }
            });
        }
    }
    /**
     * Deselects a button by its index.
     * ```typescript
     * @ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    this.buttonG.deselectButton(2);
     *    this.cdr.detectChanges();
     * }
     * ```
     * @memberOf {@link IgxButtonGroupComponent}
     */
    deselectButton(index) {
        if (index >= this.buttons.length || index < 0) {
            return;
        }
        const button = this.buttons[index];
        const buttonElement = button.nativeElement;
        this.selectedIndexes.splice(this.selectedIndexes.indexOf(index), 1);
        button.selected = false;
        this._renderer.setAttribute(buttonElement, 'aria-pressed', 'false');
        this._renderer.removeClass(buttonElement, 'igx-button-group__item--selected');
        this.onUnselect.emit({ button: button, index: index });
        const indexInViewButtons = this.viewButtons.toArray().indexOf(button);
        if (indexInViewButtons !== -1) {
            this.values[indexInViewButtons].selected = false;
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.templateButtons.forEach((button) => {
            if (!button.initialDensity) {
                button.displayDensity = this.displayDensity;
            }
        });
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        const initButtons = () => {
            // Cancel any existing buttonClick subscriptions
            this.buttonClickNotifier$.next();
            this.selectedIndexes.splice(0, this.selectedIndexes.length);
            // initial configuration
            this.buttons.forEach((button, index) => {
                const buttonElement = button.nativeElement;
                if (this.disabled) {
                    button.disabled = true;
                }
                if (button.selected) {
                    this.selectButton(index);
                }
                button.buttonClick.pipe(takeUntil(this.buttonClickNotifier$)).subscribe((ev) => this._clickHandler(ev, index));
                this._renderer.addClass(buttonElement, 'igx-button-group__item');
            });
        };
        this.viewButtons.changes.pipe(takeUntil(this.queryListNotifier$)).subscribe(() => initButtons());
        this.templateButtons.changes.pipe(takeUntil(this.queryListNotifier$)).subscribe(() => initButtons());
        initButtons();
        this._cdr.detectChanges();
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.buttonClickNotifier$.next();
        this.buttonClickNotifier$.complete();
        this.queryListNotifier$.next();
        this.queryListNotifier$.complete();
    }
    /**
     * @hidden
     */
    _clickHandler(event, i) {
        if (this.selectedIndexes.indexOf(i) !== -1) {
            this.deselectButton(i);
        }
        else {
            this.selectButton(i);
        }
    }
}
IgxButtonGroupComponent.ɵfac = function IgxButtonGroupComponent_Factory(t) { return new (t || IgxButtonGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxButtonGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxButtonGroupComponent, selectors: [["igx-buttongroup"]], contentQueries: function IgxButtonGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxButtonDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateButtons = _t);
    } }, viewQuery: function IgxButtonGroupComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxButtonDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewButtons = _t);
    } }, hostVars: 3, hostBindings: function IgxButtonGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵstyleProp("z-index", ctx.zIndex);
    } }, inputs: { id: "id", multiSelection: "multiSelection", itemContentCssClass: "itemContentCssClass", disabled: "disabled", alignment: "alignment", values: "values" }, outputs: { onSelect: "onSelect", onUnselect: "onUnselect" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 3, vars: 3, consts: [["role", "group", 1, "igx-button-group"], ["type", "button", "igxButton", "flat", 3, "displayDensity", "selected", "disabled", "igxButtonColor", "igxButtonBackground", "igxLabel", "igxRipple", 4, "ngFor", "ngForOf"], ["type", "button", "igxButton", "flat", 3, "displayDensity", "selected", "disabled", "igxButtonColor", "igxButtonBackground", "igxLabel", "igxRipple"], ["fontSet", "material", 4, "ngIf"], ["class", "igx-button-group__button-text", 4, "ngIf"], ["fontSet", "material"], [1, "igx-button-group__button-text"]], template: function IgxButtonGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxButtonGroupComponent_button_1_Template, 4, 13, "button", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-button-group--vertical", ctx.isVertical);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.values);
    } }, directives: [ɵngcc2.NgForOf, IgxButtonDirective, IgxRippleDirective, ɵngcc2.NgIf, IgxIconComponent], encapsulation: 2 });
IgxButtonGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxButtonGroupComponent.propDecorators = {
    viewButtons: [{ type: ViewChildren, args: [IgxButtonDirective,] }],
    templateButtons: [{ type: ContentChildren, args: [IgxButtonDirective,] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    zIndex: [{ type: HostBinding, args: ['style.zIndex',] }],
    itemContentCssClass: [{ type: Input }],
    multiSelection: [{ type: Input }],
    values: [{ type: Input }],
    disabled: [{ type: Input }],
    alignment: [{ type: Input }],
    onSelect: [{ type: Output }],
    onUnselect: [{ type: Output }]
};
/**
 * @hidden
 */
class IgxButtonGroupModule {
}
IgxButtonGroupModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxButtonGroupModule });
IgxButtonGroupModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxButtonGroupModule_Factory(t) { return new (t || IgxButtonGroupModule)(); }, imports: [[IgxButtonModule, CommonModule, IgxRippleModule, IgxIconModule]] });

var DateRangeType;
(function (DateRangeType) {
    DateRangeType[DateRangeType["After"] = 0] = "After";
    DateRangeType[DateRangeType["Before"] = 1] = "Before";
    DateRangeType[DateRangeType["Between"] = 2] = "Between";
    DateRangeType[DateRangeType["Specific"] = 3] = "Specific";
    DateRangeType[DateRangeType["Weekdays"] = 4] = "Weekdays";
    DateRangeType[DateRangeType["Weekends"] = 5] = "Weekends";
})(DateRangeType || (DateRangeType = {}));

/**
 * @hidden
 */
var TimeDeltaInterval;
(function (TimeDeltaInterval) {
    TimeDeltaInterval["Month"] = "month";
    TimeDeltaInterval["Year"] = "year";
})(TimeDeltaInterval || (TimeDeltaInterval = {}));
const MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const FEBRUARY = 1;
function range(start = 0, stop, step = 1) {
    const res = [];
    const cur = (stop === undefined) ? 0 : start;
    const max = (stop === undefined) ? start : stop;
    for (let i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
}
/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param year
 * @returns
 */
function isLeap(year) {
    return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
}
function weekDay(year, month, day) {
    return new Date(year, month, day).getDay();
}
/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param year
 * @param month
 * @returns
 */
function monthRange(year, month) {
    if ((month < 0) || (month > 11)) {
        throw new Error('Invalid month specified');
    }
    const day = weekDay(year, month, 1);
    let nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
}
function isDateInRanges(date, ranges) {
    date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const dateInMs = date.getTime();
    if (!ranges) {
        return false;
    }
    for (const descriptor of ranges) {
        const dRanges = descriptor.dateRange ? descriptor.dateRange.map(r => new Date(r.getFullYear(), r.getMonth(), r.getDate())) : undefined;
        switch (descriptor.type) {
            case (DateRangeType.After):
                if (dateInMs > dRanges[0].getTime()) {
                    return true;
                }
                break;
            case (DateRangeType.Before):
                if (dateInMs < dRanges[0].getTime()) {
                    return true;
                }
                break;
            case (DateRangeType.Between):
                const dRange = dRanges.map(d => d.getTime());
                const min = Math.min(dRange[0], dRange[1]);
                const max = Math.max(dRange[0], dRange[1]);
                if (dateInMs >= min && dateInMs <= max) {
                    return true;
                }
                break;
            case (DateRangeType.Specific):
                const datesInMs = dRanges.map(d => d.getTime());
                for (const specificDateInMs of datesInMs) {
                    if (dateInMs === specificDateInMs) {
                        return true;
                    }
                }
                break;
            case (DateRangeType.Weekdays):
                const day = date.getDay();
                if (day % 6 !== 0) {
                    return true;
                }
                break;
            case (DateRangeType.Weekends):
                const weekday = date.getDay();
                if (weekday % 6 === 0) {
                    return true;
                }
                break;
            default:
                return false;
        }
    }
    return false;
}
var WEEKDAYS;
(function (WEEKDAYS) {
    WEEKDAYS[WEEKDAYS["SUNDAY"] = 0] = "SUNDAY";
    WEEKDAYS[WEEKDAYS["MONDAY"] = 1] = "MONDAY";
    WEEKDAYS[WEEKDAYS["TUESDAY"] = 2] = "TUESDAY";
    WEEKDAYS[WEEKDAYS["WEDNESDAY"] = 3] = "WEDNESDAY";
    WEEKDAYS[WEEKDAYS["THURSDAY"] = 4] = "THURSDAY";
    WEEKDAYS[WEEKDAYS["FRIDAY"] = 5] = "FRIDAY";
    WEEKDAYS[WEEKDAYS["SATURDAY"] = 6] = "SATURDAY";
})(WEEKDAYS || (WEEKDAYS = {}));
class Calendar {
    constructor(firstWeekDay = WEEKDAYS.SUNDAY) {
        this._firstWeekDay = firstWeekDay;
    }
    get firstWeekDay() {
        return this._firstWeekDay % 7;
    }
    set firstWeekDay(value) {
        this._firstWeekDay = value;
    }
    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * @returns
     *
     * @memberof Calendar
     */
    weekdays() {
        const res = [];
        for (const i of range(this.firstWeekDay, this.firstWeekDay + 7)) {
            res.push(i % 7);
        }
        return res;
    }
    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * @param year
     * @param month
     * @param boolean
     * @returns
     *
     * @memberof Calendar
     */
    monthdates(year, month, extraWeek = false) {
        let date = new Date(year, month, 1);
        let days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, 'day', -days);
        const res = [];
        let value;
        while (true) {
            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, 'day', 1);
            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    for (const _ of range(0, 7)) {
                        value = this.generateICalendarDate(date, year, month);
                        res.push(value);
                        date = this.timedelta(date, 'day', 1);
                    }
                }
                break;
            }
        }
        return res;
    }
    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * @param year
     * @param month
     * @returns
     *
     * @memberof Calendar
     */
    monthdatescalendar(year, month, extraWeek = false) {
        const dates = this.monthdates(year, month, extraWeek);
        const res = [];
        for (const i of range(0, dates.length, 7)) {
            res.push(dates.slice(i, i + 7));
        }
        return res;
    }
    timedelta(date, interval, units) {
        const ret = new Date(date);
        const checkRollover = () => {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };
        switch (interval.toLowerCase()) {
            case 'year':
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case 'quarter':
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case 'month':
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case 'week':
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case 'day':
                ret.setDate(ret.getDate() + units);
                break;
            case 'hour':
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case 'minute':
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case 'second':
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error('Invalid interval specifier');
        }
        return ret;
    }
    formatToParts(date, locale, options, parts) {
        const formatter = new Intl.DateTimeFormat(locale, options);
        const result = {
            date,
            full: formatter.format(date)
        };
        if (formatter.formatToParts) {
            const formattedParts = formatter.formatToParts(date);
            const toType = (partType) => {
                const index = formattedParts.findIndex(({ type }) => type === partType);
                const o = { value: '', literal: '', combined: '' };
                if (partType === 'era' && index > -1) {
                    o.value = formattedParts[index].value;
                    return o;
                }
                else if (partType === 'era' && index === -1) {
                    return o;
                }
                o.value = formattedParts[index].value;
                o.literal = formattedParts[index + 1] ? formattedParts[index + 1].value : '';
                o.combined = [o.value, o.literal].join('');
                return o;
            };
            for (const each of parts) {
                result[each] = toType(each);
            }
        }
        else {
            for (const each of parts) {
                result[each] = { value: '', literal: '', combined: '' };
            }
        }
        return result;
    }
    getFirstViewDate(date, interval, activeViewIdx) {
        return this.timedelta(date, interval, -activeViewIdx);
    }
    getNextMonth(date) {
        return this.timedelta(date, TimeDeltaInterval.Month, 1);
    }
    getPrevMonth(date) {
        return this.timedelta(date, TimeDeltaInterval.Month, -1);
    }
    getNextYear(date) {
        return this.timedelta(date, TimeDeltaInterval.Year, 1);
    }
    getPrevYear(date) {
        return this.timedelta(date, TimeDeltaInterval.Year, -1);
    }
    getWeekNumber(date) {
        const firstJan = new Date(date.getFullYear(), 0, 1).getTime();
        const today = new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
        const dayInMilSeconds = 86400000;
        const dayOfYear = ((today - firstJan + 1) / dayInMilSeconds);
        return Math.ceil(dayOfYear / 7);
    }
    generateICalendarDate(date, year, month) {
        return {
            date,
            isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
            isNextMonth: this.isNextMonth(date, year, month),
            isPrevMonth: this.isPreviousMonth(date, year, month)
        };
    }
    isPreviousMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    }
    isNextMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    }
}

/**
 * Sets the selection type - single, multi or range.
 */
const CalendarSelection = mkenum({
    SINGLE: 'single',
    MULTI: 'multi',
    RANGE: 'range'
});
var ScrollMonth;
(function (ScrollMonth) {
    ScrollMonth["PREV"] = "prev";
    ScrollMonth["NEXT"] = "next";
    ScrollMonth["NONE"] = "none";
})(ScrollMonth || (ScrollMonth = {}));
/** @hidden @internal */
class IgxCalendarBaseDirective {
    /**
     * @hidden
     */
    constructor() {
        /**
         * Sets/gets whether the outside dates (dates that are out of the current month) will be hidden.
         * Default value is `false`.
         * ```html
         * <igx-calendar [hideOutsideDays] = "true"></igx-calendar>
         * ```
         * ```typescript
         * let hideOutsideDays = this.calendar.hideOutsideDays;
         * ```
         */
        this.hideOutsideDays = false;
        /**
         * Emits an event when a date is selected.
         * Provides reference the `selectedDates` property.
         */
        this.onSelection = new EventEmitter();
        /**
         * Emits an event when the month in view is changed.
         * ```html
         * <igx-calendar (viewDateChanged)="viewDateChanged($event)"></igx-calendar>
         * ```
         * ```typescript
         * public viewDateChanged(event: IViewDateChangeEventArgs) {
         *  let viewDate = event.currentValue;
         * }
         * ```
         */
        this.viewDateChanged = new EventEmitter();
        /**
         * Emits an event when the active view is changed.
         * ```html
         * <igx-calendar (activeViewChanged)="activeViewChanged($event)"></igx-calendar>
         * ```
         * ```typescript
         * public activeViewChanged(event: CalendarView) {
         *  let activeView = event;
         * }
         * ```
         */
        this.activeViewChanged = new EventEmitter();
        /**
         * @hidden
         */
        this._selection = CalendarSelection.SINGLE;
        /**
         * @hidden
         */
        this.rangeStarted = false;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._disabledDates = null;
        /**
         * @hidden
         */
        this._specialDates = null;
        /**
         * @hidden
         */
        this._formatOptions = {
            day: 'numeric',
            month: 'short',
            weekday: 'short',
            year: 'numeric'
        };
        /**
         * @hidden
         */
        this._formatViews = {
            day: false,
            month: true,
            year: false
        };
        /**
         * @hidden
         */
        this.monthScrollDirection = ScrollMonth.NONE;
        /**
         * @hidden
         */
        this.scrollMonth$ = new Subject();
        /**
         * @hidden
         */
        this.stopMonthScroll$ = new Subject();
        /**
         * @hidden
         */
        this.startMonthScroll$ = new Subject();
        /**
         * @hidden
         */
        this._onTouchedCallback = () => { };
        /**
         * @hidden
         */
        this._onChangeCallback = () => { };
        this.calendarModel = new Calendar();
        this.viewDate = this.viewDate ? this.viewDate : new Date();
        this.calendarModel.firstWeekDay = this.weekStart;
        this.initFormatters();
    }
    /**
     * Gets the start day of the week.
     * Can return a numeric or an enum representation of the week day.
     * Defaults to `Sunday` / `0`.
     */
    get weekStart() {
        return this.calendarModel.firstWeekDay;
    }
    /**
     * Sets the start day of the week.
     * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
     */
    set weekStart(value) {
        this.calendarModel.firstWeekDay = value;
    }
    /**
     * Gets the `locale` of the calendar.
     * Default value is `"en"`.
     */
    get locale() {
        return this._locale;
    }
    /**
     * Sets the `locale` of the calendar.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     */
    set locale(value) {
        this._locale = value;
        this.initFormatters();
    }
    /**
     * Gets the date format options of the days view.
     */
    get formatOptions() {
        return this._formatOptions;
    }
    /**
     * Sets the date format options of the days view.
     * Default is { day: 'numeric', month: 'short', weekday: 'short', year: 'numeric' }
     */
    set formatOptions(formatOptions) {
        this._formatOptions = Object.assign(this._formatOptions, formatOptions);
        this.initFormatters();
    }
    /**
     * Gets whether the `day`, `month` and `year` should be rendered
     * according to the locale and formatOptions, if any.
     */
    get formatViews() {
        return this._formatViews;
    }
    /**
     * Gets whether the `day`, `month` and `year` should be rendered
     * according to the locale and formatOptions, if any.
     */
    set formatViews(formatViews) {
        this._formatViews = Object.assign(this._formatViews, formatViews);
    }
    /**
     *
     * Gets the selection type.
     * Default value is `"single"`.
     * Changing the type of selection resets the currently
     * selected values if any.
     */
    get selection() {
        return this._selection;
    }
    /**
     * Sets the selection.
     */
    set selection(value) {
        switch (value) {
            case CalendarSelection.SINGLE:
                this.selectedDates = null;
                break;
            case CalendarSelection.MULTI:
            case CalendarSelection.RANGE:
                this.selectedDates = [];
                break;
            default:
                throw new Error('Invalid selection value');
        }
        this._onChangeCallback(this.selectedDates);
        this.rangeStarted = false;
        this._selection = value;
    }
    /**
     * Gets the selected date(s).
     *
     * When selection is set to `single`, it returns
     * a single `Date` object.
     * Otherwise it is an array of `Date` objects.
     */
    get value() {
        return this.selectedDates;
    }
    /**
     * Sets the selected date(s).
     *
     * When selection is set to `single`, it accepts
     * a single `Date` object.
     * Otherwise it is an array of `Date` objects.
     */
    set value(value) {
        if (!value || !!value && value.length === 0) {
            this.selectedDatesWithoutFocus = new Date();
            return;
        }
        if (!this.selectedDatesWithoutFocus) {
            const valueDate = value[0] ? Math.min.apply(null, value) : value;
            const date = this.getDateOnly(new Date(valueDate)).setDate(1);
            this.viewDate = new Date(date);
        }
        this.selectDate(value);
        this.selectedDatesWithoutFocus = value;
    }
    /**
     * Gets the date that is presented.
     * By default it is the current date.
     */
    get viewDate() {
        return this._viewDate;
    }
    /**
     * Sets the date that will be presented in the default view when the component renders.
     */
    set viewDate(value) {
        if (this._viewDate) {
            this.selectedDatesWithoutFocus = value;
        }
        const date = this.getDateOnly(value).setDate(1);
        this._viewDate = new Date(date);
    }
    /**
     * Gets the disabled dates descriptors.
     */
    get disabledDates() {
        return this._disabledDates;
    }
    /**
     * Sets the disabled dates' descriptors.
     * ```typescript
     * @ViewChild("MyCalendar")
     * public calendar: IgxCalendarComponent;
     * ngOnInit(){
     *    this.calendar.disabledDates = [
     *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
     *     {type: DateRangeType.Weekends}];
     * }
     * ```
     */
    set disabledDates(value) {
        this._disabledDates = value;
    }
    /**
     * Gets the special dates descriptors.
     */
    get specialDates() {
        return this._specialDates;
    }
    /**
     * Sets the special dates' descriptors.
     * ```typescript
     * @ViewChild("MyCalendar")
     * public calendar: IgxCalendarComponent;
     * ngOnInit(){
     *    this.calendar.specialDates = [
     *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
     *     {type: DateRangeType.Weekends}];
     * }
     * ```
     */
    set specialDates(value) {
        this._specialDates = value;
    }
    /**
     * @hidden
     */
    getDateOnlyInMs(date) {
        return this.getDateOnly(date).getTime();
    }
    /**
     * @hidden
     */
    generateDateRange(start, end) {
        const result = [];
        start = this.getDateOnly(start);
        end = this.getDateOnly(end);
        while (start.getTime() < end.getTime()) {
            start = this.calendarModel.timedelta(start, 'day', 1);
            result.push(start);
        }
        return result;
    }
    /**
     * Performs a single selection.
     * @hidden
     */
    selectSingle(value) {
        this.selectedDates = this.getDateOnly(value);
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * Performs a multiple selection
     * @hidden
     */
    selectMultiple(value) {
        if (Array.isArray(value)) {
            const newDates = value.map(v => this.getDateOnly(v).getTime());
            const selDates = this.selectedDates.map(v => this.getDateOnly(v).getTime());
            if (JSON.stringify(newDates) === JSON.stringify(selDates)) {
                return;
            }
            this.selectedDates = Array.from(new Set([...newDates, ...selDates])).map(v => new Date(v));
        }
        else {
            const valueDateOnly = this.getDateOnly(value);
            const newSelection = [];
            if (this.selectedDates.every((date) => date.getTime() !== valueDateOnly.getTime())) {
                newSelection.push(valueDateOnly);
            }
            else {
                this.selectedDates = this.selectedDates.filter((date) => date.getTime() !== valueDateOnly.getTime());
            }
            if (newSelection.length > 0) {
                this.selectedDates = this.selectedDates.concat(newSelection);
            }
        }
        this.selectedDates = this.selectedDates.filter(d => !this.isDateDisabled(d));
        this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * @hidden
     */
    selectRange(value, excludeDisabledDates = false) {
        let start;
        let end;
        if (Array.isArray(value)) {
            // this.rangeStarted = false;
            value.sort((a, b) => a.valueOf() - b.valueOf());
            start = this.getDateOnly(value[0]);
            end = this.getDateOnly(value[value.length - 1]);
            this.selectedDates = [start, ...this.generateDateRange(start, end)];
        }
        else {
            if (!this.rangeStarted) {
                this.rangeStarted = true;
                this.selectedDates = [value];
            }
            else {
                this.rangeStarted = false;
                if (this.selectedDates[0].getTime() === value.getTime()) {
                    this.selectedDates = [];
                    this._onChangeCallback(this.selectedDates);
                    return;
                }
                this.selectedDates.push(value);
                this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
                start = this.selectedDates.shift();
                end = this.selectedDates.pop();
                this.selectedDates = [start, ...this.generateDateRange(start, end)];
            }
        }
        if (excludeDisabledDates) {
            this.selectedDates = this.selectedDates.filter(d => !this.isDateDisabled(d));
        }
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * Performs a single deselection.
     * @hidden
     */
    deselectSingle(value) {
        if (this.selectedDates !== null &&
            this.getDateOnlyInMs(value) === this.getDateOnlyInMs(this.selectedDates)) {
            this.selectedDates = null;
            this._onChangeCallback(this.selectedDates);
        }
    }
    /**
     * Performs a multiple deselection.
     * @hidden
     */
    deselectMultiple(value) {
        value = value.filter(v => v !== null);
        const selectedDatesCount = this.selectedDates.length;
        const datesInMsToDeselect = new Set(value.map(v => this.getDateOnlyInMs(v)));
        for (let i = this.selectedDates.length - 1; i >= 0; i--) {
            if (datesInMsToDeselect.has(this.getDateOnlyInMs(this.selectedDates[i]))) {
                this.selectedDates.splice(i, 1);
            }
        }
        if (this.selectedDates.length !== selectedDatesCount) {
            this._onChangeCallback(this.selectedDates);
        }
    }
    /**
     * Performs deselection of a single value, when selection is multi
     * Usually performed by the selectMultiple method, but leads to bug when multiple months are in view
     * @hidden
     */
    deselectMultipleInMonth(value) {
        const valueDateOnly = this.getDateOnly(value);
        this.selectedDates = this.selectedDates.filter((date) => date.getTime() !== valueDateOnly.getTime());
    }
    /**
     * Performs a range deselection.
     * @hidden
     */
    deselectRange(value) {
        value = value.filter(v => v !== null);
        if (value.length < 1) {
            return;
        }
        value.sort((a, b) => a.valueOf() - b.valueOf());
        const valueStart = this.getDateOnlyInMs(value[0]);
        const valueEnd = this.getDateOnlyInMs(value[value.length - 1]);
        this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
        const selectedDatesStart = this.getDateOnlyInMs(this.selectedDates[0]);
        const selectedDatesEnd = this.getDateOnlyInMs(this.selectedDates[this.selectedDates.length - 1]);
        if (!(valueEnd < selectedDatesStart) && !(valueStart > selectedDatesEnd)) {
            this.selectedDates = [];
            this.rangeStarted = false;
            this._onChangeCallback(this.selectedDates);
        }
    }
    /**
     * @hidden
     */
    initFormatters() {
        this.formatterDay = new Intl.DateTimeFormat(this._locale, { day: this._formatOptions.day });
        this.formatterWeekday = new Intl.DateTimeFormat(this._locale, { weekday: this._formatOptions.weekday });
        this.formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month });
        this.formatterYear = new Intl.DateTimeFormat(this._locale, { year: this._formatOptions.year });
        this.formatterMonthday = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month, day: this._formatOptions.day });
    }
    /**
     * @hidden
     */
    getDateOnly(date) {
        return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.selectDate(value);
    }
    /**
     * Checks whether a date is disabled.
     * @hidden
     */
    isDateDisabled(date) {
        if (this.disabledDates === null) {
            return false;
        }
        return isDateInRanges(date, this.disabledDates);
    }
    /**
     * Selects date(s) (based on the selection type).
     */
    selectDate(value) {
        if (value === null || value === undefined || (Array.isArray(value) && value.length === 0)) {
            return;
        }
        switch (this.selection) {
            case CalendarSelection.SINGLE:
                if (isDate(value) && !this.isDateDisabled(value)) {
                    this.selectSingle(value);
                }
                break;
            case CalendarSelection.MULTI:
                this.selectMultiple(value);
                break;
            case CalendarSelection.RANGE:
                this.selectRange(value, true);
                break;
        }
    }
    /**
     * Deselects date(s) (based on the selection type).
     */
    deselectDate(value) {
        if (!this.selectedDates || this.selectedDates.length === 0) {
            return;
        }
        if (value === null || value === undefined) {
            this.selectedDates = this.selection === CalendarSelection.SINGLE ? null : [];
            this.rangeStarted = false;
            this._onChangeCallback(this.selectedDates);
            return;
        }
        switch (this.selection) {
            case CalendarSelection.SINGLE:
                this.deselectSingle(value);
                break;
            case CalendarSelection.MULTI:
                this.deselectMultiple(value);
                break;
            case CalendarSelection.RANGE:
                this.deselectRange(value);
                break;
        }
    }
    /**
     * @hidden
     */
    selectDateFromClient(value) {
        switch (this.selection) {
            case CalendarSelection.SINGLE:
            case CalendarSelection.MULTI:
                this.selectDate(value);
                break;
            case CalendarSelection.RANGE:
                this.selectRange(value, true);
                break;
        }
    }
}
IgxCalendarBaseDirective.ɵfac = function IgxCalendarBaseDirective_Factory(t) { return new (t || IgxCalendarBaseDirective)(); };
IgxCalendarBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCalendarBaseDirective, selectors: [["", "igxCalendarBase", ""]], inputs: { hideOutsideDays: "hideOutsideDays", viewDate: "viewDate", weekStart: "weekStart", locale: "locale", formatOptions: "formatOptions", formatViews: "formatViews", selection: "selection", value: "value", disabledDates: "disabledDates", specialDates: "specialDates" }, outputs: { onSelection: "onSelection", viewDateChanged: "viewDateChanged", activeViewChanged: "activeViewChanged" } });
IgxCalendarBaseDirective.ctorParameters = () => [];
IgxCalendarBaseDirective.propDecorators = {
    weekStart: [{ type: Input }],
    locale: [{ type: Input }],
    formatOptions: [{ type: Input }],
    formatViews: [{ type: Input }],
    selection: [{ type: Input }],
    value: [{ type: Input }],
    viewDate: [{ type: Input }],
    disabledDates: [{ type: Input }],
    specialDates: [{ type: Input }],
    hideOutsideDays: [{ type: Input }],
    onSelection: [{ type: Output }],
    viewDateChanged: [{ type: Output }],
    activeViewChanged: [{ type: Output }]
};

/**
 * This file contains all the directives used by the @link IgxCalendarComponent.
 * Except for the directives which are used for templating the calendar itself
 * you should generally not use them directly.
 * @preferred
 */
/**
 * @hidden
 */
class IgxCalendarYearDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.onYearSelection = new EventEmitter();
    }
    get defaultCSS() {
        return !this.isCurrentYear;
    }
    get currentCSS() {
        return this.isCurrentYear;
    }
    get tabIndex() {
        return this.isCurrentYear ? 0 : -1;
    }
    get isCurrentYear() {
        return this.date.getFullYear() === this.value.getFullYear();
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    onClick() {
        this.onYearSelection.emit(this.value);
    }
}
IgxCalendarYearDirective.ɵfac = function IgxCalendarYearDirective_Factory(t) { return new (t || IgxCalendarYearDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxCalendarYearDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCalendarYearDirective, selectors: [["", "igxCalendarYear", ""]], hostVars: 5, hostBindings: function IgxCalendarYearDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxCalendarYearDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabIndex);
        ɵngcc0.ɵɵclassProp("igx-calendar__year", ctx.defaultCSS)("igx-calendar__year--current", ctx.currentCSS);
    } }, inputs: { value: ["igxCalendarYear", "value"], date: "date" }, outputs: { onYearSelection: "onYearSelection" } });
IgxCalendarYearDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxCalendarYearDirective.propDecorators = {
    value: [{ type: Input, args: ['igxCalendarYear',] }],
    date: [{ type: Input }],
    onYearSelection: [{ type: Output }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-calendar__year',] }],
    currentCSS: [{ type: HostBinding, args: ['class.igx-calendar__year--current',] }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
class IgxCalendarMonthDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.onMonthSelection = new EventEmitter();
    }
    get defaultCSS() {
        return !this.isCurrentMonth;
    }
    get currentCSS() {
        return this.isCurrentMonth;
    }
    get isCurrentMonth() {
        return this.date.getMonth() === this.value.getMonth();
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    onClick() {
        const date = new Date(this.value.getFullYear(), this.value.getMonth(), this.date.getDate());
        this.onMonthSelection.emit(date);
    }
}
IgxCalendarMonthDirective.ɵfac = function IgxCalendarMonthDirective_Factory(t) { return new (t || IgxCalendarMonthDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxCalendarMonthDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCalendarMonthDirective, selectors: [["", "igxCalendarMonth", ""]], hostVars: 4, hostBindings: function IgxCalendarMonthDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxCalendarMonthDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-calendar__month", ctx.defaultCSS)("igx-calendar__month--current", ctx.currentCSS);
    } }, inputs: { value: ["igxCalendarMonth", "value"], date: "date", index: "index" }, outputs: { onMonthSelection: "onMonthSelection" } });
IgxCalendarMonthDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxCalendarMonthDirective.propDecorators = {
    value: [{ type: Input, args: ['igxCalendarMonth',] }],
    date: [{ type: Input }],
    index: [{ type: Input }],
    onMonthSelection: [{ type: Output }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-calendar__month',] }],
    currentCSS: [{ type: HostBinding, args: ['class.igx-calendar__month--current',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
/**
 * @hidden
 */
class IgxCalendarHeaderTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCalendarHeaderTemplateDirective.ɵfac = function IgxCalendarHeaderTemplateDirective_Factory(t) { return new (t || IgxCalendarHeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCalendarHeaderTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCalendarHeaderTemplateDirective, selectors: [["", "igxCalendarHeader", ""]] });
IgxCalendarHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
class IgxCalendarSubheaderTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCalendarSubheaderTemplateDirective.ɵfac = function IgxCalendarSubheaderTemplateDirective_Factory(t) { return new (t || IgxCalendarSubheaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCalendarSubheaderTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCalendarSubheaderTemplateDirective, selectors: [["", "igxCalendarSubheader", ""]] });
IgxCalendarSubheaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
class IgxCalendarScrollMonthDirective {
    constructor(element, zone) {
        this.element = element;
        this.zone = zone;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        fromEvent(this.element.nativeElement, 'keyup').pipe(debounce(() => interval(100)), takeUntil(this.destroy$)).subscribe((event) => {
            this.stopScroll(event);
        });
        this.zone.runOutsideAngular(() => {
            fromEvent(this.element.nativeElement, 'keydown').pipe(tap((event) => {
                if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }), debounce(() => interval(100)), takeUntil(this.destroy$)).subscribe((event) => {
                if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                    this.zone.run(() => this.startScroll(true));
                }
            });
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    onMouseDown() {
        this.startScroll();
    }
    /**
     * @hidden
     */
    onMouseUp(event) {
        this.stopScroll(event);
    }
}
IgxCalendarScrollMonthDirective.ɵfac = function IgxCalendarScrollMonthDirective_Factory(t) { return new (t || IgxCalendarScrollMonthDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxCalendarScrollMonthDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCalendarScrollMonthDirective, selectors: [["", "igxCalendarScrollMonth", ""]], hostBindings: function IgxCalendarScrollMonthDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function IgxCalendarScrollMonthDirective_mousedown_HostBindingHandler() { return ctx.onMouseDown(); })("mouseup", function IgxCalendarScrollMonthDirective_mouseup_HostBindingHandler($event) { return ctx.onMouseUp($event); });
    } }, inputs: { startScroll: "startScroll", stopScroll: "stopScroll" } });
IgxCalendarScrollMonthDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
IgxCalendarScrollMonthDirective.propDecorators = {
    startScroll: [{ type: Input }],
    stopScroll: [{ type: Input }],
    onMouseDown: [{ type: HostListener, args: ['mousedown',] }],
    onMouseUp: [{ type: HostListener, args: ['mouseup', ['$event'],] }]
};

/**
 * Sets the calender view - days, months or years.
 */
var CalendarView;
(function (CalendarView) {
    CalendarView[CalendarView["DEFAULT"] = 0] = "DEFAULT";
    CalendarView[CalendarView["YEAR"] = 1] = "YEAR";
    CalendarView[CalendarView["DECADE"] = 2] = "DECADE";
})(CalendarView || (CalendarView = {}));
class IgxMonthPickerBaseDirective extends IgxCalendarBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Holds month view index we are operating on.
         */
        this.activeViewIdx = 0;
        /**
         * @hidden
         */
        this._activeView = CalendarView.DEFAULT;
    }
    get activeView() {
        return this._activeView;
    }
    /**
     * Sets the current active view.
     * ```html
     * <igx-calendar [activeView]="1" #calendar></igx-calendar>
     * ```
     * ```typescript
     * calendar.activeView = CalendarView.YEAR;
     * ```
     */
    set activeView(val) {
        this._activeView = val;
    }
    /**
     * @hidden
     */
    get isDefaultView() {
        return this._activeView === CalendarView.DEFAULT;
    }
    /**
     * @hidden
     */
    get isDecadeView() {
        return this._activeView === CalendarView.DECADE;
    }
    /**
     * @hidden
     */
    changeYear(event) {
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
        this.activeView = CalendarView.DEFAULT;
        requestAnimationFrame(() => {
            if (this.yearsBtns && this.yearsBtns.length) {
                this.yearsBtns.find((e, idx) => idx === this.activeViewIdx).nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     */
    activeViewDecade(activeViewIdx = 0) {
        this.activeView = CalendarView.DECADE;
        this.activeViewIdx = activeViewIdx;
    }
    /**
     * @hidden
     */
    activeViewDecadeKB(event, activeViewIdx = 0) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            this.activeViewDecade(activeViewIdx);
        }
    }
    /**
     * Returns the locale representation of the year in the year view if enabled,
     * otherwise returns the default `Date.getFullYear()` value.
     *
     * @hidden
     */
    formattedYear(value) {
        if (this.formatViews.year) {
            return this.formatterYear.format(value);
        }
        return `${value.getFullYear()}`;
    }
}
IgxMonthPickerBaseDirective.ɵfac = function IgxMonthPickerBaseDirective_Factory(t) { return ɵIgxMonthPickerBaseDirective_BaseFactory(t || IgxMonthPickerBaseDirective); };
IgxMonthPickerBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxMonthPickerBaseDirective, selectors: [["", "igxMonthPickerBase", ""]], viewQuery: function IgxMonthPickerBaseDirective_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c33, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearsBtns = _t);
    } }, inputs: { activeView: "activeView" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxMonthPickerBaseDirective.propDecorators = {
    yearsBtns: [{ type: ViewChildren, args: ['yearsBtn',] }],
    activeView: [{ type: Input }]
};

let NEXT_ID$c = 0;
class IgxMonthsViewComponent {
    constructor(el) {
        this.el = el;
        /**
         * Sets/gets the `id` of the months view.
         * If not set, the `id` will have value `"igx-months-view-0"`.
         * ```html
         * <igx-months-view id="my-months-view"></igx-months-view>
         * ```
         * ```typescript
         * let monthsViewId =  this.monthsView.id;
         * ```
         * @memberof IgxMonthsViewComponent
         */
        this.id = `igx-months-view-${NEXT_ID$c++}`;
        /**
         * Gets/sets whether the view should be rendered
         * according to the locale and monthFormat, if any.
         */
        this.formatView = true;
        /**
         * Emits an event when a selection is made in the months view.
         * Provides reference the `date` property in the `IgxMonthsViewComponent`.
         * ```html
         * <igx-months-view (onSelection)="onSelection($event)"></igx-months-view>
         * ```
         * @memberof IgxMonthsViewComponent
         */
        this.onSelection = new EventEmitter();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        this._date = new Date();
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._monthFormat = 'short';
        /**
         * @hidden
         */
        this._onTouchedCallback = () => { };
        /**
         * @hidden
         */
        this._onChangeCallback = () => { };
        this.initMonthFormatter();
        this._calendarModel = new Calendar();
    }
    /**
     * Gets/sets the selected date of the months view.
     * By default it is the current date.
     * ```html
     * <igx-months-view [date]="myDate"></igx-months-view>
     * ```
     * ```typescript
     * let date =  this.monthsView.date;
     * ```
     * @memberof IgxMonthsViewComponent
     */
    set date(value) {
        this._date = value;
        this.activeMonth = this.date.getMonth();
    }
    get date() {
        return this._date;
    }
    /**
     * Gets the month format option of the months view.
     * ```typescript
     * let monthFormat = this.monthsView.monthFormat.
     * ```
     */
    get monthFormat() {
        return this._monthFormat;
    }
    /**
     * Sets the month format option of the months view.
     * ```html
     * <igx-months-view> [monthFormat] = "short'"</igx-months-view>
     * ```
     * @memberof IgxMonthsViewComponent
     */
    set monthFormat(value) {
        this._monthFormat = value;
        this.initMonthFormatter();
    }
    /**
     * Gets the `locale` of the months view.
     * Default value is `"en"`.
     * ```typescript
     * let locale =  this.monthsView.locale;
     * ```
     * @memberof IgxMonthsViewComponent
     */
    get locale() {
        return this._locale;
    }
    /**
     * Sets the `locale` of the months view.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     * ```html
     * <igx-months-view [locale]="de"></igx-months-view>
     * ```
     * @memberof IgxMonthsViewComponent
     */
    set locale(value) {
        this._locale = value;
        this.initMonthFormatter();
    }
    /**
     * Returns an array of date objects which are then used to
     * properly render the month names.
     *
     * Used in the template of the component
     *
     * @hidden
     */
    get months() {
        let start = new Date(this.date.getFullYear(), 0, 1);
        const result = [];
        for (let i = 0; i < 12; i++) {
            result.push(start);
            start = this._calendarModel.timedelta(start, 'month', 1);
        }
        return result;
    }
    /**
     * Returns the locale representation of the month in the months view.
     *
     * @hidden
     */
    formattedMonth(value) {
        if (this.formatView) {
            return this._formatterMonth.format(value);
        }
        return `${value.getMonth()}`;
    }
    /**
     * @hidden
     */
    selectMonth(event) {
        this.onSelection.emit(event);
        this.date = event;
        this.activeMonth = this.date.getMonth();
        this._onChangeCallback(this.date);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        if (value) {
            this.date = value;
        }
    }
    /**
     * @hidden
     */
    monthTracker(index, item) {
        return `${item.getMonth()}}`;
    }
    /**
     * @hidden
     */
    initMonthFormatter() {
        this._formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this.monthFormat });
    }
    /**
     * @hidden
     */
    onKeydownArrowUp(event) {
        event.preventDefault();
        event.stopPropagation();
        const node = this.monthsRef.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        const months = this.monthsRef.toArray();
        const nodeRect = node.nativeElement.getBoundingClientRect();
        for (let index = months.indexOf(node) - 1; index >= 0; index--) {
            const nextNodeRect = months[index].nativeElement.getBoundingClientRect();
            const tolerance = 6;
            if (nodeRect.top !== nextNodeRect.top && (nextNodeRect.left - nodeRect.left) < tolerance) {
                const month = months[index];
                month.nativeElement.focus();
                this.activeMonth = month.value.getMonth();
                break;
            }
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        const node = this.monthsRef.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        const months = this.monthsRef.toArray();
        const nodeRect = node.nativeElement.getBoundingClientRect();
        for (let index = months.indexOf(node) + 1; index < months.length; index++) {
            const nextNodeRect = months[index].nativeElement.getBoundingClientRect();
            const tolerance = 6;
            if (nextNodeRect.top !== nodeRect.top && (nodeRect.left - nextNodeRect.left) < tolerance) {
                const month = months[index];
                month.nativeElement.focus();
                this.activeMonth = month.value.getMonth();
                break;
            }
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowRight(event) {
        event.preventDefault();
        event.stopPropagation();
        const node = this.monthsRef.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        const months = this.monthsRef.toArray();
        if (months.indexOf(node) + 1 < months.length) {
            const month = months[months.indexOf(node) + 1];
            this.activeMonth = month.value.getMonth();
            month.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowLeft(event) {
        event.preventDefault();
        event.stopPropagation();
        const node = this.monthsRef.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        const months = this.monthsRef.toArray();
        if (months.indexOf(node) - 1 >= 0) {
            const month = months[months.indexOf(node) - 1];
            this.activeMonth = month.value.getMonth();
            month.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onKeydownHome(event) {
        event.preventDefault();
        event.stopPropagation();
        const month = this.monthsRef.toArray()[0];
        this.activeMonth = month.value.getMonth();
        month.nativeElement.focus();
    }
    /**
     * @hidden
     */
    onKeydownEnd(event) {
        event.preventDefault();
        event.stopPropagation();
        const months = this.monthsRef.toArray();
        const month = months[months.length - 1];
        this.activeMonth = month.value.getMonth();
        month.nativeElement.focus();
    }
    /**
     * @hidden
     */
    onKeydownEnter(event) {
        const value = this.monthsRef.find((date) => date.nativeElement === event.target).value;
        this.date = new Date(value.getFullYear(), value.getMonth(), this.date.getDate());
        this.activeMonth = this.date.getMonth();
        this.onSelection.emit(this.date);
        this._onChangeCallback(this.date);
    }
    resetActiveMonth(event) {
        this.activeMonth = this.date.getMonth();
    }
}
IgxMonthsViewComponent.ɵfac = function IgxMonthsViewComponent_Factory(t) { return new (t || IgxMonthsViewComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxMonthsViewComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxMonthsViewComponent, selectors: [["igx-months-view"]], viewQuery: function IgxMonthsViewComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxCalendarMonthDirective, true, IgxCalendarMonthDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthsRef = _t);
    } }, hostVars: 3, hostBindings: function IgxMonthsViewComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.arrowup", function IgxMonthsViewComponent_keydown_arrowup_HostBindingHandler($event) { return ctx.onKeydownArrowUp($event); })("keydown.arrowdown", function IgxMonthsViewComponent_keydown_arrowdown_HostBindingHandler($event) { return ctx.onKeydownArrowDown($event); })("keydown.arrowright", function IgxMonthsViewComponent_keydown_arrowright_HostBindingHandler($event) { return ctx.onKeydownArrowRight($event); })("keydown.arrowleft", function IgxMonthsViewComponent_keydown_arrowleft_HostBindingHandler($event) { return ctx.onKeydownArrowLeft($event); })("keydown.home", function IgxMonthsViewComponent_keydown_home_HostBindingHandler($event) { return ctx.onKeydownHome($event); })("keydown.end", function IgxMonthsViewComponent_keydown_end_HostBindingHandler($event) { return ctx.onKeydownEnd($event); })("keydown.enter", function IgxMonthsViewComponent_keydown_enter_HostBindingHandler($event) { return ctx.onKeydownEnter($event); })("focusout", function IgxMonthsViewComponent_focusout_HostBindingHandler($event) { return ctx.resetActiveMonth($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-calendar", ctx.styleClass);
    } }, inputs: { id: "id", formatView: "formatView", date: "date", monthFormat: "monthFormat", locale: "locale" }, outputs: { onSelection: "onSelection" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxMonthsViewComponent, multi: true }])], decls: 3, vars: 2, consts: [[1, "igx-calendar__body"], [1, "igx-calendar__body-row--wrap"], [3, "igxCalendarMonth", "date", "index", "onMonthSelection", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "igxCalendarMonth", "date", "index", "onMonthSelection"]], template: function IgxMonthsViewComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, IgxMonthsViewComponent_div_2_Template, 3, 7, "div", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.months)("ngForTrackBy", ctx.monthTracker);
    } }, directives: [ɵngcc2.NgForOf, IgxCalendarMonthDirective], pipes: [ɵngcc2.TitleCasePipe], encapsulation: 2 });
IgxMonthsViewComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxMonthsViewComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    date: [{ type: Input }],
    monthFormat: [{ type: Input }],
    locale: [{ type: Input }],
    formatView: [{ type: Input }],
    onSelection: [{ type: Output }],
    styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
    monthsRef: [{ type: ViewChildren, args: [IgxCalendarMonthDirective, { read: IgxCalendarMonthDirective },] }],
    onKeydownArrowUp: [{ type: HostListener, args: ['keydown.arrowup', ['$event'],] }],
    onKeydownArrowDown: [{ type: HostListener, args: ['keydown.arrowdown', ['$event'],] }],
    onKeydownArrowRight: [{ type: HostListener, args: ['keydown.arrowright', ['$event'],] }],
    onKeydownArrowLeft: [{ type: HostListener, args: ['keydown.arrowleft', ['$event'],] }],
    onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }],
    onKeydownEnter: [{ type: HostListener, args: ['keydown.enter', ['$event'],] }],
    resetActiveMonth: [{ type: HostListener, args: ['focusout', ['$event'],] }]
};

let NEXT_ID$d = 0;
class CalendarHammerConfig extends HammerGestureConfig {
    constructor() {
        super(...arguments);
        this.overrides = {
            pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
        };
    }
}
CalendarHammerConfig.ɵfac = function CalendarHammerConfig_Factory(t) { return ɵCalendarHammerConfig_BaseFactory(t || CalendarHammerConfig); };
CalendarHammerConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CalendarHammerConfig, factory: CalendarHammerConfig.ɵfac });
class IgxYearsViewComponent {
    constructor(el) {
        this.el = el;
        /**
         * Sets/gets the `id` of the years view.
         * If not set, the `id` will have value `"igx-years-view-0"`.
         * ```html
         * <igx-years-view id = "my-years-view"></igx-years-view>
         * ```
         * ```typescript
         * let yearsViewId =  this.yearsView.id;
         * ```
         * @memberof IgxCalendarComponent
         */
        this.id = `igx-years-view-${NEXT_ID$d++}`;
        /**
         * Gets/sets the selected date of the years view.
         * By default it is the current date.
         * ```html
         * <igx-years-view [date]="myDate"></igx-years-view>
         * ```
         * ```typescript
         * let date =  this.yearsView.date;
         * ```
         * @memberof IgxYearsViewComponent
         */
        this.date = new Date();
        /**
         * Emits an event when a selection is made in the years view.
         * Provides reference the `date` property in the `IgxYearsViewComponent`.
         * ```html
         * <igx-years-view (onSelection)="onSelection($event)"></igx-years-view>
         * ```
         * @memberof IgxYearsViewComponent
         */
        this.onSelection = new EventEmitter();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._yearFormat = 'numeric';
        /**
         * @hidden
         */
        this._onTouchedCallback = () => { };
        /**
         * @hidden
         */
        this._onChangeCallback = () => { };
        this.initYearFormatter();
        this._calendarModel = new Calendar();
    }
    /**
     * Gets the year format option of the years view.
     * ```typescript
     * let yearFormat = this.yearsView.yearFormat.
     * ```
     */
    get yearFormat() {
        return this._yearFormat;
    }
    /**
     * Sets the year format option of the years view.
     * ```html
     * <igx-years-view [yearFormat]="numeric"></igx-years-view>
     * ```
     * @memberof IgxYearsViewComponent
     */
    set yearFormat(value) {
        this._yearFormat = value;
        this.initYearFormatter();
    }
    /**
     * Gets the `locale` of the years view.
     * Default value is `"en"`.
     * ```typescript
     * let locale =  this.yearsView.locale;
     * ```
     * @memberof IgxYearsViewComponent
     */
    get locale() {
        return this._locale;
    }
    /**
     * Sets the `locale` of the years view.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     * ```html
     * <igx-years-view [locale]="de"></igx-years-view>
     * ```
     * @memberof IgxYearsViewComponent
     */
    set locale(value) {
        this._locale = value;
        this.initYearFormatter();
    }
    /**
     * Returns an array of date objects which are then used to properly
     * render the years.
     *
     * Used in the template of the component.
     *
     * @hidden
     */
    get decade() {
        const result = [];
        const start = this.date.getFullYear() - 3;
        const end = this.date.getFullYear() + 4;
        for (const year of range(start, end)) {
            result.push(new Date(year, this.date.getMonth(), this.date.getDate()));
        }
        return result;
    }
    /**
     * Returns the locale representation of the year in the years view.
     *
     * @hidden
     */
    formattedYear(value) {
        if (this.formatView) {
            return this._formatterYear.format(value);
        }
        return `${value.getFullYear()}`;
    }
    /**
     * @hidden
     */
    selectYear(event) {
        this.date = event;
        this.onSelection.emit(this.date);
        this._onChangeCallback(this.date);
    }
    /**
     * @hidden
     */
    scroll(event) {
        event.preventDefault();
        event.stopPropagation();
        const delta = event.deltaY < 0 ? -1 : 1;
        this.generateYearRange(delta);
    }
    /**
     * @hidden
     */
    pan(event) {
        const delta = event.deltaY < 0 ? 1 : -1;
        this.generateYearRange(delta);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    yearTracker(index, item) {
        return `${item.getFullYear()}}`;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        if (value) {
            this.date = value;
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        this.generateYearRange(1);
        this.calendarDir.find(date => date.isCurrentYear).nativeElement.nextElementSibling.focus();
    }
    /**
     * @hidden
     */
    onKeydownArrowUp(event) {
        event.preventDefault();
        event.stopPropagation();
        this.generateYearRange(-1);
        this.calendarDir.find(date => date.isCurrentYear).nativeElement.previousElementSibling.focus();
    }
    /**
     * @hidden
     */
    onKeydownEnter() {
        this.onSelection.emit(this.date);
        this._onChangeCallback(this.date);
    }
    /**
     * @hidden
     */
    initYearFormatter() {
        this._formatterYear = new Intl.DateTimeFormat(this._locale, { year: this.yearFormat });
    }
    /**
     * @hidden
     */
    generateYearRange(delta) {
        const currentYear = new Date().getFullYear();
        if ((delta > 0 && this.date.getFullYear() - currentYear >= 95) ||
            (delta < 0 && currentYear - this.date.getFullYear() >= 95)) {
            return;
        }
        this.date = this._calendarModel.timedelta(this.date, 'year', delta);
    }
}
IgxYearsViewComponent.ɵfac = function IgxYearsViewComponent_Factory(t) { return new (t || IgxYearsViewComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxYearsViewComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxYearsViewComponent, selectors: [["igx-years-view"]], viewQuery: function IgxYearsViewComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxCalendarYearDirective, true, IgxCalendarYearDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.calendarDir = _t);
    } }, hostVars: 3, hostBindings: function IgxYearsViewComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.arrowdown", function IgxYearsViewComponent_keydown_arrowdown_HostBindingHandler($event) { return ctx.onKeydownArrowDown($event); })("keydown.arrowup", function IgxYearsViewComponent_keydown_arrowup_HostBindingHandler($event) { return ctx.onKeydownArrowUp($event); })("keydown.enter", function IgxYearsViewComponent_keydown_enter_HostBindingHandler() { return ctx.onKeydownEnter(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-calendar", ctx.styleClass);
    } }, inputs: { id: "id", date: "date", yearFormat: "yearFormat", locale: "locale", formatView: "formatView" }, outputs: { onSelection: "onSelection" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxYearsViewComponent,
                multi: true
            },
            {
                provide: HAMMER_GESTURE_CONFIG,
                useClass: CalendarHammerConfig
            }
        ])], decls: 3, vars: 2, consts: [[1, "igx-calendar__body"], [1, "igx-calendar__body-column", 3, "wheel", "pan"], [3, "igxCalendarYear", "date", "onYearSelection", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "igxCalendarYear", "date", "onYearSelection"]], template: function IgxYearsViewComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵlistener("wheel", function IgxYearsViewComponent_Template_div_wheel_1_listener($event) { return ctx.scroll($event); })("pan", function IgxYearsViewComponent_Template_div_pan_1_listener($event) { return ctx.pan($event); });
        ɵngcc0.ɵɵtemplate(2, IgxYearsViewComponent_span_2_Template, 2, 3, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.decade)("ngForTrackBy", ctx.yearTracker);
    } }, directives: [ɵngcc2.NgForOf, IgxCalendarYearDirective], encapsulation: 2 });
IgxYearsViewComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxYearsViewComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    date: [{ type: Input }],
    yearFormat: [{ type: Input }],
    locale: [{ type: Input }],
    formatView: [{ type: Input }],
    onSelection: [{ type: Output }],
    styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
    calendarDir: [{ type: ViewChildren, args: [IgxCalendarYearDirective, { read: IgxCalendarYearDirective },] }],
    onKeydownArrowDown: [{ type: HostListener, args: ['keydown.arrowdown', ['$event'],] }],
    onKeydownArrowUp: [{ type: HostListener, args: ['keydown.arrowup', ['$event'],] }],
    onKeydownEnter: [{ type: HostListener, args: ['keydown.enter',] }]
};

/**
 * @hidden
 */
class IgxDayItemComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.hideOutsideDays = false;
        this.isLastInRange = false;
        this.isFirstInRange = false;
        this.isWithinRange = false;
        this.onDateSelection = new EventEmitter();
        this._selected = false;
    }
    /**
     * Returns boolean indicating if the day is selected
     *
     */
    get selected() {
        return this._selected;
    }
    /**
     * Selects the day
     */
    set selected(value) {
        this._selected = value;
    }
    get isCurrentMonth() {
        return this.date.isCurrentMonth;
    }
    get isPreviousMonth() {
        return this.date.isPrevMonth;
    }
    get isNextMonth() {
        return this.date.isNextMonth;
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    get isSelectedCSS() {
        return (!this.isDisabled && this.selected);
    }
    get isInactive() {
        return this.date.isNextMonth || this.date.isPrevMonth;
    }
    get isHidden() {
        return this.hideOutsideDays && this.isInactive;
    }
    get isToday() {
        const today = new Date(Date.now());
        const date = this.date.date;
        return (date.getFullYear() === today.getFullYear() &&
            date.getMonth() === today.getMonth() &&
            date.getDate() === today.getDate());
    }
    get isWeekend() {
        const day = this.date.date.getDay();
        return day === 0 || day === 6;
    }
    get isDisabled() {
        if (this.disabledDates === null) {
            return false;
        }
        return isDateInRanges(this.date.date, this.disabledDates);
    }
    get isOutOfRange() {
        if (!this.outOfRangeDates) {
            return false;
        }
        return isDateInRanges(this.date.date, this.outOfRangeDates);
    }
    get isFocusable() {
        return this.isCurrentMonth && !this.isHidden && !this.isDisabled && !this.isOutOfRange;
    }
    get isWithinRangeCSS() {
        return !this.isSingleSelection && this.isWithinRange;
    }
    get isSpecial() {
        if (this.specialDates === null) {
            return false;
        }
        return isDateInRanges(this.date.date, this.specialDates);
    }
    get defaultCSS() {
        return this.date.isCurrentMonth && !(this.isWeekend && this.selected);
    }
    get isDisabledCSS() {
        return this.isHidden || this.isDisabled || this.isOutOfRange;
    }
    get isSingleSelection() {
        return this.selection !== CalendarSelection.RANGE;
    }
    onSelect(event) {
        event.stopPropagation();
        this.onDateSelection.emit(this.date);
    }
}
IgxDayItemComponent.ɵfac = function IgxDayItemComponent_Factory(t) { return new (t || IgxDayItemComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxDayItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDayItemComponent, selectors: [["igx-day-item"]], hostVars: 24, hostBindings: function IgxDayItemComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxDayItemComponent_click_HostBindingHandler($event) { return ctx.onSelect($event); })("keydown.enter", function IgxDayItemComponent_keydown_enter_HostBindingHandler($event) { return ctx.onSelect($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-calendar__date--last", ctx.isLastInRange)("igx-calendar__date--first", ctx.isFirstInRange)("igx-calendar__date--selected", ctx.isSelectedCSS)("igx-calendar__date--inactive", ctx.isInactive)("igx-calendar__date--hidden", ctx.isHidden)("igx-calendar__date--current", ctx.isToday)("igx-calendar__date--weekend", ctx.isWeekend)("igx-calendar__date--range", ctx.isWithinRangeCSS)("igx-calendar__date--special", ctx.isSpecial)("igx-calendar__date", ctx.defaultCSS)("igx-calendar__date--disabled", ctx.isDisabledCSS)("igx-calendar__date--single", ctx.isSingleSelection);
    } }, inputs: { hideOutsideDays: "hideOutsideDays", isLastInRange: "isLastInRange", isFirstInRange: "isFirstInRange", isWithinRange: "isWithinRange", selected: "selected", date: "date", selection: "selection", disabledDates: "disabledDates", outOfRangeDates: "outOfRangeDates", specialDates: "specialDates" }, outputs: { onDateSelection: "onDateSelection" }, ngContentSelectors: _c2, decls: 2, vars: 0, consts: [[1, "igx-calendar__date-content"]], template: function IgxDayItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
IgxDayItemComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxDayItemComponent.propDecorators = {
    date: [{ type: Input }],
    selection: [{ type: Input }],
    selected: [{ type: Input }],
    disabledDates: [{ type: Input }],
    outOfRangeDates: [{ type: Input }],
    specialDates: [{ type: Input }],
    hideOutsideDays: [{ type: Input }],
    isLastInRange: [{ type: Input }, { type: HostBinding, args: ['class.igx-calendar__date--last',] }],
    isFirstInRange: [{ type: Input }, { type: HostBinding, args: ['class.igx-calendar__date--first',] }],
    isWithinRange: [{ type: Input }],
    onDateSelection: [{ type: Output }],
    isSelectedCSS: [{ type: HostBinding, args: ['class.igx-calendar__date--selected',] }],
    isInactive: [{ type: HostBinding, args: ['class.igx-calendar__date--inactive',] }],
    isHidden: [{ type: HostBinding, args: ['class.igx-calendar__date--hidden',] }],
    isToday: [{ type: HostBinding, args: ['class.igx-calendar__date--current',] }],
    isWeekend: [{ type: HostBinding, args: ['class.igx-calendar__date--weekend',] }],
    isWithinRangeCSS: [{ type: HostBinding, args: ['class.igx-calendar__date--range',] }],
    isSpecial: [{ type: HostBinding, args: ['class.igx-calendar__date--special',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-calendar__date',] }],
    isDisabledCSS: [{ type: HostBinding, args: ['class.igx-calendar__date--disabled',] }],
    isSingleSelection: [{ type: HostBinding, args: ['class.igx-calendar__date--single',] }],
    onSelect: [{ type: HostListener, args: ['click', ['$event'],] }, { type: HostListener, args: ['keydown.enter', ['$event'],] }]
};

var Direction;
(function (Direction) {
    Direction["Up"] = "ArrowUp";
    Direction["Down"] = "ArrowDown";
    Direction["Left"] = "ArrowLeft";
    Direction["Right"] = "ArrowRight";
})(Direction || (Direction = {}));
const ARROW = 'Arrow';
/** @hidden */
class IgxDaysViewNavigationService {
    /**
     * Implements kb navigation in all MoveDirections. nextDate and nextMonthView naming convention is used for both previous/next
     * @hidden
     */
    focusNextDate(target, key, nextView = false) {
        if (target.childElementCount === 0) {
            target = target.parentElement;
        }
        if (key.indexOf('Arrow') === -1) {
            key = ARROW.concat(key);
        }
        const monthView = this.monthView;
        const node = monthView.dates.find((date) => date.nativeElement === target);
        let dates = monthView.dates.toArray(), day, step, i, nextDate;
        const index = dates.indexOf(node);
        if (!node) {
            return;
        }
        // focus item in current month
        switch (key) {
            case Direction.Left: {
                step = -1;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i > 0; i--) {
                    day = nextView ? dates[i] : dates[i - 1];
                    nextDate = day.date.date;
                    if (day.date.isPrevMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
            case Direction.Right: {
                step = 1;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i < dates.length - 1; i++) {
                    day = nextView ? dates[i] : dates[i + 1];
                    nextDate = day.date.date;
                    if (day.date.isNextMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
            case Direction.Up: {
                step = -7;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i - 7 > -1; i -= 7) {
                    day = nextView ? dates[i] : dates[i - 7];
                    nextDate = day.date.date;
                    if (day.date.isPrevMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
            case Direction.Down: {
                step = 7;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i + 7 < 42; i += 7) {
                    day = nextView ? dates[i] : dates[i + 7];
                    nextDate = day.date.date;
                    if (day.date.isNextMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
        }
        // focus item in prev/next visible month
        const nextMonthView = step > 0 ? monthView.nextMonthView : monthView.prevMonthView;
        if (nextMonthView) {
            dates = nextMonthView.dates.toArray();
            day = dates.find((item) => item.date.date.getTime() === nextDate.getTime());
            if (day && day.isFocusable) {
                day.nativeElement.focus();
                return;
            }
            nextMonthView.daysNavService.focusNextDate(day.nativeElement, key);
        }
        // if iterating in the visible prev/next moths above found a day that is not focusable, ie is disabled, hidden, etc
        // then it is needed to recalculate the next day, which is going to be part of the prev/next months
        if (day && !day.isFocusable) {
            day = dates[i + step];
            if (!day) {
                nextDate = this.timedelta(node.date.date, step + i - index);
            }
        }
        // focus item in prev/next month, which is currently out of view
        let dayIsNextMonth; // determine what we need to check for next date - if it belongs to prev or next month
        if (day) {
            dayIsNextMonth = step > 0 ? day.date.isNextMonth : day.date.isPrevMonth;
        }
        if (monthView.changeDaysView && !nextMonthView && ((day && dayIsNextMonth) || !day)) {
            const monthAction = step > 0 ? ScrollMonth.NEXT : ScrollMonth.PREV;
            monthView.onViewChanging.emit({ monthAction: monthAction, key: key, nextDate: nextDate });
        }
    }
    /**
     * Focuses first focusable day in the month. Will go to next visible month, if no day in the first month is focusable
     * @hidden
     */
    focusHomeDate() {
        let monthView = this.monthView;
        while (!this.focusFirstDay(monthView) && monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
        }
    }
    /**
     * Focuses last focusable day in the month. Will go to previous visible month, if no day in the first month is focusable
     * @hidden
     */
    focusEndDate() {
        let monthView = this.monthView;
        while (!this.focusLastDay(monthView) && monthView.prevMonthView) {
            monthView = monthView.prevMonthView;
        }
    }
    timedelta(date, units) {
        const ret = new Date(date);
        ret.setDate(ret.getDate() + units);
        return ret;
    }
    focusFirstDay(monthView) {
        const dates = monthView.dates.filter(d => d.isCurrentMonth);
        for (let i = 0; i < dates.length; i++) {
            if (dates[i].isFocusable) {
                dates[i].nativeElement.focus();
                return true;
            }
        }
        return false;
    }
    focusLastDay(monthView) {
        const dates = monthView.dates.filter(d => d.isCurrentMonth);
        for (let i = dates.length - 1; i >= 0; i--) {
            if (dates[i].isFocusable) {
                dates[i].nativeElement.focus();
                return true;
            }
        }
        return false;
    }
}
IgxDaysViewNavigationService.ɵfac = function IgxDaysViewNavigationService_Factory(t) { return new (t || IgxDaysViewNavigationService)(); };
IgxDaysViewNavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxDaysViewNavigationService, factory: IgxDaysViewNavigationService.ɵfac });

let NEXT_ID$e = 0;
class IgxDaysViewComponent extends IgxCalendarBaseDirective {
    /**
     * @hidden
     */
    constructor(daysNavService) {
        super();
        this.daysNavService = daysNavService;
        /**
         * Sets/gets the `id` of the days view.
         * If not set, the `id` will have value `"igx-days-view-0"`.
         * ```html
         * <igx-days-view id="my-days-view"></igx-days-view>
         * ```
         * ```typescript
         * let daysViewId =  this.daysView.id;
         * ```
         */
        this.id = `igx-days-view-${NEXT_ID$e++}`;
        /**
         * @hidden
         */
        this.changeDaysView = false;
        /**
         * @hidden
         */
        this.onDateSelection = new EventEmitter();
        /**
         * @hidden
         */
        this.onViewChanging = new EventEmitter();
        /**
         * @hidden
         */
        this.activeDateChange = new EventEmitter();
        /**
         * @hidden
         */
        this.monthsViewBlur = new EventEmitter();
        /** @hidden */
        this.shouldResetDate = true;
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
    }
    /**
     * @hidden
     * @internal
     */
    set activeDate(value) {
        this._activeDate = value;
        this.activeDateChange.emit(this._activeDate);
    }
    get activeDate() {
        return this._activeDate ? this._activeDate : this.viewDate.toLocaleDateString();
    }
    /**
     * @hidden
     * @internal
     */
    resetActiveMonth() {
        if (this.shouldResetDate) {
            const date = this.dates.find(day => day.selected && day.isCurrentMonth)
                || this.dates.find(day => day.isToday && day.isCurrentMonth) || this.dates.find(d => d.isFocusable);
            if (date) {
                this.activeDate = date.date.date.toLocaleDateString();
            }
            this.monthsViewBlur.emit();
        }
        this.shouldResetDate = true;
    }
    /**
     * @hidden
     * @internal
     */
    pointerDown() {
        this.shouldResetDate = false;
    }
    /**
     * @hidden
     */
    get getCalendarMonth() {
        return this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth(), true);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.daysNavService.monthView = this;
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        if (!this.changeDaysView && this.dates) {
            this.disableOutOfRangeDates();
        }
    }
    /**
     * @hidden
     * @internal
     */
    tabIndex(day) {
        return this.activeDate && this.activeDate === day.date.toLocaleDateString() && day.isCurrentMonth ? 0 : -1;
    }
    /**
     * Returns the week number by date
     *
     * @hidden
     */
    getWeekNumber(date) {
        return this.calendarModel.getWeekNumber(date);
    }
    /**
     * Returns the locale representation of the date in the days view.
     *
     * @hidden
     */
    formattedDate(value) {
        if (this.formatViews.day) {
            return this.formatterDay.format(value);
        }
        return `${value.getDate()}`;
    }
    /**
     * @hidden
     */
    generateWeekHeader() {
        const dayNames = [];
        const rv = this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth())[0];
        for (const day of rv) {
            dayNames.push(this.formatterWeekday.format(day.date));
        }
        return dayNames;
    }
    /**
     * @hidden
     */
    rowTracker(index, item) {
        return `${item[index].date.getMonth()}${item[index].date.getDate()}`;
    }
    /**
     * @hidden
     */
    dateTracker(index, item) {
        return `${item.date.getMonth()}--${item.date.getDate()}`;
    }
    /**
     * @hidden
     */
    isCurrentMonth(value) {
        return this.viewDate.getMonth() === value.getMonth();
    }
    /**
     * @hidden
     */
    isCurrentYear(value) {
        return this.viewDate.getFullYear() === value.getFullYear();
    }
    /**
     * @hidden
     */
    isSelected(date) {
        let selectedDates;
        if (this.isDateDisabled(date.date) || !this.value ||
            (Array.isArray(this.value) && this.value.length === 0)) {
            return false;
        }
        if (this.selection === CalendarSelection.SINGLE) {
            selectedDates = this.value;
            return this.getDateOnly(selectedDates).getTime() === date.date.getTime();
        }
        selectedDates = this.value;
        if (this.selection === CalendarSelection.RANGE && selectedDates.length === 1) {
            return this.getDateOnly(selectedDates[0]).getTime() === date.date.getTime();
        }
        if (this.selection === CalendarSelection.MULTI) {
            const start = this.getDateOnly(selectedDates[0]);
            const end = this.getDateOnly(selectedDates[selectedDates.length - 1]);
            if (this.isWithinRange(date.date, false, start, end)) {
                const currentDate = selectedDates.find(element => element.getTime() === date.date.getTime());
                return !!currentDate;
            }
            else {
                return false;
            }
        }
        else {
            return this.isWithinRange(date.date, true);
        }
    }
    /**
     * @hidden
     */
    isLastInRange(date) {
        if (this.isSingleSelection || !this.value) {
            return false;
        }
        const dates = this.value;
        const lastDate = dates[dates.length - 1];
        return isEqual(lastDate, date.date);
    }
    /**
     * @hidden
     */
    isFirstInRange(date) {
        if (this.isSingleSelection || !this.value) {
            return false;
        }
        return isEqual(this.value[0], date.date);
    }
    /**
     * @hidden
     */
    isWithinRange(date, checkForRange, min, max) {
        if (checkForRange && !(Array.isArray(this.value) && this.value.length > 1)) {
            return false;
        }
        min = min ? min : this.value[0];
        max = max ? max : this.value[this.value.length - 1];
        return isDateInRanges(date, [
            {
                type: DateRangeType.Between,
                dateRange: [min, max]
            }
        ]);
    }
    /**
     * @hidden
     */
    focusActiveDate() {
        let date = this.dates.find((d) => d.selected);
        if (!date) {
            date = this.dates.find((d) => d.isToday);
        }
        if (date.isFocusable) {
            date.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    selectDay(event) {
        this.selectDateFromClient(event.date);
        this.onDateSelection.emit(event);
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * @hidden
     */
    disableOutOfRangeDates() {
        const dateRange = [];
        this.dates.toArray().forEach((date) => {
            if (!date.isCurrentMonth) {
                dateRange.push(date.date.date);
            }
        });
        this.outOfRangeDates = [{
                type: DateRangeType.Specific,
                dateRange: dateRange
            }];
    }
    /**
     * @hidden
     */
    getFirstMonthView() {
        let monthView = this;
        while (monthView.prevMonthView) {
            monthView = monthView.prevMonthView;
        }
        return monthView;
    }
    /**
     * @hidden
     */
    getLastMonthView() {
        let monthView = this;
        while (monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
        }
        return monthView;
    }
    /**
     * @hidden
     */
    get isSingleSelection() {
        return this.selection !== CalendarSelection.RANGE;
    }
    /**
     * @hidden
     */
    onKeydownArrow(event) {
        event.preventDefault();
        event.stopPropagation();
        this.shouldResetDate = false;
        this.daysNavService.focusNextDate(event.target, event.key);
    }
    /**
     * @hidden
     */
    onKeydownHome(event) {
        event.preventDefault();
        event.stopPropagation();
        this.shouldResetDate = false;
        this.getFirstMonthView().daysNavService.focusHomeDate();
    }
    /**
     * @hidden
     */
    onKeydownEnd(event) {
        event.preventDefault();
        event.stopPropagation();
        this.shouldResetDate = false;
        this.getLastMonthView().daysNavService.focusEndDate();
    }
}
IgxDaysViewComponent.ɵfac = function IgxDaysViewComponent_Factory(t) { return new (t || IgxDaysViewComponent)(ɵngcc0.ɵɵdirectiveInject(IgxDaysViewNavigationService)); };
IgxDaysViewComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDaysViewComponent, selectors: [["igx-days-view"]], viewQuery: function IgxDaysViewComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxDayItemComponent, true, IgxDayItemComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dates = _t);
    } }, hostVars: 3, hostBindings: function IgxDaysViewComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusout", function IgxDaysViewComponent_focusout_HostBindingHandler() { return ctx.resetActiveMonth(); })("keydown.pagedown", function IgxDaysViewComponent_keydown_pagedown_HostBindingHandler() { return ctx.pointerDown(); })("keydown.pageup", function IgxDaysViewComponent_keydown_pageup_HostBindingHandler() { return ctx.pointerDown(); })("keydown.shift.pagedown", function IgxDaysViewComponent_keydown_shift_pagedown_HostBindingHandler() { return ctx.pointerDown(); })("keydown.shift.pageup", function IgxDaysViewComponent_keydown_shift_pageup_HostBindingHandler() { return ctx.pointerDown(); })("pointerdown", function IgxDaysViewComponent_pointerdown_HostBindingHandler() { return ctx.pointerDown(); })("keydown.arrowleft", function IgxDaysViewComponent_keydown_arrowleft_HostBindingHandler($event) { return ctx.onKeydownArrow($event); })("keydown.arrowright", function IgxDaysViewComponent_keydown_arrowright_HostBindingHandler($event) { return ctx.onKeydownArrow($event); })("keydown.arrowup", function IgxDaysViewComponent_keydown_arrowup_HostBindingHandler($event) { return ctx.onKeydownArrow($event); })("keydown.arrowdown", function IgxDaysViewComponent_keydown_arrowdown_HostBindingHandler($event) { return ctx.onKeydownArrow($event); })("keydown.home", function IgxDaysViewComponent_keydown_home_HostBindingHandler($event) { return ctx.onKeydownHome($event); })("keydown.end", function IgxDaysViewComponent_keydown_end_HostBindingHandler($event) { return ctx.onKeydownEnd($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-calendar", ctx.styleClass);
    } }, inputs: { id: "id", changeDaysView: "changeDaysView", activeDate: "activeDate", showWeekNumbers: "showWeekNumbers" }, outputs: { onDateSelection: "onDateSelection", onViewChanging: "onViewChanging", activeDateChange: "activeDateChange", monthsViewBlur: "monthsViewBlur" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxDaysViewComponent
            },
            { provide: IgxDaysViewNavigationService, useClass: IgxDaysViewNavigationService }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 4, consts: [[1, "igx-calendar__body-row"], ["class", "igx-calendar__label igx-calendar__label--week-number", 4, "ngIf"], ["class", "igx-calendar__label", 4, "ngFor", "ngForOf"], ["class", "igx-calendar__body-row", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "igx-calendar__label", "igx-calendar__label--week-number"], [1, "igx-calendar__label"], ["class", "igx-calendar__date igx-calendar__date--week-number", 4, "ngIf"], [3, "date", "selection", "selected", "isLastInRange", "isFirstInRange", "isWithinRange", "disabledDates", "specialDates", "outOfRangeDates", "hideOutsideDays", "focus", "onDateSelection", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "igx-calendar__date", "igx-calendar__date--week-number"], [1, "igx-calendar__date-content", "igx-calendar__date-content--week-number"], [3, "date", "selection", "selected", "isLastInRange", "isFirstInRange", "isWithinRange", "disabledDates", "specialDates", "outOfRangeDates", "hideOutsideDays", "focus", "onDateSelection"]], template: function IgxDaysViewComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxDaysViewComponent_div_1_Template, 3, 0, "div", 1);
        ɵngcc0.ɵɵtemplate(2, IgxDaysViewComponent_span_2_Template, 3, 3, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, IgxDaysViewComponent_div_3_Template, 3, 3, "div", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showWeekNumbers);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.generateWeekHeader());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.getCalendarMonth)("ngForTrackBy", ctx.rowTracker);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgForOf, IgxDayItemComponent], pipes: [ɵngcc2.TitleCasePipe], encapsulation: 2 });
IgxDaysViewComponent.ctorParameters = () => [
    { type: IgxDaysViewNavigationService }
];
IgxDaysViewComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    changeDaysView: [{ type: Input }],
    showWeekNumbers: [{ type: Input }],
    activeDate: [{ type: Input }],
    onDateSelection: [{ type: Output }],
    onViewChanging: [{ type: Output }],
    activeDateChange: [{ type: Output }],
    monthsViewBlur: [{ type: Output }],
    dates: [{ type: ViewChildren, args: [IgxDayItemComponent, { read: IgxDayItemComponent },] }],
    styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
    resetActiveMonth: [{ type: HostListener, args: ['focusout',] }],
    pointerDown: [{ type: HostListener, args: ['keydown.pagedown',] }, { type: HostListener, args: ['keydown.pageup',] }, { type: HostListener, args: ['keydown.shift.pagedown',] }, { type: HostListener, args: ['keydown.shift.pageup',] }, { type: HostListener, args: ['pointerdown',] }],
    onKeydownArrow: [{ type: HostListener, args: ['keydown.arrowleft', ['$event'],] }, { type: HostListener, args: ['keydown.arrowright', ['$event'],] }, { type: HostListener, args: ['keydown.arrowup', ['$event'],] }, { type: HostListener, args: ['keydown.arrowdown', ['$event'],] }],
    onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }]
};

let NEXT_ID$f = 0;
/**
 * Calendar provides a way to display date information.
 *
 * @igxModule IgxCalendarModule
 *
 * @igxTheme igx-calendar-theme, igx-icon-theme
 *
 * @igxKeywords calendar, datepicker, schedule, date
 *
 * @igxGroup Scheduling
 *
 * @remarks
 * The Ignite UI Calendar provides an easy way to display a calendar and allow users to select dates using single, multiple
 * or range selection.
 *
 * @example:
 * ```html
 * <igx-calendar selection="range"></igx-calendar>
 * ```
 */
class IgxCalendarComponent extends IgxMonthPickerBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Sets/gets the `id` of the calendar.
         *
         * @remarks
         * If not set, the `id` will have value `"igx-calendar-0"`.
         *
         * @example
         * ```html
         * <igx-calendar id="my-first-calendar"></igx-calendar>
         * ```
         * @memberof IgxCalendarComponent
         */
        this.id = `igx-calendar-${NEXT_ID$f++}`;
        /**
         * Sets/gets whether the calendar has header.
         * Default value is `true`.
         *
         * @example
         * ```html
         * <igx-calendar [hasHeader]="false"></igx-calendar>
         * ```
         */
        this.hasHeader = true;
        /**
         * Sets/gets whether the calendar header will be in vertical position.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-calendar [vertical] = "true"></igx-calendar>
         * ```
         */
        this.vertical = false;
        /**
         * Show/hide week numbers
         *
         * @example
         * ```html
         * <igx-calendar [showWeekNumbers]="true"></igx-calendar>
         * ``
         */
        this.showWeekNumbers = false;
        /**
         * Apply the different states for the transitions of animateChange
         * @hidden
         * @internal
         */
        this.animationAction = '';
        /**
         * Denote if the calendar view was changed with the keyboard
         *
         * @hidden
         * @internal
         */
        this.isKeydownTrigger = false;
        /**
         * The default aria role attribute for the component.
         *
         * @hidden
         * @internal
         */
        this.role = 'grid';
        /**
         * The default aria lebelled by attribute for the component.
         *
         * @hidden
         * @internal
         */
        this.ariaLabelledBy = 'calendar';
        /**
         * The default css class applied to the component.
         *
         * @hidden
         * @internal
         */
        this.styleClass = true;
        /**
         * @hidden
         * @internal
         */
        this.activeDate = new Date().toLocaleDateString();
        /**
         * @hidden
         * @internal
         */
        this._monthsViewNumber = 1;
        /**
         * Continious navigation through the previous months
         * @hidden
         * @internal
         */
        this.startPrevMonthScroll = (isKeydownTrigger = false) => {
            this.startMonthScroll$.next();
            this.monthScrollDirection = ScrollMonth.PREV;
            this.animationAction = ScrollMonth.PREV;
            this.previousMonth(isKeydownTrigger);
        };
        /**
         * Continious navigation through the next months
         * @hidden
         * @internal
         */
        this.startNextMonthScroll = (isKeydownTrigger = false) => {
            this.startMonthScroll$.next();
            this.monthScrollDirection = ScrollMonth.NEXT;
            this.animationAction = ScrollMonth.NEXT;
            this.nextMonth(isKeydownTrigger);
        };
        /**
         * Stop continuous navigation
         * @hidden
         * @internal
         */
        this.stopMonthScroll = (event) => {
            event.stopPropagation();
            // generally the scrolling is built on the calendar component
            // and all start/stop scrolling methods are called on the calendar
            // if we change below lines to call stopMonthScroll$ on the calendar instead of on the views,
            // strange bug is introduced --> after changing number of months, continuous scrolling on mouse click does not happen
            this.daysView.stopMonthScroll$.next(true);
            this.daysView.stopMonthScroll$.complete();
            if (this.monthScrollDirection === ScrollMonth.PREV) {
                this.prevMonthBtn.nativeElement.focus();
            }
            else if (this.monthScrollDirection === ScrollMonth.NEXT) {
                this.nextMonthBtn.nativeElement.focus();
            }
            if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                this.resetActiveDate();
            }
            this.monthScrollDirection = ScrollMonth.NONE;
        };
    }
    /**
     * Sets/gets the number of month views displayed.
     * Default value is `1`.
     *
     * @example
     * ```html
     * <igx-calendar [monthsViewNumber]="2"></igx-calendar>
     * ```
     */
    get monthsViewNumber() {
        return this._monthsViewNumber;
    }
    set monthsViewNumber(val) {
        if (val < 1) {
            return;
        }
        this._monthsViewNumber = val;
    }
    /**
     * The default css class applied to the component.
     *
     * @hidden
     * @internal
     */
    get styleVerticalClass() {
        return this.vertical;
    }
    /**
     * Denote if the year view is active.
     * @hidden
     * @internal
     */
    get isYearView() {
        return this.activeView === CalendarView.YEAR;
    }
    /**
     * Gets the header template.
     *
     * @example
     * ```typescript
     * let headerTemplate =  this.calendar.headerTeamplate;
     * ```
     * @memberof IgxCalendarComponent
     */
    get headerTemplate() {
        if (this.headerTemplateDirective) {
            return this.headerTemplateDirective.template;
        }
        return null;
    }
    /**
     * Sets the header template.
     *
     * @example
     * ```html
     * <igx-calendar headerTemplateDirective = "igxCalendarHeader"></igx-calendar>
     * ```
     * @memberof IgxCalendarComponent
     */
    set headerTemplate(directive) {
        this.headerTemplateDirective = directive;
    }
    /**
     * Gets the subheader template.
     *
     * @example
     * ```typescript
     * let subheaderTemplate = this.calendar.subheaderTemplate;
     * ```
     */
    get subheaderTemplate() {
        if (this.subheaderTemplateDirective) {
            return this.subheaderTemplateDirective.template;
        }
        return null;
    }
    /**
     * Sets the subheader template.
     *
     * @example
     * ```html
     * <igx-calendar subheaderTemplate = "igxCalendarSubheader"></igx-calendar>
     * ```
     * @memberof IgxCalendarComponent
     */
    set subheaderTemplate(directive) {
        this.subheaderTemplateDirective = directive;
    }
    /**
     * Gets the context for the template marked with the `igxCalendarHeader` directive.
     *
     * @example
     * ```typescript
     * let headerContext =  this.calendar.headerContext;
     * ```
     */
    get headerContext() {
        const date = this.headerDate;
        return this.generateContext(date);
    }
    /**
     * Gets the context for the template marked with either `igxCalendarSubHeaderMonth`
     * or `igxCalendarSubHeaderYear` directive.
     *
     * @example
     * ```typescript
     * let context =  this.calendar.context;
     * ```
     */
    get context() {
        const date = this.viewDate;
        return this.generateContext(date);
    }
    /**
     * Date displayed in header
     *
     * @hidden
     * @internal
     */
    get headerDate() {
        return this.selectedDates ? this.selectedDates : new Date();
    }
    ngAfterViewInit() {
        this.setSiblingMonths(this.monthViews);
        this._monthViewsChanges$ = this.monthViews.changes.subscribe(c => {
            this.setSiblingMonths(c);
        });
        this.startMonthScroll$.pipe(takeUntil(this.stopMonthScroll$), switchMap(() => this.scrollMonth$.pipe(skipLast(1), debounce(() => interval(300)), takeUntil(this.stopMonthScroll$)))).subscribe(() => {
            switch (this.monthScrollDirection) {
                case ScrollMonth.PREV:
                    this.previousMonth();
                    break;
                case ScrollMonth.NEXT:
                    this.nextMonth();
                    break;
                case ScrollMonth.NONE:
                default:
                    break;
            }
        });
    }
    /**
     * Returns the locale representation of the month in the month view if enabled,
     * otherwise returns the default `Date.getMonth()` value.
     *
     * @hidden
     * @internal
     */
    formattedMonth(value) {
        if (this.formatViews.month) {
            return this.formatterMonth.format(value);
        }
        return `${value.getMonth()}`;
    }
    /**
     * Change to previous month
     *
     * @hidden
     * @internal
     */
    previousMonth(isKeydownTrigger = false) {
        if (isKeydownTrigger && this.animationAction === ScrollMonth.NEXT) {
            return;
        }
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getPrevMonth(this.viewDate);
        this.animationAction = ScrollMonth.PREV;
        this.isKeydownTrigger = isKeydownTrigger;
    }
    suppressBlur() {
        var _a;
        (_a = this.monthViews) === null || _a === void 0 ? void 0 : _a.forEach(d => d.shouldResetDate = false);
        if (this.daysView) {
            this.daysView.shouldResetDate = false;
        }
    }
    /**
     * Change to next month
     *
     * @hidden
     * @internal
     */
    nextMonth(isKeydownTrigger = false) {
        if (isKeydownTrigger && this.animationAction === 'prev') {
            return;
        }
        this.isKeydownTrigger = isKeydownTrigger;
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getNextMonth(this.viewDate);
        this.animationAction = ScrollMonth.NEXT;
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewDecade(args, activeViewIdx) {
        super.activeViewDecade(activeViewIdx);
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.date = args;
                this.dacadeView.calendarDir.find(date => date.isCurrentYear).nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewDecadeKB(event, args, activeViewIdx) {
        super.activeViewDecadeKB(event, activeViewIdx);
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.date = args;
                this.dacadeView.calendarDir.find(date => date.isCurrentYear).nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @internal
     */
    getFormattedDate() {
        const date = this.headerDate;
        return {
            monthday: this.formatterMonthday.format(date),
            weekday: this.formatterWeekday.format(date),
        };
    }
    /**
     * Handles invoked on date selection
     * @hidden
     * @internal
     */
    childClicked(instance) {
        if (instance.isPrevMonth) {
            this.previousMonth();
        }
        if (instance.isNextMonth) {
            this.nextMonth();
        }
        this.selectDateFromClient(instance.date);
        if (this.selection === 'multi') {
            this.deselectDateInMonthViews(instance.date);
        }
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * @hidden
     * @internal
     */
    viewChanging(args) {
        this.animationAction = args.monthAction;
        this.isKeydownTrigger = true;
        this.nextDate = args.nextDate;
        this.callback = (next) => {
            const day = this.daysView.dates.find((item) => item.date.date.getTime() === next.getTime());
            if (day) {
                this.daysView.daysNavService.focusNextDate(day.nativeElement, args.key, true);
            }
        };
        this.previousViewDate = this.viewDate;
        this.viewDate = this.nextDate;
    }
    /**
     * @hidden
     * @intenal
     */
    changeMonth(event) {
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
        this.activeView = CalendarView.DEFAULT;
        requestAnimationFrame(() => {
            const elem = this.monthsBtns.find((e, idx) => idx === this.activeViewIdx);
            if (elem) {
                elem.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewYear(args, activeViewIdx, event) {
        this.activeView = CalendarView.YEAR;
        this.activeViewIdx = activeViewIdx;
        requestAnimationFrame(() => {
            this.monthsView.date = args;
            this.focusMonth(event.target);
        });
    }
    focusMonth(target) {
        const month = this.monthsView.monthsRef.find((e) => e.index === parseInt(target.parentElement.attributes['data-month'].value, 10));
        if (month) {
            month.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewYearKB(args, event, activeViewIdx) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            this.onActiveViewYear(args, activeViewIdx, event);
        }
    }
    /**
     * Deselects date(s) (based on the selection type).
     *
     * @example
     * ```typescript
     *  this.calendar.deselectDate(new Date(`2018-06-12`));
     * ````
     */
    deselectDate(value) {
        super.deselectDate(value);
        this.monthViews.forEach((view) => {
            view.selectedDates = this.selectedDates;
            view.rangeStarted = false;
        });
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * Helper method that does deselection for all month views when selection is "multi"
     * If not called, selection in other month views stays
     * @hidden
     * @internal
     */
    deselectDateInMonthViews(value) {
        this.monthViews.forEach(m => {
            m.deselectMultipleInMonth(value);
        });
    }
    /**
     * @hidden
     * @internal
     */
    getViewDate(i) {
        const date = this.calendarModel.timedelta(this.viewDate, 'month', i);
        return date;
    }
    /**
     * Getter for the context object inside the calendar templates.
     * @hidden
     * @internal
     */
    getContext(i) {
        const date = this.getViewDate(i);
        return this.generateContext(date, i);
    }
    /**
     * @hidden
     * @internal
     */
    animationDone(event) {
        if ((event.fromState === ScrollMonth.NONE && (event.toState === ScrollMonth.PREV || event.toState === ScrollMonth.NEXT)) ||
            (event.fromState === 'void' && event.toState === ScrollMonth.NONE)) {
            this.viewDateChanged.emit({ previousValue: this.previousViewDate, currentValue: this.viewDate });
        }
        if (!this.isKeydownTrigger) {
            this.resetActiveDate();
        }
        if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.scrollMonth$.next();
        }
        if (this.activeView !== CalendarView.DEFAULT) {
            return;
        }
        let monthView = this.daysView;
        let date = monthView.dates.find((d) => d.selected);
        while (!date && monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
            date = monthView.dates.find((d) => d.selected);
        }
        if (date && date.isFocusable && !this.isKeydownTrigger) {
            setTimeout(() => {
                date.nativeElement.focus();
            }, parseInt(slideInRight.options.params.duration, 10));
        }
        else if (this.callback && (event.toState === ScrollMonth.NEXT || event.toState === ScrollMonth.PREV)) {
            this.callback(this.nextDate);
        }
        this.animationAction = ScrollMonth.NONE;
    }
    /**
     * @hidden
     * @internal
     */
    viewRendered(event) {
        if (event.fromState !== 'void') {
            this.activeViewChanged.emit(this.activeView);
            if (this.activeView === 0) {
                this.resetActiveDate();
            }
        }
    }
    /**
     * @hidden
     * @internal
     */
    resetActiveDate() {
        if (!this.monthViews) {
            return;
        }
        let dates = [];
        this.monthViews.map(mv => mv.dates).forEach(days => { dates = dates.concat(days.toArray()); });
        const date = dates.find(day => day.selected && day.isCurrentMonth) || dates.find(day => day.isToday && day.isCurrentMonth)
            || dates.find(d => d.isFocusable);
        if (date) {
            this.activeDate = date.date.date.toLocaleDateString();
        }
    }
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * @internal
     */
    onKeydownPageDown(event) {
        event.preventDefault();
        if (this.activeView !== CalendarView.DEFAULT) {
            return;
        }
        const isPageDown = event.key === 'PageDown';
        const step = isPageDown ? 1 : -1;
        let monthView = this.daysView;
        let activeDate;
        while (!activeDate && monthView) {
            activeDate = monthView.dates.find((date) => date.nativeElement === document.activeElement);
            monthView = monthView.nextMonthView;
        }
        if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            let year = this.nextDate.getFullYear();
            let month = this.nextDate.getMonth() + step;
            if (isPageDown) {
                if (month > 11) {
                    month = 0;
                    year += step;
                }
            }
            else {
                if (month < 0) {
                    month = 11;
                    year += step;
                }
            }
            const range = monthRange(this.nextDate.getFullYear(), month);
            let day = this.nextDate.getDate();
            if (day > range[1]) {
                day = range[1];
            }
            this.nextDate.setDate(day);
            this.nextDate.setMonth(month);
            this.nextDate.setFullYear(year);
            this.callback = (next) => {
                monthView = this.daysView;
                let dayItem;
                while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                    dayItem = monthView.dates.find((d) => d.date.date.getTime() === next.getTime());
                    monthView = monthView.nextMonthView;
                }
                if (dayItem && dayItem.isFocusable) {
                    dayItem.nativeElement.focus();
                }
            };
        }
        if (isPageDown) {
            event.repeat ? requestAnimationFrame(() => this.nextMonth(true)) : this.nextMonth(true);
        }
        else {
            event.repeat ? requestAnimationFrame(() => this.previousMonth(true)) : this.previousMonth(true);
        }
    }
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * @internal
     */
    onKeydownShiftPageUp(event) {
        event.preventDefault();
        if (this.activeView !== CalendarView.DEFAULT) {
            return;
        }
        const isPageDown = event.key === 'PageDown';
        const step = isPageDown ? 1 : -1;
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', step);
        this.animationAction = isPageDown ? ScrollMonth.NEXT : ScrollMonth.PREV;
        this.isKeydownTrigger = true;
        let monthView = this.daysView;
        let activeDate;
        while (!activeDate && monthView) {
            activeDate = monthView.dates.find((date) => date.nativeElement === document.activeElement);
            monthView = monthView.nextMonthView;
        }
        if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            const year = this.nextDate.getFullYear() + step;
            const range = monthRange(year, this.nextDate.getMonth());
            let day = this.nextDate.getDate();
            if (day > range[1]) {
                day = range[1];
            }
            this.nextDate.setDate(day);
            this.nextDate.setFullYear(year);
            this.callback = (next) => {
                monthView = this.daysView;
                let dayItem;
                while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                    dayItem = monthView.dates.find((d) => d.date.date.getTime() === next.getTime());
                    monthView = monthView.nextMonthView;
                }
                if (dayItem && dayItem.isFocusable) {
                    dayItem.nativeElement.focus();
                }
            };
        }
    }
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * @internal
     */
    onKeydownHome(event) {
        if (this.daysView) {
            this.daysView.onKeydownHome(event);
        }
    }
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * @internal
     */
    onKeydownEnd(event) {
        if (this.daysView) {
            this.daysView.onKeydownEnd(event);
        }
    }
    /**
     * Stop continuous navigation on mouseup event
     * @hidden
     * @internal
     */
    onMouseUp(event) {
        if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.stopMonthScroll(event);
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        if (this._monthViewsChanges$) {
            this._monthViewsChanges$.unsubscribe();
        }
    }
    /**
     * Helper method building and returning the context object inside
     * the calendar templates.
     * @hidden
     * @internal
     */
    generateContext(value, i) {
        const formatObject = Object.assign({ index: i, monthView: () => this.onActiveViewYear(value, i), yearView: () => this.onActiveViewDecade(value, i) }, this.calendarModel.formatToParts(value, this.locale, this.formatOptions, ['era', 'year', 'month', 'day', 'weekday']));
        return { $implicit: formatObject };
    }
    /**
     * Helper method that sets references for prev/next months for each month in the view
     * @hidden
     * @internal
     */
    setSiblingMonths(monthViews) {
        monthViews.forEach((item, index) => {
            const prevMonthView = this.getMonthView(index - 1);
            const nextMonthView = this.getMonthView(index + 1);
            item.nextMonthView = nextMonthView;
            item.prevMonthView = prevMonthView;
        });
    }
    /**
     * Helper method returning previous/next day views
     * @hidden
     * @internal
     */
    getMonthView(index) {
        if (index === -1 || index === this.monthViews.length) {
            return null;
        }
        else {
            return this.monthViews.toArray()[index];
        }
    }
}
IgxCalendarComponent.ɵfac = function IgxCalendarComponent_Factory(t) { return ɵIgxCalendarComponent_BaseFactory(t || IgxCalendarComponent); };
IgxCalendarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCalendarComponent, selectors: [["igx-calendar"]], contentQueries: function IgxCalendarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, IgxCalendarHeaderTemplateDirective, true, IgxCalendarHeaderTemplateDirective);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, IgxCalendarSubheaderTemplateDirective, true, IgxCalendarSubheaderTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.subheaderTemplateDirective = _t.first);
    } }, viewQuery: function IgxCalendarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c34, true, IgxMonthsViewComponent);
        ɵngcc0.ɵɵviewQuery(_c35, true, IgxYearsViewComponent);
        ɵngcc0.ɵɵviewQuery(_c36, true, IgxDaysViewComponent);
        ɵngcc0.ɵɵviewQuery(_c37, true);
        ɵngcc0.ɵɵviewQuery(_c38, true);
        ɵngcc0.ɵɵviewQuery(_c39, true);
        ɵngcc0.ɵɵviewQuery(_c36, true, IgxDaysViewComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthsView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dacadeView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.daysView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.prevMonthBtn = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nextMonthBtn = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthsBtns = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthViews = _t);
    } }, hostVars: 7, hostBindings: function IgxCalendarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.pagedown", function IgxCalendarComponent_keydown_pagedown_HostBindingHandler($event) { return ctx.onKeydownPageDown($event); })("keydown.pageup", function IgxCalendarComponent_keydown_pageup_HostBindingHandler($event) { return ctx.onKeydownPageDown($event); })("keydown.shift.pageup", function IgxCalendarComponent_keydown_shift_pageup_HostBindingHandler($event) { return ctx.onKeydownShiftPageUp($event); })("keydown.shift.pagedown", function IgxCalendarComponent_keydown_shift_pagedown_HostBindingHandler($event) { return ctx.onKeydownShiftPageUp($event); })("keydown.home", function IgxCalendarComponent_keydown_home_HostBindingHandler($event) { return ctx.onKeydownHome($event); })("keydown.end", function IgxCalendarComponent_keydown_end_HostBindingHandler($event) { return ctx.onKeydownEnd($event); })("mouseup", function IgxCalendarComponent_mouseup_HostBindingHandler($event) { return ctx.onMouseUp($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role)("aria-labelledby", ctx.ariaLabelledBy);
        ɵngcc0.ɵɵclassProp("igx-calendar", ctx.styleClass)("igx-calendar--vertical", ctx.styleVerticalClass);
    } }, inputs: { id: "id", hasHeader: "hasHeader", vertical: "vertical", showWeekNumbers: "showWeekNumbers", animationAction: "animationAction", monthsViewNumber: "monthsViewNumber" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxCalendarComponent
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 8, vars: 4, consts: [["defaultHeader", ""], ["defaultMonth", ""], ["class", "igx-calendar__header", 4, "ngIf"], ["class", "igx-calendar__body", 3, "swiperight", "swipeleft", "pointerdown", 4, "ngIf"], [3, "date", "locale", "formatView", "monthFormat", "onSelection", 4, "ngIf"], [3, "date", "locale", "formatView", "yearFormat", "onSelection", 4, "ngIf"], ["tabindex", "0", 1, "igx-calendar-picker__date", 3, "keydown", "click"], ["monthsBtn", ""], ["yearsBtn", ""], [1, "igx-calendar__header"], [1, "igx-calendar__header-year"], [1, "igx-calendar__header-date"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-calendar__body", 3, "swiperight", "swipeleft", "pointerdown"], [1, "igx-calendar-picker"], ["tabindex", "0", "igxCalendarScrollMonth", "", 1, "igx-calendar-picker__prev", 3, "startScroll", "stopScroll", "ngStyle"], ["prevMonthBtn", ""], ["fontSet", "material"], ["class", "igx-calendar-picker__dates", 3, "width", 4, "ngFor", "ngForOf"], ["tabindex", "0", "igxCalendarScrollMonth", "", 1, "igx-calendar-picker__next", 3, "startScroll", "stopScroll", "ngStyle"], ["nextMonthBtn", ""], [2, "display", "flex"], [3, "changeDaysView", "selection", "locale", "value", "activeDate", "viewDate", "weekStart", "formatOptions", "formatViews", "disabledDates", "specialDates", "hideOutsideDays", "showWeekNumbers", "activeDateChange", "onViewChanging", "onDateSelection", "monthsViewBlur", 4, "ngFor", "ngForOf"], [1, "igx-calendar-picker__dates"], [3, "changeDaysView", "selection", "locale", "value", "activeDate", "viewDate", "weekStart", "formatOptions", "formatViews", "disabledDates", "specialDates", "hideOutsideDays", "showWeekNumbers", "activeDateChange", "onViewChanging", "onDateSelection", "monthsViewBlur"], ["days", ""], [3, "date", "locale", "formatView", "monthFormat", "onSelection"], ["months", ""], [3, "date", "locale", "formatView", "yearFormat", "onSelection"], ["decade", ""]], template: function IgxCalendarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxCalendarComponent_ng_template_0_Template, 4, 2, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxCalendarComponent_ng_template_2_Template, 6, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxCalendarComponent_div_4_Template, 5, 3, "div", 2);
        ɵngcc0.ɵɵtemplate(5, IgxCalendarComponent_div_5_Template, 15, 18, "div", 3);
        ɵngcc0.ɵɵtemplate(6, IgxCalendarComponent_igx_months_view_6_Template, 2, 5, "igx-months-view", 4);
        ɵngcc0.ɵɵtemplate(7, IgxCalendarComponent_igx_years_view_7_Template, 2, 5, "igx-years-view", 5);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selection === "single" && ctx.hasHeader);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isDefaultView);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isYearView);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isDecadeView);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, IgxCalendarScrollMonthDirective, ɵngcc2.NgStyle, IgxIconComponent, ɵngcc2.NgForOf, IgxDaysViewComponent, IgxMonthsViewComponent, IgxYearsViewComponent]; }, pipes: function () { return [IgxMonthViewSlotsCalendar, IgxGetViewDateCalendar]; }, encapsulation: 2, data: { animation: [
            trigger('animateView', [
                transition('void => 0', useAnimation(fadeIn)),
                transition('void => *', useAnimation(scaleInCenter, {
                    params: {
                        duration: '.2s',
                        fromScale: .9
                    }
                }))
            ]),
            trigger('animateChange', [
                transition('* => prev', useAnimation(slideInLeft, {
                    params: {
                        fromPosition: 'translateX(-30%)'
                    }
                })),
                transition('* => next', useAnimation(slideInRight, {
                    params: {
                        fromPosition: 'translateX(30%)'
                    }
                }))
            ])
        ] } });
IgxCalendarComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    hasHeader: [{ type: Input }],
    vertical: [{ type: Input }],
    monthsViewNumber: [{ type: Input }],
    showWeekNumbers: [{ type: Input }],
    animationAction: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    ariaLabelledBy: [{ type: HostBinding, args: ['attr.aria-labelledby',] }],
    styleVerticalClass: [{ type: HostBinding, args: ['class.igx-calendar--vertical',] }],
    styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
    monthsView: [{ type: ViewChild, args: ['months', { read: IgxMonthsViewComponent },] }],
    monthsBtns: [{ type: ViewChildren, args: ['monthsBtn',] }],
    dacadeView: [{ type: ViewChild, args: ['decade', { read: IgxYearsViewComponent },] }],
    daysView: [{ type: ViewChild, args: ['days', { read: IgxDaysViewComponent },] }],
    monthViews: [{ type: ViewChildren, args: ['days', { read: IgxDaysViewComponent },] }],
    prevMonthBtn: [{ type: ViewChild, args: ['prevMonthBtn',] }],
    nextMonthBtn: [{ type: ViewChild, args: ['nextMonthBtn',] }],
    headerTemplateDirective: [{ type: ContentChild, args: [forwardRef(() => IgxCalendarHeaderTemplateDirective), { read: IgxCalendarHeaderTemplateDirective, static: true },] }],
    subheaderTemplateDirective: [{ type: ContentChild, args: [forwardRef(() => IgxCalendarSubheaderTemplateDirective), { read: IgxCalendarSubheaderTemplateDirective, static: true },] }],
    onKeydownPageDown: [{ type: HostListener, args: ['keydown.pagedown', ['$event'],] }, { type: HostListener, args: ['keydown.pageup', ['$event'],] }],
    onKeydownShiftPageUp: [{ type: HostListener, args: ['keydown.shift.pageup', ['$event'],] }, { type: HostListener, args: ['keydown.shift.pagedown', ['$event'],] }],
    onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }],
    onMouseUp: [{ type: HostListener, args: ['document:mouseup', ['$event'],] }]
};

let NEXT_ID$g = 0;
class IgxMonthPickerComponent extends IgxMonthPickerBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Sets/gets the `id` of the month picker.
         * If not set, the `id` will have value `"igx-month-picker-0"`.
         */
        this.id = `igx-month-picker-${NEXT_ID$g++}`;
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * @hidden
         */
        this.yearAction = '';
    }
    /**
     * @hidden
     */
    animationDone(event) {
        if ((event.fromState === 'void' && event.toState === '') ||
            (event.fromState === '' && (event.toState === ScrollMonth.PREV || event.toState === ScrollMonth.NEXT))) {
            this.viewDateChanged.emit({ previousValue: this.previousViewDate, currentValue: this.viewDate });
        }
        this.yearAction = '';
    }
    /**
     * @hidden
     */
    viewRendered(event) {
        if (event.fromState !== 'void') {
            this.activeViewChanged.emit(this.activeView);
        }
    }
    /**
     * @hidden
     */
    activeViewDecadeKB(event) {
        super.activeViewDecadeKB(event);
        if (event.key === "ArrowRight" /* RIGHT_ARROW */ || event.key === "Right" /* RIGHT_ARROW_IE */) {
            this.nextYear(event);
        }
        if (event.key === "ArrowLeft" /* LEFT_ARROW */ || event.key === "Left" /* LEFT_ARROW_IE */) {
            this.previousYear(event);
        }
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.el.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     */
    activeViewDecade() {
        super.activeViewDecade();
        requestAnimationFrame(() => {
            this.dacadeView.el.nativeElement.focus();
        });
    }
    /**
     * @hidden
     */
    changeYearKB(event, next = true) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.stopPropagation();
            next ? this.nextYear() : this.previousYear();
        }
    }
    /**
     * @hidden
     */
    selectYear(event) {
        this.previousViewDate = this.viewDate;
        this.viewDate = new Date(event.getFullYear(), event.getMonth(), event.getDate());
        this.activeView = CalendarView.DEFAULT;
        requestAnimationFrame(() => {
            if (this.yearsBtn) {
                this.yearsBtn.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     */
    selectMonth(event) {
        this.selectDate(event);
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * Selects a date.
     * ```typescript
     *  this.monthPicker.selectDate(new Date(`2018-06-12`));
     * ```
     */
    selectDate(value) {
        if (!value) {
            return new Date();
        }
        super.selectDate(value);
        this.viewDate = value;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        if (value) {
            this.viewDate = this.selectedDates = value;
        }
    }
    /**
     * @hidden
     */
    previousYear(event) {
        event === null || event === void 0 ? void 0 : event.preventDefault();
        if (event && this.yearAction === 'next') {
            return;
        }
        this.yearAction = 'prev';
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getPrevYear(this.viewDate);
    }
    /**
     * @hidden
     */
    nextYear(event) {
        event === null || event === void 0 ? void 0 : event.preventDefault();
        if (event && this.yearAction === 'prev') {
            return;
        }
        this.yearAction = 'next';
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getNextYear(this.viewDate);
    }
    /**
     * @hidden
     */
    onKeydownHome(event) {
        if (this.monthsView) {
            this.monthsView.el.nativeElement.focus();
            this.monthsView.onKeydownHome(event);
        }
    }
    /**
     * @hidden
     */
    onKeydownEnd(event) {
        if (this.monthsView) {
            this.monthsView.el.nativeElement.focus();
            this.monthsView.onKeydownEnd(event);
        }
    }
}
IgxMonthPickerComponent.ɵfac = function IgxMonthPickerComponent_Factory(t) { return ɵIgxMonthPickerComponent_BaseFactory(t || IgxMonthPickerComponent); };
IgxMonthPickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxMonthPickerComponent, selectors: [["igx-month-picker"]], viewQuery: function IgxMonthPickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c34, true, IgxMonthsViewComponent);
        ɵngcc0.ɵɵviewQuery(_c35, true, IgxYearsViewComponent);
        ɵngcc0.ɵɵviewQuery(_c36, true, IgxDaysViewComponent);
        ɵngcc0.ɵɵviewQuery(_c33, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthsView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dacadeView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.daysView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearsBtn = _t.first);
    } }, hostVars: 3, hostBindings: function IgxMonthPickerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.pageup", function IgxMonthPickerComponent_keydown_pageup_HostBindingHandler($event) { return ctx.previousYear($event); })("keydown.pagedown", function IgxMonthPickerComponent_keydown_pagedown_HostBindingHandler($event) { return ctx.nextYear($event); })("keydown.home", function IgxMonthPickerComponent_keydown_home_HostBindingHandler($event) { return ctx.onKeydownHome($event); })("keydown.end", function IgxMonthPickerComponent_keydown_end_HostBindingHandler($event) { return ctx.onKeydownEnd($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-calendar", ctx.styleClass);
    } }, inputs: { id: "id" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxMonthPickerComponent
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [["class", "igx-calendar__body", 3, "swiperight", "swipeleft", 4, "ngIf"], [3, "date", "locale", "formatView", "yearFormat", "onSelection", 4, "ngIf"], [1, "igx-calendar__body", 3, "swiperight", "swipeleft"], [1, "igx-calendar-picker"], ["tabindex", "0", 1, "igx-calendar-picker__prev", 3, "ngStyle", "click", "keydown"], ["fontSet", "material"], ["tabindex", "0", 1, "igx-calendar-picker__date", 3, "keydown", "click"], ["yearsBtn", ""], ["tabindex", "0", 1, "igx-calendar-picker__next", 3, "ngStyle", "click", "keydown"], [3, "date", "locale", "formatView", "monthFormat", "onSelection"], ["months", ""], [3, "date", "locale", "formatView", "yearFormat", "onSelection"], ["decade", ""]], template: function IgxMonthPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxMonthPickerComponent_div_0_Template, 14, 13, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxMonthPickerComponent_igx_years_view_1_Template, 2, 5, "igx-years-view", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isDefaultView);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isDecadeView);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgStyle, IgxIconComponent, IgxMonthsViewComponent, IgxYearsViewComponent], encapsulation: 2, data: { animation: [
            trigger('animateView', [
                transition('void => 0', useAnimation(fadeIn)),
                transition('void => *', useAnimation(scaleInCenter, {
                    params: {
                        duration: '.2s',
                        fromScale: .9
                    }
                }))
            ]),
            trigger('animateChange', [
                transition('* => prev', useAnimation(slideInLeft, {
                    params: {
                        fromPosition: 'translateX(-30%)'
                    }
                })),
                transition('* => next', useAnimation(slideInRight, {
                    params: {
                        fromPosition: 'translateX(30%)'
                    }
                }))
            ])
        ] } });
IgxMonthPickerComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
    monthsView: [{ type: ViewChild, args: ['months', { read: IgxMonthsViewComponent },] }],
    dacadeView: [{ type: ViewChild, args: ['decade', { read: IgxYearsViewComponent },] }],
    daysView: [{ type: ViewChild, args: ['days', { read: IgxDaysViewComponent },] }],
    yearsBtn: [{ type: ViewChild, args: ['yearsBtn',] }],
    previousYear: [{ type: HostListener, args: ['keydown.pageup', ['$event'],] }],
    nextYear: [{ type: HostListener, args: ['keydown.pagedown', ['$event'],] }],
    onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }]
};

class IgxMonthViewSlotsCalendar {
    transform(monthViews) {
        return new Array(monthViews);
    }
}
IgxMonthViewSlotsCalendar.ɵfac = function IgxMonthViewSlotsCalendar_Factory(t) { return new (t || IgxMonthViewSlotsCalendar)(); };
IgxMonthViewSlotsCalendar.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "IgxMonthViewSlots", type: IgxMonthViewSlotsCalendar, pure: true });
class IgxGetViewDateCalendar {
    constructor() {
        this.calendar = new Calendar();
    }
    transform(index, viewDate, wholeDate = true) {
        const date = this.calendar.timedelta(viewDate, 'month', index);
        return wholeDate ? date : date.getMonth();
    }
}
IgxGetViewDateCalendar.ɵfac = function IgxGetViewDateCalendar_Factory(t) { return new (t || IgxGetViewDateCalendar)(); };
IgxGetViewDateCalendar.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "IgxGetViewDate", type: IgxGetViewDateCalendar, pure: true });
IgxGetViewDateCalendar.ctorParameters = () => [];

/**
 * @hidden
 */
class IgxCalendarModule {
}
IgxCalendarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxCalendarModule });
IgxCalendarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxCalendarModule_Factory(t) { return new (t || IgxCalendarModule)(); }, imports: [[CommonModule, FormsModule, IgxIconModule]] });

let NEXT_ID$h = 0;
/**
 * IgxCardMedia is container for the card media section.
 * Use it to wrap images and videos.
 */
class IgxCardMediaDirective {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card__media';
        /**
         * An @Input property that sets the `width` and `min-width` style property
         * of the media container. If not provided it will be set to `auto`.
         *
         * @example
         * ```html
         * <igx-card-media width="300px"></igx-card-media>
         * ```
         */
        this.width = 'auto';
        /**
         * An @Input property that sets the `height` style property of the media container.
         * If not provided it will be set to `auto`.
         *
         * @example
         * ```html
         * <igx-card-media height="50%"></igx-card-media>
         * ```
         */
        this.height = 'auto';
        /**
         * An @Input property that sets the `role` attribute of the media container.
         */
        this.role = 'img';
    }
}
IgxCardMediaDirective.ɵfac = function IgxCardMediaDirective_Factory(t) { return new (t || IgxCardMediaDirective)(); };
IgxCardMediaDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCardMediaDirective, selectors: [["igx-card-media"]], hostVars: 9, hostBindings: function IgxCardMediaDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵstyleProp("width", ctx.width)("min-width", ctx.width)("height", ctx.height);
        ɵngcc0.ɵɵclassProp("igx-card__media", ctx.cssClass);
    } }, inputs: { width: "width", height: "height", role: "role" } });
IgxCardMediaDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-card__media',] }],
    width: [{ type: HostBinding, args: ['style.width',] }, { type: HostBinding, args: ['style.min-width',] }, { type: Input }],
    height: [{ type: HostBinding, args: ['style.height',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }]
};
/**
 * IgxCardHeader is container for the card header
 */
class IgxCardHeaderComponent {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card-header';
        /**
         * An @Input property that sets the layout style of the header.
         * By default the header elements(thumbnail and title/subtitle) are aligned horizontally.
         *
         * @example
         * ```html
         * <igx-card-header [vertical]="true"></igx-card-header>
         * ```
         */
        this.vertical = false;
        /**
         * An @Input property that sets the value of the `role` attribute of the card header.
         * By default the value is set to `header`.
         *
         * @example
         * ```html
         * <igx-card-header role="header"></igx-card-header>
         * ```
         */
        this.role = 'header';
    }
}
IgxCardHeaderComponent.ɵfac = function IgxCardHeaderComponent_Factory(t) { return new (t || IgxCardHeaderComponent)(); };
IgxCardHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCardHeaderComponent, selectors: [["igx-card-header"]], hostVars: 5, hostBindings: function IgxCardHeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-card-header", ctx.cssClass)("igx-card-header--vertical", ctx.vertical);
    } }, inputs: { vertical: "vertical" }, ngContentSelectors: _c44, decls: 5, vars: 0, consts: [[1, "igx-card-header__thumbnail"], [1, "igx-card-header__titles"]], template: function IgxCardHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c43);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵprojection(3, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(4, 2);
    } }, encapsulation: 2 });
IgxCardHeaderComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-card-header',] }],
    vertical: [{ type: HostBinding, args: ['class.igx-card-header--vertical',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }]
};
/**
 * IgxCardThumbnail is container for the card thumbnail section.
 * Use it to wrap anything you want to be used as a thumbnail.
 */
class IgxCardThumbnailDirective {
}
IgxCardThumbnailDirective.ɵfac = function IgxCardThumbnailDirective_Factory(t) { return new (t || IgxCardThumbnailDirective)(); };
IgxCardThumbnailDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCardThumbnailDirective, selectors: [["", "igxCardThumbnail", ""]] });
/**
 * igxCardHeaderTitle is used to denote the header title in a card.
 * Use it to tag text nodes.
 */
class IgxCardHeaderTitleDirective {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card__header__title';
    }
}
IgxCardHeaderTitleDirective.ɵfac = function IgxCardHeaderTitleDirective_Factory(t) { return new (t || IgxCardHeaderTitleDirective)(); };
IgxCardHeaderTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCardHeaderTitleDirective, selectors: [["", "igxCardHeaderTitle", ""]], hostVars: 2, hostBindings: function IgxCardHeaderTitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-card-header__title", ctx.cssClass);
    } } });
IgxCardHeaderTitleDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-card-header__title',] }]
};
/**
 * igxCardHeaderSubtitle is used to denote the header subtitle in a card.
 * Use it to tag text nodes.
 */
class IgxCardHeaderSubtitleDirective {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card-header__subtitle';
    }
}
IgxCardHeaderSubtitleDirective.ɵfac = function IgxCardHeaderSubtitleDirective_Factory(t) { return new (t || IgxCardHeaderSubtitleDirective)(); };
IgxCardHeaderSubtitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCardHeaderSubtitleDirective, selectors: [["", "igxCardHeaderSubtitle", ""]], hostVars: 2, hostBindings: function IgxCardHeaderSubtitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-card-header__subtitle", ctx.cssClass);
    } } });
IgxCardHeaderSubtitleDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-card-header__subtitle',] }]
};
/**
 * IgxCardContent is container for the card content.
 */
class IgxCardContentDirective {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card-content';
    }
}
IgxCardContentDirective.ɵfac = function IgxCardContentDirective_Factory(t) { return new (t || IgxCardContentDirective)(); };
IgxCardContentDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCardContentDirective, selectors: [["igx-card-content"]], hostVars: 2, hostBindings: function IgxCardContentDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-card-content", ctx.cssClass);
    } } });
IgxCardContentDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-card-content',] }]
};
/**
 * IgxCardFooter is container for the card footer
 */
class IgxCardFooterDirective {
    constructor() {
        /**
         * An @Input property that sets the value of the `role` attribute of the card footer.
         * By default the value is set to `footer`.
         *
         * @example
         * ```html
         * <igx-card-footer role="footer"></igx-card-footer>
         * ```
         */
        this.role = 'footer';
    }
}
IgxCardFooterDirective.ɵfac = function IgxCardFooterDirective_Factory(t) { return new (t || IgxCardFooterDirective)(); };
IgxCardFooterDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCardFooterDirective, selectors: [["igx-card-footer"]], hostVars: 1, hostBindings: function IgxCardFooterDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
    } }, inputs: { role: "role" } });
IgxCardFooterDirective.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }]
};
/**
 * Card provides a way to display organized content in appealing way.
 *
 * @igxModule IgxCardModule
 *
 * @igxTheme igx-card-theme, igx-icon-theme, igx-button-theme
 *
 * @igxKeywords card, button, avatar, icon
 *
 * @igxGroup Layouts
 *
 * @remarks
 * The Ignite UI Card serves as a container that allows custom content to be organized in an appealing way. There are
 * five sections in a card that you can use to organize your content. These are header, media, content, actions, and footer.
 *
 * @example
 * ```html
 * <igx-card>
 *   <igx-card-header>
 *     <h3 igxCardHeaderTitle>{{title}}</h3>
 *     <h5 igxCardHeaderSubtitle>{{subtitle}}</h5>
 *   </igx-card-header>
 *   <igx-card-actions>
 *       <button igxButton igxRipple>Share</button>
 *       <button igxButton igxRipple>Play Album</button>
 *   </igx-card-actions>
 * </igx-card>
 * ```
 */
const IgxCardType = mkenum({
    ELEVATED: 'elevated',
    OUTLINED: 'outlined'
});
class IgxCardComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the card.
         * If not set, `id` will have value `"igx-card-0"`;
         *
         * @example
         * ```html
         * <igx-card id = "my-first-card"></igx-card>
         * ```
         * ```typescript
         * let cardId =  this.card.id;
         * ```
         */
        this.id = `igx-card-${NEXT_ID$h++}`;
        /**
         * An @Input property that sets the value of the `role` attribute of the card.
         * By default the value is set to `group`.
         *
         * @example
         * ```html
         * <igx-card role="group"></igx-card>
         * ```
         */
        this.role = 'group';
        /**
         * An @Input property that sets the value of the `type` attribute of the card.
         * By default the value is set to `default`. You can make the card use the
         * outlined style by setting the value to `outlined`.
         *
         * @example
         * ```html
         * <igx-card type="outlined"></igx-card>
         * ```
         */
        this.type = IgxCardType.ELEVATED;
        /**
         * An @Input property that sets the value of the `horizontal` attribute of the card.
         * Setting this to `true` will make the different card sections align horizontally,
         * essentially flipping the card to the side.
         *
         * @example
         * ```html
         * <igx-card [horizontal]="true"></igx-card>
         * ```
         */
        this.horizontal = false;
    }
    /**
     * A getter which will return true if the card type is `outlined`.
     */
    get isOutlinedCard() {
        return this.type === IgxCardType.OUTLINED;
    }
}
IgxCardComponent.ɵfac = function IgxCardComponent_Factory(t) { return new (t || IgxCardComponent)(); };
IgxCardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCardComponent, selectors: [["igx-card"]], hostVars: 8, hostBindings: function IgxCardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-card", ctx.type)("igx-card--horizontal", ctx.horizontal)("igx-card--outlined", ctx.isOutlinedCard);
    } }, inputs: { id: "id", role: "role", type: "type", horizontal: "horizontal" }, ngContentSelectors: _c2, decls: 5, vars: 0, consts: [["select", "igx-card-media"], ["select", "igx-card-header"], ["select", "igx-card-content"], ["select", "igx-card-actions"]], template: function IgxCardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementContainer(1, 1);
        ɵngcc0.ɵɵelementContainerStart(2, 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementContainer(4, 3);
    } }, encapsulation: 2 });
IgxCardComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    type: [{ type: HostBinding, args: ['class.igx-card',] }, { type: Input }],
    isOutlinedCard: [{ type: HostBinding, args: ['class.igx-card--outlined',] }],
    horizontal: [{ type: HostBinding, args: ['class.igx-card--horizontal',] }, { type: Input }]
};
const IgxCardActionsLayout = mkenum({
    START: 'start',
    JUSTIFY: 'justify'
});
/**
 * IgxCardActions is container for the card actions.
 */
class IgxCardActionsComponent {
    constructor(card) {
        this.card = card;
        this.isVerticalSet = false;
        /**
         * An @Input property that sets the layout style of the actions.
         * By default icons and icon buttons, as well as regular buttons
         * are split into two containers, which are then positioned on both ends
         * of the card-actions area.
         * You can justify the elements in those groups so they are positioned equally
         * from one another taking up all the space available along the card actions axis.
         *
         * @example
         * ```html
         * <igx-card-actions layout="justify"></igx-card-actions>
         * ```
         */
        this.layout = IgxCardActionsLayout.START;
        /**
         * An @Input property that sets order of the buttons the actions area.
         * By default all icons/icon buttons are placed at the end of the action
         * area. Any regular buttons(flat, raised) will appear before the icons/icon buttons
         * placed in the actions area.
         * If you want to reverse their positions so that icons appear first, use the `reverse`
         * attribute.
         *
         * @example
         * ```html
         * <igx-card-actions [reverse]="true"></igx-card-actions>
         * ```
         */
        this.reverse = false;
    }
    /**
     * A getter that returns `true` when the layout has been
     * set to `justify`.
     */
    get isJustifyLayout() {
        return this.layout === IgxCardActionsLayout.JUSTIFY;
    }
    ngOnChanges(changes) {
        for (const prop in changes) {
            if (prop === 'vertical') {
                this.isVerticalSet = true;
            }
        }
    }
    ngOnInit() {
        this.vertical = !this.isVerticalSet && this.card.horizontal;
    }
}
IgxCardActionsComponent.ɵfac = function IgxCardActionsComponent_Factory(t) { return new (t || IgxCardActionsComponent)(ɵngcc0.ɵɵdirectiveInject(IgxCardComponent, 8)); };
IgxCardActionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCardActionsComponent, selectors: [["igx-card-actions"]], hostVars: 8, hostBindings: function IgxCardActionsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-card-actions", ctx.layout)("igx-card-actions--reverse", ctx.reverse)("igx-card-actions--justify", ctx.isJustifyLayout)("igx-card-actions--vertical", ctx.vertical);
    } }, inputs: { layout: "layout", reverse: "reverse", vertical: "vertical" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c46, decls: 6, vars: 0, consts: [[1, "igx-card-actions__icons"], [1, "igx-card-actions__buttons"], ["buttons", ""]], template: function IgxCardActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c45);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵprojection(4, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(5, 2);
    } }, encapsulation: 2 });
IgxCardActionsComponent.ctorParameters = () => [
    { type: IgxCardComponent, decorators: [{ type: Optional }, { type: Inject, args: [IgxCardComponent,] }] }
];
IgxCardActionsComponent.propDecorators = {
    layout: [{ type: HostBinding, args: ['class.igx-card-actions',] }, { type: Input }],
    vertical: [{ type: HostBinding, args: ['class.igx-card-actions--vertical',] }, { type: Input }],
    isJustifyLayout: [{ type: HostBinding, args: ['class.igx-card-actions--justify',] }],
    reverse: [{ type: HostBinding, args: ['class.igx-card-actions--reverse',] }, { type: Input }]
};
/**
 * @hidden
 */
class IgxCardModule {
}
IgxCardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxCardModule });
IgxCardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxCardModule_Factory(t) { return new (t || IgxCardModule)(); }, imports: [[CommonModule, IgxButtonModule]] });

class IgxCarouselIndicatorDirective {
}
IgxCarouselIndicatorDirective.ɵfac = function IgxCarouselIndicatorDirective_Factory(t) { return new (t || IgxCarouselIndicatorDirective)(); };
IgxCarouselIndicatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCarouselIndicatorDirective, selectors: [["", "igxCarouselIndicator", ""]] });
class IgxCarouselNextButtonDirective {
}
IgxCarouselNextButtonDirective.ɵfac = function IgxCarouselNextButtonDirective_Factory(t) { return new (t || IgxCarouselNextButtonDirective)(); };
IgxCarouselNextButtonDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCarouselNextButtonDirective, selectors: [["", "igxCarouselNextButton", ""]] });
class IgxCarouselPrevButtonDirective {
}
IgxCarouselPrevButtonDirective.ɵfac = function IgxCarouselPrevButtonDirective_Factory(t) { return new (t || IgxCarouselPrevButtonDirective)(); };
IgxCarouselPrevButtonDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCarouselPrevButtonDirective, selectors: [["", "igxCarouselPrevButton", ""]] });

var Direction$1;
(function (Direction) {
    Direction[Direction["NONE"] = 0] = "NONE";
    Direction[Direction["NEXT"] = 1] = "NEXT";
    Direction[Direction["PREV"] = 2] = "PREV";
})(Direction$1 || (Direction$1 = {}));
/**
 * A slide component that usually holds an image and/or a caption text.
 * IgxSlideComponent is usually a child component of an IgxCarouselComponent.
 *
 * ```
 * <igx-slide [input bindings] >
 *    <ng-content></ng-content>
 * </igx-slide>
 * ```
 *
 * @export
 */
class IgxSlideComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this._active = false;
        this._destroy$ = new Subject();
        /**
         * Returns the class of the slide component.
         * ```typescript
         * let class =  this.slide.cssClass;
         * ```
         * @memberof IgxSlideComponent
         */
        this.cssClass = 'igx-slide';
        this.previous = false;
        /**
         * @hidden
         */
        this.activeChange = new EventEmitter();
    }
    /**
     * Returns the `tabIndex` of the slide component.
     * ```typescript
     * let tabIndex =  this.carousel.tabIndex;
     * ```
     * @memberof IgxSlideComponent
     */
    get tabIndex() {
        return this.active ? 0 : null;
    }
    /**
     * Returns the `aria-selected` of the slide.
     *
     * ```typescript
     * let slide = this.slide.ariaSelected;
     * ```
     *
     */
    get ariaSelected() {
        return this.active;
    }
    /**
     * Returns the `aria-live` of the slide.
     *
     * ```typescript
     * let slide = this.slide.ariaLive;
     * ```
     *
     */
    get ariaLive() {
        return this.active ? 'polite' : null;
    }
    /**
     * Gets/sets the `active` state of the slide.
     * ```html
     * <igx-carousel>
     *  <igx-slide [active] ="false"></igx-slide>
     * <igx-carousel>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-carousel>
     *  <igx-slide [(active)] ="model.isActive"></igx-slide>
     * <igx-carousel>
     * ```
     * @memberof IgxSlideComponent
     */
    get active() {
        return this._active;
    }
    set active(value) {
        this._active = !!value;
        this.activeChange.emit(this._active);
    }
    /**
     * Returns a reference to the carousel element in the DOM.
     * ```typescript
     * let nativeElement =  this.slide.nativeElement;
     * ```
     * @memberof IgxSlideComponent
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get isDestroyed() {
        return this._destroy$;
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
    }
}
IgxSlideComponent.ɵfac = function IgxSlideComponent_Factory(t) { return new (t || IgxSlideComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxSlideComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSlideComponent, selectors: [["igx-slide"]], hostVars: 8, hostBindings: function IgxSlideComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabIndex)("aria-selected", ctx.ariaLive);
        ɵngcc0.ɵɵclassProp("igx-slide", ctx.cssClass)("igx-slide--previous", ctx.previous)("igx-slide--current", ctx.active);
    } }, inputs: { previous: "previous", active: "active", index: "index", direction: "direction" }, outputs: { activeChange: "activeChange" }, ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxSlideComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
IgxSlideComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxSlideComponent.propDecorators = {
    index: [{ type: Input }],
    direction: [{ type: Input }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
    ariaLive: [{ type: HostBinding, args: ['attr.aria-selected',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-slide',] }],
    active: [{ type: HostBinding, args: ['class.igx-slide--current',] }, { type: Input }],
    previous: [{ type: HostBinding, args: ['class.igx-slide--previous',] }, { type: Input }],
    activeChange: [{ type: Output }]
};

const DateRangePickerResourceStringsEN = {
    igx_date_range_picker_date_separator: 'to'
};

const GridResourceStringsEN = {
    igx_grid_groupByArea_message: 'Drag a column header and drop it here to group by that column.',
    igx_grid_emptyFilteredGrid_message: 'No records found.',
    igx_grid_emptyGrid_message: 'Grid has no data.',
    igx_grid_filter: 'Filter',
    igx_grid_filter_row_close: 'Close',
    igx_grid_filter_row_reset: 'Reset',
    igx_grid_filter_row_placeholder: 'Add filter value',
    igx_grid_filter_row_boolean_placeholder: 'All',
    igx_grid_filter_row_date_placeholder: 'Pick up date',
    igx_grid_filter_operator_and: 'And',
    igx_grid_filter_operator_or: 'Or',
    igx_grid_complex_filter: 'Complex Filter',
    igx_grid_filter_contains: 'Contains',
    igx_grid_filter_doesNotContain: 'Does Not Contain',
    igx_grid_filter_startsWith: 'Starts With',
    igx_grid_filter_endsWith: 'Ends With',
    igx_grid_filter_equals: 'Equals',
    igx_grid_filter_doesNotEqual: 'Does Not Equal',
    igx_grid_filter_empty: 'Empty',
    igx_grid_filter_notEmpty: 'Not Empty',
    igx_grid_filter_null: 'Null',
    igx_grid_filter_notNull: 'Not Null',
    igx_grid_filter_before: 'Before',
    igx_grid_filter_after: 'After',
    igx_grid_filter_today: 'Today',
    igx_grid_filter_yesterday: 'Yesterday',
    igx_grid_filter_thisMonth: 'This Month',
    igx_grid_filter_lastMonth: 'Last Month',
    igx_grid_filter_nextMonth: 'Next Month',
    igx_grid_filter_thisYear: 'This Year',
    igx_grid_filter_lastYear: 'Last Year',
    igx_grid_filter_nextYear: 'Next Year',
    igx_grid_filter_greaterThan: 'Greater Than',
    igx_grid_filter_lessThan: 'Less Than',
    igx_grid_filter_greaterThanOrEqualTo: 'Greater Than Or Equal To',
    igx_grid_filter_lessThanOrEqualTo: 'Less Than Or Equal To',
    igx_grid_filter_true: 'True',
    igx_grid_filter_false: 'False',
    igx_grid_filter_all: 'All',
    igx_grid_filter_condition_placeholder: 'Select filter',
    igx_grid_summary_count: 'Count',
    igx_grid_summary_min: 'Min',
    igx_grid_summary_max: 'Max',
    igx_grid_summary_sum: 'Sum',
    igx_grid_summary_average: 'Avg',
    igx_grid_summary_earliest: 'Earliest',
    igx_grid_summary_latest: 'Latest',
    igx_grid_excel_filter_moving_left: 'move left',
    igx_grid_excel_filter_moving_left_short: 'left',
    igx_grid_excel_filter_moving_right: 'move right',
    igx_grid_excel_filter_moving_right_short: 'right',
    igx_grid_excel_filter_moving_header: 'move',
    igx_grid_excel_filter_sorting_asc: 'ascending',
    igx_grid_excel_filter_sorting_asc_short: 'asc',
    igx_grid_excel_filter_sorting_desc: 'descending',
    igx_grid_excel_filter_sorting_desc_short: 'desc',
    igx_grid_excel_filter_sorting_header: 'sort',
    igx_grid_excel_filter_clear: 'Clear column filters',
    igx_grid_excel_custom_dialog_add: 'add filter',
    igx_grid_excel_custom_dialog_clear: 'Clear filter',
    igx_grid_excel_custom_dialog_header: 'Custom auto-filter on column: ',
    igx_grid_excel_cancel: 'cancel',
    igx_grid_excel_apply: 'apply',
    igx_grid_excel_search_placeholder: 'Search',
    igx_grid_excel_select_all: 'Select All',
    igx_grid_excel_select_all_search_results: 'Select all search results',
    igx_grid_excel_add_to_filter: 'Add current selection to filter',
    igx_grid_excel_blanks: '(Blanks)',
    igx_grid_excel_hide: 'Hide column',
    igx_grid_excel_show: 'Show column',
    igx_grid_excel_pin: 'Pin column',
    igx_grid_excel_unpin: 'Unpin column',
    igx_grid_excel_select: 'Select column',
    igx_grid_excel_text_filter: 'Text filter',
    igx_grid_excel_number_filter: 'Number filter',
    igx_grid_excel_date_filter: 'Date filter',
    igx_grid_excel_boolean_filter: 'Boolean filter',
    igx_grid_excel_custom_filter: 'Custom filter...',
    igx_grid_advanced_filter_title: 'Advanced Filtering',
    igx_grid_advanced_filter_and_group: '"And" Group',
    igx_grid_advanced_filter_or_group: '"Or" Group',
    igx_grid_advanced_filter_end_group: 'End Group',
    igx_grid_advanced_filter_create_and_group: 'Create "And" Group',
    igx_grid_advanced_filter_create_or_group: 'Create "Or" Group',
    igx_grid_advanced_filter_and_label: 'and',
    igx_grid_advanced_filter_or_label: 'or',
    igx_grid_advanced_filter_add_condition: 'Condition',
    igx_grid_advanced_filter_ungroup: 'Ungroup',
    igx_grid_advanced_filter_delete: 'Delete',
    igx_grid_advanced_filter_delete_filters: 'Delete filters',
    igx_grid_advanced_filter_initial_text: 'Start with creating a group of conditions linked with "And" or "Or"',
    igx_grid_advanced_filter_column_placeholder: 'Select column',
    igx_grid_advanced_filter_value_placeholder: 'Value',
    igx_grid_pinned_row_indicator: 'Pinned',
    igx_grid_hiding_check_all_label: 'Hide All',
    igx_grid_hiding_uncheck_all_label: 'Show All',
    igx_grid_pinning_check_all_label: 'Pin All',
    igx_grid_pinning_uncheck_all_label: 'Unpin All',
    igx_grid_toolbar_actions_filter_prompt: 'Filter columns list ...',
    igx_grid_snackbar_addrow_label: 'Row added',
    igx_grid_snackbar_addrow_actiontext: 'SHOW',
    igx_grid_actions_edit_label: 'Edit',
    igx_grid_actions_add_label: 'Add',
    igx_grid_add_row_label: 'ADD ROW',
    igx_grid_actions_add_child_label: 'Add Child',
    igx_grid_actions_delete_label: 'Delete',
    igx_grid_actions_pin_label: 'Pin',
    igx_grid_actions_unpin_label: 'Unpin',
    igx_grid_actions_jumpUp_label: 'Jump up',
    igx_grid_actions_jumpDown_label: 'Jump down'
};

const TimePickerResourceStringsEN = {
    igx_time_picker_ok: 'OK',
    igx_time_picker_cancel: 'Cancel'
};

const PaginatorResourceStringsEN = {
    igx_paginator_label: 'Items per page',
    igx_paginator_pager_text: 'of',
    igx_paginator_first_page_button_text: 'Go to first page',
    igx_paginator_previous_page_button_text: 'Previous page',
    igx_paginator_last_page_button_text: 'Go to last page',
    igx_paginator_next_page_button_text: 'Next page',
};

const CarouselResourceStringsEN = {
    igx_carousel_of: 'of'
};

const ListResourceStringsEN = {
    igx_list_no_items: 'There are no items in the list.',
    igx_list_loading: 'Loading data from the server...'
};

/**
 * @hidden
 */
const CurrentResourceStrings = {
    GridResStrings: cloneValue(GridResourceStringsEN),
    PaginatorResStrings: cloneValue(PaginatorResourceStringsEN),
    TimePickerResStrings: cloneValue(TimePickerResourceStringsEN),
    DateRangePickerResStrings: cloneValue(DateRangePickerResourceStringsEN),
    CarouselResStrings: cloneValue(CarouselResourceStringsEN),
    ListResStrings: cloneValue(ListResourceStringsEN),
};
function updateResourceStrings(currentStrings, newStrings) {
    for (const key of Object.keys(newStrings)) {
        if (key in currentStrings) {
            currentStrings[key] = newStrings[key];
        }
    }
}
/**
 * Changes the resource strings for all components in the application
 * ```
 * @param resourceStrings to be applied
 */
function changei18n(resourceStrings) {
    for (const key of Object.keys(CurrentResourceStrings)) {
        updateResourceStrings(CurrentResourceStrings[key], resourceStrings);
    }
}
/**
 * Returns current resource strings for all components
 */
function getCurrentResourceStrings() {
    return Object.assign(Object.assign({}, CurrentResourceStrings.GridResStrings), CurrentResourceStrings.TimePickerResStrings);
}

let NEXT_ID$i = 0;
const CarouselIndicatorsOrientation = mkenum({
    bottom: 'bottom',
    top: 'top'
});
const CarouselAnimationType = mkenum({
    none: 'none',
    slide: 'slide',
    fade: 'fade'
});
class CarouselHammerConfig extends HammerGestureConfig {
    constructor() {
        super(...arguments);
        this.overrides = {
            pan: { direction: Hammer.DIRECTION_HORIZONTAL }
        };
    }
}
CarouselHammerConfig.ɵfac = function CarouselHammerConfig_Factory(t) { return ɵCarouselHammerConfig_BaseFactory(t || CarouselHammerConfig); };
CarouselHammerConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CarouselHammerConfig, factory: CarouselHammerConfig.ɵfac });
/**
 * **Ignite UI for Angular Carousel** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/carousel.html)
 *
 * The Ignite UI Carousel is used to browse or navigate through a collection of slides. Slides can contain custom
 * content such as images or cards and be used for things such as on-boarding tutorials or page-based interfaces.
 * It can be used as a separate fullscreen element or inside another component.
 *
 * Example:
 * ```html
 * <igx-carousel>
 *   <igx-slide>
 *     <h3>First Slide Header</h3>
 *     <p>First slide Content</p>
 *   <igx-slide>
 *   <igx-slide>
 *     <h3>Second Slide Header</h3>
 *     <p>Second Slide Content</p>
 * </igx-carousel>
 * ```
 */
class IgxCarouselComponent {
    constructor(element, iterableDiffers, builder, platformUtil) {
        this.element = element;
        this.iterableDiffers = iterableDiffers;
        this.builder = builder;
        this.platformUtil = platformUtil;
        /**
         * Returns the `role` attribute of the carousel.
         * ```typescript
         * let carouselRole =  this.carousel.role;
         * ```
         * @memberof IgxCarouselComponent
         */
        this.role = 'region';
        /**
         * Sets the `id` of the carousel.
         * If not set, the `id` of the first carousel component will be `"igx-carousel-0"`.
         * ```html
         * <igx-carousel id="my-first-carousel"></igx-carousel>
         * ```
         * @memberof IgxCarouselComponent
         */
        this.id = `igx-carousel-${NEXT_ID$i++}`;
        /**
         * Returns the `aria-label` of the carousel.
         *
         * ```typescript
         * let carousel = this.carousel.ariaLabel;
         * ```
         *
         */
        this.ariaLabel = 'carousel';
        /**
         * Returns the class of the carousel component.
         * ```typescript
         * let class =  this.carousel.cssClass;
         * ```
         * @memberof IgxCarouselComponent
         */
        this.cssClass = 'igx-carousel';
        /**
         * Sets whether the carousel should `loop` back to the first slide after reaching the last slide.
         * Default value is `true`.
         * ```html
         * <igx-carousel [loop]="false"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.loop = true;
        /**
         * Sets whether the carousel will `pause` the slide transitions on user interactions.
         * Default value is `true`.
         * ```html
         *  <igx-carousel [pause]="false"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.pause = true;
        /**
         * Controls whether the carousel should render the left/right `navigation` buttons.
         * Default value is `true`.
         * ```html
         * <igx-carousel [navigation] = "false"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.navigation = true;
        /**
         * Controls whether the carousel should support keyboard navigation.
         * Default value is `true`.
         * ```html
         * <igx-carousel [keyboardSupport] = "false"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.keyboardSupport = true;
        /**
         * Controls whether the carousel should support gestures.
         * Default value is `true`.
         * ```html
         * <igx-carousel [gesturesSupport] = "false"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.gesturesSupport = true;
        /**
         * Controls the maximum indexes that can be shown.
         * Default value is `5`.
         * ```html
         * <igx-carousel [maximumIndicatorsCount] = "10"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.maximumIndicatorsCount = 5;
        /**
         * Gets/sets the display mode of carousel indicators. It can be top or bottom.
         * Default value is `bottom`.
         * ```html
         * <igx-carousel indicatorsOrientation='top'>
         * <igx-carousel>
         * ```
         * @memberOf IgxSlideComponent
         */
        this.indicatorsOrientation = CarouselIndicatorsOrientation.bottom;
        /**
         * Gets/sets the animation type of carousel.
         * Default value is `slide`.
         * ```html
         * <igx-carousel animationType='none'>
         * <igx-carousel>
         * ```
         * @memberOf IgxSlideComponent
         */
        this.animationType = CarouselAnimationType.slide;
        /**
         * The custom template, if any, that should be used when rendering carousel indicators
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.carousel.indicatorTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-carousel #carousel>
         *      ...
         *      <ng-template igxCarouselIndicator let-slide>
         *         <igx-icon *ngIf="slide.active"  fontSet="material">brightness_7</igx-icon>
         *         <igx-icon *ngIf="!slide.active"  fontSet="material">brightness_5</igx-icon>
         *      </ng-template>
         *  </igx-carousel>
         * ```
         */
        this.indicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering carousel next button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.carousel.nextButtonTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-carousel #carousel>
         *      ...
         *      <ng-template igxCarouselNextButton let-disabled>
         *            <button igxButton="fab" igxRipple="white" [disabled]="disabled">
         *                <igx-icon fontSet="material">add</igx-icon>
         *           </button>
         *      </ng-template>
         *  </igx-carousel>
         * ```
         */
        this.nextButtonTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering carousel previous button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.carousel.nextButtonTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-carousel #carousel>
         *      ...
         *      <ng-template igxCarouselPrevButton let-disabled>
         *            <button igxButton="fab" igxRipple="white" [disabled]="disabled">
         *                <igx-icon fontSet="material">remove</igx-icon>
         *           </button>
         *      </ng-template>
         *  </igx-carousel>
         * ```
         */
        this.prevButtonTemplate = null;
        /**
         * An event that is emitted after a slide transition has happened.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideChanged)="onSlideChanged($event)"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.onSlideChanged = new EventEmitter();
        /**
         * An event that is emitted after a slide has been added to the carousel.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideAdded)="onSlideAdded($event)"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.onSlideAdded = new EventEmitter();
        /**
         * An event that is emitted after a slide has been removed from the carousel.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideRemoved)="onSlideRemoved($event)"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.onSlideRemoved = new EventEmitter();
        /**
         * An event that is emitted after the carousel has been paused.
         * Provides a reference to the `IgxCarouselComponent` as an event argument.
         * ```html
         * <igx-carousel (onCarouselPaused)="onCarouselPaused($event)"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.onCarouselPaused = new EventEmitter();
        /**
         * An event that is emitted after the carousel has resumed transitioning between `slides`.
         * Provides a reference to the `IgxCarouselComponent` as an event argument.
         * ```html
         * <igx-carousel (onCarouselPlaying)="onCarouselPlaying($event)"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.onCarouselPlaying = new EventEmitter();
        this._resourceStrings = CurrentResourceStrings.CarouselResStrings;
        this.destroy$ = new Subject();
        this.differ = null;
        this.animationDuration = 320;
        this.animationPosition = 0;
        this.newDuration = 0;
        this.differ = this.iterableDiffers.find([]).create(null);
    }
    /**
     * Returns the `tabIndex` of the carousel component.
     * ```typescript
     * let tabIndex =  this.carousel.tabIndex;
     * ```
     * @memberof IgxCarouselComponent
     */
    get tabIndex() {
        return 0;
    }
    /**
     * Gets the `touch-action` style of the `list item`.
     * ```typescript
     * let touchAction = this.listItem.touchAction;
     * ```
     */
    get touchAction() {
        return this.gesturesSupport ? 'pan-y' : 'auto';
    }
    /**
     * Returns the time `interval` in milliseconds before the slide changes.
     * ```typescript
     * let timeInterval = this.carousel.interval;
     * ```
     * @memberof IgxCarouselComponent
     */
    get interval() {
        return this._interval;
    }
    /**
     * Sets the time `interval` in milliseconds before the slide changes.
     * If not set, the carousel will not change `slides` automatically.
     * ```html
     * <igx-carousel [interval] = "1000"></igx-carousel>
     * ```
     * @memberof IgxCarouselComponent
     */
    set interval(value) {
        this._interval = +value;
        this.restartInterval();
    }
    /**
     * An accessor that sets the resource strings.
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /** @hidden */
    ngAfterContentInit() {
        this.slides.changes
            .pipe(takeUntil(this.destroy$))
            .subscribe((change) => { this.initSlides(change); });
        this.initSlides(this.slides);
    }
    /** @hidden */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
        this.destroyed = true;
        if (this.lastInterval) {
            clearInterval(this.lastInterval);
        }
    }
    unsubscriber(slide) {
        return merge$1(this.destroy$, slide.isDestroyed);
    }
    onSlideActivated(slide) {
        if (slide.active && slide !== this.currentSlide) {
            if (slide.direction === Direction$1.NONE) {
                const newIndex = slide.index;
                slide.direction = newIndex > this.current ? Direction$1.NEXT : Direction$1.PREV;
            }
            if (this.currentSlide) {
                if (this.previousSlide && this.previousSlide.previous) {
                    this.previousSlide.previous = false;
                }
                this.currentSlide.direction = slide.direction;
                this.currentSlide.active = false;
                this.previousSlide = this.currentSlide;
                this.currentSlide = slide;
                if (this.animationType !== CarouselAnimationType.none) {
                    if (this.animationStarted(this.leaveAnimationPlayer) || this.animationStarted(this.enterAnimationPlayer)) {
                        requestAnimationFrame(() => {
                            this.resetAnimations();
                            this.playAnimations();
                        });
                    }
                    else {
                        this.playAnimations();
                    }
                }
            }
            else {
                this.currentSlide = slide;
            }
            this.onSlideChanged.emit({ carousel: this, slide });
            this.restartInterval();
        }
    }
    playAnimations() {
        this.playLeaveAnimation();
        this.playEnterAnimation();
    }
    finishAnimations() {
        if (this.animationStarted(this.leaveAnimationPlayer)) {
            this.leaveAnimationPlayer.finish();
        }
        if (this.animationStarted(this.enterAnimationPlayer)) {
            this.enterAnimationPlayer.finish();
        }
    }
    resetAnimations() {
        if (this.animationStarted(this.leaveAnimationPlayer)) {
            this.leaveAnimationPlayer.reset();
        }
        if (this.animationStarted(this.enterAnimationPlayer)) {
            this.enterAnimationPlayer.reset();
        }
    }
    animationStarted(animation) {
        return animation && animation.hasStarted();
    }
    getAnimation() {
        let duration;
        if (this.newDuration) {
            duration = this.animationPosition ? this.animationPosition * this.newDuration : this.newDuration;
        }
        else {
            duration = this.animationPosition ? this.animationPosition * this.animationDuration : this.animationDuration;
        }
        switch (this.animationType) {
            case CarouselAnimationType.slide:
                const trans = this.animationPosition ? this.animationPosition * 100 : 100;
                return {
                    enterAnimation: useAnimation(slideInLeft, {
                        params: {
                            delay: '0s',
                            duration: `${duration}ms`,
                            endOpacity: 1,
                            startOpacity: 1,
                            fromPosition: `translateX(${this.currentSlide.direction === 1 ? trans : -trans}%)`,
                            toPosition: 'translateX(0%)'
                        }
                    }),
                    leaveAnimation: useAnimation(slideInLeft, {
                        params: {
                            delay: '0s',
                            duration: `${duration}ms`,
                            endOpacity: 1,
                            startOpacity: 1,
                            fromPosition: `translateX(0%)`,
                            toPosition: `translateX(${this.currentSlide.direction === 1 ? -trans : trans}%)`,
                        }
                    })
                };
            case CarouselAnimationType.fade:
                return {
                    enterAnimation: useAnimation(fadeIn, { params: { duration: `${duration}ms`, startOpacity: `${this.animationPosition}` } }),
                    leaveAnimation: null
                };
        }
        return {
            enterAnimation: null,
            leaveAnimation: null
        };
    }
    playEnterAnimation() {
        const animation = this.getAnimation().enterAnimation;
        if (!animation) {
            return;
        }
        const animationBuilder = this.builder.build(animation);
        this.enterAnimationPlayer = animationBuilder.create(this.currentSlide.nativeElement);
        this.enterAnimationPlayer.onDone(() => {
            if (this.enterAnimationPlayer) {
                this.enterAnimationPlayer.reset();
                this.enterAnimationPlayer = null;
            }
            this.animationPosition = 0;
            this.newDuration = 0;
            this.previousSlide.previous = false;
        });
        this.previousSlide.previous = true;
        this.enterAnimationPlayer.play();
    }
    playLeaveAnimation() {
        const animation = this.getAnimation().leaveAnimation;
        if (!animation) {
            return;
        }
        const animationBuilder = this.builder.build(animation);
        this.leaveAnimationPlayer = animationBuilder.create(this.previousSlide.nativeElement);
        this.leaveAnimationPlayer.onDone(() => {
            if (this.leaveAnimationPlayer) {
                this.leaveAnimationPlayer.reset();
                this.leaveAnimationPlayer = null;
            }
            this.animationPosition = 0;
            this.newDuration = 0;
        });
        this.leaveAnimationPlayer.play();
    }
    initSlides(change) {
        const diff = this.differ.diff(change.toArray());
        if (diff) {
            this.slides.reduce((any, c, ind) => c.index = ind, 0); // reset slides indexes
            diff.forEachAddedItem((record) => {
                const slide = record.item;
                this.onSlideAdded.emit({ carousel: this, slide });
                if (slide.active) {
                    this.currentSlide = slide;
                }
                slide.activeChange.pipe(takeUntil(this.unsubscriber(slide))).subscribe(() => this.onSlideActivated(slide));
            });
            diff.forEachRemovedItem((record) => {
                const slide = record.item;
                this.onSlideRemoved.emit({ carousel: this, slide });
                if (slide.active) {
                    slide.active = false;
                    this.currentSlide = this.get(slide.index < this.total ? slide.index : this.total - 1);
                }
            });
            this.updateSlidesSelection();
        }
    }
    updateSlidesSelection() {
        requestAnimationFrame(() => {
            if (this.currentSlide) {
                this.currentSlide.active = true;
                const activeSlides = this.slides.filter(slide => slide.active && slide.index !== this.currentSlide.index);
                activeSlides.forEach(slide => { slide.active = false; });
            }
            else if (this.total) {
                this.slides.first.active = true;
            }
            this.play();
        });
    }
    /** @hidden */
    get getIndicatorTemplate() {
        if (this.indicatorTemplate) {
            return this.indicatorTemplate;
        }
        return this.defaultIndicator;
    }
    /** @hidden */
    get getNextButtonTemplate() {
        if (this.nextButtonTemplate) {
            return this.nextButtonTemplate;
        }
        return this.defaultNextButton;
    }
    /** @hidden */
    get getPrevButtonTemplate() {
        if (this.prevButtonTemplate) {
            return this.prevButtonTemplate;
        }
        return this.defaultPrevButton;
    }
    /** @hidden */
    setAriaLabel(slide) {
        return `Item ${slide.index + 1} of ${this.total}`;
    }
    /** @hidden */
    get indicatorsOrientationClass() {
        return `igx-carousel-indicators--${this.indicatorsOrientation}`;
    }
    /** @hidden */
    get showIndicators() {
        return this.total <= this.maximumIndicatorsCount && this.total > 0;
    }
    /** @hidden */
    get showIndicatorsLabel() {
        return this.total > this.maximumIndicatorsCount;
    }
    /** @hidden */
    get getCarouselLabel() {
        return `${this.current + 1} ${this.resourceStrings.igx_carousel_of} ${this.total}`;
    }
    /**
     * Returns the total number of `slides` in the carousel.
     * ```typescript
     * let slideCount =  this.carousel.total;
     * ```
     * @memberOf IgxCarouselComponent
     */
    get total() {
        return this.slides.length;
    }
    /**
     * The index of the slide being currently shown.
     * ```typescript
     * let currentSlideNumber =  this.carousel.current;
     * ```
     * @memberOf IgxCarouselComponent
     */
    get current() {
        return !this.currentSlide ? 0 : this.currentSlide.index;
    }
    getNextIndex() {
        return (this.current + 1) % this.total;
    }
    getPrevIndex() {
        return this.current - 1 < 0 ? this.total - 1 : this.current - 1;
    }
    /**
     * Returns a boolean indicating if the carousel is playing.
     * ```typescript
     * let isPlaying =  this.carousel.isPlaying;
     * ```
     * @memberOf IgxCarouselComponent
     */
    get isPlaying() {
        return this.playing;
    }
    /**
     * Returns а boolean indicating if the carousel is destroyed.
     * ```typescript
     * let isDestroyed =  this.carousel.isDestroyed;
     * ```
     * @memberOf IgxCarouselComponent
     */
    get isDestroyed() {
        return this.destroyed;
    }
    /**
     * Returns a reference to the carousel element in the DOM.
     * ```typescript
     * let nativeElement =  this.carousel.nativeElement;
     * ```
     * @memberof IgxCarouselComponent
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * Returns the slide corresponding to the provided `index` or null.
     * ```typescript
     * let slide1 =  this.carousel.get(1);
     * ```
     * @memberOf IgxCarouselComponent
     */
    get(index) {
        return this.slides.find((slide) => slide.index === index);
    }
    /**
     * Adds a new slide to the carousel.
     * ```typescript
     * this.carousel.add(newSlide);
     * ```
     * @memberOf IgxCarouselComponent
     */
    add(slide) {
        const newSlides = this.slides.toArray();
        newSlides.push(slide);
        this.slides.reset(newSlides);
        this.slides.notifyOnChanges();
    }
    /**
     * Removes a slide from the carousel.
     * ```typescript
     * this.carousel.remove(slide);
     * ```
     * @memberOf IgxCarouselComponent
     */
    remove(slide) {
        if (slide && slide === this.get(slide.index)) { // check if the requested slide for delete is present in the carousel
            const newSlides = this.slides.toArray();
            newSlides.splice(slide.index, 1);
            this.slides.reset(newSlides);
            this.slides.notifyOnChanges();
        }
    }
    /**
     * Kicks in a transition for a given slide with a given `direction`.
     * ```typescript
     * this.carousel.select(this.carousel.get(2), Direction.NEXT);
     * ```
     * @memberOf IgxCarouselComponent
     */
    select(slide, direction = Direction$1.NONE) {
        if (slide && slide !== this.currentSlide) {
            slide.direction = direction;
            slide.active = true;
        }
    }
    /**
     * Transitions to the next slide in the carousel.
     * ```typescript
     * this.carousel.next();
     * ```
     * @memberOf IgxCarouselComponent
     */
    next() {
        const index = this.getNextIndex();
        if (index === 0 && !this.loop) {
            this.stop();
            return;
        }
        return this.select(this.get(index), Direction$1.NEXT);
    }
    /**
     * Transitions to the previous slide in the carousel.
     * ```typescript
     * this.carousel.prev();
     * ```
     * @memberOf IgxCarouselComponent
     */
    prev() {
        const index = this.getPrevIndex();
        if (!this.loop && index === this.total - 1) {
            this.stop();
            return;
        }
        return this.select(this.get(index), Direction$1.PREV);
    }
    /**
     * Resumes playing of the carousel if in paused state.
     * No operation otherwise.
     * ```typescript
     * this.carousel.play();
     * }
     * ```
     * @memberOf IgxCarouselComponent
     */
    play() {
        if (!this.playing) {
            this.playing = true;
            this.onCarouselPlaying.emit(this);
            this.restartInterval();
            this.stoppedByInteraction = false;
        }
    }
    /**
     * Stops slide transitions if the `pause` option is set to `true`.
     * No operation otherwise.
     * ```typescript
     *  this.carousel.stop();
     * }
     * ```
     * @memberOf IgxCarouselComponent
     */
    stop() {
        if (this.pause) {
            this.playing = false;
            this.onCarouselPaused.emit(this);
            this.resetInterval();
        }
    }
    resetInterval() {
        if (this.lastInterval) {
            clearInterval(this.lastInterval);
            this.lastInterval = null;
        }
    }
    restartInterval() {
        this.resetInterval();
        if (!isNaN(this.interval) && this.interval > 0 && this.platformUtil.isBrowser) {
            this.lastInterval = setInterval(() => {
                const tick = +this.interval;
                if (this.playing && this.total && !isNaN(tick) && tick > 0) {
                    this.next();
                }
                else {
                    this.stop();
                }
            }, this.interval);
        }
    }
    /** @hidden */
    get nextButtonDisabled() {
        return !this.loop && this.current === (this.total - 1);
    }
    /** @hidden */
    get prevButtonDisabled() {
        return !this.loop && this.current === 0;
    }
    /** @hidden */
    onKeydownArrowRight(event) {
        if (this.keyboardSupport) {
            event.preventDefault();
            this.next();
            requestAnimationFrame(() => this.nativeElement.focus());
        }
    }
    /** @hidden */
    onKeydownArrowLeft(event) {
        if (this.keyboardSupport) {
            event.preventDefault();
            this.prev();
            requestAnimationFrame(() => this.nativeElement.focus());
        }
    }
    /** @hidden */
    onTap(event) {
        // play pause only when tap on slide
        if (event.target && event.target.classList.contains('igx-slide')) {
            if (this.isPlaying) {
                if (this.pause) {
                    this.stoppedByInteraction = true;
                }
                this.stop();
            }
            else if (this.stoppedByInteraction) {
                this.play();
            }
        }
    }
    /** @hidden */
    onKeydownHome(event) {
        if (this.keyboardSupport && this.slides.length > 0) {
            event.preventDefault();
            this.slides.first.active = true;
            requestAnimationFrame(() => this.nativeElement.focus());
        }
    }
    /** @hidden */
    onKeydownEnd(event) {
        if (this.keyboardSupport && this.slides.length > 0) {
            event.preventDefault();
            this.slides.last.active = true;
            requestAnimationFrame(() => this.nativeElement.focus());
        }
    }
    /** @hidden */
    onMouseEnter() {
        if (this.pause && this.isPlaying) {
            this.stoppedByInteraction = true;
        }
        this.stop();
    }
    /** @hidden */
    onMouseLeave() {
        if (this.stoppedByInteraction) {
            this.play();
        }
    }
    /** @hidden */
    onPanLeft(event) {
        this.pan(event);
    }
    /** @hidden */
    onPanRight(event) {
        this.pan(event);
    }
    resetSlideStyles(slide) {
        slide.nativeElement.style.transform = '';
        slide.nativeElement.style.opacity = '';
    }
    pan(event) {
        const slideWidth = this.currentSlide.nativeElement.offsetWidth;
        const panOffset = (slideWidth / 1000);
        const deltaX = event.deltaX;
        const index = deltaX < 0 ? this.getNextIndex() : this.getPrevIndex();
        const offset = deltaX < 0 ? slideWidth + deltaX : -slideWidth + deltaX;
        if (!this.gesturesSupport || event.isFinal || Math.abs(deltaX) + panOffset >= slideWidth) {
            return;
        }
        if (!this.loop && ((this.current === 0 && deltaX > 0) || (this.current === this.total - 1 && deltaX < 0))) {
            this.incomingSlide = null;
            return;
        }
        event.preventDefault();
        if (this.isPlaying) {
            this.stoppedByInteraction = true;
            this.stop();
        }
        if (this.previousSlide && this.previousSlide.previous) {
            this.previousSlide.previous = false;
        }
        this.finishAnimations();
        if (this.incomingSlide) {
            if (index !== this.incomingSlide.index) {
                this.resetSlideStyles(this.incomingSlide);
                this.incomingSlide.previous = false;
                this.incomingSlide = this.get(index);
            }
        }
        else {
            this.incomingSlide = this.get(index);
        }
        this.incomingSlide.previous = true;
        if (this.animationType === CarouselAnimationType.fade) {
            this.currentSlide.nativeElement.style.opacity = `${Math.abs(offset) / slideWidth}`;
        }
        else {
            this.currentSlide.nativeElement.style.transform = `translateX(${deltaX}px)`;
            this.incomingSlide.nativeElement.style.transform = `translateX(${offset}px)`;
        }
    }
    /**
     * @hidden
     */
    onPanEnd(event) {
        if (!this.gesturesSupport) {
            return;
        }
        event.preventDefault();
        const slideWidth = this.currentSlide.nativeElement.offsetWidth;
        const panOffset = (slideWidth / 1000);
        const deltaX = Math.abs(event.deltaX) + panOffset < slideWidth ? Math.abs(event.deltaX) : slideWidth - panOffset;
        const velocity = Math.abs(event.velocity);
        this.resetSlideStyles(this.currentSlide);
        if (this.incomingSlide) {
            this.resetSlideStyles(this.incomingSlide);
            if (slideWidth / 2 < deltaX || velocity > 1) {
                this.incomingSlide.direction = event.deltaX < 0 ? Direction$1.NEXT : Direction$1.PREV;
                this.incomingSlide.previous = false;
                this.animationPosition = this.animationType === CarouselAnimationType.fade ?
                    deltaX / slideWidth : (slideWidth - deltaX) / slideWidth;
                if (velocity > 1) {
                    this.newDuration = this.animationDuration / velocity;
                }
                this.incomingSlide.active = true;
            }
            else {
                this.currentSlide.direction = event.deltaX > 0 ? Direction$1.NEXT : Direction$1.PREV;
                this.previousSlide = this.incomingSlide;
                this.previousSlide.previous = true;
                this.animationPosition = this.animationType === CarouselAnimationType.fade ?
                    Math.abs((slideWidth - deltaX) / slideWidth) : deltaX / slideWidth;
                this.playAnimations();
            }
        }
        if (this.stoppedByInteraction) {
            this.play();
        }
    }
}
IgxCarouselComponent.ɵfac = function IgxCarouselComponent_Factory(t) { return new (t || IgxCarouselComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AnimationBuilder), ɵngcc0.ɵɵdirectiveInject(PlatformUtil)); };
IgxCarouselComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCarouselComponent, selectors: [["igx-carousel"]], contentQueries: function IgxCarouselComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCarouselIndicatorDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCarouselNextButtonDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCarouselPrevButtonDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSlideComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.indicatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nextButtonTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.prevButtonTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.slides = _t);
    } }, viewQuery: function IgxCarouselComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c47, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c48, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c49, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultIndicator = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultNextButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultPrevButton = _t.first);
    } }, hostVars: 8, hostBindings: function IgxCarouselComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.arrowright", function IgxCarouselComponent_keydown_arrowright_HostBindingHandler($event) { return ctx.onKeydownArrowRight($event); })("keydown.arrowleft", function IgxCarouselComponent_keydown_arrowleft_HostBindingHandler($event) { return ctx.onKeydownArrowLeft($event); })("tap", function IgxCarouselComponent_tap_HostBindingHandler($event) { return ctx.onTap($event); })("keydown.home", function IgxCarouselComponent_keydown_home_HostBindingHandler($event) { return ctx.onKeydownHome($event); })("keydown.end", function IgxCarouselComponent_keydown_end_HostBindingHandler($event) { return ctx.onKeydownEnd($event); })("mouseenter", function IgxCarouselComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function IgxCarouselComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); })("panleft", function IgxCarouselComponent_panleft_HostBindingHandler($event) { return ctx.onPanLeft($event); })("panright", function IgxCarouselComponent_panright_HostBindingHandler($event) { return ctx.onPanRight($event); })("panend", function IgxCarouselComponent_panend_HostBindingHandler($event) { return ctx.onPanEnd($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("id", ctx.id)("aria-label", ctx.ariaLabel)("tabindex", ctx.tabIndex);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.touchAction);
        ɵngcc0.ɵɵclassProp("igx-carousel", ctx.cssClass);
    } }, inputs: { id: "id", loop: "loop", pause: "pause", navigation: "navigation", keyboardSupport: "keyboardSupport", gesturesSupport: "gesturesSupport", maximumIndicatorsCount: "maximumIndicatorsCount", indicatorsOrientation: "indicatorsOrientation", animationType: "animationType", interval: "interval", resourceStrings: "resourceStrings" }, outputs: { onSlideChanged: "onSlideChanged", onSlideAdded: "onSlideAdded", onSlideRemoved: "onSlideRemoved", onCarouselPaused: "onCarouselPaused", onCarouselPlaying: "onCarouselPlaying" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: HAMMER_GESTURE_CONFIG,
                useClass: CarouselHammerConfig
            }
        ])], ngContentSelectors: _c2, decls: 12, vars: 4, consts: [["defaultIndicator", ""], ["defaultNextButton", ""], ["defaultPrevButton", ""], [3, "ngClass", 4, "ngIf"], ["role", "list", 1, "igx-carousel__inner"], ["role", "button", "tabindex", "0", "class", "igx-carousel__arrow--prev", 3, "click", 4, "ngIf"], ["role", "button", "tabindex", "0", "class", "igx-carousel__arrow--next", 3, "click", 4, "ngIf"], [1, "igx-nav-dot"], [1, "igx-nav-arrow"], ["fontSet", "material"], [3, "ngClass"], ["class", "igx-carousel-indicators__indicator", 3, "click", 4, "ngFor", "ngForOf"], [1, "igx-carousel-indicators__indicator", 3, "click"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-carousel__label"], ["role", "button", "tabindex", "0", 1, "igx-carousel__arrow--prev", 3, "click"], ["role", "button", "tabindex", "0", 1, "igx-carousel__arrow--next", 3, "click"]], template: function IgxCarouselComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, IgxCarouselComponent_ng_template_0_Template, 1, 2, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxCarouselComponent_ng_template_2_Template, 3, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxCarouselComponent_ng_template_4_Template, 3, 2, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxCarouselComponent_div_6_Template, 2, 2, "div", 3);
        ɵngcc0.ɵɵtemplate(7, IgxCarouselComponent_div_7_Template, 3, 2, "div", 3);
        ɵngcc0.ɵɵelementStart(8, "div", 4);
        ɵngcc0.ɵɵprojection(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, IgxCarouselComponent_div_10_Template, 2, 4, "div", 5);
        ɵngcc0.ɵɵtemplate(11, IgxCarouselComponent_div_11_Template, 2, 4, "div", 6);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showIndicators);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showIndicatorsLabel);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.navigation && ctx.slides.length);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.navigation && ctx.slides.length);
    } }, directives: [ɵngcc2.NgIf, IgxIconComponent, ɵngcc2.NgClass, ɵngcc2.NgForOf, ɵngcc2.NgTemplateOutlet], styles: ["[_nghost-%COMP%] {\n        display: block;\n        outline-style: none;\n    }"] });
IgxCarouselComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IterableDiffers },
    { type: AnimationBuilder },
    { type: PlatformUtil }
];
IgxCarouselComponent.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.role',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    ariaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-carousel',] }],
    touchAction: [{ type: HostBinding, args: ['style.touch-action',] }],
    loop: [{ type: Input }],
    pause: [{ type: Input }],
    interval: [{ type: Input }],
    navigation: [{ type: Input }],
    keyboardSupport: [{ type: Input }],
    gesturesSupport: [{ type: Input }],
    maximumIndicatorsCount: [{ type: Input }],
    indicatorsOrientation: [{ type: Input }],
    animationType: [{ type: Input }],
    resourceStrings: [{ type: Input }],
    defaultIndicator: [{ type: ViewChild, args: ['defaultIndicator', { read: TemplateRef, static: true },] }],
    defaultNextButton: [{ type: ViewChild, args: ['defaultNextButton', { read: TemplateRef, static: true },] }],
    defaultPrevButton: [{ type: ViewChild, args: ['defaultPrevButton', { read: TemplateRef, static: true },] }],
    indicatorTemplate: [{ type: ContentChild, args: [IgxCarouselIndicatorDirective, { read: TemplateRef, static: false },] }],
    nextButtonTemplate: [{ type: ContentChild, args: [IgxCarouselNextButtonDirective, { read: TemplateRef, static: false },] }],
    prevButtonTemplate: [{ type: ContentChild, args: [IgxCarouselPrevButtonDirective, { read: TemplateRef, static: false },] }],
    slides: [{ type: ContentChildren, args: [IgxSlideComponent,] }],
    onSlideChanged: [{ type: Output }],
    onSlideAdded: [{ type: Output }],
    onSlideRemoved: [{ type: Output }],
    onCarouselPaused: [{ type: Output }],
    onCarouselPlaying: [{ type: Output }],
    onKeydownArrowRight: [{ type: HostListener, args: ['keydown.arrowright', ['$event'],] }],
    onKeydownArrowLeft: [{ type: HostListener, args: ['keydown.arrowleft', ['$event'],] }],
    onTap: [{ type: HostListener, args: ['tap', ['$event'],] }],
    onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }],
    onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }],
    onPanLeft: [{ type: HostListener, args: ['panleft', ['$event'],] }],
    onPanRight: [{ type: HostListener, args: ['panright', ['$event'],] }],
    onPanEnd: [{ type: HostListener, args: ['panend', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxCarouselModule {
}
IgxCarouselModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxCarouselModule });
IgxCarouselModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxCarouselModule_Factory(t) { return new (t || IgxCarouselModule)(); }, imports: [[CommonModule, IgxIconModule]] });

let CHIP_ID = 0;
/**
 * Chip is compact visual component that displays information in an obround.
 *
 * @igxModule IgxChipsModule
 *
 * @igxTheme igx-chip-theme
 *
 * @igxKeywords chip
 *
 * @igxGroup display
 *
 * @remarks
 * The Ignite UI Chip can be templated, deleted, and selected.
 * Multiple chips can be reordered and visually connected to each other.
 * Chips reside in a container called chips area which is responsible for managing the interactions between the chips.
 *
 * @example
 * ```html
 * <igx-chip class="chipStyle" [id]="901" [draggable]="true" [removable]="true" (onRemove)="chipRemoved($event)">
 *    <igx-avatar class="chip-avatar-resized" igxPrefix fontSet="material" roundShape="true"></igx-avatar>
 * </igx-chip>
 * ```
 */
class IgxChipComponent extends DisplayDensityBase {
    constructor(cdr, elementRef, renderer, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'"></igx-chip>
         * ```
         */
        this.id = `igx-chip-${CHIP_ID++}`;
        /**
         * An @Input property that defines if the `IgxChipComponent` can be dragged in order to change it's position.
         * By default it is set to false.
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true"></igx-chip>
         * ```
         */
        this.draggable = false;
        /**
         * An @Input property that enables/disables the draggable element animation when the element is released.
         * By default it's set to true.
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [animateOnRelease]="false"></igx-chip>
         * ```
         */
        this.animateOnRelease = true;
        /**
         * An @Input property that enables/disables the hiding of the base element that has been dragged.
         * By default it's set to true.
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [hideBaseOnDrag]="false"></igx-chip>
         * ```
         */
        this.hideBaseOnDrag = true;
        /**
         * An @Input property that defines if the `IgxChipComponent` should render remove button and throw remove events.
         * By default it is set to false.
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [removable]="true"></igx-chip>
         * ```
         */
        this.removable = false;
        /**
         * An @Input property that defines if the `IgxChipComponent` can be selected on click or through navigation,
         * By default it is set to false.
         * @example
         * ```html
         * <igx-chip [id]="chip.id" [draggable]="true" [removable]="true" [selectable]="true"></igx-chip>
         * ```
         */
        this.selectable = false;
        /**
         * @hidden
         * @internal
         */
        this.class = '';
        /**
         * An @Input property that defines if the `IgxChipComponent` is disabled. When disabled it restricts user interactions
         * like focusing on click or tab, selection on click or Space, dragging.
         * By default it is set to false.
         * @example
         * ```html
         * <igx-chip [id]="chip.id" [disabled]="true"></igx-chip>
         * ```
         */
        this.disabled = false;
        /**
         * @hidden
         * @internal
         */
        this.selectedChange = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` moving starts.
         * Returns the moving `IgxChipComponent`.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onMoveStart)="moveStarted($event)">
         * ```
         */
        this.onMoveStart = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` moving ends.
         * Returns the moved `IgxChipComponent`.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onMoveEnd)="moveEnded($event)">
         * ```
         */
        this.onMoveEnd = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` is removed.
         * Returns the removed `IgxChipComponent`.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onRemove)="remove($event)">
         * ```
         */
        this.onRemove = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` is clicked.
         * Returns the clicked `IgxChipComponent`, whether the event should be canceled.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onClick)="chipClick($event)">
         * ```
         */
        this.onClick = new EventEmitter();
        /**
         * Emits event when the `IgxChipComponent` is selected/deselected.
         * Returns the selected chip reference, whether the event should be canceled, what is the next selection state and
         * when the event is triggered by interaction `originalEvent` is provided, otherwise `originalEvent` is `null`.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (onSelection)="chipSelect($event)">
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         * Emits event when the `IgxChipComponent` is selected/deselected and any related animations and transitions also end.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (onSelectionDone)="chipSelectEnd($event)">
         * ```
         */
        this.onSelectionDone = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` keyboard navigation is being used.
         * Returns the focused/selected `IgxChipComponent`, whether the event should be canceled,
         * if the `alt`, `shift` or `control` key is pressed and the pressed key name.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onKeyDown)="chipKeyDown($event)">
         * ```
         */
        this.onKeyDown = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` has entered the `IgxChipsAreaComponent`.
         * Returns the target `IgxChipComponent`, the drag `IgxChipComponent`, as  well as
         * the original drop event arguments.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onDragEnter)="chipEnter($event)">
         * ```
         */
        this.onDragEnter = new EventEmitter();
        /**
         * @hidden
         * @internal
         */
        this.hideBaseElement = false;
        this._tabIndex = null;
        this._selected = false;
        this._selectedItemClass = 'igx-chip__item--selected';
        this._movedWhileRemoving = false;
    }
    /**
     * An @Input property that sets the value of `tabindex` attribute. If not provided it will use the element's tabindex if set.
     * @example
     * ```html
     * <igx-chip [id]="'igx-chip-1'" [tabIndex]="1"></igx-chip>
     * ```
     */
    set tabIndex(value) {
        this._tabIndex = value;
    }
    get tabIndex() {
        if (this._tabIndex !== null) {
            return this._tabIndex;
        }
        return !this.disabled ? 0 : null;
    }
    /**
     * Sets the `IgxChipComponent` selected state.
     * @example
     * ```html
     * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [selected]="true">
     * ```
     *
     * Two-way data binding:
     * ```html
     * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [(selected)]="model.isSelected">
     * ```
     */
    set selected(newValue) {
        this.changeSelection(newValue);
    }
    /**
     * Returns if the `IgxChipComponent` is selected.
     * @example
     * ```typescript
     * @ViewChild('myChip')
     * public chip: IgxChipComponent;
     * selectedChip(){
     *     let selectedChip = this.chip.selected;
     * }
     * ```
     */
    get selected() {
        return this._selected;
    }
    /**
     * An @Input property that sets the `IgxChipComponent` background color.
     * The `color` property supports string, rgb, hex.
     * @example
     * ```html
     * <igx-chip #myChip [id]="'igx-chip-1'" [color]="'#ff0000'"></igx-chip>
     * ```
     */
    set color(newColor) {
        this.chipArea.nativeElement.style.backgroundColor = newColor;
    }
    /**
     * Returns the background color of the `IgxChipComponent`.
     * @example
     * ```typescript
     * @ViewChild('myChip')
     * public chip: IgxChipComponent;
     * ngAfterViewInit(){
     *     let chipColor = this.chip.color;
     * }
     * ```
     */
    get color() {
        return this.chipArea.nativeElement.style.backgroundColor;
    }
    /**
     * @hidden
     * @internal
     */
    get hostClass() {
        const classes = [this.getComponentDensityClass('igx-chip')];
        classes.push(this.disabled ? 'igx-chip--disabled' : '');
        // The custom classes should be at the end.
        classes.push(this.class);
        return classes.join(' ');
    }
    /**
     * @hidden
     * @internal
     */
    get removeButtonTemplate() {
        return this.removeIcon || this.defaultRemoveIcon;
    }
    /**
     * @hidden
     * @internal
     */
    get selectIconTemplate() {
        return this.selectIcon || this.defaultSelectIcon;
    }
    /**
     * @hidden
     * @internal
     */
    get ghostClass() {
        return this.getComponentDensityClass('igx-chip__ghost');
    }
    /**
     * @hidden
     * @internal
     */
    selectClass(condition) {
        const SELECT_CLASS = 'igx-chip__select';
        return {
            [SELECT_CLASS]: condition,
            [`${SELECT_CLASS}--hidden`]: !condition
        };
    }
    changeSelection(newValue, srcEvent = null) {
        const onSelectArgs = {
            originalEvent: srcEvent,
            owner: this,
            selected: false,
            cancel: false
        };
        fromEvent(this.selectContainer.nativeElement, 'transitionend')
            .pipe(filter(event => event.propertyName === 'width'), take(1))
            .subscribe(event => this.onSelectTransitionDone(event));
        if (newValue && !this._selected) {
            onSelectArgs.selected = true;
            this.onSelection.emit(onSelectArgs);
            if (!onSelectArgs.cancel) {
                this.renderer.addClass(this.chipArea.nativeElement, this._selectedItemClass);
                this._selected = newValue;
                this.selectedChange.emit(this._selected);
            }
        }
        else if (!newValue && this._selected) {
            this.onSelection.emit(onSelectArgs);
            if (!onSelectArgs.cancel) {
                this.renderer.removeClass(this.chipArea.nativeElement, this._selectedItemClass);
                this._selected = newValue;
                this.selectedChange.emit(this._selected);
            }
        }
    }
    onSelectTransitionDone(event) {
        if (!!event.target.tagName) {
            // Trigger onSelectionDone on when `width` property is changed and the target is valid element(not comment).
            this.onSelectionDone.emit({
                owner: this,
                originalEvent: event
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    onChipKeyDown(event) {
        const keyDownArgs = {
            originalEvent: event,
            owner: this,
            cancel: false
        };
        this.onKeyDown.emit(keyDownArgs);
        if (keyDownArgs.cancel) {
            return;
        }
        if ((event.key === 'Delete' || event.key === 'Del') && this.removable) {
            this.onRemove.emit({
                originalEvent: event,
                owner: this
            });
        }
        if ((event.key === ' ' || event.key === 'Spacebar') && this.selectable && !this.disabled) {
            this.changeSelection(!this.selected, event);
        }
        if (event.key !== 'Tab') {
            event.preventDefault();
        }
    }
    /**
     * @hidden
     * @internal
     */
    keyEvent(event) {
        this.onChipKeyDown(event);
    }
    /**
     * @hidden
     * @internal
     */
    onRemoveBtnKeyDown(event) {
        if (event.key === ' ' || event.key === 'Spacebar' || event.key === 'Enter') {
            this.onRemove.emit({
                originalEvent: event,
                owner: this
            });
            event.preventDefault();
            event.stopPropagation();
        }
    }
    onRemoveMouseDown(event) {
        event.stopPropagation();
    }
    /**
     * @hidden
     * @internal
     */
    onRemoveClick(event) {
        this.onRemove.emit({
            originalEvent: event,
            owner: this
        });
    }
    /**
     * @hidden
     * @internal
     */
    onRemoveTouchMove() {
        // We don't remove chip if user starting touch interacting on the remove button moves the chip
        this._movedWhileRemoving = true;
    }
    /**
     * @hidden
     * @internal
     */
    onRemoveTouchEnd(event) {
        if (!this._movedWhileRemoving) {
            this.onRemoveClick(event);
        }
        this._movedWhileRemoving = false;
    }
    /**
     * @hidden
     * @internal
     */
    // -----------------------------
    // Start chip igxDrag behavior
    onChipDragStart(event) {
        this.onMoveStart.emit({
            originalEvent: event,
            owner: this
        });
        event.cancel = !this.draggable || this.disabled;
    }
    /**
     * @hidden
     * @internal
     */
    onChipDragEnd() {
        if (this.animateOnRelease) {
            this.dragDirective.transitionToOrigin();
        }
    }
    /**
     * @hidden
     * @internal
     */
    onChipMoveEnd(event) {
        // moveEnd is triggered after return animation has finished. This happen when we drag and release the chip.
        this.onMoveEnd.emit({
            originalEvent: event,
            owner: this
        });
        if (this.selected) {
            this.chipArea.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * @internal
     */
    onChipGhostCreate() {
        this.hideBaseElement = this.hideBaseOnDrag;
    }
    /**
     * @hidden
     * @internal
     */
    onChipGhostDestroy() {
        this.hideBaseElement = false;
    }
    /**
     * @hidden
     * @internal
     */
    onChipDragClicked(event) {
        const clickEventArgs = {
            originalEvent: event,
            owner: this,
            cancel: false
        };
        this.onClick.emit(clickEventArgs);
        if (!clickEventArgs.cancel && this.selectable && !this.disabled) {
            this.changeSelection(!this.selected, event);
        }
    }
    // End chip igxDrag behavior
    /**
     * @hidden
     * @internal
     */
    // -----------------------------
    // Start chip igxDrop behavior
    onChipDragEnterHandler(event) {
        if (this.dragDirective === event.drag || !event.drag.data || !event.drag.data.chip) {
            return;
        }
        const eventArgs = {
            owner: this,
            dragChip: event.drag.data.chip,
            originalEvent: event
        };
        this.onDragEnter.emit(eventArgs);
    }
    /**
     * @hidden
     * @internal
     */
    onChipDrop(event) {
        // Cancel the default drop logic
        event.cancel = true;
    }
}
IgxChipComponent.ɵfac = function IgxChipComponent_Factory(t) { return new (t || IgxChipComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxChipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxChipComponent, selectors: [["igx-chip"]], viewQuery: function IgxChipComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c50, true, IgxDragDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c50, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c51, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c52, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c53, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chipArea = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.selectContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultRemoveIcon = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultSelectIcon = _t.first);
    } }, hostVars: 3, hostBindings: function IgxChipComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function IgxChipComponent_keydown_HostBindingHandler($event) { return ctx.keyEvent($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("tabIndex", ctx.tabIndex)("class", ctx.hostClass);
    } }, inputs: { id: "id", draggable: "draggable", animateOnRelease: "animateOnRelease", hideBaseOnDrag: "hideBaseOnDrag", removable: "removable", selectable: "selectable", class: "class", disabled: "disabled", tabIndex: "tabIndex", selected: "selected", color: "color", data: "data", removeIcon: "removeIcon", selectIcon: "selectIcon" }, outputs: { selectedChange: "selectedChange", onMoveStart: "onMoveStart", onMoveEnd: "onMoveEnd", onRemove: "onRemove", onClick: "onClick", onSelection: "onSelection", onSelectionDone: "onSelectionDone", onKeyDown: "onKeyDown", onDragEnter: "onDragEnter" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c56, decls: 14, vars: 9, consts: [["igxDrop", "", 1, "igx-chip__item", 3, "igxDrag", "ghostClass", "dragStart", "ghostCreate", "ghostDestroy", "dragEnd", "transitioned", "dragClick", "enter", "dropped"], ["chipArea", ""], [3, "ngClass"], ["selectContainer", ""], [4, "ngTemplateOutlet"], [1, "igx-chip__content"], ["class", "igx-chip__remove", 3, "keydown", "pointerdown", "mousedown", "click", "touchmove", "touchend", 4, "ngIf"], ["defaultSelectIcon", ""], ["defaultRemoveIcon", ""], [1, "igx-chip__remove", 3, "keydown", "pointerdown", "mousedown", "click", "touchmove", "touchend"]], template: function IgxChipComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c54);
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵlistener("dragStart", function IgxChipComponent_Template_div_dragStart_0_listener($event) { return ctx.onChipDragStart($event); })("ghostCreate", function IgxChipComponent_Template_div_ghostCreate_0_listener() { return ctx.onChipGhostCreate(); })("ghostDestroy", function IgxChipComponent_Template_div_ghostDestroy_0_listener() { return ctx.onChipGhostDestroy(); })("dragEnd", function IgxChipComponent_Template_div_dragEnd_0_listener() { return ctx.onChipDragEnd(); })("transitioned", function IgxChipComponent_Template_div_transitioned_0_listener($event) { return ctx.onChipMoveEnd($event); })("dragClick", function IgxChipComponent_Template_div_dragClick_0_listener($event) { return ctx.onChipDragClicked($event); })("enter", function IgxChipComponent_Template_div_enter_0_listener($event) { return ctx.onChipDragEnterHandler($event); })("dropped", function IgxChipComponent_Template_div_dropped_0_listener($event) { return ctx.onChipDrop($event); });
        ɵngcc0.ɵɵelementStart(2, "div", 2, 3);
        ɵngcc0.ɵɵtemplate(4, IgxChipComponent_ng_container_4_Template, 1, 0, "ng-container", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(5);
        ɵngcc0.ɵɵelementStart(6, "div", 5);
        ɵngcc0.ɵɵprojection(7, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(8, 2);
        ɵngcc0.ɵɵtemplate(9, IgxChipComponent_div_9_Template, 2, 2, "div", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, IgxChipComponent_ng_template_10_Template, 2, 0, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(12, IgxChipComponent_ng_template_12_Template, 2, 0, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("visibility", ctx.hideBaseElement ? "hidden" : "visible");
        ɵngcc0.ɵɵproperty("igxDrag", ɵngcc0.ɵɵpureFunction1(7, _c55, ctx))("ghostClass", ctx.ghostClass);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ctx.selectClass(ctx.selected));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.selectIconTemplate);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.removable);
    } }, directives: [IgxDropDirective, IgxDragDirective, ɵngcc2.NgClass, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxIconComponent], encapsulation: 2 });
IgxChipComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxChipComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabIndex',] }, { type: Input }],
    data: [{ type: Input }],
    draggable: [{ type: Input }],
    animateOnRelease: [{ type: Input }],
    hideBaseOnDrag: [{ type: Input }],
    removable: [{ type: Input }],
    removeIcon: [{ type: Input }],
    selectable: [{ type: Input }],
    selectIcon: [{ type: Input }],
    class: [{ type: Input }],
    disabled: [{ type: Input }],
    selected: [{ type: Input }],
    selectedChange: [{ type: Output }],
    color: [{ type: Input }],
    onMoveStart: [{ type: Output }],
    onMoveEnd: [{ type: Output }],
    onRemove: [{ type: Output }],
    onClick: [{ type: Output }],
    onSelection: [{ type: Output }],
    onSelectionDone: [{ type: Output }],
    onKeyDown: [{ type: Output }],
    onDragEnter: [{ type: Output }],
    hostClass: [{ type: HostBinding, args: ['attr.class',] }],
    dragDirective: [{ type: ViewChild, args: ['chipArea', { read: IgxDragDirective, static: true },] }],
    chipArea: [{ type: ViewChild, args: ['chipArea', { read: ElementRef, static: true },] }],
    selectContainer: [{ type: ViewChild, args: ['selectContainer', { read: ElementRef, static: true },] }],
    defaultRemoveIcon: [{ type: ViewChild, args: ['defaultRemoveIcon', { read: TemplateRef, static: true },] }],
    defaultSelectIcon: [{ type: ViewChild, args: ['defaultSelectIcon', { read: TemplateRef, static: true },] }],
    keyEvent: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * The chip area allows you to perform more complex scenarios with chips that require interaction,
 * like dragging, selection, navigation, etc.
 *
 * @igxModule IgxChipsModule
 *
 * @igxTheme igx-chip-theme
 *
 * @igxKeywords chip area, chip
 *
 * @igxGroup display
 *
 * @example
 * ```html
 * <igx-chips-area>
 *    <igx-chip *ngFor="let chip of chipList" [id]="chip.id">
 *        <span>{{chip.text}}</span>
 *    </igx-chip>
 * </igx-chips-area>
 * ```
 */
class IgxChipsAreaComponent {
    constructor(cdr, element, _iterableDiffers) {
        this.cdr = cdr;
        this.element = element;
        this._iterableDiffers = _iterableDiffers;
        /**
         * @hidden
         * @internal
         */
        this.class = '';
        /**
         * Emits an event when `IgxChipComponent`s in the `IgxChipsAreaComponent` should be reordered.
         * Returns an array of `IgxChipComponent`s.
         * @example
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onReorder)="changedOrder($event)"></igx-chips-area>
         * ```
         */
        this.onReorder = new EventEmitter();
        /**
         * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is selected/deselected.
         * Fired after the chips area is initialized if there are initially selected chips as well.
         * Returns an array of selected `IgxChipComponent`s and the `IgxChipAreaComponent`.
         * @example
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onSelection)="selection($event)"></igx-chips-area>
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
         * @example
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onMoveStart)="moveStart($event)"></igx-chips-area>
         * ```
         */
        this.onMoveStart = new EventEmitter();
        /**
         * Emits an event after an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
         * @example
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onMoveEnd)="moveEnd($event)"></igx-chips-area>
         * ```
         */
        this.onMoveEnd = new EventEmitter();
        this._differ = null;
        this.destroy$ = new Subject();
        this._differ = this._iterableDiffers.find([]).create(null);
    }
    /**
     * @hidden
     * @internal
     */
    get hostClass() {
        const classes = ['igx-chip-area'];
        classes.push(this.class);
        return classes.join(' ');
    }
    /**
     * @hidden
     * @internal
     */
    ngAfterViewInit() {
        // If we have initially selected chips through their inputs, we need to get them, because we cannot listen to their events yet.
        if (this.chipsList.length) {
            const selectedChips = this.chipsList.filter((item) => item.selected);
            if (selectedChips.length) {
                this.onSelection.emit({
                    originalEvent: null,
                    newSelection: selectedChips,
                    owner: this
                });
            }
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngDoCheck() {
        if (this.chipsList) {
            const changes = this._differ.diff(this.chipsList.toArray());
            if (changes) {
                changes.forEachAddedItem((addedChip) => {
                    addedChip.item.onMoveStart.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                        this.onChipMoveStart(args);
                    });
                    addedChip.item.onMoveEnd.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                        this.onChipMoveEnd(args);
                    });
                    addedChip.item.onDragEnter.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                        this.onChipDragEnter(args);
                    });
                    addedChip.item.onKeyDown.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                        this.onChipKeyDown(args);
                    });
                    if (addedChip.item.selectable) {
                        addedChip.item.onSelection.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                            this.onChipSelectionChange(args);
                        });
                    }
                });
                this.modifiedChipsArray = this.chipsList.toArray();
            }
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     * @internal
     */
    onChipKeyDown(event) {
        let orderChanged = false;
        const chipsArray = this.chipsList.toArray();
        const dragChipIndex = chipsArray.findIndex((el) => el === event.owner);
        if (event.originalEvent.shiftKey === true) {
            if (event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') {
                orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex - 1, false, event.originalEvent);
                if (orderChanged) {
                    setTimeout(() => {
                        this.chipsList.toArray()[dragChipIndex - 1].elementRef.nativeElement.focus();
                    });
                }
            }
            else if (event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') {
                orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex + 1, true, event.originalEvent);
            }
        }
        else {
            if ((event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') && dragChipIndex > 0) {
                chipsArray[dragChipIndex - 1].elementRef.nativeElement.focus();
            }
            else if ((event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') &&
                dragChipIndex < chipsArray.length - 1) {
                chipsArray[dragChipIndex + 1].elementRef.nativeElement.focus();
            }
        }
    }
    /**
     * @hidden
     * @internal
     */
    onChipMoveStart(event) {
        this.onMoveStart.emit({
            originalEvent: event.originalEvent,
            owner: this
        });
    }
    /**
     * @hidden
     * @internal
     */
    onChipMoveEnd(event) {
        this.onMoveEnd.emit({
            originalEvent: event.originalEvent,
            owner: this
        });
    }
    /**
     * @hidden
     * @internal
     */
    onChipDragEnter(event) {
        const dropChipIndex = this.chipsList.toArray().findIndex((el) => el === event.owner);
        const dragChipIndex = this.chipsList.toArray().findIndex((el) => el === event.dragChip);
        if (dragChipIndex < dropChipIndex) {
            // from the left to right
            this.positionChipAtIndex(dragChipIndex, dropChipIndex, true, event.originalEvent);
        }
        else {
            // from the right to left
            this.positionChipAtIndex(dragChipIndex, dropChipIndex, false, event.originalEvent);
        }
    }
    /**
     * @hidden
     * @internal
     */
    positionChipAtIndex(chipIndex, targetIndex, shiftRestLeft, originalEvent) {
        if (chipIndex < 0 || this.chipsList.length <= chipIndex ||
            targetIndex < 0 || this.chipsList.length <= targetIndex) {
            return false;
        }
        const chipsArray = this.chipsList.toArray();
        const result = [];
        for (let i = 0; i < chipsArray.length; i++) {
            if (shiftRestLeft) {
                if (chipIndex <= i && i < targetIndex) {
                    result.push(chipsArray[i + 1]);
                }
                else if (i === targetIndex) {
                    result.push(chipsArray[chipIndex]);
                }
                else {
                    result.push(chipsArray[i]);
                }
            }
            else {
                if (targetIndex < i && i <= chipIndex) {
                    result.push(chipsArray[i - 1]);
                }
                else if (i === targetIndex) {
                    result.push(chipsArray[chipIndex]);
                }
                else {
                    result.push(chipsArray[i]);
                }
            }
        }
        this.modifiedChipsArray = result;
        const eventData = {
            chipsArray: this.modifiedChipsArray,
            originalEvent: originalEvent,
            owner: this
        };
        this.onReorder.emit(eventData);
        return true;
    }
    /**
     * @hidden
     * @internal
     */
    onChipSelectionChange(event) {
        let selectedChips = this.chipsList.filter((chip) => chip.selected);
        if (event.selected && !selectedChips.includes(event.owner)) {
            selectedChips.push(event.owner);
        }
        else if (!event.selected && selectedChips.includes(event.owner)) {
            selectedChips = selectedChips.filter((chip) => {
                return chip.id !== event.owner.id;
            });
        }
        this.onSelection.emit({
            originalEvent: event.originalEvent,
            newSelection: selectedChips,
            owner: this
        });
    }
}
IgxChipsAreaComponent.ɵfac = function IgxChipsAreaComponent_Factory(t) { return new (t || IgxChipsAreaComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers)); };
IgxChipsAreaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxChipsAreaComponent, selectors: [["igx-chips-area"]], contentQueries: function IgxChipsAreaComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxChipComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chipsList = _t);
    } }, hostVars: 5, hostBindings: function IgxChipsAreaComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.hostClass);
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px")("height", ctx.height, "px");
    } }, inputs: { class: "class", width: "width", height: "height" }, outputs: { onReorder: "onReorder", onSelection: "onSelection", onMoveStart: "onMoveStart", onMoveEnd: "onMoveEnd" }, ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxChipsAreaComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
IgxChipsAreaComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: IterableDiffers }
];
IgxChipsAreaComponent.propDecorators = {
    class: [{ type: Input }],
    hostClass: [{ type: HostBinding, args: ['attr.class',] }],
    width: [{ type: HostBinding, args: ['style.width.px',] }, { type: Input }],
    height: [{ type: HostBinding, args: ['style.height.px',] }, { type: Input }],
    onReorder: [{ type: Output }],
    onSelection: [{ type: Output }],
    onMoveStart: [{ type: Output }],
    onMoveEnd: [{ type: Output }],
    chipsList: [{ type: ContentChildren, args: [IgxChipComponent, { descendants: true },] }]
};

/**
 * @hidden
 */
class IgxChipsModule {
}
IgxChipsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxChipsModule });
IgxChipsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxChipsModule_Factory(t) { return new (t || IgxChipsModule)(); }, imports: [[
            CommonModule,
            IgxRippleModule,
            IgxIconModule,
            IgxButtonModule,
            IgxAvatarModule,
            IgxDragDropModule,
            IgxPrefixModule,
            IgxSuffixModule
        ]] });

/**
 * @hidden
 */
class IgxComboHeaderDirective {
}
IgxComboHeaderDirective.ɵfac = function IgxComboHeaderDirective_Factory(t) { return new (t || IgxComboHeaderDirective)(); };
IgxComboHeaderDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboHeaderDirective, selectors: [["", "igxComboHeader", ""]] });
/**
 * @hidden
 */
class IgxComboFooterDirective {
}
IgxComboFooterDirective.ɵfac = function IgxComboFooterDirective_Factory(t) { return new (t || IgxComboFooterDirective)(); };
IgxComboFooterDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboFooterDirective, selectors: [["", "igxComboFooter", ""]] });
/**
 * @hidden
 */
class IgxComboItemDirective {
}
IgxComboItemDirective.ɵfac = function IgxComboItemDirective_Factory(t) { return new (t || IgxComboItemDirective)(); };
IgxComboItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboItemDirective, selectors: [["", "igxComboItem", ""]] });
/**
 * @hidden
 */
class IgxComboEmptyDirective {
}
IgxComboEmptyDirective.ɵfac = function IgxComboEmptyDirective_Factory(t) { return new (t || IgxComboEmptyDirective)(); };
IgxComboEmptyDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboEmptyDirective, selectors: [["", "igxComboEmpty", ""]] });
/**
 * @hidden
 */
class IgxComboHeaderItemDirective {
}
IgxComboHeaderItemDirective.ɵfac = function IgxComboHeaderItemDirective_Factory(t) { return new (t || IgxComboHeaderItemDirective)(); };
IgxComboHeaderItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboHeaderItemDirective, selectors: [["", "igxComboHeaderItem", ""]] });
/**
 * @hidden
 */
class IgxComboAddItemDirective {
}
IgxComboAddItemDirective.ɵfac = function IgxComboAddItemDirective_Factory(t) { return new (t || IgxComboAddItemDirective)(); };
IgxComboAddItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboAddItemDirective, selectors: [["", "igxComboAddItem", ""]] });
/**
 * @hidden
 */
class IgxComboToggleIconDirective {
}
IgxComboToggleIconDirective.ɵfac = function IgxComboToggleIconDirective_Factory(t) { return new (t || IgxComboToggleIconDirective)(); };
IgxComboToggleIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboToggleIconDirective, selectors: [["", "igxComboToggleIcon", ""]] });
/**
 * @hidden
 */
class IgxComboClearIconDirective {
}
IgxComboClearIconDirective.ɵfac = function IgxComboClearIconDirective_Factory(t) { return new (t || IgxComboClearIconDirective)(); };
IgxComboClearIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboClearIconDirective, selectors: [["", "igxComboClearIcon", ""]] });

/**
 * @hidden
 */
class IgxComboAPIService {
    constructor() {
        this.disableTransitions = false;
    }
    register(combo) {
        this.combo = combo;
    }
    clear() {
        this.combo = null;
    }
    get valueKey() {
        return this.combo.valueKey !== null && this.combo.valueKey !== undefined ? this.combo.valueKey : null;
    }
    get item_focusable() {
        return false;
    }
    get isRemote() {
        return this.combo.isRemote;
    }
    add_custom_item() {
        if (!this.combo) {
            return;
        }
        this.combo.addItemToCollection();
    }
    get comboID() {
        return this.combo.id;
    }
    set_selected_item(itemID, event) {
        const selected = this.combo.isItemSelected(itemID);
        if (itemID === null || itemID === undefined) {
            return;
        }
        if (!selected) {
            this.combo.selectItems([itemID], false, event);
        }
        else {
            this.combo.deselectItems([itemID], event);
        }
    }
    is_item_selected(itemID) {
        return this.combo.isItemSelected(itemID);
    }
}
IgxComboAPIService.ɵfac = function IgxComboAPIService_Factory(t) { return new (t || IgxComboAPIService)(); };
IgxComboAPIService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxComboAPIService, factory: IgxComboAPIService.ɵfac });

/** @hidden */
class IgxComboItemComponent extends IgxDropDownItemComponent {
    constructor(comboAPI, dropDown, elementRef, selection) {
        super(dropDown, elementRef, null, selection);
        this.comboAPI = comboAPI;
        this.dropDown = dropDown;
        this.elementRef = elementRef;
        this.selection = selection;
        /**
         * Gets the height of a list item
         * @hidden
         */
        this.itemHeight = '';
    }
    /**
     * @hidden
     */
    get itemID() {
        const valueKey = this.comboAPI.valueKey;
        return valueKey !== null ? this.value[valueKey] : this.value;
    }
    /**
     * @hidden
     */
    get comboID() {
        return this.comboAPI.comboID;
    }
    /**
     * @hidden
     * @internal
     */
    get disableTransitions() {
        return this.comboAPI.disableTransitions;
    }
    /**
     * @hidden
     */
    get selected() {
        return this.comboAPI.is_item_selected(this.itemID);
    }
    set selected(value) {
        if (this.isHeader) {
            return;
        }
        this._selected = value;
    }
    /**
     * @hidden
     */
    isVisible(direction) {
        const rect = this.element.nativeElement.getBoundingClientRect();
        const parentDiv = this.element.nativeElement.parentElement.parentElement.getBoundingClientRect();
        if (direction === Navigate.Down) {
            return rect.y + rect.height <= parentDiv.y + parentDiv.height;
        }
        return rect.y >= parentDiv.y;
    }
    /**
     * @inheritdoc
     */
    clicked(event) {
        this.comboAPI.disableTransitions = false;
        if (!this.isSelectable) {
            return;
        }
        this.dropDown.navigateItem(this.index);
        this.comboAPI.set_selected_item(this.itemID, event);
    }
    /**
     * @hidden
     * @internal
     * The event that is prevented is the click on the checkbox label element.
     * That is the only visible element that a user can interact with.
     * The click propagates to the host and the preventDefault is to stop it from
     * switching focus to the input it's base on.
     * The toggle happens in an internal handler in the drop-down on the next task queue cycle.
     */
    disableCheck(event) {
        event.preventDefault();
    }
    ngDoCheck() {
    }
}
IgxComboItemComponent.ɵfac = function IgxComboItemComponent_Factory(t) { return new (t || IgxComboItemComponent)(ɵngcc0.ɵɵdirectiveInject(IgxComboAPIService), ɵngcc0.ɵɵdirectiveInject(IGX_DROPDOWN_BASE), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxSelectionAPIService)); };
IgxComboItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxComboItemComponent, selectors: [["igx-combo-item"]], hostVars: 2, hostBindings: function IgxComboItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("height", ctx.itemHeight, "px");
    } }, inputs: { itemHeight: "itemHeight" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 3, vars: 1, consts: [[4, "ngIf"], [1, "igx-drop-down__inner"], ["disableRipple", "true", 1, "igx-combo__checkbox", 3, "checked", "disableTransitions", "tabindex", "click"]], template: function IgxComboItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, IgxComboItemComponent_ng_container_0_Template, 2, 3, "ng-container", 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isHeader);
    } }, directives: [ɵngcc2.NgIf, IgxCheckboxComponent], encapsulation: 2 });
IgxComboItemComponent.ctorParameters = () => [
    { type: IgxComboAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DROPDOWN_BASE,] }] },
    { type: ElementRef },
    { type: IgxSelectionAPIService, decorators: [{ type: Inject, args: [IgxSelectionAPIService,] }] }
];
IgxComboItemComponent.propDecorators = {
    itemHeight: [{ type: Input }, { type: HostBinding, args: ['style.height.px',] }]
};

const IGX_COMBO_COMPONENT = new InjectionToken('IgxComboComponentToken');

/**
 * @hidden
 */
class IgxComboAddItemComponent extends IgxComboItemComponent {
    get selected() {
        return false;
    }
    set selected(value) {
    }
    /**
     * @inheritdoc
     */
    clicked(event) {
        this.comboAPI.disableTransitions = false;
        this.comboAPI.add_custom_item();
    }
}
IgxComboAddItemComponent.ɵfac = function IgxComboAddItemComponent_Factory(t) { return ɵIgxComboAddItemComponent_BaseFactory(t || IgxComboAddItemComponent); };
IgxComboAddItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxComboAddItemComponent, selectors: [["igx-combo-add-item"]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxComboItemComponent, useExisting: IgxComboAddItemComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxComboAddItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });

/** @hidden */
class IgxComboDropDownComponent extends IgxDropDownComponent {
    constructor(elementRef, cdr, selection, combo, comboAPI, _displayDensityOptions) {
        super(elementRef, cdr, selection, _displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this.combo = combo;
        this.comboAPI = comboAPI;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * @hidden
         * @internal
         */
        this.children = null;
        this.scrollHandler = () => {
            this.comboAPI.disableTransitions = true;
        };
    }
    /** @hidden @internal */
    get scrollContainer() {
        return this.virtDir.dc.location.nativeElement;
    }
    get isScrolledToLast() {
        const scrollTop = this.virtDir.scrollPosition;
        const scrollHeight = this.virtDir.getScroll().scrollHeight;
        return Math.floor(scrollTop + this.virtDir.igxForContainerSize) === scrollHeight;
    }
    get lastVisibleIndex() {
        return this.combo.totalItemCount ?
            Math.floor(this.combo.itemsMaxHeight / this.combo.itemHeight) :
            this.items.length - 1;
    }
    /**
     * @hidden @internal
     */
    onFocus() {
        this.focusedItem = this._focusedItem || this.items[0];
    }
    /**
     * @hidden @internal
     */
    onBlur(evt) {
        this.focusedItem = null;
    }
    /**
     * @hidden @internal
     */
    onToggleOpened() {
        this.onOpened.emit();
    }
    /**
     * @hidden
     */
    navigateFirst() {
        this.navigateItem(this.virtDir.igxForOf.findIndex(e => !e.isHeader));
    }
    /**
     * @hidden
     */
    navigatePrev() {
        if (this._focusedItem && this._focusedItem.index === 0 && this.virtDir.state.startIndex === 0) {
            this.combo.focusSearchInput(false);
        }
        else {
            super.navigatePrev();
        }
    }
    /**
     * @hidden
     */
    navigateNext() {
        const lastIndex = this.combo.totalItemCount ? this.combo.totalItemCount - 1 : this.virtDir.igxForOf.length - 1;
        if (this._focusedItem && this._focusedItem.index === lastIndex) {
            this.focusAddItemButton();
        }
        else {
            super.navigateNext();
        }
    }
    /**
     * @hidden @internal
     */
    selectItem(item) {
        if (item === null || item === undefined) {
            return;
        }
        this.comboAPI.set_selected_item(item.itemID);
        this._focusedItem = item;
    }
    focusAddItemButton() {
        if (this.combo.isAddButtonVisible()) {
            this.focusedItem = this.items[this.items.length - 1];
        }
    }
    scrollToHiddenItem(newItem) { }
    get sortedChildren() {
        if (this.children !== undefined) {
            return this.children.toArray()
                .sort((a, b) => {
                return a.index - b.index;
            });
        }
        return null;
    }
    /**
     * Get all non-header items
     *
     * ```typescript
     * let myDropDownItems = this.dropdown.items;
     * ```
     */
    get items() {
        const items = [];
        if (this.children !== undefined) {
            const sortedChildren = this.sortedChildren;
            for (const child of sortedChildren) {
                if (!child.isHeader) {
                    items.push(child);
                }
            }
        }
        return items;
    }
    /**
     * @hidden @internal
     */
    updateScrollPosition() {
        this.virtDir.getScroll().scrollTop = this._scrollPosition;
    }
    /**
     * @hidden @internal
     */
    onItemActionKey(key) {
        switch (key) {
            case DropDownActionKey.ENTER:
                this.handleEnter();
                break;
            case DropDownActionKey.SPACE:
                this.handleSpace();
                break;
            case DropDownActionKey.ESCAPE:
                this.close();
        }
    }
    handleEnter() {
        if (this.isAddItemFocused()) {
            this.combo.addItemToCollection();
        }
        else {
            this.close();
        }
    }
    handleSpace() {
        if (this.isAddItemFocused()) {
            return;
        }
        else {
            this.selectItem(this.focusedItem);
        }
    }
    isAddItemFocused() {
        return this.focusedItem instanceof IgxComboAddItemComponent;
    }
    ngAfterViewInit() {
        this.virtDir.getScroll().addEventListener('scroll', this.scrollHandler);
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.virtDir.getScroll().removeEventListener('scroll', this.scrollHandler);
        this.destroy$.next(true);
        this.destroy$.complete();
    }
}
IgxComboDropDownComponent.ɵfac = function IgxComboDropDownComponent_Factory(t) { return new (t || IgxComboDropDownComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxSelectionAPIService), ɵngcc0.ɵɵdirectiveInject(IGX_COMBO_COMPONENT), ɵngcc0.ɵɵdirectiveInject(IgxComboAPIService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxComboDropDownComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxComboDropDownComponent, selectors: [["igx-combo-drop-down"]], contentQueries: function IgxComboDropDownComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IGX_DROPDOWN_BASE, useExisting: IgxComboDropDownComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 4, vars: 8, consts: [["igxToggle", "", 1, "igx-drop-down__list", 3, "onAppended", "onOpening", "onOpened", "onClosing", "onClosed"], ["role", "listbox", 1, "igx-drop-down__list-scroll"], ["scrollContainer", ""], [4, "ngIf"]], template: function IgxComboDropDownComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("onAppended", function IgxComboDropDownComponent_Template_div_onAppended_0_listener() { return ctx.onToggleContentAppended(); })("onOpening", function IgxComboDropDownComponent_Template_div_onOpening_0_listener($event) { return ctx.onToggleOpening($event); })("onOpened", function IgxComboDropDownComponent_Template_div_onOpened_0_listener() { return ctx.onToggleOpened(); })("onClosing", function IgxComboDropDownComponent_Template_div_onClosing_0_listener($event) { return ctx.onToggleClosing($event); })("onClosed", function IgxComboDropDownComponent_Template_div_onClosed_0_listener() { return ctx.onToggleClosed(); });
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵtemplate(3, IgxComboDropDownComponent_ng_container_3_Template, 2, 0, "ng-container", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.height)("max-height", ctx.maxHeight);
        ɵngcc0.ɵɵattribute("id", ctx.listId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.collapsed);
    } }, directives: [IgxToggleDirective, ɵngcc2.NgIf], encapsulation: 2 });
IgxComboDropDownComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxSelectionAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IGX_COMBO_COMPONENT,] }] },
    { type: IgxComboAPIService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxComboDropDownComponent.propDecorators = {
    children: [{ type: ContentChildren, args: [IgxComboItemComponent, { descendants: true },] }]
};

/**
 * @hidden
 */
class IgxComboFilteringPipe {
    transform(collection, searchValue, displayKey, shouldFilter, filteringOptions) {
        if (!collection) {
            return [];
        }
        if (!searchValue || !shouldFilter) {
            return collection;
        }
        else {
            const searchTerm = filteringOptions.caseSensitive ? searchValue.trim() : searchValue.toLowerCase().trim();
            if (displayKey != null) {
                return collection.filter(e => filteringOptions.caseSensitive ? e[displayKey].includes(searchTerm) :
                    e[displayKey].toLowerCase().includes(searchTerm));
            }
            else {
                return collection.filter(e => filteringOptions.caseSensitive ? e.includes(searchTerm) :
                    e.toLowerCase().includes(searchTerm));
            }
        }
    }
}
IgxComboFilteringPipe.ɵfac = function IgxComboFilteringPipe_Factory(t) { return new (t || IgxComboFilteringPipe)(); };
IgxComboFilteringPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "comboFiltering", type: IgxComboFilteringPipe, pure: true });
/**
 * @hidden
 */
class IgxComboGroupingPipe {
    constructor(combo) {
        this.combo = combo;
    }
    transform(collection, groupKey, valueKey) {
        this.combo.filteredData = collection;
        if ((!groupKey && groupKey !== 0) || !collection.length) {
            return collection;
        }
        const sorted = DataUtil.sort(cloneArray(collection), [{
                fieldName: groupKey,
                dir: SortingDirection.Asc,
                ignoreCase: true,
                strategy: DefaultSortingStrategy.instance()
            }]);
        const data = cloneArray(sorted);
        let inserts = 0;
        let currentHeader = null;
        for (let i = 0; i < sorted.length; i++) {
            let insertFlag = 0;
            if (currentHeader !== sorted[i][groupKey]) {
                currentHeader = sorted[i][groupKey];
                insertFlag = 1;
            }
            if (insertFlag) {
                data.splice(i + inserts, 0, {
                    [valueKey]: currentHeader,
                    [groupKey]: currentHeader,
                    isHeader: true
                });
                inserts++;
            }
        }
        return data;
    }
}
IgxComboGroupingPipe.ɵfac = function IgxComboGroupingPipe_Factory(t) { return new (t || IgxComboGroupingPipe)(ɵngcc0.ɵɵdirectiveInject(IGX_COMBO_COMPONENT)); };
IgxComboGroupingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "comboGrouping", type: IgxComboGroupingPipe, pure: true });
IgxComboGroupingPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_COMBO_COMPONENT,] }] }
];

/**
 * @hidden
 */
var DataTypes;
(function (DataTypes) {
    DataTypes["EMPTY"] = "empty";
    DataTypes["PRIMITIVE"] = "primitive";
    DataTypes["COMPLEX"] = "complex";
    DataTypes["PRIMARYKEY"] = "valueKey";
})(DataTypes || (DataTypes = {}));
/**
 * @hidden
 */
const ItemHeights = {
    'comfortable': 40,
    'cosy': 32,
    'compact': 28,
};
/**
 * @hidden
 * The default number of items that should be in the combo's
 * drop-down list if no `[itemsMaxHeight]` is specified
 */
const itemsInContainer = 10;
var IgxComboState;
(function (IgxComboState) {
    /**
     * Combo with initial state.
     */
    IgxComboState[IgxComboState["INITIAL"] = 0] = "INITIAL";
    /**
     * Combo with valid state.
     */
    IgxComboState[IgxComboState["VALID"] = 1] = "VALID";
    /**
     * Combo with invalid state.
     */
    IgxComboState[IgxComboState["INVALID"] = 2] = "INVALID";
})(IgxComboState || (IgxComboState = {}));
/**
 * When called with sets A & B, returns A - B (as array);
 * @hidden
 */
function diffInSets(set1, set2) {
    const results = [];
    set1.forEach(entry => {
        if (!set2.has(entry)) {
            results.push(entry);
        }
    });
    return results;
}
let NEXT_ID$j = 0;
const noop$4 = () => { };
const ɵ0$5 = noop$4;
class IgxComboComponent extends DisplayDensityBase {
    constructor(elementRef, cdr, selection, comboAPI, _iconService, _displayDensityOptions, _inputGroupType, _injector) {
        super(_displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this.comboAPI = comboAPI;
        this._iconService = _iconService;
        this._displayDensityOptions = _displayDensityOptions;
        this._inputGroupType = _inputGroupType;
        this._injector = _injector;
        /**
         * @hidden @internal
         */
        this.customValueFlag = true;
        /**
         * @hidden @internal
         */
        this.defaultFallbackGroup = 'Other';
        /**
         * @hidden @internal
         */
        this.filteringOptions = {
            caseSensitive: false
        };
        /** @hidden @internal */
        this.filterValue = '';
        this.stringFilters = IgxStringFilteringOperand;
        this.booleanFilters = IgxBooleanFilteringOperand;
        this._groupKey = '';
        this._prevInputValue = '';
        this._dataType = '';
        this._searchValue = '';
        this._type = null;
        this.ngControl = null;
        this.destroy$ = new Subject();
        this._data = [];
        this._filteredData = [];
        this._itemHeight = null;
        this._itemsMaxHeight = null;
        this._remoteSelection = {};
        this._onChangeCallback = noop$4;
        this._onTouchedCallback = noop$4;
        this._value = '';
        this._valid = IgxComboState.INITIAL;
        /**
         * Set custom overlay settings that control how the combo's list of items is displayed.
         * Set:
         * ```html
         * <igx-combo [overlaySettings] = "customOverlaySettings"></igx-combo>
         * ```
         *
         * ```typescript
         *  const customSettings = { positionStrategy: { settings: { target: myTarget } } };
         *  combo.overlaySettings = customSettings;
         * ```
         * Get any custom overlay settings used by the combo:
         * ```typescript
         *  const comboOverlaySettings: OverlaySettings = myCombo.overlaySettings;
         * ```
         */
        this.overlaySettings = null;
        /**
         * @hidden @internal
         */
        this.searchInput = null;
        /**
         * The custom template, if any, that should be used when rendering ITEMS in the combo list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.itemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboItem>
         *          <div class="custom-item" let-item let-key="valueKey">
         *              <div class="custom-item__name">{{ item[key] }}</div>
         *              <div class="custom-item__cost">{{ item.cost }}</div>
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.itemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the HEADER for the combo items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.headerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboHeader>
         *          <div class="combo__header">
         *              This is a custom header
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.headerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the FOOTER for the combo items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.footerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboFooter>
         *          <div class="combo__footer">
         *              This is a custom footer
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.footerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering HEADER ITEMS for groups in the combo list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.headerItemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboHeaderItem let-item let-key="groupKey">
         *          <div class="custom-item--group">Group header for {{ item[key] }}</div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.headerItemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.addItemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboAddItem>
         *          <button class="combo__add-button">
         *              Click to add item
         *          </button>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.addItemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.emptyTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboEmpty>
         *          <div class="combo--empty">
         *              There are no items to display
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.emptyTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the combo TOGGLE(open/close) button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.toggleIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboToggleIcon let-collapsed>
         *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.toggleIconTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the combo CLEAR button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.clearIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboClearIcon>
         *          <igx-icon>clear</igx-icon>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.clearIconTemplate = null;
        this.dropdownContainer = null;
        /**
         * Emitted when item selection is changing, before the selection completes
         *
         * ```html
         * <igx-combo (onSelectionChange)='handleSelection()'></igx-combo>
         * ```
         */
        this.onSelectionChange = new EventEmitter();
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-combo onOpening='handleOpening($event)'></igx-combo>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-combo (onOpened)='handleOpened()'></igx-combo>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-combo (onClosing)='handleClosing($event)'></igx-combo>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-combo (onClosed)='handleClosed()'></igx-combo>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted when an item is being added to the data collection
         *
         * ```html
         * <igx-combo (onAddition)='handleAdditionEvent()'></igx-combo>
         * ```
         */
        this.onAddition = new EventEmitter();
        /**
         * Emitted when the value of the search input changes (e.g. typing, pasting, clear, etc.)
         *
         * ```html
         * <igx-combo (onSearchInput)='handleSearchInputEvent()'></igx-combo>
         * ```
         */
        this.onSearchInput = new EventEmitter();
        /**
         * Emitted when new chunk of data is loaded from the virtualization
         *
         * ```html
         * <igx-combo (onDataPreLoad)='handleDataPreloadEvent()'></igx-combo>
         * ```
         */
        this.onDataPreLoad = new EventEmitter();
        /**
         * Gets/gets combo id.
         *
         * ```typescript
         * // get
         * let id = this.combo.id;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [id]='combo1'></igx-combo>
         * ```
         */
        this.id = `igx-combo-${NEXT_ID$j++}`;
        /**
         * @hidden @internal
         */
        this.cssClass = 'igx-combo'; // Independent of display density, at the time being
        /**
         * @hidden @internal
         */
        this.role = 'combobox';
        /**
         * Controls whether custom values can be added to the collection
         *
         * ```typescript
         * // get
         * let comboAllowsCustomValues = this.combo.allowCustomValues;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [allowCustomValues]='true'></igx-combo>
         * ```
         */
        this.allowCustomValues = false;
        /**
         * @hidden @internal
         */
        this.filteringLogic = FilteringLogic.Or;
        /**
         * Defines the placeholder value for the combo dropdown search field
         *
         * ```typescript
         * // get
         * let myComboSearchPlaceholder = this.combo.searchPlaceholder;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [searchPlaceholder]='newPlaceHolder'></igx-combo>
         * ```
         */
        this.searchPlaceholder = 'Enter a Search Term';
        /**
         * Defines whether the caseSensitive icon should be shown in the search input
         *
         * ```typescript
         * // get
         * let myComboShowSearchCaseIcon = this.combo.showSearchCaseIcon;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [showSearchCaseIcon]='true'></igx-combo>
         * ```
         */
        this.showSearchCaseIcon = false;
        /**
         * Combo value data source property.
         *
         * ```typescript
         * // get
         * let myComboValueKey = this.combo.valueKey;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [valueKey]='myKey'></igx-combo>
         * ```
         */
        this.valueKey = null;
        /**
         * An @Input property that enabled/disables filtering in the list. The default is `true`.
         * ```html
         * <igx-combo [filterable]="false">
         * ```
         */
        this.filterable = true;
        /**
         * An @Input property that enabled/disables combo. The default is `false`.
         * ```html
         * <igx-combo [disabled]="'true'">
         * ```
         */
        this.disabled = false;
        /**
         * An @Input property that controls whether the combo's search box
         * should be focused after the `onOpened` event is called
         * When `false`, the combo's list item container will be focused instead
         */
        this.autoFocusSearch = true;
        this.onStatusChanged = () => {
            if ((this.ngControl.control.touched || this.ngControl.control.dirty) &&
                (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {
                if (!this.collapsed || this.inputGroup.isFocused) {
                    this.valid = this.ngControl.valid ? IgxComboState.VALID : IgxComboState.INVALID;
                }
                else {
                    this.valid = this.ngControl.valid ? IgxComboState.INITIAL : IgxComboState.INVALID;
                }
            }
            this.manageRequiredAsterisk();
        };
        this.comboAPI.register(this);
    }
    /**
     * @hidden @internal
     */
    get displaySearchInput() {
        return this.filterable || this.allowCustomValues;
    }
    /**
     * @hidden @internal
     */
    get ariaExpanded() {
        return !this.dropdown.collapsed;
    }
    /**
     * @hidden @internal
     */
    get hasPopUp() {
        return 'listbox';
    }
    /**
     * @hidden @internal
     */
    get ariaOwns() {
        return this.dropdown.id;
    }
    /**
     * Configures the drop down list height
     *
     * ```typescript
     * // get
     * let myComboItemsMaxHeight = this.combo.itemsMaxHeight;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-combo [itemsMaxHeight]='320'></igx-combo>
     * ```
     */
    get itemsMaxHeight() {
        if (this._itemsMaxHeight === null || this._itemsMaxHeight === undefined) {
            return this.itemHeight * itemsInContainer;
        }
        return this._itemsMaxHeight;
    }
    set itemsMaxHeight(val) {
        this._itemsMaxHeight = val;
    }
    /**
     * Configures the drop down list item height
     *
     * ```typescript
     * // get
     * let myComboItemHeight = this.combo.itemHeight;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-combo [itemHeight]='32'></igx-combo>
     * ```
     */
    get itemHeight() {
        if (this._itemHeight === null || this._itemHeight === undefined) {
            return ItemHeights[this.displayDensity];
        }
        return this._itemHeight;
    }
    set itemHeight(val) {
        this._itemHeight = val;
    }
    /**
     * @hidden @internal
     */
    get inputEmpty() {
        return !this.value && !this.placeholder;
    }
    /**
     * Combo data source.
     *
     * ```html
     * <!--set-->
     * <igx-combo [data]='items'></igx-combo>
     * ```
     */
    get data() {
        return this._data;
    }
    set data(val) {
        this._data = (val) ? val : [];
    }
    set displayKey(val) {
        this._displayKey = val;
    }
    /**
     * Combo text data source property.
     *
     * ```typescript
     * // get
     * let myComboDisplayKey = this.combo.displayKey;
     *
     * // set
     * this.combo.displayKey = 'val';
     *
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-combo [displayKey]='myDisplayKey'></igx-combo>
     * ```
     */
    get displayKey() {
        return this._displayKey ? this._displayKey : this.valueKey;
    }
    /**
     * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
     *
     * ```html
     * <!--set-->
     * <igx-combo [groupKey]='newGroupKey'></igx-combo>
     * ```
     */
    set groupKey(val) {
        this._groupKey = val;
    }
    /**
     * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
     *
     * ```typescript
     * // get
     * let currentGroupKey = this.combo.groupKey;
     * ```
     */
    get groupKey() {
        return this._groupKey;
    }
    /**
     * An @Input property that sets how the combo will be styled.
     * The allowed values are `line`, `box`, `border` and `search`. The default is `box`.
     * ```html
     * <igx-combo [type]="'line'">
     * ```
     */
    get type() {
        return this._type || this._inputGroupType || 'box';
    }
    set type(val) {
        this._type = val;
    }
    /**
     * Gets if control is valid, when used in a form
     *
     * ```typescript
     * // get
     * let valid = this.combo.valid;
     * ```
     */
    get valid() {
        return this._valid;
    }
    /**
     * Sets if control is valid, when used in a form
     *
     * ```typescript
     * // set
     * this.combo.valid = IgxComboState.INVALID;
     * ```
     */
    set valid(valid) {
        this._valid = valid;
        this.comboInput.valid = IgxInputState[IgxComboState[valid]];
    }
    /**
     * @hidden @internal
     */
    get searchValue() {
        return this._searchValue;
    }
    set searchValue(val) {
        this.filterValue = val;
        this._searchValue = val;
    }
    /**
     * @hidden @internal
     */
    onArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        this.open();
    }
    /**
     * @hidden @internal
     */
    onInputClick(event) {
        event.stopPropagation();
        event.preventDefault();
        if (!this.disabled) {
            this.toggle();
        }
    }
    /**
     * Defines the current state of the virtualized data. It contains `startIndex` and `chunkSize`
     *
     * ```typescript
     * // get
     * let state = this.combo.virtualizationState;
     * ```
     */
    get virtualizationState() {
        return this.virtDir.state;
    }
    /**
     * Sets the current state of the virtualized data.
     *
     * ```typescript
     * // set
     * this.combo.virtualizationState(state);
     * ```
     */
    set virtualizationState(state) {
        this.virtDir.state = state;
    }
    /**
     * Gets total count of the virtual data items, when using remote service.
     *
     * ```typescript
     * // get
     * let count = this.combo.totalItemCount;
     * ```
     */
    get totalItemCount() {
        return this.virtDir.totalItemCount;
    }
    /**
     * Sets total count of the virtual data items, when using remote service.
     *
     * ```typescript
     * // set
     * this.combo.totalItemCount(remoteService.count);
     * ```
     */
    set totalItemCount(count) {
        this.virtDir.totalItemCount = count;
    }
    /**
     * The text displayed in the combo input
     *
     * ```typescript
     * // get
     * let comboValue = this.combo.value;
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * @hidden @internal
     */
    get filteredData() {
        return this.filterable ? this._filteredData : this.data;
    }
    /**
     * @hidden @internal
     */
    set filteredData(val) {
        this._filteredData = this.groupKey ? (val || []).filter((e) => e.isHeader !== true) : val;
        this.checkMatch();
    }
    /**
     * @hidden @internal
     */
    handleKeyUp(event) {
        if (event.key === 'ArrowDown' || event.key === 'Down') {
            this.dropdown.focusedItem = this.dropdown.items[0];
            this.dropdownContainer.nativeElement.focus();
        }
        else if (event.key === 'Escape' || event.key === 'Esc') {
            this.toggle();
        }
    }
    /**
     * @hidden @internal
     */
    handleKeyDown(event) {
        if (event.key === 'ArrowUp' || event.key === 'Up') {
            event.preventDefault();
            event.stopPropagation();
            this.close();
        }
    }
    checkMatch() {
        const displayKey = this.displayKey;
        const matchFn = (e) => {
            const value = displayKey ? e[displayKey] : e;
            return value.toString().toLowerCase() === this.searchValue.trim().toLowerCase();
        };
        const itemMatch = this.filteredData.some(matchFn);
        this.customValueFlag = this.allowCustomValues && !itemMatch;
    }
    /**
     * @hidden @internal
     */
    handleInputChange(event) {
        if (event !== undefined) {
            const args = {
                searchText: event,
                owner: this,
                cancel: false
            };
            this.onSearchInput.emit(args);
            if (args.cancel) {
                this.filterValue = null;
            }
        }
        this.checkMatch();
    }
    /**
     * @hidden @internal
     */
    get dataType() {
        if (this.displayKey) {
            return DataTypes.COMPLEX;
        }
        return DataTypes.PRIMITIVE;
    }
    /**
     * @hidden @internal
     */
    get isRemote() {
        return this.totalItemCount > 0 &&
            this.valueKey &&
            this.dataType === DataTypes.COMPLEX;
    }
    /** Contains key-value pairs of the selected valueKeys and their resp. displayKeys */
    registerRemoteEntries(ids, add = true) {
        if (add) {
            const selection = this.getValueDisplayPairs(ids);
            for (const entry of selection) {
                this._remoteSelection[entry[this.valueKey]] = entry[this.displayKey];
            }
        }
        else {
            for (const entry of ids) {
                delete this._remoteSelection[entry];
            }
        }
    }
    /**
     * For `id: any[]` returns a mapped `{ [combo.valueKey]: any, [combo.displayKey]: any }[]`
     */
    getValueDisplayPairs(ids) {
        return this.data.filter(entry => ids.indexOf(entry[this.valueKey]) > -1).map(e => {
            return {
                [this.valueKey]: e[this.valueKey],
                [this.displayKey]: e[this.displayKey]
            };
        });
    }
    /**
     * Returns if the specified itemID is selected
     * @hidden
     * @internal
     */
    isItemSelected(item) {
        return this.selection.is_item_selected(this.id, item);
    }
    /**
     * Triggers change detection on the combo view
     */
    triggerCheck() {
        this.cdr.detectChanges();
    }
    /**
     * @hidden @internal
     */
    isAddButtonVisible() {
        // This should always return a boolean value. If this.searchValue was '', it returns '' instead of false;
        return this.searchValue !== '' && this.customValueFlag;
    }
    /**
     * @hidden @internal
     */
    handleSelectAll(evt) {
        if (evt.checked) {
            this.selectAllItems();
        }
        else {
            this.deselectAllItems();
        }
    }
    /**
     * @hidden @internal
     */
    addItemToCollection() {
        if (!this.searchValue) {
            return;
        }
        const newValue = this.searchValue.trim();
        const addedItem = this.displayKey ? {
            [this.valueKey]: newValue,
            [this.displayKey]: newValue
        } : newValue;
        if (this.groupKey) {
            Object.assign(addedItem, { [this.groupKey]: this.defaultFallbackGroup });
        }
        const oldCollection = this.data;
        const newCollection = [...this.data];
        newCollection.push(addedItem);
        const args = {
            oldCollection, addedItem, newCollection, owner: this
        };
        this.onAddition.emit(args);
        this.data.push(addedItem);
        // If you mutate the array, no pipe is invoked and the display isn't updated;
        // if you replace the array, the pipe executes and the display is updated.
        this.data = cloneArray(this.data);
        this.selectItems(this.comboAPI.valueKey !== null ? [addedItem[this.valueKey]] : [addedItem], false);
        this.customValueFlag = false;
        this.searchInput.nativeElement.focus();
        this.dropdown.focusedItem = null;
        this.virtDir.scrollTo(0);
    }
    /**
     * @hidden @internal
     */
    focusSearchInput(opening) {
        if (this.displaySearchInput && this.searchInput) {
            this.searchInput.nativeElement.focus();
        }
        else {
            if (opening) {
                this.dropdownContainer.nativeElement.focus();
            }
            else {
                this.comboInput.nativeElement.focus();
                this.toggle();
            }
        }
    }
    manageRequiredAsterisk() {
        if (this.ngControl && this.ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            const error = this.ngControl.control.validator({});
            this.inputGroup.isRequired = error && error.required;
        }
    }
    /**
     * @hidden @internal
     */
    onBlur() {
        if (this.collapsed) {
            this._onTouchedCallback();
            if (this.ngControl && !this.ngControl.valid) {
                this.valid = IgxComboState.INVALID;
            }
            else {
                this.valid = IgxComboState.INITIAL;
            }
        }
    }
    /**
     * @hidden @internal
     */
    ngOnInit() {
        this.ngControl = this._injector.get(NgControl, null);
        const targetElement = this.elementRef.nativeElement;
        this._overlaySettings = {
            target: targetElement,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy(),
            modal: false,
            closeOnOutsideClick: true,
            excludeFromOutsideClick: [targetElement]
        };
        this.selection.set(this.id, new Set());
        this._iconService.addSvgIconFromText(caseSensitive.name, caseSensitive.value, 'imx-icons');
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        this.filteredData = [...this.data];
        if (this.ngControl) {
            this.ngControl.statusChanges.pipe(takeUntil(this.destroy$)).subscribe(this.onStatusChanged);
            this.manageRequiredAsterisk();
            this.cdr.detectChanges();
        }
        this.virtDir.onChunkPreload.pipe(takeUntil(this.destroy$)).subscribe((e) => {
            const eventArgs = Object.assign({}, e, { owner: this });
            this.onDataPreLoad.emit(eventArgs);
        });
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.comboAPI.clear();
        this.selection.clear(this.id);
    }
    /**
     * @hidden @internal
     */
    writeValue(value) {
        const selection = Array.isArray(value) ? value : [];
        const oldSelection = this.selectedItems();
        this.selection.select_items(this.id, selection, true);
        this._value = this.createDisplayText(this.selectedItems(), oldSelection);
    }
    /**
     * @hidden @internal
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden @internal
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden @internal
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    getEditElement() {
        return this.comboInput.nativeElement;
    }
    /**
     * @hidden @internal
     */
    get template() {
        this._dataType = this.dataType;
        if (this.itemTemplate) {
            return this.itemTemplate;
        }
        if (this._dataType === DataTypes.COMPLEX) {
            return this.complexTemplate;
        }
        return this.primitiveTemplate;
    }
    /**
     * @hidden @internal
     */
    get context() {
        return {
            $implicit: this
        };
    }
    /**
     * @hidden @internal
     */
    handleClearItems(event) {
        if (this.disabled) {
            return;
        }
        this.deselectAllItems(true, event);
        if (this.collapsed) {
            this.getEditElement().focus();
        }
        else {
            this.focusSearchInput(true);
        }
        event.stopPropagation();
    }
    /**
     * A method that opens/closes the combo.
     *
     * ```html
     * <button (click)="combo.toggle()">Toggle Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     */
    toggle() {
        const overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
        this.dropdown.toggle(overlaySettings);
    }
    /**
     * A method that opens the combo.
     *
     * ```html
     * <button (click)="combo.open()">Open Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     */
    open() {
        const overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
        this.dropdown.open(overlaySettings);
    }
    /**
     * A method that closes the combo.
     *
     * ```html
     * <button (click)="combo.close()">Close Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     */
    close() {
        this.dropdown.close();
    }
    /**
     * Gets drop down state.
     *
     * ```typescript
     * let state = this.combo.collapsed;
     * ```
     */
    get collapsed() {
        return this.dropdown.collapsed;
    }
    /**
     * Get current selection state
     * @returns Array of selected items
     * ```typescript
     * let selectedItems = this.combo.selectedItems();
     * ```
     */
    selectedItems() {
        const items = Array.from(this.selection.get(this.id));
        return items;
    }
    /**
     * Select defined items
     * @param newItems new items to be selected
     * @param clearCurrentSelection if true clear previous selected items
     * ```typescript
     * this.combo.selectItems(["New York", "New Jersey"]);
     * ```
     */
    selectItems(newItems, clearCurrentSelection, event) {
        if (newItems) {
            const newSelection = this.selection.add_items(this.id, newItems, clearCurrentSelection);
            this.setSelection(newSelection, event);
        }
    }
    /**
     * Deselect defined items
     * @param items items to deselected
     * ```typescript
     * this.combo.deselectItems(["New York", "New Jersey"]);
     * ```
     */
    deselectItems(items, event) {
        if (items) {
            const newSelection = this.selection.delete_items(this.id, items);
            this.setSelection(newSelection, event);
        }
    }
    /**
     * Select all (filtered) items
     * @param ignoreFilter if set to true, selects all items, otherwise selects only the filtered ones.
     * ```typescript
     * this.combo.selectAllItems();
     * ```
     */
    selectAllItems(ignoreFilter, event) {
        const allVisible = this.selection.get_all_ids(ignoreFilter ? this.data : this.filteredData, this.valueKey);
        const newSelection = this.selection.add_items(this.id, allVisible);
        this.setSelection(newSelection, event);
    }
    /**
     * Deselect all (filtered) items
     * @param ignoreFilter if set to true, deselects all items, otherwise deselects only the filtered ones.
     * ```typescript
     * this.combo.deselectAllItems();
     * ```
     */
    deselectAllItems(ignoreFilter, event) {
        let newSelection = this.selection.get_empty();
        if (this.filteredData.length !== this.data.length && !ignoreFilter) {
            newSelection = this.selection.delete_items(this.id, this.selection.get_all_ids(this.filteredData, this.valueKey));
        }
        this.setSelection(newSelection, event);
    }
    /**
     * Selects/Deselects a single item
     * @param itemID the itemID of the specific item
     * @param select If the item should be selected (true) or deselected (false)
     *
     * Without specified valueKey;
     * ```typescript
     * this.combo.valueKey = null;
     * const items: { field: string, region: string}[] = data;
     * this.combo.setSelectedItem(items[0], true);
     * ```
     * With specified valueKey;
     * ```typescript
     * this.combo.valueKey = 'field';
     * const items: { field: string, region: string}[] = data;
     * this.combo.setSelectedItem('Connecticut', true);
     * ```
     */
    setSelectedItem(itemID, select = true, event) {
        if (itemID === null || itemID === undefined) {
            return;
        }
        if (select) {
            this.selectItems([itemID], false, event);
        }
        else {
            this.deselectItems([itemID], event);
        }
    }
    setSelection(newSelection, event) {
        const removed = diffInSets(this.selection.get(this.id), newSelection);
        const added = diffInSets(newSelection, this.selection.get(this.id));
        const newSelectionAsArray = Array.from(newSelection);
        const oldSelectionAsArray = Array.from(this.selection.get(this.id) || []);
        const displayText = this.createDisplayText(newSelectionAsArray, oldSelectionAsArray);
        const args = {
            newSelection: newSelectionAsArray,
            oldSelection: oldSelectionAsArray,
            added,
            removed,
            event,
            owner: this,
            displayText,
            cancel: false
        };
        this.onSelectionChange.emit(args);
        if (!args.cancel) {
            this.selection.select_items(this.id, args.newSelection, true);
            if (displayText !== args.displayText) {
                this._value = args.displayText;
            }
            else {
                this._value = this.createDisplayText(args.newSelection, args.oldSelection);
            }
            this._onChangeCallback(args.newSelection);
        }
    }
    /** Returns a string that should be populated in the combo's text box */
    concatDisplayText(selection) {
        const value = this.displayKey !== null && this.displayKey !== undefined ?
            this.convertKeysToItems(selection).map(entry => entry[this.displayKey]).join(', ') :
            selection.join(', ');
        return value;
    }
    /**
     * Constructs the combo display value
     * If remote, caches the key displayText
     * If not, just combine the object.displayKeys
     */
    createDisplayText(newSelection, oldSelection) {
        let value = '';
        if (this.isRemote) {
            if (newSelection.length) {
                const removedItems = oldSelection.filter(e => newSelection.indexOf(e) < 0);
                const addedItems = newSelection.filter(e => oldSelection.indexOf(e) < 0);
                this.registerRemoteEntries(addedItems);
                this.registerRemoteEntries(removedItems, false);
                value = Object.keys(this._remoteSelection).map(e => this._remoteSelection[e]).join(', ');
            }
            else {
                // If new selection is empty, clear all items
                this.registerRemoteEntries(oldSelection, false);
            }
        }
        else {
            value = this.concatDisplayText(newSelection);
        }
        return value;
    }
    /** if there is a valueKey - map the keys to data items, else - just return the keys */
    convertKeysToItems(keys) {
        if (this.comboAPI.valueKey === null) {
            return keys;
        }
        // map keys vs. filter data to retain the order of the selected items
        return keys.map(key => this.data.find(entry => entry[this.valueKey] === key)).filter(e => e !== undefined);
    }
    /**
     * Event handlers
     * @hidden
     * @internal
     */
    handleOpening(event) {
        const eventArgs = Object.assign({}, event, { owner: this });
        this.onOpening.emit(eventArgs);
        event.cancel = eventArgs.cancel;
    }
    /**
     * @hidden @internal
     */
    handleOpened() {
        this.triggerCheck();
        // Disabling focus of the search input should happen only when drop down opens.
        // During keyboard navigation input should receive focus, even the autoFocusSearch is disabled.
        // That is why in such cases focusing of the dropdownContainer happens outside focusSearchInput method.
        if (this.autoFocusSearch) {
            this.focusSearchInput(true);
        }
        else {
            this.dropdownContainer.nativeElement.focus();
        }
        this.onOpened.emit();
    }
    /**
     * @hidden @internal
     */
    handleClosing(event) {
        const eventArgs = Object.assign({}, event, { owner: this });
        this.onClosing.emit(eventArgs);
        event.cancel = eventArgs.cancel;
        if (event.cancel) {
            return;
        }
        this.searchValue = '';
        this.comboInput.nativeElement.focus();
    }
    /**
     * @hidden @internal
     */
    handleClosed() {
        this.onClosed.emit();
    }
    /**
     * @hidden @internal
     */
    toggleCaseSensitive() {
        this.filteringOptions = { caseSensitive: !this.filteringOptions.caseSensitive };
    }
}
IgxComboComponent.ɵfac = function IgxComboComponent_Factory(t) { return new (t || IgxComboComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxSelectionAPIService), ɵngcc0.ɵɵdirectiveInject(IgxComboAPIService), ɵngcc0.ɵɵdirectiveInject(IgxIconService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(IGX_INPUT_GROUP_TYPE, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector, 8)); };
IgxComboComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxComboComponent, selectors: [["igx-combo"]], contentQueries: function IgxComboComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboItemDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboHeaderDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboFooterDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboHeaderItemDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboAddItemDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboEmptyDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboToggleIconDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboClearIconDirective, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerItemTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.addItemTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.emptyTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleIconTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.clearIconTemplate = _t.first);
    } }, viewQuery: function IgxComboComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c57, true);
        ɵngcc0.ɵɵstaticViewQuery(_c58, true);
        ɵngcc0.ɵɵstaticViewQuery(IgxForOfDirective, true, IgxForOfDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c59, true, IgxInputGroupComponent);
        ɵngcc0.ɵɵstaticViewQuery(_c60, true, IgxInputDirective);
        ɵngcc0.ɵɵstaticViewQuery(IgxComboDropDownComponent, true, IgxComboDropDownComponent);
        ɵngcc0.ɵɵstaticViewQuery(_c61, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c62, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(IgxForOfDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdownContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.comboInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdown = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.primitiveTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.complexTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtualScrollContainer = _t.first);
    } }, hostVars: 10, hostBindings: function IgxComboComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.ArrowDown", function IgxComboComponent_keydown_ArrowDown_HostBindingHandler($event) { return ctx.onArrowDown($event); })("keydown.Alt.ArrowDown", function IgxComboComponent_keydown_Alt_ArrowDown_HostBindingHandler($event) { return ctx.onArrowDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role)("aria-expanded", ctx.ariaExpanded)("aria-haspopup", ctx.hasPopUp)("aria-owns", ctx.ariaOwns)("aria-labelledby", ctx.ariaLabelledBy);
        ɵngcc0.ɵɵstyleProp("width", ctx.width);
        ɵngcc0.ɵɵclassProp("igx-combo", ctx.cssClass);
    } }, inputs: { overlaySettings: "overlaySettings", id: "id", allowCustomValues: "allowCustomValues", searchPlaceholder: "searchPlaceholder", showSearchCaseIcon: "showSearchCaseIcon", valueKey: "valueKey", filterable: "filterable", disabled: "disabled", autoFocusSearch: "autoFocusSearch", itemsMaxHeight: "itemsMaxHeight", itemHeight: "itemHeight", data: "data", displayKey: "displayKey", groupKey: "groupKey", type: "type", width: "width", itemsWidth: "itemsWidth", placeholder: "placeholder", ariaLabelledBy: "ariaLabelledBy" }, outputs: { onSelectionChange: "onSelectionChange", onOpening: "onOpening", onOpened: "onOpened", onClosing: "onClosing", onClosed: "onClosed", onAddition: "onAddition", onSearchInput: "onSearchInput", onDataPreLoad: "onDataPreLoad" }, features: [ɵngcc0.ɵɵProvidersFeature([
            IgxComboAPIService,
            { provide: IGX_COMBO_COMPONENT, useExisting: IgxComboComponent },
            { provide: NG_VALUE_ACCESSOR, useExisting: IgxComboComponent, multi: true }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c67, decls: 37, vars: 41, consts: [[3, "displayDensity", "type", "click"], ["inputGroup", ""], ["ngProjectAs", "[igxLabel]", 5, ["", "igxLabel", ""]], ["ngProjectAs", "igx-prefix", 5, ["igx-prefix"]], ["ngProjectAs", "igx-hint, [igxHint]", 5, ["igx-hint"]], ["igxInput", "", "name", "comboInput", "type", "text", "readonly", "", 3, "value", "disabled", "blur"], ["comboInput", ""], ["ngProjectAs", "igx-suffix", 5, ["igx-suffix"]], ["aria-label", "Clear Selection", "class", "igx-combo__clear-button", 3, "click", 4, "ngIf"], [1, "igx-combo__toggle-button"], [4, "ngIf"], ["fontSet", "material", 4, "ngIf"], [1, "igx-combo__drop-down", 3, "displayDensity", "width", "onOpening", "onClosing", "onOpened", "onClosed"], ["igxComboDropDown", ""], ["class", "igx-combo__search", 3, "displayDensity", 4, "ngIf"], [4, "ngTemplateOutlet"], ["role", "listbox", 1, "igx-combo__content", 3, "igxDropDownItemNavigation", "tabindex", "focus"], ["dropdownItemContainer", ""], ["role", "option", 3, "itemHeight", "value", "isHeader", "index", 4, "igxFor", "igxForOf", "igxForContainerSize", "igxForScrollOrientation", "igxForItemSize"], ["class", "igx-combo__add", 4, "ngIf"], ["complex", ""], ["primitive", ""], ["empty", ""], ["addItemDefault", ""], ["headerItemBase", ""], ["aria-label", "Clear Selection", 1, "igx-combo__clear-button", 3, "click"], ["fontSet", "material"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-combo__search", 3, "displayDensity"], ["igxInput", "", "name", "searchInput", "autocomplete", "off", "type", "text", "aria-autocomplete", "both", 1, "igx-combo-input", 3, "ngModel", "ngModelChange", "keyup", "keydown", "focus"], ["searchInput", ""], ["fontSet", "imx-icons", "name", "case-sensitive", 3, "isActive", "click"], ["role", "option", 3, "itemHeight", "value", "isHeader", "index"], ["listItem", ""], [1, "igx-combo__add"], ["class", "igx-combo__empty", 4, "ngIf"], ["class", "igx-combo__add-item", "role", "button", "aria-label", "Add Item", 3, "itemHeight", "tabindex", "index", 4, "ngIf"], [1, "igx-combo__empty"], ["role", "button", "aria-label", "Add Item", 1, "igx-combo__add-item", 3, "itemHeight", "tabindex", "index"], ["igxButton", "flat", "igxRipple", ""]], template: function IgxComboComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c65);
        ɵngcc0.ɵɵelementStart(0, "igx-input-group", 0, 1);
        ɵngcc0.ɵɵlistener("click", function IgxComboComponent_Template_igx_input_group_click_0_listener($event) { return ctx.onInputClick($event); });
        ɵngcc0.ɵɵelementContainerStart(2, 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementContainerStart(4, 3);
        ɵngcc0.ɵɵprojection(5, 1);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementContainerStart(6, 4);
        ɵngcc0.ɵɵprojection(7, 2);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(8, "input", 5, 6);
        ɵngcc0.ɵɵlistener("blur", function IgxComboComponent_Template_input_blur_8_listener() { return ctx.onBlur(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerStart(10, 7);
        ɵngcc0.ɵɵprojection(11, 3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵtemplate(12, IgxComboComponent_igx_suffix_12_Template, 3, 2, "igx-suffix", 8);
        ɵngcc0.ɵɵelementStart(13, "igx-suffix", 9);
        ɵngcc0.ɵɵtemplate(14, IgxComboComponent_ng_container_14_Template, 2, 4, "ng-container", 10);
        ɵngcc0.ɵɵtemplate(15, IgxComboComponent_igx_icon_15_Template, 2, 1, "igx-icon", 11);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(16, "igx-combo-drop-down", 12, 13);
        ɵngcc0.ɵɵlistener("onOpening", function IgxComboComponent_Template_igx_combo_drop_down_onOpening_16_listener($event) { return ctx.handleOpening($event); })("onClosing", function IgxComboComponent_Template_igx_combo_drop_down_onClosing_16_listener($event) { return ctx.handleClosing($event); })("onOpened", function IgxComboComponent_Template_igx_combo_drop_down_onOpened_16_listener() { return ctx.handleOpened(); })("onClosed", function IgxComboComponent_Template_igx_combo_drop_down_onClosed_16_listener() { return ctx.handleClosed(); });
        ɵngcc0.ɵɵtemplate(18, IgxComboComponent_igx_input_group_18_Template, 4, 6, "igx-input-group", 14);
        ɵngcc0.ɵɵtemplate(19, IgxComboComponent_ng_container_19_Template, 1, 0, "ng-container", 15);
        ɵngcc0.ɵɵelementStart(20, "div", 16, 17);
        ɵngcc0.ɵɵlistener("focus", function IgxComboComponent_Template_div_focus_20_listener() { return ctx.dropdown.onFocus(); });
        ɵngcc0.ɵɵtemplate(22, IgxComboComponent_igx_combo_item_22_Template, 3, 6, "igx-combo-item", 18);
        ɵngcc0.ɵɵpipe(23, "comboGrouping");
        ɵngcc0.ɵɵpipe(24, "comboFiltering");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(25, IgxComboComponent_div_25_Template, 3, 2, "div", 19);
        ɵngcc0.ɵɵtemplate(26, IgxComboComponent_ng_container_26_Template, 1, 0, "ng-container", 15);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(27, IgxComboComponent_ng_template_27_Template, 1, 1, "ng-template", null, 20, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(29, IgxComboComponent_ng_template_29_Template, 1, 1, "ng-template", null, 21, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(31, IgxComboComponent_ng_template_31_Template, 2, 0, "ng-template", null, 22, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(33, IgxComboComponent_ng_template_33_Template, 2, 0, "ng-template", null, 23, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(35, IgxComboComponent_ng_template_35_Template, 1, 1, "ng-template", null, 24, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity)("type", ctx.type);
        ɵngcc0.ɵɵadvance(8);
        ɵngcc0.ɵɵproperty("value", ctx.value)("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("placeholder", ctx.placeholder);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.value.length);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.toggleIconTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.toggleIconTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity)("width", ctx.itemsWidth || "100%");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.displaySearchInput);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.headerTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("overflow", "hidden")("max-height", ctx.itemsMaxHeight, "px");
        ɵngcc0.ɵɵproperty("igxDropDownItemNavigation", ctx.dropdown)("tabindex", ctx.dropdown.collapsed ? -1 : 0);
        ɵngcc0.ɵɵattribute("id", ctx.dropdown.id);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("igxForOf", ɵngcc0.ɵɵpipeBind3(23, 25, ɵngcc0.ɵɵpipeBindV(24, 29, ɵngcc0.ɵɵpureFunction5(35, _c66, ctx.data, ctx.filterValue, ctx.displayKey, ctx.filterable, ctx.filteringOptions)), ctx.groupKey, ctx.valueKey))("igxForContainerSize", ctx.itemsMaxHeight)("igxForScrollOrientation", "vertical")("igxForItemSize", ctx.itemHeight);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.filteredData.length === 0 || ctx.isAddButtonVisible());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.footerTemplate);
    } }, directives: [IgxInputGroupComponent, IgxInputDirective, ɵngcc2.NgIf, IgxSuffixDirective, IgxComboDropDownComponent, ɵngcc2.NgTemplateOutlet, IgxDropDownItemNavigationDirective, IgxForOfDirective, IgxIconComponent, ɵngcc3.DefaultValueAccessor, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxComboItemComponent, IgxComboAddItemComponent, IgxButtonDirective, IgxRippleDirective], pipes: [IgxComboGroupingPipe, IgxComboFilteringPipe], encapsulation: 2 });
IgxComboComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxSelectionAPIService },
    { type: IgxComboAPIService },
    { type: IgxIconService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [IGX_INPUT_GROUP_TYPE,] }] },
    { type: Injector, decorators: [{ type: Optional }] }
];
IgxComboComponent.propDecorators = {
    virtDir: [{ type: ViewChild, args: [IgxForOfDirective, { read: IgxForOfDirective, static: true },] }],
    overlaySettings: [{ type: Input }],
    inputGroup: [{ type: ViewChild, args: ['inputGroup', { read: IgxInputGroupComponent, static: true },] }],
    comboInput: [{ type: ViewChild, args: ['comboInput', { read: IgxInputDirective, static: true },] }],
    dropdown: [{ type: ViewChild, args: [IgxComboDropDownComponent, { read: IgxComboDropDownComponent, static: true },] }],
    searchInput: [{ type: ViewChild, args: ['searchInput',] }],
    itemTemplate: [{ type: ContentChild, args: [IgxComboItemDirective, { read: TemplateRef },] }],
    headerTemplate: [{ type: ContentChild, args: [IgxComboHeaderDirective, { read: TemplateRef },] }],
    footerTemplate: [{ type: ContentChild, args: [IgxComboFooterDirective, { read: TemplateRef },] }],
    headerItemTemplate: [{ type: ContentChild, args: [IgxComboHeaderItemDirective, { read: TemplateRef },] }],
    addItemTemplate: [{ type: ContentChild, args: [IgxComboAddItemDirective, { read: TemplateRef },] }],
    emptyTemplate: [{ type: ContentChild, args: [IgxComboEmptyDirective, { read: TemplateRef },] }],
    toggleIconTemplate: [{ type: ContentChild, args: [IgxComboToggleIconDirective, { read: TemplateRef },] }],
    clearIconTemplate: [{ type: ContentChild, args: [IgxComboClearIconDirective, { read: TemplateRef },] }],
    primitiveTemplate: [{ type: ViewChild, args: ['primitive', { read: TemplateRef, static: true },] }],
    complexTemplate: [{ type: ViewChild, args: ['complex', { read: TemplateRef, static: true },] }],
    virtualScrollContainer: [{ type: ViewChild, args: [IgxForOfDirective, { static: true },] }],
    dropdownContainer: [{ type: ViewChild, args: ['dropdownItemContainer', { static: true },] }],
    onSelectionChange: [{ type: Output }],
    onOpening: [{ type: Output }],
    onOpened: [{ type: Output }],
    onClosing: [{ type: Output }],
    onClosed: [{ type: Output }],
    onAddition: [{ type: Output }],
    onSearchInput: [{ type: Output }],
    onDataPreLoad: [{ type: Output }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    width: [{ type: HostBinding, args: ['style.width',] }, { type: Input }],
    cssClass: [{ type: HostBinding, args: ['class.igx-combo',] }],
    role: [{ type: HostBinding, args: [`attr.role`,] }],
    ariaExpanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
    hasPopUp: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
    ariaOwns: [{ type: HostBinding, args: ['attr.aria-owns',] }],
    allowCustomValues: [{ type: Input }],
    itemsMaxHeight: [{ type: Input }],
    itemsWidth: [{ type: Input }],
    itemHeight: [{ type: Input }],
    placeholder: [{ type: Input }],
    searchPlaceholder: [{ type: Input }],
    showSearchCaseIcon: [{ type: Input }],
    data: [{ type: Input }],
    valueKey: [{ type: Input }],
    displayKey: [{ type: Input }],
    groupKey: [{ type: Input }],
    filterable: [{ type: Input }],
    ariaLabelledBy: [{ type: Input }, { type: HostBinding, args: ['attr.aria-labelledby',] }],
    disabled: [{ type: Input }],
    type: [{ type: Input }],
    autoFocusSearch: [{ type: Input }],
    onArrowDown: [{ type: HostListener, args: ['keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['keydown.Alt.ArrowDown', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxComboModule {
}
IgxComboModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxComboModule });
IgxComboModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxComboModule_Factory(t) { return new (t || IgxComboModule)(); }, imports: [[IgxRippleModule, CommonModule, IgxInputGroupModule, FormsModule, ReactiveFormsModule,
            IgxForOfModule, IgxToggleModule, IgxCheckboxModule, IgxDropDownModule, IgxButtonModule, IgxIconModule]] });

/** @hidden */
const IGX_DATE_PICKER_COMPONENT = 'IgxDatePickerComponentToken';

/**
 * @hidden
 */
class DatePickerDisplayValuePipe {
    constructor(_datePicker) {
        this._datePicker = _datePicker;
    }
    transform(value, args) {
        if (value !== '') {
            if (value === DatePickerUtil.maskToPromptChars(this._datePicker.inputMask)) {
                return '';
            }
            this._datePicker.rawDateString = value;
            return DatePickerUtil.trimEmptyPlaceholders(value);
        }
        return '';
    }
}
DatePickerDisplayValuePipe.ɵfac = function DatePickerDisplayValuePipe_Factory(t) { return new (t || DatePickerDisplayValuePipe)(ɵngcc0.ɵɵdirectiveInject(IGX_DATE_PICKER_COMPONENT)); };
DatePickerDisplayValuePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "displayValue", type: DatePickerDisplayValuePipe, pure: true });
DatePickerDisplayValuePipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
];
/**
 * @hidden
 */
class DatePickerInputValuePipe {
    constructor(_datePicker) {
        this._datePicker = _datePicker;
    }
    transform(value, args) {
        /**
         * TODO(D.P.): This plugs into the mask, but constantly received display strings it can't handle at all
         * Those are almost immediately overridden by the pickers onFocus handling anyway; Refactor ASAP
         */
        if (this._datePicker.invalidDate !== '') {
            return this._datePicker.invalidDate;
        }
        else {
            if (this._datePicker.value === null || this._datePicker.value === undefined) {
                return DatePickerUtil.maskToPromptChars(this._datePicker.inputMask);
            }
            else {
                return this._datePicker._getEditorDate(this._datePicker.value);
                // return DatePickerUtil.addPromptCharsEditMode(this._datePicker.dateFormatParts, this._datePicker.value, value);
            }
        }
    }
}
DatePickerInputValuePipe.ɵfac = function DatePickerInputValuePipe_Factory(t) { return new (t || DatePickerInputValuePipe)(ɵngcc0.ɵɵdirectiveInject(IGX_DATE_PICKER_COMPONENT)); };
DatePickerInputValuePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "inputValue", type: DatePickerInputValuePipe, pure: true });
DatePickerInputValuePipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
];

/**
 * IgxDatePickerTemplateDirective can be used to re-template the date-picker input-group.
 *
 * @hidden
 */
class IgxDatePickerTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxDatePickerTemplateDirective.ɵfac = function IgxDatePickerTemplateDirective_Factory(t) { return new (t || IgxDatePickerTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxDatePickerTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDatePickerTemplateDirective, selectors: [["", "igxDatePickerTemplate", ""]] });
IgxDatePickerTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * IgxDatePickerActionsDirective can be used to re-template the dropdown/dialog action buttons.
 */
class IgxDatePickerActionsDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxDatePickerActionsDirective.ɵfac = function IgxDatePickerActionsDirective_Factory(t) { return new (t || IgxDatePickerActionsDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxDatePickerActionsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDatePickerActionsDirective, selectors: [["", "igxDatePickerActions", ""]] });
IgxDatePickerActionsDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * This enumeration is used to configure whether the date/time picker has an editable input with drop down
 * or is readonly - the date/time is selected only through a dialog.
 */
var InteractionMode;
(function (InteractionMode) {
    InteractionMode["DropDown"] = "dropdown";
    InteractionMode["Dialog"] = "dialog";
})(InteractionMode || (InteractionMode = {}));

/**
 * @hidden
 */
class IgxCalendarContainerComponent {
    constructor() {
        this.mode = InteractionMode.Dialog;
        this.vertical = false;
        this.onClose = new EventEmitter();
        this.onTodaySelection = new EventEmitter();
        this.styleClass = 'igx-date-picker';
    }
    get dropdownCSS() {
        return this.mode === InteractionMode.DropDown;
    }
    get verticalCSS() {
        return this.vertical && this.mode === InteractionMode.Dialog;
    }
    onEscape(event) {
        event.preventDefault();
        this.onClose.emit();
    }
    /**
     * Returns whether the date-picker is in readonly dialog mode.
     *
     * @hidden
     */
    get isReadonly() {
        return this.mode === InteractionMode.Dialog;
    }
    /**
     * Emits close event for the calendar.
     */
    closeCalendar() {
        this.onClose.emit();
    }
    /**
     * Emits today selection event for the calendar.
     */
    triggerTodaySelection() {
        this.onTodaySelection.emit();
    }
}
IgxCalendarContainerComponent.ɵfac = function IgxCalendarContainerComponent_Factory(t) { return new (t || IgxCalendarContainerComponent)(); };
IgxCalendarContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCalendarContainerComponent, selectors: [["igx-calendar-container"]], viewQuery: function IgxCalendarContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c68, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.calendar = _t.first);
    } }, hostVars: 6, hostBindings: function IgxCalendarContainerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.esc", function IgxCalendarContainerComponent_keydown_esc_HostBindingHandler($event) { return ctx.onEscape($event); })("keydown.alt.arrowup", function IgxCalendarContainerComponent_keydown_alt_arrowup_HostBindingHandler($event) { return ctx.onEscape($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-date-picker", ctx.styleClass)("igx-date-picker--dropdown", ctx.dropdownCSS)("igx-date-picker--vertical", ctx.verticalCSS);
    } }, inputs: { mode: "mode", vertical: "vertical", cancelButtonLabel: "cancelButtonLabel", todayButtonLabel: "todayButtonLabel", datePickerActions: "datePickerActions" }, outputs: { onClose: "onClose", onTodaySelection: "onTodaySelection" }, decls: 5, vars: 1, consts: [["defaultDatePickerActions", ""], ["calendar", ""], [4, "ngTemplateOutlet"], ["class", "igx-date-picker__buttons", 4, "ngIf"], [1, "igx-date-picker__buttons"], ["igxButton", "flat", "igxRipple", "", 3, "click", 4, "ngIf"], ["igxButton", "flat", "igxRipple", "", 3, "click"], ["closeButton", ""], ["todayButton", ""]], template: function IgxCalendarContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxCalendarContainerComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelement(2, "igx-calendar", null, 1);
        ɵngcc0.ɵɵtemplate(4, IgxCalendarContainerComponent_ng_container_4_Template, 1, 0, "ng-container", 2);
    } if (rf & 2) {
        const _r0 = ɵngcc0.ɵɵreference(1);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.datePickerActions ? ctx.datePickerActions.template : _r0);
    } }, directives: [IgxCalendarComponent, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxButtonDirective, IgxRippleDirective], styles: ["[_nghost-%COMP%] {display: block;}"] });
IgxCalendarContainerComponent.propDecorators = {
    calendar: [{ type: ViewChild, args: ['calendar', { static: true },] }],
    mode: [{ type: Input }],
    vertical: [{ type: Input }],
    cancelButtonLabel: [{ type: Input }],
    todayButtonLabel: [{ type: Input }],
    datePickerActions: [{ type: Input }],
    onClose: [{ type: Output }],
    onTodaySelection: [{ type: Output }],
    styleClass: [{ type: HostBinding, args: ['class.igx-date-picker',] }],
    dropdownCSS: [{ type: HostBinding, args: ['class.igx-date-picker--dropdown',] }],
    verticalCSS: [{ type: HostBinding, args: ['class.igx-date-picker--vertical',] }],
    onEscape: [{ type: HostListener, args: ['keydown.esc', ['$event'],] }, { type: HostListener, args: ['keydown.alt.arrowup', ['$event'],] }]
};

let NEXT_ID$k = 0;
/**
 * This enumeration is used to configure the date picker to operate with pre-defined format option used in Angular DatePipe.
 * 'https://angular.io/api/common/DatePipe'
 * 'shortDate': equivalent to 'M/d/yy' (6/15/15).
 * 'mediumDate': equivalent to 'MMM d, y' (Jun 15, 2015).
 * 'longDate': equivalent to 'MMMM d, y' (June 15, 2015).
 * 'fullDate': equivalent to 'EEEE, MMMM d, y' (Monday, June 15, 2015).
 */
const PredefinedFormatOptions = mkenum({
    ShortDate: 'shortDate',
    MediumDate: 'mediumDate',
    LongDate: 'longDate',
    FullDate: 'fullDate'
});
const noop$5 = () => { };
const ɵ0$6 = noop$5;
/**
 * Date Picker displays a popup calendar that lets users select a single date.
 * @igxModule IgxDatePickerModule
 * @igxTheme igx-calendar-theme, igx-icon-theme
 * @igxGroup Scheduling
 * @igxKeywords  datepicker, calendar, schedule, date
 * @example
 * ```html
 * <igx-date-picker [(ngModel)]="selectedDate"></igx-date-picker>
 * ```
 */
class IgxDatePickerComponent {
    constructor(_overlayService, element, _cdr, _moduleRef, _injector, _renderer) {
        this._overlayService = _overlayService;
        this.element = element;
        this._cdr = _cdr;
        this._moduleRef = _moduleRef;
        this._injector = _injector;
        this._renderer = _renderer;
        /**
         * Gets/Sets the `IgxDatePickerComponent` label.
         * @remarks
         * The default label is 'Date'.
         * @example
         * ```html
         * <igx-date-picker [label]="Calendar"></igx-date-picker>
         * ```
         * @deprecated Use igxLabel inside the date picker to change the label:
         * ````html
         * <igx-date-picker>
         *      <label igxLabel>Custom label</label>
         * </igx-date-picker>
         * ````
         * to set a custom label.
         */
        this.label = 'Date';
        /**
         * Gets/Sets the `IgxDatePickerComponent` label visibility.
         * @remarks
         * By default the visibility is set to true.
         * @example
         * <igx-date-picker [labelVisibility]="false"></igx-date-picker>
         */
        this.labelVisibility = true;
        /**
         * Gets/Sets on which day the week starts.
         * @example
         * ```html
         * <igx-date-picker [weekStart]="WEEKDAYS.FRIDAY" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.weekStart = WEEKDAYS.SUNDAY;
        /**
         * Gets/Sets the number of month views displayed.
         * @remarks
         * Default value is `1`.
         * @example
         * ```html
         * <igx-date-picker [monthsViewNumber]="2"></igx-date-picker>
         * ```
         * @example
         * ```typescript
         * let monthViewsDisplayed = this.datePicker.monthsViewNumber;
         * ```
         */
        this.monthsViewNumber = 1;
        /**
         * Gets/Sets the value of `id` attribute.
         * @remarks If not provided it will be automatically generated.
         * @example
         * ```html
         * <igx-date-picker [id]="'igx-date-picker-3'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.id = `igx-date-picker-${NEXT_ID$k++}`;
        /**
         * Gets/Sets the orientation of the `IgxDatePickerComponent` header.
         *  @example
         * ```html
         * <igx-date-picker [vertical]="'true'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.vertical = false;
        /**
         * Gets/Sets the interaction mode - dialog or drop down.
         *  @example
         * ```html
         * <igx-date-picker mode="dropdown"></igx-date-picker>
         * ```
         */
        this.mode = InteractionMode.Dialog;
        /**
         * Gets/Sets whether date should spin continuously or stop when min/max is reached.
         *  @example
         * ```html
         * <igx-date-picker [isSpinLoop]="false"></igx-date-picker>
         * ```
         */
        this.isSpinLoop = true;
        /**
         * Emitted when the `IgxDatePickerComponent` calendar is opened.
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted after the `IgxDatePickerComponent` is closed.
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted when the `IgxDatePickerComponent` is being closed.
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted when selection is made in the calendar.
         *  @example
         * ```html
         * <igx-date-picker (onSelection)="selection($event)"></igx-date-picker>
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         * Emitted when date picker value is changed.
         * @example
         * ```html
         * <igx-date-picker (valueChange)="valueChanged($event)" mode="dropdown"></igx-date-picker>
         * ```
         */
        this.valueChange = new EventEmitter();
        /**
         * Emitted when the user types/spins to a disabled date in the date-picker editor.
         *  @example
         * ```html
         * <igx-date-picker (onDisabledDate)="onDisabledDate($event)"></igx-date-picker>
         * ```
         */
        this.onDisabledDate = new EventEmitter();
        /**
         * Emitted when the user types/spins invalid date in the date-picker editor.
         *  @example
         * ```html
         * <igx-date-picker (onValidationFailed)="onValidationFailed($event)"></igx-date-picker>
         * ```
         */
        this.onValidationFailed = new EventEmitter();
        /** @hidden @internal */
        this.hasHeader = true;
        /** @hidden @internal */
        this.collapsed = true;
        /** @hidden @internal */
        this.displayValuePipe = new DatePickerDisplayValuePipe(this);
        /** @hidden @internal */
        this.inputValuePipe = new DatePickerInputValuePipe(this);
        /** @hidden @internal */
        this.dateFormatParts = [];
        /** @hidden @internal */
        this.isEmpty = true;
        /** @hidden @internal */
        this.invalidDate = '';
        this.spinDelta = 1;
        this.defaultLocale = 'en';
        this._formatOptions = {
            day: 'numeric',
            month: 'short',
            weekday: 'short',
            year: 'numeric'
        };
        this._formatViews = {
            day: false,
            month: true,
            year: false
        };
        this._destroy$ = new Subject();
        this._disabledDates = null;
        this._specialDates = null;
        this._onOpen = new EventEmitter();
        this._onClose = new EventEmitter();
        this._ngControl = null;
        //#region ControlValueAccessor
        this._onChangeCallback = noop$5;
        this._onTouchedCallback = noop$5;
        this._onValidatorChange = () => { };
    }
    /**
     * Gets the format options of the `IgxDatePickerComponent`.
     * @example
     * ```typescript
     * let formatOptions = this.datePicker.formatOptions;
     * ```
     */
    get formatOptions() {
        return this._formatOptions;
    }
    /**
     * Sets the format options of the `IgxDatePickerComponent`.
     * @example
     * ```typescript
     * this.datePicker.formatOptions = {  day: "numeric",  month: "long", weekday: "long", year: "numeric"};
     * ```
     */
    set formatOptions(formatOptions) {
        this._formatOptions = Object.assign(this._formatOptions, formatOptions);
    }
    /**
     * Gets/Sets the date display format of the `IgxDatePickerComponent` in dropdown mode.
     * @example
     * ```typescript
     * let format = this.datePicker.format;
     * this.datePicker.format = 'yyyy-M-d';
     * ```
     */
    get format() {
        return (this._format === undefined) ? PredefinedFormatOptions.ShortDate : this._format;
    }
    set format(format) {
        this._format = format;
    }
    /**
     * Gets/Sets the format views of the `IgxDatePickerComponent`.
     * @example
     * ```typescript
     * let formatViews = this.datePicker.formatViews;
     *  this.datePicker.formatViews = {day:false, month: false, year:false};
     * ```
     */
    get formatViews() {
        return this._formatViews;
    }
    set formatViews(formatViews) {
        this._formatViews = Object.assign(this._formatViews, formatViews);
    }
    /**
     * Gets/Sets the disabled dates descriptors.
     * @example
     * ```typescript
     * let disabledDates = this.datepicker.disabledDates;
     * this.datePicker.disabledDates = [ {type: DateRangeType.Weekends}, ...];
     * ```
     */
    get disabledDates() {
        return this._disabledDates;
    }
    set disabledDates(value) {
        this._disabledDates = value;
        this._onValidatorChange();
    }
    /**
     * Gets/Sets the special dates descriptors.
     * @example
     * ```typescript
     * let specialDates = this.datepicker.specialDates;
     * this.datePicker.specialDates = [ {type: DateRangeType.Weekends}, ... ];
     * ```
     */
    get specialDates() {
        return this._specialDates;
    }
    set specialDates(value) {
        this._specialDates = value;
    }
    /**
     * Gets/Sets the modal overlay settings.
     */
    get modalOverlaySettings() {
        return this._modalOverlay;
    }
    set modalOverlaySettings(value) {
        this._modalOverlay = value;
    }
    /**
     * Gets/Sets the drop-down overlay settings.
     */
    get dropDownOverlaySettings() {
        return this._dropDownOverlaySettings || this._defaultDropDownOverlaySettings;
    }
    set dropDownOverlaySettings(value) {
        this._dropDownOverlaySettings = value;
    }
    /**
     * Gets the formatted date when `IgxDatePickerComponent` is in dialog mode.
     *  @example
     * ```typescript
     * let selectedDate = this.datePicker.displayData;
     * ```
     */
    get displayData() {
        if (this.value) {
            return this._customFormatChecker(this.formatter, this.value);
        }
        return '';
    }
    /** @hidden @internal */
    get transformedDate() {
        if (this._value) {
            this._transformedDate = (this._isInEditMode) ? this._getEditorDate(this._value) : this._getDisplayDate(this._value);
            this.isEmpty = false;
        }
        else {
            this._transformedDate = (this._isInEditMode) ? DatePickerUtil.maskToPromptChars(this.inputMask) : '';
        }
        return this._transformedDate;
    }
    /** @hidden @internal */
    set transformedDate(value) {
        this._transformedDate = value;
    }
    /**
     * Gets the input group template.
     * @example
     * ```typescript
     * let template = this.template();
     * ```
     */
    get template() {
        if (this.datePickerTemplateDirective) {
            return this.datePickerTemplateDirective.template;
        }
        return (this.mode === InteractionMode.Dialog) ? this.readOnlyDatePickerTemplate : this.editableDatePickerTemplate;
    }
    /**
     * Gets the context passed to the input group template.
     */
    get context() {
        return {
            disabled: this.disabled,
            disabledDates: this.disabledDates,
            displayData: this.displayData,
            format: this.format,
            isSpinLoop: this.isSpinLoop,
            label: this.label,
            labelVisibility: this.labelVisibility,
            locale: this.locale,
            mask: this.mask,
            mode: this.mode,
            specialDates: this.specialDates,
            value: this.value,
            openDialog: () => this.openDialog()
        };
    }
    get required() {
        if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            const error = this._ngControl.control.validator({});
            return error && error.required;
        }
        return false;
    }
    /**
     * Gets/Sets the selected date.
     *  @example
     * ```html
     * <igx-date-picker [value]="date"></igx-date-picker>
     * ```
     */
    get value() {
        return this._value;
    }
    set value(date) {
        this._value = date;
        this._onChangeCallback(date);
    }
    /** @hidden @internal */
    writeValue(value) {
        this._value = value;
        // TODO: do we need next call
        this._cdr.markForCheck();
    }
    /** @hidden @internal */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /** @hidden @internal */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
    /** @hidden @internal */
    setDisabledState(isDisabled) { this.disabled = isDisabled; }
    /** @hidden @internal */
    registerOnValidatorChange(fn) {
        this._onValidatorChange = fn;
    }
    /** @hidden @internal */
    validate() {
        if (!!this.value && this.disabledDates && isDateInRanges(this.value, this.disabledDates)) {
            return { dateIsDisabled: true };
        }
        return null;
    }
    //#endregion
    /**
     * @hidden
     */
    onSpaceClick(event) {
        this.openDialog();
        event.preventDefault();
    }
    /** @hidden */
    getEditElement() {
        const inputDirectiveElementRef = this._inputElementRef || this._inputUserTemplateElementRef;
        return (inputDirectiveElementRef) ? inputDirectiveElementRef.nativeElement : null;
    }
    /** @hidden @internal */
    get inputGroupElement() {
        var _a;
        return (_a = this.inputGroup) === null || _a === void 0 ? void 0 : _a.element.nativeElement;
    }
    /** @hidden @internal */
    get inputGroup() {
        return this._inputGroup || this._inputGroupUserTemplate || null;
    }
    /** @hidden @internal */
    get inputDirective() {
        return this._inputDirective || this._inputDirectiveUserTemplates.first || null;
    }
    /** @hidden @internal */
    get labelDirective() {
        return this._labelDirective || this._labelDirectiveUserTemplate || null;
    }
    /** @hidden @internal */
    ngOnInit() {
        this._positionSettings = {
            openAnimation: fadeIn,
            closeAnimation: fadeOut
        };
        this._defaultDropDownOverlaySettings = {
            target: this.inputGroupElement,
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy(this._positionSettings),
            outlet: this.outlet
        };
        this._modalOverlaySettings = {
            closeOnOutsideClick: true,
            modal: true,
            closeOnEscape: true,
            outlet: this.outlet
        };
        this._overlayService.onOpening.pipe(filter((overlay) => overlay.id === this._componentID), takeUntil(this._destroy$)).subscribe((eventArgs) => {
            this._onOpening(eventArgs);
        });
        this._overlayService.onOpened.pipe(filter((overlay) => overlay.id === this._componentID), takeUntil(this._destroy$)).subscribe(() => {
            this._onOpened();
        });
        this._overlayService.onClosed.pipe(filter(overlay => overlay.id === this._componentID), takeUntil(this._destroy$)).subscribe(() => {
            this._onClosed();
        });
        this._overlayService.onClosing.pipe(filter(overlay => overlay.id === this._componentID), takeUntil(this._destroy$)).subscribe((event) => {
            this.onClosing.emit(event);
            // If canceled in a user onClosing handler
            if (event.cancel) {
                return;
            }
            // Do not focus the input if clicking outside in dropdown mode
            const input = this.getEditElement();
            if (input && !(event.event && this.mode === InteractionMode.DropDown)) {
                input.focus();
            }
            else {
                // outside click
                this._updateValidityOnBlur();
            }
        });
        if (this.mode === InteractionMode.DropDown) {
            this.dateFormatParts = DatePickerUtil.parseDateFormat(this.mask, this.locale);
            if (this.mask === undefined) {
                this.mask = DatePickerUtil.getMask(this.dateFormatParts);
            }
            this.inputMask = DatePickerUtil.getInputMask(this.dateFormatParts);
        }
        this._ngControl = this._injector.get(NgControl, null);
    }
    /** @hidden @internal */
    ngAfterViewInit() {
        if (this.mode === InteractionMode.DropDown && this._inputElementRef) {
            fromEvent(this._inputElementRef.nativeElement, 'keydown').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy$)).subscribe((res) => this.onKeyDown(res));
        }
        if (this._ngControl) {
            this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
        }
        this._inputDirectiveUserTemplates.changes.subscribe(() => {
            this.attachTemplateBlur();
        });
        this.attachTemplateBlur();
    }
    attachTemplateBlur() {
        if (this._templateInputBlur$) {
            this._templateInputBlur$.unsubscribe();
        }
        if (this._inputDirectiveUserTemplates.first) {
            const directive = this._inputDirectiveUserTemplates.first;
            this._templateInputBlur$ = fromEvent(directive.nativeElement, 'blur').pipe(takeUntil(this._destroy$)).subscribe((res) => {
                this.rawDateString = res.target.value;
                this.onBlur(res, false);
            });
            // TODO: Refactor custom template handling.
            // Revise blur handling when custom template is passed
        }
    }
    ngAfterViewChecked() {
        // If one sets mode at run time this forces initialization of new igxInputGroup
        // As a result a new igxInputDirective is initialized too. In ngAfterViewInit of
        // the new directive isRequired of the igxInputGroup is set again. However
        // ngAfterViewInit of date picker is not called again and we may finish with wrong
        // isRequired in igxInputGroup. This is why we should set it her, only when needed
        if (this.inputGroup && this.inputGroup.isRequired !== this.required) {
            this.inputGroup.isRequired = this.required;
            this._cdr.detectChanges();
        }
        // TODO: persist validation state when dynamically changing 'dropdown' to 'dialog' ot vice versa.
        // For reference -> it is currently persisted if a user template is passed (as template is not recreated)
        if (this.labelDirective) {
            this._renderer.setAttribute(this.inputDirective.nativeElement, 'aria-labelledby', this.labelDirective.id);
        }
    }
    onStatusChanged() {
        if ((this._ngControl.control.touched || this._ngControl.control.dirty) &&
            (this.inputDirective && this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {
            if (this.inputGroup.isFocused) {
                this.inputDirective.valid = this._ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
            }
            else {
                this.inputDirective.valid = this._ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
            }
        }
        if (this.inputGroup && this.inputGroup.isRequired !== this.required) {
            this.inputGroup.isRequired = this.required;
        }
    }
    /** @hidden @internal */
    ngOnDestroy() {
        if (this._componentID) {
            this._overlayService.hide(this._componentID);
        }
        this._destroy$.next(true);
        this._destroy$.complete();
    }
    /**
     * Selects today's date from calendar.
     *  @remarks
     * Changes the input field value, @calendar.viewDate and @calendar.value.
     *  @example
     * ```typescript
     * this.datePicker.triggerTodaySelection();
     * ```
     */
    triggerTodaySelection() {
        const today = new Date(Date.now());
        this.handleSelection(today);
    }
    /**
     * Change the calendar selection.
     * @remarks
     * Calling this method will emit the @calendar.onSelection event,
     * which will fire @handleSelection method.
     * @example
     * ```typescript
     * this.datePicker.selectDate(this.date);
     * ```
     * @param date passed date that has to be set to the calendar.
     */
    selectDate(date) {
        const oldValue = this.value;
        this.value = date;
        this.emitValueChangeEvent(oldValue, this.value);
        this.onSelection.emit(date);
    }
    /**
     * Deselects the calendar date.
     * @example
     * ```typescript
     * this.datePicker.deselectDate();
     * ```
     */
    deselectDate() {
        const oldValue = this.value;
        this.value = null;
        this.emitValueChangeEvent(oldValue, this.value);
        if (this.calendar) {
            this.calendar.deselectDate();
        }
    }
    /**
     * Opens the date picker drop down or dialog.
     * @param target HTMLElement - the target element to use for positioning the drop down container according to
     * @example
     * ```typescript
     * this.datePicker.openDialog(target);
     * ```
     */
    openDialog() {
        if (!this.collapsed || this.disabled) {
            return;
        }
        switch (this.mode) {
            case InteractionMode.Dialog: {
                this.hasHeader = true;
                const modalOverlay = (this.modalOverlaySettings !== undefined) ? this._modalOverlay : this._modalOverlaySettings;
                this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, modalOverlay, this._moduleRef);
                this._overlayService.show(this._componentID);
                break;
            }
            case InteractionMode.DropDown: {
                this.hasHeader = false;
                const target = this.inputGroupElement;
                if (target) {
                    this.dropDownOverlaySettings.target = target;
                }
                this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, this.dropDownOverlaySettings, this._moduleRef);
                this._overlayService.show(this._componentID);
                break;
            }
        }
    }
    /**
     * Close the calendar.
     *
     * @hidden @internal
     */
    closeCalendar() {
        this._overlayService.hide(this._componentID);
    }
    /**
     * Clear the input field, date picker value and calendar selection.
     *
     * @hidden @internal
     */
    clear() {
        if (!this.disabled) {
            this.isEmpty = true;
            this.invalidDate = '';
            this.deselectDate();
            this._setCursorPosition(0);
        }
    }
    /**
     * Evaluates when @calendar.onSelection event was fired
     * and update the input value.
     *
     * @param event selected value from calendar.
     *
     * @hidden @internal
     */
    handleSelection(date) {
        if (this.value) {
            date.setHours(this.value.getHours());
            date.setMinutes(this.value.getMinutes());
            date.setSeconds(this.value.getSeconds());
            date.setMilliseconds(this.value.getMilliseconds());
        }
        const oldValue = this.value;
        this.value = date;
        this.emitValueChangeEvent(oldValue, this.value);
        this.calendar.viewDate = date;
        this.closeCalendar();
        this.onSelection.emit(date);
    }
    /** @hidden @internal */
    onOpenClick(event) {
        event.stopPropagation();
        this.openDialog();
    }
    /** @hidden @internal */
    onBlur(event, calcDate = true) {
        this._isInEditMode = false;
        if (this.mode === InteractionMode.DropDown && calcDate) {
            this.calculateDate(event.target.value, event.type);
        }
        if (this.collapsed) {
            this._updateValidityOnBlur();
        }
    }
    /** @hidden @internal */
    onFocus() {
        this._isInEditMode = true;
        if (this.value && this.invalidDate === '') {
            this._transformedDate = this._getEditorDate(this.value);
        }
    }
    /** @hidden @internal */
    onKeyDown(event) {
        switch (event.key) {
            case "ArrowUp" /* UP_ARROW */:
            case "Up" /* UP_ARROW_IE */:
                event.preventDefault();
                event.stopPropagation();
                this.spinValue(event.target.value, 1, event.type);
                break;
            case "ArrowDown" /* DOWN_ARROW */:
            case "Down" /* DOWN_ARROW_IE */:
                if (event.altKey) {
                    this.openDialog();
                }
                else {
                    event.preventDefault();
                    event.stopPropagation();
                    this.spinValue(event.target.value, -1, event.type);
                }
                break;
            default:
                break;
        }
    }
    /** @hidden @internal */
    onWheel(event) {
        if (this._isInEditMode) {
            event.preventDefault();
            event.stopPropagation();
            const sign = (event.deltaY > 0) ? -1 : 1;
            this.spinValue(event.target.value, sign, event.type);
        }
    }
    /** @hidden @internal */
    onInput(event) {
        /**
         * Fix for #8165 until refactoring (#6483).
         * The IgxDateTimeEditor will be used to handle all inputs, i.e. this handler will be removed.
         * It extends the IgxMaskDirective which contains logic that handles this issue.
         */
        if (isIE() && !this._isInEditMode && !this.inputGroup.isFocused) {
            return;
        }
        const targetValue = event.target.value;
        const cursorPosition = this._getCursorPosition();
        const checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, targetValue);
        this._isInEditMode = true;
        if (targetValue !== DatePickerUtil.maskToPromptChars(this.inputMask)) {
            this.isEmpty = false;
        }
        // If all date parts are completed, change the date-picker value, stay in edit mode
        if (checkInput === 'complete' && event.inputType !== 'deleteContentBackward') {
            this._transformedDate = targetValue;
            this.calculateDate(targetValue, event.type);
            this._setCursorPosition(cursorPosition);
        }
        else if (checkInput === 'partial') {
            // While editing, if one date part is deleted, date-picker value is set to null, the remaining input stays intact.
            this.deselectDate();
            requestAnimationFrame(() => {
                this.getEditElement().value = targetValue;
                this._setCursorPosition(cursorPosition);
            });
        }
        else if (checkInput === 'empty') {
            // Total clean-up as input is deleted.
            this.isEmpty = true;
            this.deselectDate();
        }
    }
    emitValueChangeEvent(oldValue, newValue) {
        if (!isEqual(oldValue, newValue)) {
            this.valueChange.emit(newValue);
        }
    }
    calculateDate(dateString, invokedByEvent) {
        if (dateString !== '') {
            const prevDateValue = this.value;
            const inputValue = (invokedByEvent === 'blur') ? this.rawDateString : dateString;
            const newDateArray = DatePickerUtil.parseDateArray(this.dateFormatParts, prevDateValue, inputValue);
            if (newDateArray.state === "valid" /* Valid */) {
                const newValue = newDateArray.date;
                // Restore the time part if any
                if (prevDateValue) {
                    newValue.setHours(prevDateValue.getHours());
                    newValue.setMinutes(prevDateValue.getMinutes());
                    newValue.setSeconds(prevDateValue.getSeconds());
                    newValue.setMilliseconds(prevDateValue.getMilliseconds());
                }
                if (this.disabledDates === null
                    || (this.disabledDates !== null && !isDateInRanges(newValue, this.disabledDates))) {
                    const oldValue = this.value;
                    this.value = newValue;
                    this.emitValueChangeEvent(oldValue, this.value);
                    this.invalidDate = '';
                }
                else {
                    const args = {
                        datePicker: this,
                        currentValue: newValue,
                    };
                    this.onDisabledDate.emit(args);
                }
            }
            else {
                const args = {
                    datePicker: this,
                    prevValue: prevDateValue
                };
                this.invalidDate = dateString;
                this.onValidationFailed.emit(args);
            }
        }
    }
    spinValue(inputValue, sign, eventType) {
        this._isInEditMode = true;
        this.isEmpty = false;
        const cursorPosition = this._getCursorPosition();
        const modifiedInputValue = DatePickerUtil.getModifiedDateInput(this.dateFormatParts, inputValue, cursorPosition, this.spinDelta * sign, this.isSpinLoop);
        this.getEditElement().value = modifiedInputValue;
        this._setCursorPosition(cursorPosition);
        const checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, modifiedInputValue);
        if (checkInput === 'complete') {
            this._isInEditMode = true;
            this.calculateDate(modifiedInputValue, eventType);
            this._setCursorPosition(cursorPosition);
        }
    }
    _onOpening(event) {
        this._initializeCalendarContainer(event.componentRef.instance);
        this.collapsed = false;
    }
    _onOpened() {
        this.onOpened.emit(this);
        if (this.calendar) {
            this._focusCalendarDate();
        }
    }
    _onClosed() {
        this.collapsed = true;
        this._componentID = null;
        this.onClosed.emit(this);
    }
    _initializeCalendarContainer(componentInstance) {
        this.calendar = componentInstance.calendar;
        const isVertical = (this.vertical && this.mode === InteractionMode.Dialog);
        this.calendar.hasHeader = this.hasHeader;
        this.calendar.formatOptions = this.formatOptions;
        this.calendar.formatViews = this.formatViews;
        this.calendar.locale = this.locale;
        this.calendar.vertical = isVertical;
        this.calendar.weekStart = this.weekStart;
        this.calendar.specialDates = this.specialDates;
        this.calendar.disabledDates = this.disabledDates;
        this.calendar.headerTemplate = this.headerTemplate;
        this.calendar.subheaderTemplate = this.subheaderTemplate;
        this.calendar.hideOutsideDays = this.hideOutsideDays;
        this.calendar.monthsViewNumber = this.monthsViewNumber;
        this.calendar.showWeekNumbers = this.showWeekNumbers;
        this.calendar.onSelection.pipe(takeUntil(this._destroy$)).subscribe((ev) => this.handleSelection(ev));
        if (this.value) {
            this.calendar.value = this.value;
            this.calendar.viewDate = this.value;
        }
        componentInstance.mode = this.mode;
        componentInstance.vertical = isVertical;
        componentInstance.cancelButtonLabel = this.cancelButtonLabel;
        componentInstance.todayButtonLabel = this.todayButtonLabel;
        componentInstance.datePickerActions = this.datePickerActionsDirective;
        componentInstance.onClose.pipe(takeUntil(this._destroy$)).subscribe(() => this.closeCalendar());
        componentInstance.onTodaySelection.pipe(takeUntil(this._destroy$)).subscribe(() => this.triggerTodaySelection());
    }
    // Focus a date, after the calendar appearance into DOM.
    _focusCalendarDate() {
        requestAnimationFrame(() => {
            this.calendar.daysView.focusActiveDate();
        });
    }
    _setLocaleToDate(value) {
        if (isIE()) {
            // this is a workaround fixing the following IE11 issue:
            // IE11 has added character code 8206 (mark for RTL) to the output of toLocaleDateString() that
            // precedes each portion that comprises the total date... For more information read this article:
            // tslint:disable-next-line: max-line-length
            // https://www.csgpro.com/blog/2016/08/a-bad-date-with-internet-explorer-11-trouble-with-new-unicode-characters-in-javascript-date-strings/
            const localeDateStrIE = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
            return localeDateStrIE.toLocaleDateString(this.locale);
        }
        return value.toLocaleDateString(this.locale);
    }
    _getCursorPosition() {
        return this.getEditElement().selectionStart;
    }
    _setCursorPosition(start, end = start) {
        requestAnimationFrame(() => {
            this.getEditElement().setSelectionRange(start, end);
        });
    }
    /**
     * Apply custom user formatter upon date.
     * @param formatter custom formatter function.
     * @param date passed date
     */
    _customFormatChecker(formatter, date) {
        return this.formatter ? this.formatter(date) : this._setLocaleToDate(date);
    }
    /*
    * Transforms the date according to the specified format when `IgxDatePickerComponent` is in edit mode
    * using @angular/common formatDate method: https://angular.io/api/common/formatDate
    * @param  value: string | number | Date
    * @returns formatted string
    */
    _getDisplayDate(value) {
        if (this.format && !this.formatter) {
            const locale = this.locale || this.defaultLocale;
            return formatDate(value, this.format, locale);
        }
        else {
            return this._customFormatChecker(this.formatter, value);
        }
    }
    _getEditorDate(value) {
        const locale = this.locale || this.defaultLocale;
        const changedValue = (value) ? formatDate(value, this.mask, locale) : '';
        return DatePickerUtil.addPromptCharsEditMode(this.dateFormatParts, this.value, changedValue);
    }
    _updateValidityOnBlur() {
        this._onTouchedCallback();
        const input = this.inputDirective;
        if (input && this._ngControl && !this._ngControl.valid) {
            input.valid = IgxInputState.INVALID;
        }
        else {
            input.valid = IgxInputState.INITIAL;
        }
    }
}
IgxDatePickerComponent.ɵfac = function IgxDatePickerComponent_Factory(t) { return new (t || IgxDatePickerComponent)(ɵngcc0.ɵɵdirectiveInject(IgxOverlayService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgModuleRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IgxDatePickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDatePickerComponent, selectors: [["igx-date-picker"]], contentQueries: function IgxDatePickerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxInputGroupComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxInputDirective, true, ElementRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxLabelDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDatePickerTemplateDirective, true, IgxDatePickerTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCalendarHeaderTemplateDirective, true, IgxCalendarHeaderTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCalendarSubheaderTemplateDirective, true, IgxCalendarSubheaderTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDatePickerActionsDirective, true, IgxDatePickerActionsDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxInputDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputGroupUserTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputUserTemplateElementRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._labelDirectiveUserTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.datePickerTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.subheaderTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.datePickerActionsDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputDirectiveUserTemplates = _t);
    } }, viewQuery: function IgxDatePickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c69, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c70, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(IgxInputGroupComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxInputDirective, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(IgxInputDirective, true);
        ɵngcc0.ɵɵviewQuery(IgxLabelDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.readOnlyDatePickerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editableDatePickerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputGroup = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElementRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._labelDirective = _t.first);
    } }, hostVars: 1, hostBindings: function IgxDatePickerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.spacebar", function IgxDatePickerComponent_keydown_spacebar_HostBindingHandler($event) { return ctx.onSpaceClick($event); })("keydown.space", function IgxDatePickerComponent_keydown_space_HostBindingHandler($event) { return ctx.onSpaceClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { label: "label", labelVisibility: "labelVisibility", weekStart: "weekStart", monthsViewNumber: "monthsViewNumber", id: "id", vertical: "vertical", mode: "mode", isSpinLoop: "isSpinLoop", formatOptions: "formatOptions", format: "format", formatViews: "formatViews", disabledDates: "disabledDates", specialDates: "specialDates", modalOverlaySettings: "modalOverlaySettings", dropDownOverlaySettings: "dropDownOverlaySettings", value: "value", disabled: "disabled", mask: "mask", locale: "locale", editorTabIndex: "editorTabIndex", hideOutsideDays: "hideOutsideDays", showWeekNumbers: "showWeekNumbers", formatter: "formatter", todayButtonLabel: "todayButtonLabel", cancelButtonLabel: "cancelButtonLabel", outlet: "outlet" }, outputs: { onOpened: "onOpened", onClosed: "onClosed", onClosing: "onClosing", onSelection: "onSelection", valueChange: "valueChange", onDisabledDate: "onDisabledDate", onValidationFailed: "onValidationFailed" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxDatePickerComponent,
                multi: true
            },
            {
                provide: NG_VALIDATORS,
                useExisting: IgxDatePickerComponent,
                multi: true
            }])], ngContentSelectors: _c72, decls: 7, vars: 2, consts: [["labelTemplate", ""], ["readOnlyDatePickerTemplate", ""], ["editableDatePickerTemplate", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "click"], ["ngProjectAs", "[igxLabel]", 5, ["", "igxLabel", ""], 4, "ngTemplateOutlet"], ["igxLabel", "", 4, "ngIf"], ["igxInput", "", "readonly", "", 1, "igx-date-picker__input-date", 3, "value", "disabled", "tabindex", "blur"], ["ngProjectAs", "[igxLabel]", 5, ["", "igxLabel", ""]], ["igxLabel", ""], ["editableInputGroup", ""], ["igxInput", "", "type", "text", 1, "igx-date-picker__input-date", 3, "value", "igxMask", "placeholder", "igxTextSelection", "disabled", "displayValuePipe", "focusedValuePipe", "tabindex", "blur", "wheel", "input", "focus"], [3, "click", 4, "ngIf"]], template: function IgxDatePickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c71);
        ɵngcc0.ɵɵtemplate(0, IgxDatePickerComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxDatePickerComponent_ng_template_2_Template, 7, 5, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxDatePickerComponent_ng_template_4_Template, 9, 11, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxDatePickerComponent_ng_container_6_Template, 1, 0, "ng-container", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
    } }, directives: [ɵngcc2.NgTemplateOutlet, IgxInputGroupComponent, IgxPrefixDirective, IgxIconComponent, ɵngcc2.NgIf, IgxInputDirective, IgxLabelDirective, IgxMaskDirective, IgxTextSelectionDirective, IgxSuffixDirective], styles: [_c80] });
IgxDatePickerComponent.ctorParameters = () => [
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgModuleRef },
    { type: Injector },
    { type: Renderer2 }
];
IgxDatePickerComponent.propDecorators = {
    label: [{ type: Input }],
    labelVisibility: [{ type: Input }],
    locale: [{ type: Input }],
    editorTabIndex: [{ type: Input }],
    weekStart: [{ type: Input }],
    formatOptions: [{ type: Input }],
    hideOutsideDays: [{ type: Input }],
    monthsViewNumber: [{ type: Input }],
    showWeekNumbers: [{ type: Input }],
    format: [{ type: Input }],
    mask: [{ type: Input }],
    formatViews: [{ type: Input }],
    disabledDates: [{ type: Input }],
    specialDates: [{ type: Input }],
    modalOverlaySettings: [{ type: Input }],
    dropDownOverlaySettings: [{ type: Input }],
    value: [{ type: Input }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    formatter: [{ type: Input }],
    disabled: [{ type: Input }],
    vertical: [{ type: Input }],
    todayButtonLabel: [{ type: Input }],
    cancelButtonLabel: [{ type: Input }],
    mode: [{ type: Input }],
    isSpinLoop: [{ type: Input }],
    outlet: [{ type: Input }],
    onOpened: [{ type: Output }],
    onClosed: [{ type: Output }],
    onClosing: [{ type: Output }],
    onSelection: [{ type: Output }],
    valueChange: [{ type: Output }],
    onDisabledDate: [{ type: Output }],
    onValidationFailed: [{ type: Output }],
    readOnlyDatePickerTemplate: [{ type: ViewChild, args: ['readOnlyDatePickerTemplate', { read: TemplateRef, static: true },] }],
    editableDatePickerTemplate: [{ type: ViewChild, args: ['editableDatePickerTemplate', { read: TemplateRef, static: true },] }],
    _inputGroup: [{ type: ViewChild, args: [IgxInputGroupComponent,] }],
    _inputGroupUserTemplate: [{ type: ContentChild, args: [IgxInputGroupComponent,] }],
    _inputElementRef: [{ type: ViewChild, args: [IgxInputDirective, { read: ElementRef },] }],
    _inputUserTemplateElementRef: [{ type: ContentChild, args: [IgxInputDirective, { read: ElementRef },] }],
    _inputDirective: [{ type: ViewChild, args: [IgxInputDirective,] }],
    _inputDirectiveUserTemplates: [{ type: ContentChildren, args: [IgxInputDirective, { descendants: true },] }],
    _labelDirective: [{ type: ViewChild, args: [IgxLabelDirective,] }],
    _labelDirectiveUserTemplate: [{ type: ContentChild, args: [IgxLabelDirective,] }],
    datePickerTemplateDirective: [{ type: ContentChild, args: [IgxDatePickerTemplateDirective, { read: IgxDatePickerTemplateDirective },] }],
    headerTemplate: [{ type: ContentChild, args: [IgxCalendarHeaderTemplateDirective, { read: IgxCalendarHeaderTemplateDirective },] }],
    subheaderTemplate: [{ type: ContentChild, args: [IgxCalendarSubheaderTemplateDirective, { read: IgxCalendarSubheaderTemplateDirective },] }],
    datePickerActionsDirective: [{ type: ContentChild, args: [IgxDatePickerActionsDirective, { read: IgxDatePickerActionsDirective },] }],
    onSpaceClick: [{ type: HostListener, args: ['keydown.spacebar', ['$event'],] }, { type: HostListener, args: ['keydown.space', ['$event'],] }]
};
__decorate([
    DeprecateProperty(`Use igxLabel inside the date picker to change the label:
    <igx-date-picker>
        <label igxLabel>Custom label</label>
    </igx-date-picker> `)
], IgxDatePickerComponent.prototype, "label", void 0);
/**
 * @hidden
 */
class IgxDatePickerModule {
}
IgxDatePickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDatePickerModule });
IgxDatePickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDatePickerModule_Factory(t) { return new (t || IgxDatePickerModule)(); }, imports: [[
            CommonModule,
            IgxIconModule,
            IgxInputGroupModule,
            IgxCalendarModule,
            IgxButtonModule,
            IgxRippleModule,
            IgxMaskModule,
            IgxTextSelectionModule
        ]] });

/**
 * @hidden
 */
class IgxDialogTitleDirective {
    constructor() {
        this.defaultStyle = true;
    }
}
IgxDialogTitleDirective.ɵfac = function IgxDialogTitleDirective_Factory(t) { return new (t || IgxDialogTitleDirective)(); };
IgxDialogTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDialogTitleDirective, selectors: [["igx-dialog-title"], ["", "igxDialogTitle", ""]], hostVars: 2, hostBindings: function IgxDialogTitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-dialog__window-title", ctx.defaultStyle);
    } } });
IgxDialogTitleDirective.propDecorators = {
    defaultStyle: [{ type: HostBinding, args: ['class.igx-dialog__window-title',] }]
};
/**
 * @hidden
 */
class IgxDialogActionsDirective {
    constructor() {
        this.defaultClass = true;
    }
}
IgxDialogActionsDirective.ɵfac = function IgxDialogActionsDirective_Factory(t) { return new (t || IgxDialogActionsDirective)(); };
IgxDialogActionsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDialogActionsDirective, selectors: [["igx-dialog-actions"], ["", "igxDialogActions", ""]], hostVars: 2, hostBindings: function IgxDialogActionsDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-dialog__window-actions", ctx.defaultClass);
    } } });
IgxDialogActionsDirective.propDecorators = {
    defaultClass: [{ type: HostBinding, args: ['class.igx-dialog__window-actions',] }]
};

let DIALOG_ID = 0;
/**
 * **Ignite UI for Angular Dialog Window** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/dialog.html)
 *
 * The Ignite UI Dialog Window presents a dialog window to the user which can simply display messages or display
 * more complicated visuals such as a user sign-in form.  It also provides a right and left button
 * which can be used for custom actions.
 *
 * Example:
 * ```html
 * <button (click)="form.open()">Show Dialog</button>
 * <igx-dialog #form title="Sign In" rightButtonLabel="OK">
 *   <div>
 *     <input type="text" igxInput/>
 *     <label igxLabel>Username</label>
 *   </div>
 *   <div>
 *     <input type="password" igxInput/>
 *     <label igxLabel>Password</label>
 *   </div>
 * </igx-dialog>
 * ```
 */
class IgxDialogComponent {
    constructor(elementRef, navService) {
        this.elementRef = elementRef;
        this.navService = navService;
        /**
         * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-dialog [id]="'igx-dialog-56'" #alert title="Notification"
         *  leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()">
         * </igx-dialog>
         * ```
         */
        this.id = `igx-dialog-${DIALOG_ID++}`;
        /**
         * An @Input property controlling the `title` of the dialog.
         * ```html
         * <igx-dialog title="Notification" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.title = '';
        /**
         *  An @Input property controlling the `message` of the dialog.
         * ```html
         * <igx-dialog message="Your email was sent!" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.message = '';
        /**
         * An @Input property to set the `label` of the left button of the dialog.
         * ```html
         * <igx-dialog leftButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonLabel = '';
        /**
         * An @Input property to set the left button `type`. The types are `flat`, `raised` and `fab`.
         * The `flat` type button is a rectangle and doesn't have a shadow. <br>
         * The `raised` type button is also a rectangle but has a shadow. <br>
         * The `fab` type button is a circle with a shadow. <br>
         * The default value is `flat`.
         * ```html
         * <igx-dialog leftButtonType="raised" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonType = 'flat';
        /**
         * An @Input property to set the left button color. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonColor="yellow" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonColor = '';
        /**
         * An @Input property to set the left button `background-color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonBackgroundColor="black" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonBackgroundColor = '';
        /**
         * An @Input property to set the left button `ripple`. The `ripple` animates a click/tap to a component as a series of fading waves.
         * The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonRipple="green" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonRipple = '';
        /**
         * An @Input property to set the `label` of the right button of the dialog.
         * ```html
         * <igx-dialog rightButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonLabel = '';
        /**
         * An @Input property to set the right button `type`. The types are `flat`, `raised` and `fab`.
         * The `flat` type button is a rectangle and doesn't have a shadow. <br>
         * The `raised` type button is also a rectangle but has a shadow. <br>
         * The `fab` type button is a circle with a shadow. <br>
         * The default value is `flat`.
         * ```html
         * <igx-dialog rightButtonType="fab" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonType = 'flat';
        /**
         * An @Input property to set the right button `color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog rightButtonColor="yellow" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonColor = '';
        /**
         * An @Input property to set the right button `background-color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog rightButtonBackgroundColor="black" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonBackgroundColor = '';
        /**
         * An @Input property to set the right button `ripple`.
         * ```html
         * <igx-dialog rightButtonRipple="green" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonRipple = '';
        /**
         * An event that is emitted when the dialog is opened.
         * ```html
         * <igx-dialog (onOpen)="onDialogOpenHandler($event)" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */
        this.onOpen = new EventEmitter();
        /**
         * An event that is emitted when the dialog is closed.
         * ```html
         * <igx-dialog (onClose)="onDialogCloseHandler($event)" title="Confirmation" leftButtonLabel="Cancel" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */
        this.onClose = new EventEmitter();
        /**
         * An event that is emitted when the left button is clicked.
         * ```html
         * <igx-dialog (onLeftButtonSelect)="onDialogOKSelected($event)" #dialog leftButtonLabel="OK" rightButtonLabel="Cancel">
         * </igx-dialog>
         * ```
         */
        this.onLeftButtonSelect = new EventEmitter();
        /**
         * An event that is emitted when the right button is clicked.
         * ```html
         * <igx-dialog (onRightButtonSelect)="onDialogOKSelected($event)"
         * #dialog title="Confirmation" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK"
         * rightButtonRipple="#4CAF50" closeOnOutsideSelect="true">
         * </igx-dialog>
         * ```
         */
        this.onRightButtonSelect = new EventEmitter();
        /**
         * @hidden
         */
        this.isOpenChange = new EventEmitter();
        this._positionSettings = {
            openAnimation: useAnimation(slideInBottom, { params: { fromPosition: 'translateY(100%)' } }),
            closeAnimation: useAnimation(slideOutTop, { params: { toPosition: 'translateY(-100%)' } })
        };
        this._closeOnOutsideSelect = false;
        this._closeOnEscape = true;
        this._isModal = true;
        this.destroy$ = new Subject();
        /**
         * The default `tabindex` attribute for the component
         *
         * @hidden
         */
        this.tabindex = -1;
        this._titleId = IgxDialogComponent.NEXT_ID++ + '_title';
        this._overlayDefaultSettings = {
            positionStrategy: new GlobalPositionStrategy(this._positionSettings),
            scrollStrategy: new NoOpScrollStrategy(),
            modal: this.isModal,
            closeOnEscape: this._closeOnEscape,
            closeOnOutsideClick: this.closeOnOutsideSelect
        };
    }
    /**
     * Controls whether the dialog should be shown as modal. Defaults to `true`
     * ```html
     * <igx-dialog [isModal]="false" ></igx-dialog>
     * ```
     */
    get isModal() {
        return this._isModal;
    }
    set isModal(val) {
        this._overlayDefaultSettings.modal = val;
        this._isModal = val;
    }
    /**
     * Controls whether the dialog should close when `Esc` key is pressed. Defaults to `true`
     * ```html
     * <igx-dialog [closeOnEscape]="false" ></igx-dialog>
     * ```
     */
    get closeOnEscape() {
        return this._closeOnEscape;
    }
    set closeOnEscape(val) {
        this._overlayDefaultSettings.closeOnEscape = val;
        this._closeOnEscape = val;
    }
    /**
     * An @Input property that allows you to enable the "close on click outside the dialog". By default it's disabled.
     * ```html
     * <igx-dialog closeOnOutsideSelect="true" leftButtonLabel="Cancel" (onLeftButtonSelect)="dialog.close()"
     * rightButtonLabel="OK" rightButtonRipple="#4CAF50" (onRightButtonSelect)="onDialogOKSelected($event)">
     * </igx-dialog>
     * ```
     */
    get closeOnOutsideSelect() {
        return this._closeOnOutsideSelect;
    }
    set closeOnOutsideSelect(val) {
        this._overlayDefaultSettings.closeOnOutsideClick = val;
        this._closeOnOutsideSelect = val;
    }
    /**
     * Get the position and animation settings used by the dialog.
     * ```typescript
     * @ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
     * let currentPosition: PositionSettings = this.alert.positionSettings
     * ```
     */
    get positionSettings() {
        return this._positionSettings;
    }
    /**
     * Set the position and animation settings used by the dialog.
     * ```typescript
     * import { slideInLeft, slideOutRight } from 'igniteui-angular';
     * ...
     * @ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
     *  public newPositionSettings: PositionSettings = {
     *      openAnimation: useAnimation(slideInTop, { params: { duration: '2000ms' } }),
     *      closeAnimation: useAnimation(slideOutBottom, { params: { duration: '2000ms'} }),
     *      horizontalDirection: HorizontalAlignment.Left,
     *      verticalDirection: VerticalAlignment.Middle,
     *      horizontalStartPoint: HorizontalAlignment.Left,
     *      verticalStartPoint: VerticalAlignment.Middle,
     *      minSize: { height: 100, width: 100 }
     *  };
     * this.alert.positionSettings = this.newPositionSettings;
     * ```
     */
    set positionSettings(settings) {
        this._positionSettings = settings;
        this._overlayDefaultSettings.positionStrategy = new GlobalPositionStrategy(this._positionSettings);
    }
    /**
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * Returns the value of state. Possible state values are "open" or "close".
     * ```typescript
     * @ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *     let dialogState = this.dialog.state;
     * }
     * ```
     */
    get state() {
        return this.isOpen ? 'open' : 'close';
    }
    /**
     * State of the dialog.
     *
     * ```typescript
     * // get
     * let dialogIsOpen = this.dialog.isOpen;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-dialog [isOpen]='false'></igx-dialog>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <!--set-->
     * <igx-dialog [(isOpen)]='model.isOpen'></igx-dialog>
     * ```
     */
    get isOpen() {
        return !this.toggleRef.collapsed;
    }
    set isOpen(value) {
        this.isOpenChange.emit(value);
        if (value) {
            this.open();
        }
        else {
            this.close();
        }
    }
    get isCollapsed() {
        return this.toggleRef.collapsed;
    }
    /**
     * Returns the value of the role of the dialog. The valid values are `dialog`, `alertdialog`, `alert`.
     * ```typescript
     * @ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *     let dialogRole = this.dialog.role;
     * }
     *  ```
     */
    get role() {
        if (this.leftButtonLabel !== '' && this.rightButtonLabel !== '') {
            return 'dialog';
        }
        else if (this.leftButtonLabel !== '' ||
            this.rightButtonLabel !== '') {
            return 'alertdialog';
        }
        else {
            return 'alert';
        }
    }
    /**
     * Returns the value of the title id.
     * ```typescript
     *  @ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *     let dialogTitle = this.dialog.titleId;
     * }
     * ```
     */
    get titleId() {
        return this._titleId;
    }
    ngAfterContentInit() {
        this.toggleRef.onClosing.pipe(takeUntil(this.destroy$)).subscribe(() => this.emitCloseFromDialog());
    }
    emitCloseFromDialog() {
        this.onClose.emit({ dialog: this, event: null });
    }
    /**
     * A method that opens the dialog.
     * @memberOf {@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.open() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     */
    open(overlaySettings = this._overlayDefaultSettings) {
        this.toggleRef.open(overlaySettings);
        this.onOpen.emit({ dialog: this, event: null });
        if (!this.leftButtonLabel && !this.rightButtonLabel) {
            this.toggleRef.element.focus();
        }
    }
    /**
     * A method that that closes the dialog.
     *  @memberOf {@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.close() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     */
    close() {
        // `onClose` will emit from `toggleRef.onClosing` subscription
        this.toggleRef.close();
    }
    /**
     * A method that opens/closes the dialog.
     * @memberOf {@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.toggle() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     */
    toggle() {
        this.isOpen ? this.close() : this.open();
    }
    /**
     * @hidden
     */
    onDialogSelected(event) {
        event.stopPropagation();
        if (this.isOpen &&
            this.closeOnOutsideSelect &&
            event.target.classList.contains(IgxDialogComponent.DIALOG_CLASS)) {
            this.close();
        }
    }
    /**
     * @hidden
     */
    onInternalLeftButtonSelect(event) {
        this.onLeftButtonSelect.emit({ dialog: this, event });
    }
    /**
     * @hidden
     */
    onInternalRightButtonSelect(event) {
        this.onRightButtonSelect.emit({ dialog: this, event });
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.navService && this.id) {
            this.navService.add(this.id, this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.navService && this.id) {
            this.navService.remove(this.id);
        }
    }
}
IgxDialogComponent.ɵfac = function IgxDialogComponent_Factory(t) { return new (t || IgxDialogComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8)); };
IgxDialogComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDialogComponent, selectors: [["igx-dialog"]], viewQuery: function IgxDialogComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(IgxToggleDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleRef = _t.first);
    } }, hostVars: 4, hostBindings: function IgxDialogComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵclassProp("igx-dialog--hidden", ctx.isCollapsed);
    } }, inputs: { id: "id", title: "title", message: "message", leftButtonLabel: "leftButtonLabel", leftButtonType: "leftButtonType", leftButtonColor: "leftButtonColor", leftButtonBackgroundColor: "leftButtonBackgroundColor", leftButtonRipple: "leftButtonRipple", rightButtonLabel: "rightButtonLabel", rightButtonType: "rightButtonType", rightButtonColor: "rightButtonColor", rightButtonBackgroundColor: "rightButtonBackgroundColor", rightButtonRipple: "rightButtonRipple", isModal: "isModal", closeOnEscape: "closeOnEscape", closeOnOutsideSelect: "closeOnOutsideSelect", positionSettings: "positionSettings", isOpen: "isOpen", role: "role", titleId: "titleId" }, outputs: { onOpen: "onOpen", onClose: "onClose", onLeftButtonSelect: "onLeftButtonSelect", onRightButtonSelect: "onRightButtonSelect", isOpenChange: "isOpenChange" }, ngContentSelectors: _c74, decls: 10, vars: 8, consts: [["tabindex", "0", "igxToggle", "", 1, "igx-dialog", 3, "click"], ["dialog", ""], [1, "igx-dialog__window"], ["dialogWindow", ""], ["class", "igx-dialog__window-title", 4, "ngIf"], [4, "ngIf"], ["class", "igx-dialog__window-content", 4, "ngIf"], ["class", "igx-dialog__window-actions", 4, "ngIf"], [1, "igx-dialog__window-title"], [1, "igx-dialog__window-content"], [1, "igx-dialog__window-actions"], ["type", "button", 3, "igxFocus", "igxButton", "igxButtonColor", "igxButtonBackground", "igxRipple", "click", 4, "ngIf"], ["type", "button", 3, "igxFocus", "igxButton", "igxButtonColor", "igxButtonBackground", "igxRipple", "click"]], template: function IgxDialogComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c73);
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵlistener("click", function IgxDialogComponent_Template_div_click_0_listener($event) { return ctx.onDialogSelected($event); });
        ɵngcc0.ɵɵelementStart(2, "div", 2, 3);
        ɵngcc0.ɵɵtemplate(4, IgxDialogComponent_div_4_Template, 2, 2, "div", 4);
        ɵngcc0.ɵɵtemplate(5, IgxDialogComponent_ng_content_5_Template, 1, 0, "ng-content", 5);
        ɵngcc0.ɵɵtemplate(6, IgxDialogComponent_div_6_Template, 2, 1, "div", 6);
        ɵngcc0.ɵɵtemplate(7, IgxDialogComponent_ng_content_7_Template, 1, 0, "ng-content", 5);
        ɵngcc0.ɵɵtemplate(8, IgxDialogComponent_div_8_Template, 3, 2, "div", 7);
        ɵngcc0.ɵɵtemplate(9, IgxDialogComponent_ng_content_9_Template, 1, 0, "ng-content", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("role", ctx.role)("aria-labelledby", ctx.titleId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.message);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.message);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.leftButtonLabel || ctx.rightButtonLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.leftButtonLabel && !ctx.rightButtonLabel);
    } }, directives: [IgxToggleDirective, ɵngcc2.NgIf, IgxFocusDirective, IgxButtonDirective, IgxRippleDirective], encapsulation: 2 });
IgxDialogComponent.NEXT_ID = 1;
IgxDialogComponent.DIALOG_CLASS = 'igx-dialog';
IgxDialogComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
IgxDialogComponent.propDecorators = {
    toggleRef: [{ type: ViewChild, args: [IgxToggleDirective, { static: true },] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    isModal: [{ type: Input }],
    closeOnEscape: [{ type: Input }],
    title: [{ type: Input }],
    message: [{ type: Input }],
    leftButtonLabel: [{ type: Input }],
    leftButtonType: [{ type: Input }],
    leftButtonColor: [{ type: Input }],
    leftButtonBackgroundColor: [{ type: Input }],
    leftButtonRipple: [{ type: Input }],
    rightButtonLabel: [{ type: Input }],
    rightButtonType: [{ type: Input }],
    rightButtonColor: [{ type: Input }],
    rightButtonBackgroundColor: [{ type: Input }],
    rightButtonRipple: [{ type: Input }],
    closeOnOutsideSelect: [{ type: Input }],
    positionSettings: [{ type: Input }],
    onOpen: [{ type: Output }],
    onClose: [{ type: Output }],
    onLeftButtonSelect: [{ type: Output }],
    onRightButtonSelect: [{ type: Output }],
    isOpenChange: [{ type: Output }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    isOpen: [{ type: Input }],
    isCollapsed: [{ type: HostBinding, args: ['class.igx-dialog--hidden',] }],
    role: [{ type: Input }],
    titleId: [{ type: Input }]
};
/**
 * @hidden
 */
class IgxDialogModule {
}
IgxDialogModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDialogModule });
IgxDialogModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDialogModule_Factory(t) { return new (t || IgxDialogModule)(); }, imports: [[CommonModule, IgxToggleModule, IgxButtonModule, IgxRippleModule, IgxFocusModule]] });

/**
 * @hidden
 */
class IgxTemplateOutletDirective {
    constructor(_viewContainerRef, _zone, cdr) {
        this._viewContainerRef = _viewContainerRef;
        this._zone = _zone;
        this.cdr = cdr;
        /**
         * The embedded views cache. Collection is key-value paired.
         * Key is the template id, value is the embedded view for the related template.
         */
        this._embeddedViewsMap = new Map();
        this.onViewCreated = new EventEmitter();
        this.onViewMoved = new EventEmitter();
        this.onCachedViewLoaded = new EventEmitter();
        this.onBeforeViewDetach = new EventEmitter();
    }
    ngOnChanges(changes) {
        const actionType = this._getActionType(changes);
        switch (actionType) {
            case TemplateOutletAction.CreateView:
                this._recreateView();
                break;
            case TemplateOutletAction.MoveView:
                this._moveView();
                break;
            case TemplateOutletAction.UseCachedView:
                this._useCachedView();
                break;
            case TemplateOutletAction.UpdateViewContext:
                this._updateExistingContext(this.igxTemplateOutletContext);
                break;
        }
    }
    cleanCache() {
        this._embeddedViewsMap.forEach((item) => {
            if (!item.destroyed) {
                item.destroy();
            }
        });
        this._embeddedViewsMap.clear();
    }
    cleanView(tmplID) {
        const embView = this._embeddedViewsMap.get(tmplID);
        if (embView) {
            embView.destroy();
            this._embeddedViewsMap.delete(tmplID);
        }
    }
    _recreateView() {
        const prevIndex = this._viewRef ? this._viewContainerRef.indexOf(this._viewRef) : -1;
        // detach old and create new
        if (prevIndex !== -1) {
            this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
            this._viewContainerRef.detach(prevIndex);
        }
        if (this.igxTemplateOutlet) {
            this._viewRef = this._viewContainerRef.createEmbeddedView(this.igxTemplateOutlet, this.igxTemplateOutletContext);
            this.onViewCreated.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
            const tmplId = this.igxTemplateOutletContext['templateID'];
            if (tmplId) {
                // if context contains a template id, check if we have a view for that template already stored in the cache
                // if not create a copy and add it to the cache in detached state.
                // Note: Views in detached state do not appear in the DOM, however they remain stored in memory.
                const res = this._embeddedViewsMap.get(this.igxTemplateOutletContext['templateID']);
                if (!res) {
                    this._embeddedViewsMap.set(this.igxTemplateOutletContext['templateID'], this._viewRef);
                }
            }
        }
    }
    _moveView() {
        // using external view and inserting it in current view.
        const view = this.igxTemplateOutletContext['moveView'];
        const owner = this.igxTemplateOutletContext['owner'];
        if (view !== this._viewRef) {
            if (owner._viewContainerRef.indexOf(view) !== -1) {
                // detach in case view it is attached somewhere else at the moment.
                this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                owner._viewContainerRef.detach(owner._viewContainerRef.indexOf(view));
            }
            if (this._viewRef && this._viewContainerRef.indexOf(this._viewRef) !== -1) {
                this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
            }
            this._viewRef = view;
            this._viewContainerRef.insert(view, 0);
            this._updateExistingContext(this.igxTemplateOutletContext);
            this.onViewMoved.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
        }
        else {
            this._updateExistingContext(this.igxTemplateOutletContext);
        }
    }
    _useCachedView() {
        // use view for specific template cached in the current template outlet
        const tmplID = this.igxTemplateOutletContext['templateID'];
        const cachedView = tmplID ?
            this._embeddedViewsMap.get(tmplID) :
            null;
        // if view exists, but template has been changed and there is a view in the cache with the related template
        // then detach old view and insert the stored one with the matching template
        // after that update its context.
        if (this._viewContainerRef.length > 0) {
            this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
            this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
        }
        this._viewRef = cachedView;
        const oldContext = this._cloneContext(cachedView.context);
        this._viewContainerRef.insert(this._viewRef, 0);
        this._updateExistingContext(this.igxTemplateOutletContext);
        this.onCachedViewLoaded.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext, oldContext });
    }
    _shouldRecreateView(changes) {
        const ctxChange = changes['igxTemplateOutletContext'];
        return !!changes['igxTemplateOutlet'] || (ctxChange && this._hasContextShapeChanged(ctxChange));
    }
    _hasContextShapeChanged(ctxChange) {
        const prevCtxKeys = Object.keys(ctxChange.previousValue || {});
        const currCtxKeys = Object.keys(ctxChange.currentValue || {});
        if (prevCtxKeys.length === currCtxKeys.length) {
            for (const propName of currCtxKeys) {
                if (prevCtxKeys.indexOf(propName) === -1) {
                    return true;
                }
            }
            return false;
        }
        else {
            return true;
        }
    }
    _updateExistingContext(ctx) {
        for (const propName of Object.keys(ctx)) {
            this._viewRef.context[propName] = this.igxTemplateOutletContext[propName];
        }
    }
    _cloneContext(ctx) {
        const clone = {};
        for (const propName of Object.keys(ctx)) {
            clone[propName] = ctx[propName];
        }
        return clone;
    }
    _getActionType(changes) {
        const movedView = this.igxTemplateOutletContext['moveView'];
        const tmplID = this.igxTemplateOutletContext['templateID'];
        const cachedView = tmplID ?
            this._embeddedViewsMap.get(tmplID) :
            null;
        const shouldRecreate = this._shouldRecreateView(changes);
        if (movedView) {
            // view is moved from external source
            return TemplateOutletAction.MoveView;
        }
        else if (shouldRecreate && cachedView) {
            // should recreate (template or context change) and there is a matching template in cache
            return TemplateOutletAction.UseCachedView;
        }
        else if (!this._viewRef || shouldRecreate) {
            // no view or should recreate
            return TemplateOutletAction.CreateView;
        }
        else if (this.igxTemplateOutletContext) {
            // has context, update context
            return TemplateOutletAction.UpdateViewContext;
        }
    }
}
IgxTemplateOutletDirective.ɵfac = function IgxTemplateOutletDirective_Factory(t) { return new (t || IgxTemplateOutletDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxTemplateOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTemplateOutletDirective, selectors: [["", "igxTemplateOutlet", ""]], inputs: { igxTemplateOutletContext: "igxTemplateOutletContext", igxTemplateOutlet: "igxTemplateOutlet" }, outputs: { onViewCreated: "onViewCreated", onViewMoved: "onViewMoved", onCachedViewLoaded: "onCachedViewLoaded", onBeforeViewDetach: "onBeforeViewDetach" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
IgxTemplateOutletDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: NgZone },
    { type: ChangeDetectorRef }
];
IgxTemplateOutletDirective.propDecorators = {
    igxTemplateOutletContext: [{ type: Input }],
    igxTemplateOutlet: [{ type: Input }],
    onViewCreated: [{ type: Output }],
    onViewMoved: [{ type: Output }],
    onCachedViewLoaded: [{ type: Output }],
    onBeforeViewDetach: [{ type: Output }]
};
var TemplateOutletAction;
(function (TemplateOutletAction) {
    TemplateOutletAction[TemplateOutletAction["CreateView"] = 0] = "CreateView";
    TemplateOutletAction[TemplateOutletAction["MoveView"] = 1] = "MoveView";
    TemplateOutletAction[TemplateOutletAction["UseCachedView"] = 2] = "UseCachedView";
    TemplateOutletAction[TemplateOutletAction["UpdateViewContext"] = 3] = "UpdateViewContext";
})(TemplateOutletAction || (TemplateOutletAction = {}));
/**
 * @hidden
 */
class IgxTemplateOutletModule {
}
IgxTemplateOutletModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTemplateOutletModule });
IgxTemplateOutletModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTemplateOutletModule_Factory(t) { return new (t || IgxTemplateOutletModule)(); }, imports: [[CommonModule]] });

class IgxProcessBarTextTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxProcessBarTextTemplateDirective.ɵfac = function IgxProcessBarTextTemplateDirective_Factory(t) { return new (t || IgxProcessBarTextTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxProcessBarTextTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxProcessBarTextTemplateDirective, selectors: [["", "igxProcessBarText", ""]] });
IgxProcessBarTextTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxProgressBarGradientDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxProgressBarGradientDirective.ɵfac = function IgxProgressBarGradientDirective_Factory(t) { return new (t || IgxProgressBarGradientDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxProgressBarGradientDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxProgressBarGradientDirective, selectors: [["", "igxProgressBarGradient", ""]] });
IgxProgressBarGradientDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * Injection token is used to inject the document into Directionality
 * which factory could be faked for testing purposes.
 *
 * We can't provide and mock the DOCUMENT token from platform-browser because configureTestingModule
 * allows override of the default providers, directive, pipes, modules of the test injector
 * which causes errors.
 *
 * @hidden
 */
const DIR_DOCUMENT = new InjectionToken('dir-doc', {
    providedIn: 'root',
    factory: DIR_DOCUMENT_FACTORY
});
/**
 * @hidden
 */
function DIR_DOCUMENT_FACTORY() {
    return inject(DOCUMENT);
}
/**
 * @hidden
 *
 * Bidirectional service that extracts the value of the direction attribute on the body or html elements.
 *
 * The dir attribute over the body element takes precedence.
 */
class IgxDirectionality {
    constructor(document) {
        this._document = document;
        const bodyDir = this._document.body ? this._document.body.dir : null;
        const htmlDir = this._document.documentElement ? this._document.documentElement.dir : null;
        const extractedDir = bodyDir || htmlDir;
        this._dir = (extractedDir === 'ltr' || extractedDir === 'rtl') ? extractedDir : 'ltr';
    }
    get value() {
        return this._dir;
    }
    get document() {
        return this._document;
    }
    get rtl() {
        return this._dir === 'rtl';
    }
}
IgxDirectionality.ɵfac = function IgxDirectionality_Factory(t) { return new (t || IgxDirectionality)(ɵngcc0.ɵɵinject(DIR_DOCUMENT)); };
IgxDirectionality.ɵprov = ɵɵdefineInjectable({ factory: function IgxDirectionality_Factory() { return new IgxDirectionality(ɵɵinject(DIR_DOCUMENT)); }, token: IgxDirectionality, providedIn: "root" });
IgxDirectionality.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DIR_DOCUMENT,] }] }
];

const ONE_PERCENT = 0.01;
const MIN_VALUE = 0;
const IgxTextAlign = mkenum({
    START: 'start',
    CENTER: 'center',
    END: 'end'
});
const IgxProgressType = mkenum({
    ERROR: 'error',
    INFO: 'info',
    WARNING: 'warning',
    SUCCESS: 'success'
});
/**
 * @hidden
 */
class BaseProgressDirective {
    constructor() {
        this.requestAnimationId = undefined;
        this._initValue = 0;
        this._contentInit = false;
        this._valueInPercent = MIN_VALUE;
        this._max = 100;
        this._value = MIN_VALUE;
        this._newVal = MIN_VALUE;
        this._animate = true;
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *     alert("Progress made!");
         * }
         *  //...
         * ```
         * ```html
         * <igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
         * <igx-linear-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-linear-bar>
         * ```
         */
        this.onProgressChanged = new EventEmitter();
    }
    /**
     * Returns the value which update the progress indicator of the `progress bar`.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public stepValue(event) {
     *     let step = this.progressBar.step;
     *     alert(step);
     * }
     * ```
     */
    get step() {
        if (this._step) {
            return this._step;
        }
        return this._max * ONE_PERCENT;
    }
    /**
     * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0" [step]="1"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0" [step]="1"></igx-circular-bar>
     * ```
     */
    set step(val) {
        this._step = Number(val);
    }
    /**
     * Animating the progress. By default it is set to true.
     * ```html
     * <igx-linear-bar [animate]="false" [max]="200" [value]="50"></igx-linear-bar>
     * <igx-circular-bar [animate]="false" [max]="200" [value]="50"></igx-circular-bar>
     * ```
     */
    set animate(animate) {
        this._animate = animate;
    }
    /**
     * Returns whether the `progress bar` has animation true/false.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public animationStatus(event) {
     *     let animationStatus = this.progressBar.animate;
     *     alert(animationStatus);
     * }
     * ```
     */
    get animate() {
        return this._animate;
    }
    /**
     * Set maximum value that can be passed. By default it is set to 100.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
     * ```
     */
    set max(maxNum) {
        this._max = maxNum;
    }
    /**
     * Returns the the maximum progress value of the `progress bar`.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public maxValue(event) {
     *     let max = this.progressBar.max;
     *     alert(max);
     * }
     * ```
     */
    get max() {
        return this._max;
    }
    /**
     * Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     *     public setValue(event){
     *     this.progressBar.valueInPercent = 56;
     * }
     * ```
     */
    set valueInPercent(value) {
        this._valueInPercent = value;
    }
    /**
     * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     * public valuePercent(event){
     *     let percentValue = this.progressBar.valueInPercent;
     *     alert(percentValue);
     * }
     * ```
     */
    get valueInPercent() {
        return this._valueInPercent;
    }
    triggerProgressTransition(oldVal, newVal) {
        if (oldVal === newVal) {
            return;
        }
        const changedValues = {
            currentValue: newVal,
            previousValue: oldVal
        };
        const stepDirection = this.directionFlow(oldVal, newVal);
        if (this._animate) {
            this.runAnimation(newVal, stepDirection);
        }
        else {
            this.updateProgressDirectly(newVal);
        }
        this.onProgressChanged.emit(changedValues);
    }
    /**
     * @hidden
     */
    runAnimation(val, step) {
        this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
    }
    /**
     * @hidden
     */
    updateProgressSmoothly(val, step) {
        this._value = valueInRange(this._value, this._max) + step;
        const passedValue = toPercent(val, this._max);
        const progressValue = toPercent(this._value, this._max);
        if (this.valueInPercent === passedValue) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else if (this.isInLimitRange(progressValue, passedValue, step)) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else {
            this.valueInPercent = progressValue;
            this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
        }
    }
    /**
     * @hidden
     */
    updateProgressDirectly(val) {
        this._value = valueInRange(val, this._max);
        this.valueInPercent = toPercent(this._value, this._max);
    }
    /**
     * @hidden
     */
    directionFlow(currentValue, prevValue) {
        return currentValue < prevValue ? this.step : -this.step;
    }
    /**
     * @hidden
     */
    isInLimitRange(val, comparator, step) {
        return this.isExceedingUpperLimit(val, comparator, step) || this.isExceedingLowerLimit(val, comparator, step);
    }
    /**
     * @hidden
     *
     *
     * @param val
     * @param comparator
     * @param step
     */
    isExceedingUpperLimit(val, comparator, step) {
        return val > comparator && step > 0;
    }
    /**
     * @hidden
     *
     * @param val
     * @param comparator
     * @param step
     */
    isExceedingLowerLimit(val, comparator, step) {
        return val < comparator && step < 0;
    }
    /**
     * @hidden
     * @param step
     */
    updateProgress(val) {
        this._value = valueInRange(val, this._max);
        this.valueInPercent = toPercent(this._value, this._max);
    }
}
BaseProgressDirective.ɵfac = function BaseProgressDirective_Factory(t) { return new (t || BaseProgressDirective)(); };
BaseProgressDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BaseProgressDirective, hostVars: 1, hostBindings: function BaseProgressDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-valuemax", ctx.max);
    } }, inputs: { step: "step", animate: "animate", max: "max" }, outputs: { onProgressChanged: "onProgressChanged" } });
BaseProgressDirective.propDecorators = {
    onProgressChanged: [{ type: Output }],
    step: [{ type: Input }],
    animate: [{ type: Input }],
    max: [{ type: HostBinding, args: ['attr.aria-valuemax',] }, { type: Input }]
};
let NEXT_LINEAR_ID = 0;
let NEXT_CIRCULAR_ID = 0;
let NEXT_GRADIENT_ID = 0;
class IgxLinearProgressBarComponent extends BaseProgressDirective {
    constructor() {
        super();
        this.valueMin = 0;
        this.cssClass = 'igx-linear-bar';
        /**
         * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         * ```html
         * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.striped = false;
        /**
         * Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * An @Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
         * ```html
         * <igx-linear-bar role="progressbar"></igx-linear-bar>
         * ```
         */
        this.role = 'progressbar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.id = `igx-linear-bar-${NEXT_LINEAR_ID++}`;
        /**
         * Set the position that defines where the text is aligned.
         * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         * ```typescript
         * public positionCenter: IgxTextAlign;
         * public ngOnInit() {
         *     this.positionCenter = IgxTextAlign.CENTER;
         * }
         *  //...
         * ```
         *  ```html
         * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         * ```
         */
        this.textAlign = IgxTextAlign.START;
        /**
         * Set the text to be visible. By default it is set to true.
         * ```html
         *  <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         * ```html
         *  <igx-linear-bar type="error" [textTop]="true"></igx-linear-bar>
         * ```
         */
        this.textTop = false;
        /**
         * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="error"></igx-linear-bar>
         * ```
         */
        this.type = 'default';
    }
    /**
     * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public getValue(event) {
     *     let value = this.progressBar.value;
     *     alert(value);
     * }
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     */
    set value(val) {
        const valInRange = valueInRange(val, this.max);
        if (isNaN(valInRange) || this._value === val || this.indeterminate) {
            return;
        }
        if (this._contentInit) {
            this.triggerProgressTransition(this._value, valInRange);
        }
        else {
            this._initValue = valInRange;
        }
    }
    /**
     * @hidden
     */
    get error() {
        return this.type === IgxProgressType.ERROR;
    }
    /**
     * @hidden
     */
    get info() {
        return this.type === IgxProgressType.INFO;
    }
    /**
     * @hidden
     */
    get warning() {
        return this.type === IgxProgressType.WARNING;
    }
    /**
     * @hidden
     */
    get success() {
        return this.type === IgxProgressType.SUCCESS;
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
}
IgxLinearProgressBarComponent.ɵfac = function IgxLinearProgressBarComponent_Factory(t) { return new (t || IgxLinearProgressBarComponent)(); };
IgxLinearProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxLinearProgressBarComponent, selectors: [["igx-linear-bar"]], hostVars: 18, hostBindings: function IgxLinearProgressBarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-valuemin", ctx.valueMin)("role", ctx.role)("id", ctx.id)("aria-valuenow", ctx.value);
        ɵngcc0.ɵɵclassProp("igx-linear-bar", ctx.cssClass)("igx-linear-bar--striped", ctx.striped)("igx-linear-bar--indeterminate", ctx.indeterminate)("igx-linear-bar--danger", ctx.error)("igx-linear-bar--info", ctx.info)("igx-linear-bar--warning", ctx.warning)("igx-linear-bar--success", ctx.success);
    } }, inputs: { striped: "striped", indeterminate: "indeterminate", role: "role", id: "id", textAlign: "textAlign", textVisibility: "textVisibility", textTop: "textTop", type: "type", value: "value", text: "text" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 10, consts: [[1, "igx-linear-bar__base"], [1, "igx-linear-bar__indicator"], [1, "igx-linear-bar__value", 3, "ngClass"]], template: function IgxLinearProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelement(1, "div", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 2);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.valueInPercent, "%");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction5(4, _c75, ctx.textAlign === "start", ctx.textAlign === "center", ctx.textAlign === "end", ctx.textTop, !ctx.textVisibility));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.text ? ctx.text : ctx.valueInPercent + "%", "\n");
    } }, directives: [ɵngcc2.NgClass], encapsulation: 2 });
IgxLinearProgressBarComponent.ctorParameters = () => [];
IgxLinearProgressBarComponent.propDecorators = {
    valueMin: [{ type: HostBinding, args: ['attr.aria-valuemin',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-linear-bar',] }],
    striped: [{ type: HostBinding, args: ['class.igx-linear-bar--striped',] }, { type: Input }],
    indeterminate: [{ type: HostBinding, args: ['class.igx-linear-bar--indeterminate',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    textAlign: [{ type: Input }],
    textVisibility: [{ type: Input }],
    textTop: [{ type: Input }],
    text: [{ type: Input }],
    type: [{ type: Input }],
    value: [{ type: HostBinding, args: ['attr.aria-valuenow',] }, { type: Input }],
    error: [{ type: HostBinding, args: ['class.igx-linear-bar--danger',] }],
    info: [{ type: HostBinding, args: ['class.igx-linear-bar--info',] }],
    warning: [{ type: HostBinding, args: ['class.igx-linear-bar--warning',] }],
    success: [{ type: HostBinding, args: ['class.igx-linear-bar--success',] }]
};
class IgxCircularProgressBarComponent extends BaseProgressDirective {
    constructor(renderer, _directionality) {
        super();
        this.renderer = renderer;
        this._directionality = _directionality;
        this.STROKE_OPACITY_DVIDER = 100;
        this.STROKE_OPACITY_ADDITION = .2;
        /** @hidden */
        this.cssClass = 'igx-circular-bar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         * ```
         */
        this.id = `igx-circular-bar-${NEXT_CIRCULAR_ID++}`;
        /**
         * @hidden
         */
        this.gradientId = `igx-circular-gradient-${NEXT_GRADIENT_ID++}`;
        /**
         * An @Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
         * ```html
         * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * Sets the text visibility. By default it is set to true.
         * ```html
         * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         * ```
         */
        this.textVisibility = true;
        this._circleRadius = 46;
        this._circumference = 2 * Math.PI * this._circleRadius;
    }
    /**
     * @hidden
     */
    get context() {
        return {
            $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
        };
    }
    /**
     * Returns value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public getValue(event) {
     *     let value = this.progressBar.value;
     *     alert(value);
     * }
     * ```
     * ```html
     * <button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```html
     * <igx-circular-bar [value]="50"></igx-circular-bar>
     * ```
     */
    set value(val) {
        const valInRange = valueInRange(val, this.max);
        if (isNaN(valInRange) || this._value === val || this.indeterminate) {
            return;
        }
        if (this._contentInit) {
            this.triggerProgressTransition(this._value, valInRange);
        }
        else {
            this._initValue = valInRange;
        }
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
    ngAfterViewInit() {
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke', `url(#${this.gradientId})`);
    }
    /**
     * @hidden
     */
    updateProgressSmoothly(val, step) {
        // Set frames for the animation
        const FRAMES = [{
                strokeDashoffset: this.getProgress(this._value),
                strokeOpacity: (this._value / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }, {
                strokeDashoffset: this.getProgress(this.valueInPercent),
                strokeOpacity: (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }];
        this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards'
        });
        super.updateProgressSmoothly(val, step);
    }
    /**
     * @hidden
     */
    get textContent() {
        return this.text;
    }
    /**
     * @hidden
     */
    updateProgressDirectly(val) {
        super.updateProgressDirectly(val);
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-dashoffset', this.getProgress(this.valueInPercent));
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-opacity', (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION);
    }
    getProgress(percentage) {
        return this._directionality.rtl ?
            this._circumference + (percentage * this._circumference / 100) :
            this._circumference - (percentage * this._circumference / 100);
    }
}
IgxCircularProgressBarComponent.ɵfac = function IgxCircularProgressBarComponent_Factory(t) { return new (t || IgxCircularProgressBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(IgxDirectionality)); };
IgxCircularProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCircularProgressBarComponent, selectors: [["igx-circular-bar"]], contentQueries: function IgxCircularProgressBarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxProcessBarTextTemplateDirective, true, IgxProcessBarTextTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxProgressBarGradientDirective, true, IgxProgressBarGradientDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.textTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.gradientTemplate = _t.first);
    } }, viewQuery: function IgxCircularProgressBarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c76, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._svgCircle = _t.first);
    } }, hostVars: 5, hostBindings: function IgxCircularProgressBarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-circular-bar", ctx.cssClass)("igx-circular-bar--indeterminate", ctx.indeterminate);
    } }, inputs: { id: "id", indeterminate: "indeterminate", textVisibility: "textVisibility", value: "value", text: "text" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 12, vars: 7, consts: [["xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink", "version", "1.1", "viewBox", "0 0 100 100", "preserveAspectRatio", "xMidYMid meet", "role", "progressbar", "aria-valuemin", "0"], ["svg", ""], ["cx", "50", "cy", "50", "r", "46", 1, "igx-circular-bar__inner"], ["cx", "50", "cy", "50", "r", "46", 1, "igx-circular-bar__outer"], ["circle", ""], ["text-anchor", "middle", "x", "50", "y", "60", 4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["defaultTextTemplate", ""], ["defaultGradientTemplate", ""], ["text-anchor", "middle", "x", "50", "y", "60"], [1, "igx-circular-bar__text"], ["gradientTransform", "rotate(90)", 3, "id"], ["offset", "0%", 1, "igx-circular-bar__gradient-start"], ["offset", "100%", 1, "igx-circular-bar__gradient-end"]], template: function IgxCircularProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "svg", 0, 1);
        ɵngcc0.ɵɵelement(2, "circle", 2);
        ɵngcc0.ɵɵelement(3, "circle", 3, 4);
        ɵngcc0.ɵɵtemplate(5, IgxCircularProgressBarComponent__svg_text_5_Template, 2, 2, "text", 5);
        ɵngcc0.ɵɵelementStart(6, "defs");
        ɵngcc0.ɵɵtemplate(7, IgxCircularProgressBarComponent__svg_ng_container_7_Template, 1, 0, "ng-container", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, IgxCircularProgressBarComponent__svg_ng_template_8_Template, 2, 1, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(10, IgxCircularProgressBarComponent__svg_ng_template_10_Template, 3, 1, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r6 = ɵngcc0.ɵɵreference(11);
        ɵngcc0.ɵɵattribute("aria-valuemax", ctx.max)("aria-valuenow", ctx.value);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.textVisibility);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.gradientTemplate ? ctx.gradientTemplate.template : _r6)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(5, _c17, ctx.gradientId));
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
IgxCircularProgressBarComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: IgxDirectionality }
];
IgxCircularProgressBarComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-circular-bar',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    indeterminate: [{ type: HostBinding, args: ['class.igx-circular-bar--indeterminate',] }, { type: Input }],
    textVisibility: [{ type: Input }],
    text: [{ type: Input }],
    textTemplate: [{ type: ContentChild, args: [IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective },] }],
    gradientTemplate: [{ type: ContentChild, args: [IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective },] }],
    value: [{ type: Input }],
    _svgCircle: [{ type: ViewChild, args: ['circle', { static: true },] }]
};
function valueInRange(value, max, min = 0) {
    return Math.max(Math.min(value, max), min);
}
function toPercent(value, max) {
    return Math.floor(100 * value / max);
}
/**
 * @hidden
 */
class IgxProgressBarModule {
}
IgxProgressBarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxProgressBarModule });
IgxProgressBarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxProgressBarModule_Factory(t) { return new (t || IgxProgressBarModule)(); }, imports: [[CommonModule]] });

class IgxSelectItemComponent extends IgxDropDownItemComponent {
    /**
     * An @Input property that gets/sets the item's text to be displayed in the select component's input when the item is selected.
     *
     * ```typescript
     *  //get
     *  let mySelectedItem = this.dropDown.selectedItem;
     *  let selectedItemText = mySelectedItem.text;
     * ```
     *
     * ```html
     * // set
     * <igx-select-item [text]="'London'"></igx-select-item>
     * ```
     */
    get text() {
        return this._text;
    }
    set text(text) {
        this._text = text;
    }
    /** @hidden @internal */
    get itemText() {
        if (this._text !== undefined) {
            return this._text;
        }
        // If text @Input is undefined, try extract a meaningful item text out of the item template
        return this.elementRef.nativeElement.textContent.trim();
    }
    /**
     * Sets/Gets if the item is the currently selected one in the select
     *
     * ```typescript
     *  let mySelectedItem = this.select.selectedItem;
     *  let isMyItemSelected = mySelectedItem.selected; // true
     * ```
     */
    get selected() {
        return !this.isHeader && !this.disabled && this.selection.is_item_selected(this.dropDown.id, this);
    }
    set selected(value) {
        if (value && !this.isHeader && !this.disabled) {
            this.dropDown.selectItem(this);
        }
    }
    ngDoCheck() {
    }
}
IgxSelectItemComponent.ɵfac = function IgxSelectItemComponent_Factory(t) { return ɵIgxSelectItemComponent_BaseFactory(t || IgxSelectItemComponent); };
IgxSelectItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSelectItemComponent, selectors: [["igx-select-item"]], inputs: { text: "text" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 2, vars: 0, consts: [[1, "igx-drop-down__inner"]], template: function IgxSelectItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
IgxSelectItemComponent.propDecorators = {
    text: [{ type: Input }]
};

/** @hidden @internal */
class SelectPositioningStrategy extends BaseFitPositionStrategy {
    constructor(select, settings) {
        super();
        this.select = select;
        this._selectDefaultSettings = {
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Top,
            openAnimation: fadeIn,
            closeAnimation: fadeOut
        };
        // Global variables required for cases of !initialCall (page scroll/overlay repositionAll)
        this.global_yOffset = 0;
        this.global_xOffset = 0;
        this.global_styles = {};
        this.settings = Object.assign({}, this._selectDefaultSettings, settings);
    }
    /** @inheritdoc */
    position(contentElement, size, document, initialCall, target) {
        this.select.scrollContainer.scrollTop = 0;
        const targetElement = target || this.settings.target;
        const rects = super.calculateElementRectangles(contentElement, targetElement);
        // selectFit obj, to be used for both cases of initialCall and !initialCall(page scroll/overlay repositionAll)
        const selectFit = {
            verticalOffset: this.global_yOffset,
            horizontalOffset: this.global_xOffset,
            targetRect: rects.targetRect,
            contentElementRect: rects.elementRect,
            styles: this.global_styles,
            scrollContainer: this.select.scrollContainer,
            scrollContainerRect: this.select.scrollContainer.getBoundingClientRect()
        };
        if (initialCall) {
            // Fill in the required selectFit object properties.
            selectFit.viewPortRect = Util.getViewportRect(document);
            selectFit.itemElement = this.getInteractionItemElement();
            selectFit.itemRect = selectFit.itemElement.getBoundingClientRect();
            // Calculate input and selected item elements style related variables
            selectFit.styles = this.calculateStyles(selectFit, targetElement);
            selectFit.scrollAmount = this.calculateScrollAmount(selectFit);
            // Calculate how much to offset the overlay container.
            this.calculateYoffset(selectFit);
            this.calculateXoffset(selectFit);
            super.updateViewPortFit(selectFit);
            // container does not fit in viewPort and is out on Top or Bottom
            if (selectFit.fitVertical.back < 0 || selectFit.fitVertical.forward < 0) {
                this.fitInViewport(contentElement, selectFit);
            }
            this.select.scrollContainer.scrollTop = selectFit.scrollAmount;
        }
        this.setStyles(contentElement, selectFit);
    }
    /**
     * Calculate selected item scroll position.
     */
    calculateScrollAmount(selectFit) {
        const itemElementRect = selectFit.itemRect;
        const scrollContainer = selectFit.scrollContainer;
        const scrollContainerRect = selectFit.scrollContainerRect;
        const scrollDelta = scrollContainerRect.top - itemElementRect.top;
        let scrollPosition = scrollContainer.scrollTop - scrollDelta;
        const dropDownHeight = scrollContainer.clientHeight;
        scrollPosition -= dropDownHeight / 2;
        scrollPosition += itemElementRect.height / 2;
        return Math.round(Math.min(Math.max(0, scrollPosition), scrollContainer.scrollHeight - scrollContainerRect.height));
    }
    /**
     * Position the items outer container so selected item text is positioned over input text and if header
     * And/OR footer - both header/footer are visible
     * @param selectFit selectFit to use for computation.
     */
    fitInViewport(contentElement, selectFit) {
        const footer = selectFit.scrollContainerRect.bottom - selectFit.contentElementRect.bottom;
        const header = selectFit.scrollContainerRect.top - selectFit.contentElementRect.top;
        const lastItemFitSize = selectFit.targetRect.bottom + selectFit.styles.itemTextToInputTextDiff - footer;
        const firstItemFitSize = selectFit.targetRect.top - selectFit.styles.itemTextToInputTextDiff - header;
        // out of viewPort on Top
        if (selectFit.fitVertical.back < 0) {
            const possibleScrollAmount = selectFit.scrollContainer.scrollHeight -
                selectFit.scrollContainerRect.height - selectFit.scrollAmount;
            if (possibleScrollAmount + selectFit.fitVertical.back > 0 && firstItemFitSize > selectFit.viewPortRect.top) {
                selectFit.scrollAmount -= selectFit.fitVertical.back;
                selectFit.verticalOffset -= selectFit.fitVertical.back;
                this.global_yOffset = selectFit.verticalOffset;
            }
            else {
                selectFit.verticalOffset = 0;
                this.global_yOffset = 0;
            }
            // out of viewPort on Bottom
        }
        else if (selectFit.fitVertical.forward < 0) {
            if (selectFit.scrollAmount + selectFit.fitVertical.forward > 0 && lastItemFitSize < selectFit.viewPortRect.bottom) {
                selectFit.scrollAmount += selectFit.fitVertical.forward;
                selectFit.verticalOffset += selectFit.fitVertical.forward;
                this.global_yOffset = selectFit.verticalOffset;
            }
            else {
                selectFit.verticalOffset = -selectFit.contentElementRect.height + selectFit.targetRect.height;
                this.global_yOffset = selectFit.verticalOffset;
            }
        }
    }
    /**
     * Sets element's style which effectively positions the provided element
     * @param element Element to position
     * @param selectFit selectFit to use for computation.
     * @param initialCall should be true if this is the initial call to the position method calling setStyles
     */
    setStyles(contentElement, selectFit) {
        super.setStyle(contentElement, selectFit.targetRect, selectFit.contentElementRect, selectFit);
        contentElement.style.width = `${selectFit.styles.contentElementNewWidth}px`; // manage container based on paddings?
        this.global_styles.contentElementNewWidth = selectFit.styles.contentElementNewWidth;
    }
    /**
     * Calculate the necessary input and selected item styles to be used for positioning item text over input text.
     * Calculate & Set default items container width.
     * @param selectFit selectFit to use for computation.
     */
    calculateStyles(selectFit, target) {
        const styles = {};
        const inputElementStyles = window.getComputedStyle(target);
        const itemElementStyles = window.getComputedStyle(selectFit.itemElement);
        const numericInputFontSize = parseFloat(inputElementStyles.fontSize);
        const numericItemFontSize = parseFloat(itemElementStyles.fontSize);
        const inputTextToInputTop = (selectFit.targetRect.bottom - selectFit.targetRect.top - numericInputFontSize) / 2;
        const itemTextToItemTop = (selectFit.itemRect.height - numericItemFontSize) / 2;
        // Adjust for input top padding
        const negateInputPaddings = (parseFloat(inputElementStyles.paddingTop) -
            parseFloat(inputElementStyles.paddingBottom)) / 2;
        styles.itemTextToInputTextDiff = Math.round(itemTextToItemTop - inputTextToInputTop + negateInputPaddings);
        const numericLeftPadding = parseFloat(itemElementStyles.paddingLeft);
        const numericTextIndent = parseFloat(itemElementStyles.textIndent);
        styles.itemTextPadding = numericLeftPadding;
        styles.itemTextIndent = numericTextIndent;
        // 24 is the input's toggle ddl icon width
        styles.contentElementNewWidth = selectFit.targetRect.width + 24 + numericLeftPadding * 2;
        return styles;
    }
    /**
     * Obtain the selected item if there is such one or otherwise use the first one
     */
    getInteractionItemElement() {
        let itemElement;
        if (this.select.selectedItem) {
            itemElement = this.select.selectedItem.element.nativeElement;
            // D.P. Feb 22 2019, #3921 Force item scroll before measuring in IE11, due to base scrollToItem delay
            if (isIE()) {
                this.select.scrollContainer.scrollTop = this.select.calculateScrollPosition(this.select.selectedItem);
            }
        }
        else {
            itemElement = this.select.getFirstItemElement();
        }
        return itemElement;
    }
    /**
     * Calculate how much to offset the overlay container for Y-axis.
     */
    calculateYoffset(selectFit) {
        selectFit.verticalOffset = -(selectFit.itemRect.top - selectFit.contentElementRect.top +
            selectFit.styles.itemTextToInputTextDiff - selectFit.scrollAmount);
        this.global_yOffset = selectFit.verticalOffset;
    }
    /**
     * Calculate how much to offset the overlay container for X-axis.
     */
    calculateXoffset(selectFit) {
        selectFit.horizontalOffset = selectFit.styles.itemTextIndent - selectFit.styles.itemTextPadding;
        this.global_xOffset = selectFit.horizontalOffset;
    }
}

/** @hidden @internal */
class IgxSelectToggleIconDirective {
}
IgxSelectToggleIconDirective.ɵfac = function IgxSelectToggleIconDirective_Factory(t) { return new (t || IgxSelectToggleIconDirective)(); };
IgxSelectToggleIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSelectToggleIconDirective, selectors: [["", "igxSelectToggleIcon", ""]] });
/** @hidden @internal */
class IgxSelectHeaderDirective {
}
IgxSelectHeaderDirective.ɵfac = function IgxSelectHeaderDirective_Factory(t) { return new (t || IgxSelectHeaderDirective)(); };
IgxSelectHeaderDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSelectHeaderDirective, selectors: [["", "igxSelectHeader", ""]] });
/** @hidden @internal */
class IgxSelectFooterDirective {
}
IgxSelectFooterDirective.ɵfac = function IgxSelectFooterDirective_Factory(t) { return new (t || IgxSelectFooterDirective)(); };
IgxSelectFooterDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSelectFooterDirective, selectors: [["", "igxSelectFooter", ""]] });
const noop$6 = () => { };
const ɵ0$7 = noop$6;
/**
 * **Ignite UI for Angular Select** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/select)
 *
 * The `igxSelect` provides an input with dropdown list allowing selection of a single item.
 *
 * Example:
 * ```html
 * <igx-select #select1 [placeholder]="'Pick One'">
 *   <label igxLabel>Select Label</label>
 *   <igx-select-item *ngFor="let item of items" [value]="item.field">
 *     {{ item.field }}
 *   </igx-select-item>
 * </igx-select>
 * ```
 */
class IgxSelectComponent extends IgxDropDownComponent {
    constructor(elementRef, cdr, selection, _displayDensityOptions, _inputGroupType, _injector) {
        super(elementRef, cdr, selection, _displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this._displayDensityOptions = _displayDensityOptions;
        this._inputGroupType = _inputGroupType;
        this._injector = _injector;
        this.ngControl = null;
        this._type = null;
        this.destroy$ = new Subject();
        /** @hidden @internal do not use the drop-down container class */
        this.cssClass = false;
        /** @hidden @internal */
        this.allowItemsFocus = false;
        /**
         * An @Input property that disables the `IgxSelectComponent`.
         * ```html
         * <igx-select [disabled]="'true'"></igx-select>
         * ```
         */
        this.disabled = false;
        /** @hidden @internal */
        this.maxHeight = '256px';
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-select onOpening='handleOpening($event)'></igx-select>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-select (onOpened)='handleOpened()'></igx-select>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-select (onClosing)='handleClosing($event)'></igx-select>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-select (onClosed)='handleClosed()'></igx-select>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * The custom template, if any, that should be used when rendering the select TOGGLE(open/close) button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.select.toggleIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-select #select>
         *      ...
         *      <ng-template igxSelectToggleIcon let-collapsed>
         *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
         *      </ng-template>
         *  </igx-select>
         * ```
         */
        this.toggleIconTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the HEADER for the select items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.select.headerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-select #select>
         *      ...
         *      <ng-template igxSelectHeader>
         *          <div class="select__header">
         *              This is a custom header
         *          </div>
         *      </ng-template>
         *  </igx-select>
         * ```
         */
        this.headerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the FOOTER for the select items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.select.footerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-select #select>
         *      ...
         *      <ng-template igxSelectFooter>
         *          <div class="select__footer">
         *              This is a custom footer
         *          </div>
         *      </ng-template>
         *  </igx-select>
         * ```
         */
        this.footerTemplate = null;
        //#region ControlValueAccessor
        this._onChangeCallback = noop$6;
        this._onTouchedCallback = noop$6;
        /** @hidden @internal */
        this.writeValue = (value) => {
            this.value = value;
        };
    }
    /**
     * An @Input property that gets/sets the component value.
     *
     * ```typescript
     * // get
     * let selectValue = this.select.value;
     * ```
     *
     * ```typescript
     * // set
     * this.select.value = 'London';
     * ```
     * ```html
     * <igx-select [value]="value"></igx-select>
     * ```
     */
    get value() {
        return this._value;
    }
    set value(v) {
        if (this._value === v) {
            return;
        }
        this._value = v;
        this.setSelection(this.items.find(x => x.value === this.value));
    }
    /**
     * An @Input property that sets how the select will be styled.
     * The allowed values are `line`, `box` and `border`. The input-group default is `line`.
     * ```html
     * <igx-select [type]="'box'"></igx-select>
     * ```
     */
    get type() {
        return this._type || this._inputGroupType || 'line';
    }
    set type(val) {
        this._type = val;
    }
    /** @hidden @internal */
    get selectionValue() {
        const selectedItem = this.selectedItem;
        return selectedItem ? selectedItem.itemText : '';
    }
    /** @hidden @internal */
    get selectedItem() {
        return this.selection.first_item(this.id);
    }
    /** @hidden @internal */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /** @hidden @internal */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /** @hidden @internal */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    //#endregion
    /** @hidden @internal */
    getEditElement() {
        return this.input.nativeElement;
    }
    /** @hidden @internal */
    selectItem(newSelection, event) {
        const oldSelection = this.selectedItem;
        if (event) {
            this.toggleDirective.close();
        }
        if (newSelection === null || newSelection === oldSelection || newSelection.disabled || newSelection.isHeader) {
            return;
        }
        const args = { oldSelection, newSelection, cancel: false };
        this.onSelection.emit(args);
        if (args.cancel) {
            return;
        }
        this.setSelection(newSelection);
        this._value = newSelection.value;
        this.cdr.detectChanges();
        this._onChangeCallback(this.value);
    }
    /** @hidden @internal */
    getFirstItemElement() {
        return this.children.first.element.nativeElement;
    }
    /**
     * Opens the select
     *
     * ```typescript
     * this.select.open();
     * ```
     */
    open(overlaySettings) {
        if (this.disabled || this.items.length === 0) {
            return;
        }
        if (!this.selectedItem) {
            this.navigateFirst();
        }
        super.open(Object.assign({}, this._overlayDefaults, this.overlaySettings, overlaySettings));
    }
    inputGroupClick(event, overlaySettings) {
        const targetElement = event.target;
        if (this.hintElement && targetElement.contains(this.hintElement.nativeElement)) {
            return;
        }
        this.toggle(Object.assign({}, this._overlayDefaults, this.overlaySettings, overlaySettings));
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this._overlayDefaults = {
            target: this.getEditElement(),
            modal: false,
            positionStrategy: new SelectPositioningStrategy(this),
            scrollStrategy: new AbsoluteScrollStrategy(),
            excludeFromOutsideClick: [this.inputGroup.element.nativeElement]
        };
        const changes$ = this.children.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.setSelection(this.items.find(x => x.value === this.value));
            this.cdr.detectChanges();
        });
        Promise.resolve().then(() => {
            if (!changes$.closed) {
                this.children.notifyOnChanges();
            }
        });
    }
    navigate(direction, currentIndex) {
        if (this.collapsed && this.selectedItem) {
            this.navigateItem(this.selectedItem.itemIndex);
        }
        super.navigate(direction, currentIndex);
    }
    manageRequiredAsterisk() {
        const hasRequiredHTMLAttribute = this.elementRef.nativeElement.hasAttribute('required');
        if (this.ngControl && this.ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            const error = this.ngControl.control.validator({});
            this.inputGroup.isRequired = error && error.required;
            this.cdr.markForCheck();
            // If validator is dynamically cleared and no required HTML attribute is set,
            // reset label's required class(asterisk) and IgxInputState #6896
        }
        else if (this.inputGroup.isRequired && this.ngControl && !this.ngControl.control.validator && !hasRequiredHTMLAttribute) {
            this.input.valid = IgxInputState.INITIAL;
            this.inputGroup.isRequired = false;
            this.cdr.markForCheck();
        }
    }
    setSelection(item) {
        if (item && item.value !== undefined && item.value !== null) {
            this.selection.set(this.id, new Set([item]));
        }
        else {
            this.selection.clear(this.id);
        }
    }
    /**
     * Event handlers
     * @hidden @internal
     */
    handleOpening(event) {
        const args = { cancel: event.cancel };
        this.onOpening.emit(args);
        event.cancel = args.cancel;
        if (args.cancel) {
            return;
        }
        this.scrollToItem(this.selectedItem);
    }
    /** @hidden @internal */
    handleOpened() {
        this.updateItemFocus();
        this.onOpened.emit();
    }
    /** @hidden @internal */
    handleClosing(event) {
        const args = { cancel: event.cancel };
        this.onClosing.emit(args);
        event.cancel = args.cancel;
    }
    /** @hidden @internal */
    handleClosed() {
        this.focusItem(false);
        this.onClosed.emit();
    }
    /** @hidden @internal */
    onBlur() {
        this._onTouchedCallback();
        if (this.ngControl && !this.ngControl.valid) {
            this.input.valid = IgxInputState.INVALID;
        }
        else {
            this.input.valid = IgxInputState.INITIAL;
        }
    }
    /** @hidden @internal */
    onFocus() {
        this._onTouchedCallback();
    }
    onStatusChanged() {
        if ((this.ngControl.control.touched || this.ngControl.control.dirty) &&
            (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {
            if (this.inputGroup.isFocused) {
                this.input.valid = this.ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
            }
            else {
                this.input.valid = this.ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
            }
        }
        this.manageRequiredAsterisk();
    }
    /**
     * @hidden @internal
     */
    ngOnInit() {
        this.ngControl = this._injector.get(NgControl, null);
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        if (this.ngControl) {
            this.ngControl.statusChanges.pipe(takeUntil(this.destroy$)).subscribe(this.onStatusChanged.bind(this));
            this.manageRequiredAsterisk();
        }
        this.cdr.detectChanges();
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
        this.selection.clear(this.id);
    }
    /**
     * @hidden @internal
     * Prevent input blur - closing the items container on Header/Footer Template click.
     */
    mousedownHandler(event) {
        event.preventDefault();
    }
}
IgxSelectComponent.ɵfac = function IgxSelectComponent_Factory(t) { return new (t || IgxSelectComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxSelectionAPIService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(IGX_INPUT_GROUP_TYPE, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
IgxSelectComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSelectComponent, selectors: [["igx-select"]], contentQueries: function IgxSelectComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSelectToggleIconDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSelectHeaderDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSelectFooterDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxHintDirective, true, ElementRef);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, IgxLabelDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSelectItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleIconTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hintElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.label = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, viewQuery: function IgxSelectComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c59, true, IgxInputGroupComponent);
        ɵngcc0.ɵɵstaticViewQuery(_c77, true, IgxInputDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 2, hostBindings: function IgxSelectComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("max-height", ctx.maxHeight);
    } }, inputs: { disabled: "disabled", value: "value", type: "type", placeholder: "placeholder", overlaySettings: "overlaySettings" }, outputs: { onOpening: "onOpening", onOpened: "onOpened", onClosing: "onClosing", onClosed: "onClosed" }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NG_VALUE_ACCESSOR, useExisting: IgxSelectComponent, multi: true },
            { provide: IGX_DROPDOWN_BASE, useExisting: IgxSelectComponent }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c79, decls: 21, vars: 18, consts: [[1, "input-group", 3, "type", "displayDensity", "click"], ["inputGroup", ""], ["ngProjectAs", "[igxLabel]", 5, ["", "igxLabel", ""]], ["ngProjectAs", "igx-prefix", 5, ["igx-prefix"]], ["type", "text", "igxInput", "", "readonly", "true", "role", "combobox", "aria-haspopup", "listbox", 1, "input", 3, "igxSelectItemNavigation", "disabled", "value", "blur", "focus"], ["input", ""], ["ngProjectAs", "igx-suffix", 5, ["igx-suffix"]], [4, "ngIf"], ["fontSet", "material", 4, "ngIf"], ["ngProjectAs", "igx-hint, [igxHint]", 5, ["igx-hint"]], ["igxToggle", "", 1, "igx-drop-down__list", 3, "mousedown", "onOpening", "onOpened", "onClosing", "onClosed"], ["class", "igx-drop-down__select-header", 4, "ngIf"], ["unselectable", "on", "role", "listbox", 1, "igx-drop-down__list-scroll"], ["scrollContainer", ""], ["class", "igx-drop-down__select-footer", 4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["fontSet", "material"], [1, "igx-drop-down__select-header"], [4, "ngTemplateOutlet"], [1, "igx-drop-down__select-footer"]], template: function IgxSelectComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c78);
        ɵngcc0.ɵɵelementStart(0, "igx-input-group", 0, 1);
        ɵngcc0.ɵɵlistener("click", function IgxSelectComponent_Template_igx_input_group_click_0_listener($event) { return ctx.inputGroupClick($event); });
        ɵngcc0.ɵɵelementContainerStart(2, 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementContainerStart(4, 3);
        ɵngcc0.ɵɵprojection(5, 1);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(6, "input", 4, 5);
        ɵngcc0.ɵɵlistener("blur", function IgxSelectComponent_Template_input_blur_6_listener() { return ctx.onBlur(); })("focus", function IgxSelectComponent_Template_input_focus_6_listener() { return ctx.onFocus(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerStart(8, 6);
        ɵngcc0.ɵɵprojection(9, 2);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(10, "igx-suffix");
        ɵngcc0.ɵɵtemplate(11, IgxSelectComponent_ng_container_11_Template, 2, 4, "ng-container", 7);
        ɵngcc0.ɵɵtemplate(12, IgxSelectComponent_igx_icon_12_Template, 2, 1, "igx-icon", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerStart(13, 9);
        ɵngcc0.ɵɵprojection(14, 3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(15, "div", 10);
        ɵngcc0.ɵɵlistener("mousedown", function IgxSelectComponent_Template_div_mousedown_15_listener($event) { return ctx.mousedownHandler($event); })("onOpening", function IgxSelectComponent_Template_div_onOpening_15_listener($event) { return ctx.handleOpening($event); })("onOpened", function IgxSelectComponent_Template_div_onOpened_15_listener() { return ctx.handleOpened(); })("onClosing", function IgxSelectComponent_Template_div_onClosing_15_listener($event) { return ctx.handleClosing($event); })("onClosed", function IgxSelectComponent_Template_div_onClosed_15_listener() { return ctx.handleClosed(); });
        ɵngcc0.ɵɵtemplate(16, IgxSelectComponent_div_16_Template, 2, 1, "div", 11);
        ɵngcc0.ɵɵelementStart(17, "div", 12, 13);
        ɵngcc0.ɵɵprojection(19, 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(20, IgxSelectComponent_div_20_Template, 2, 1, "div", 14);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("type", ctx.type)("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("igxSelectItemNavigation", ctx)("disabled", ctx.disabled)("value", ctx.selectionValue);
        ɵngcc0.ɵɵattribute("placeholder", ctx.placeholder)("aria-labelledby", ctx.label == null ? null : ctx.label.id)("aria-expanded", !ctx.collapsed)("aria-owns", ctx.listId)("aria-activedescendant", !ctx.collapsed ? ctx.focusedItem == null ? null : ctx.focusedItem.id : null);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.toggleIconTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.toggleIconTemplate);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.headerTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("max-height", ctx.maxHeight);
        ɵngcc0.ɵɵattribute("id", ctx.listId)("aria-labelledby", ctx.label == null ? null : ctx.label.id);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.footerTemplate);
    } }, directives: function () { return [IgxInputGroupComponent, IgxInputDirective, IgxSelectItemNavigationDirective, IgxSuffixDirective, ɵngcc2.NgIf, IgxToggleDirective, ɵngcc2.NgTemplateOutlet, IgxIconComponent]; }, styles: [_c80] });
IgxSelectComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxSelectionAPIService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [IGX_INPUT_GROUP_TYPE,] }] },
    { type: Injector }
];
IgxSelectComponent.propDecorators = {
    inputGroup: [{ type: ViewChild, args: ['inputGroup', { read: IgxInputGroupComponent, static: true },] }],
    input: [{ type: ViewChild, args: ['input', { read: IgxInputDirective, static: true },] }],
    hintElement: [{ type: ContentChild, args: [IgxHintDirective, { read: ElementRef },] }],
    children: [{ type: ContentChildren, args: [forwardRef(() => IgxSelectItemComponent), { descendants: true },] }],
    label: [{ type: ContentChild, args: [forwardRef(() => IgxLabelDirective), { static: true },] }],
    value: [{ type: Input }],
    placeholder: [{ type: Input }],
    disabled: [{ type: Input }],
    overlaySettings: [{ type: Input }],
    maxHeight: [{ type: HostBinding, args: ['style.maxHeight',] }],
    type: [{ type: Input }],
    onOpening: [{ type: Output }],
    onOpened: [{ type: Output }],
    onClosing: [{ type: Output }],
    onClosed: [{ type: Output }],
    toggleIconTemplate: [{ type: ContentChild, args: [IgxSelectToggleIconDirective, { read: TemplateRef },] }],
    headerTemplate: [{ type: ContentChild, args: [IgxSelectHeaderDirective, { read: TemplateRef, static: false },] }],
    footerTemplate: [{ type: ContentChild, args: [IgxSelectFooterDirective, { read: TemplateRef, static: false },] }]
};

/** @hidden @internal */
class IgxSelectItemNavigationDirective extends IgxDropDownItemNavigationDirective {
    constructor() {
        super(null);
        this._target = null;
        // tslint:disable:member-ordering
        this.inputStream = '';
        this.clearStream$ = Subscription.EMPTY;
    }
    get target() {
        return this._target;
    }
    set target(target) {
        this._target = target ? target : this.dropdown;
    }
    /** Captures keydown events and calls the appropriate handlers on the target component */
    handleKeyDown(event) {
        if (!event) {
            return;
        }
        const key = event.key.toLowerCase();
        if (event.altKey && (key === 'arrowdown' || key === 'arrowup' || key === 'down' || key === 'up')) {
            this.target.toggle();
            return;
        }
        if (this.target.collapsed) {
            switch (key) {
                case 'space':
                case 'spacebar':
                case ' ':
                case 'enter':
                    event.preventDefault();
                    this.target.open();
                    return;
                case 'arrowdown':
                case 'down':
                    this.target.navigateNext();
                    this.target.selectItem(this.target.focusedItem);
                    event.preventDefault();
                    return;
                case 'arrowup':
                case 'up':
                    this.target.navigatePrev();
                    this.target.selectItem(this.target.focusedItem);
                    event.preventDefault();
                    return;
                default:
                    break;
            }
        }
        else if (key === 'tab' || event.shiftKey && key === 'tab') {
            this.target.close();
        }
        super.handleKeyDown(event);
    }
    /** Handle continuous letter typing navigation */
    captureKey(event) {
        // relying only on key, available on all major browsers:
        // https://caniuse.com/#feat=keyboardevent-key (IE/Edge quirk doesn't affect letter typing)
        if (!event || !event.key || event.key.length > 1) {
            // ignore longer keys ('Alt', 'ArrowDown', etc)
            return;
        }
        this.clearStream$.unsubscribe();
        this.clearStream$ = timer(500).subscribe(() => {
            this.inputStream = '';
        });
        this.inputStream += event.key;
        const focusedItem = this.target.focusedItem;
        // select the item
        if (focusedItem && this.inputStream.length > 1 && focusedItem.itemText.toLowerCase().startsWith(this.inputStream.toLowerCase())) {
            return;
        }
        this.activateItemByText(this.inputStream);
    }
    activateItemByText(text) {
        const items = this.target.items;
        const activeItemIndex = items.indexOf(this.target.focusedItem) || 0;
        // ^ this is focused OR selected if the dd is closed
        let nextItem = items.slice(activeItemIndex + 1).find(x => !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase())));
        if (!nextItem) {
            nextItem = items.slice(0, activeItemIndex).find(x => !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase())));
        }
        if (!nextItem) {
            return;
        }
        if (this.target.collapsed) {
            this.target.selectItem(nextItem);
        }
        this.target.navigateItem(items.indexOf(nextItem));
    }
    ngOnDestroy() {
        this.clearStream$.unsubscribe();
    }
}
IgxSelectItemNavigationDirective.ɵfac = function IgxSelectItemNavigationDirective_Factory(t) { return new (t || IgxSelectItemNavigationDirective)(); };
IgxSelectItemNavigationDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSelectItemNavigationDirective, selectors: [["", "igxSelectItemNavigation", ""]], hostBindings: function IgxSelectItemNavigationDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup", function IgxSelectItemNavigationDirective_keyup_HostBindingHandler($event) { return ctx.captureKey($event); });
    } }, inputs: { target: ["igxSelectItemNavigation", "target"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxSelectItemNavigationDirective.ctorParameters = () => [];
IgxSelectItemNavigationDirective.propDecorators = {
    target: [{ type: Input, args: ['igxSelectItemNavigation',] }],
    captureKey: [{ type: HostListener, args: ['keyup', ['$event'],] }]
};

/**
 * The `<igx-select-item>` is a container intended for row items in
 * a `<igx-select>` container.
 */
class IgxSelectGroupComponent extends IgxDropDownGroupComponent {
}
IgxSelectGroupComponent.ɵfac = function IgxSelectGroupComponent_Factory(t) { return ɵIgxSelectGroupComponent_BaseFactory(t || IgxSelectGroupComponent); };
IgxSelectGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSelectGroupComponent, selectors: [["igx-select-item-group"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c82, decls: 3, vars: 2, consts: [[3, "id"]], template: function IgxSelectGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c81);
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵpropertyInterpolate("id", ctx.labelId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
    } }, encapsulation: 2 });

/** @hidden */
class IgxSelectModule {
}
IgxSelectModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxSelectModule });
IgxSelectModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxSelectModule_Factory(t) { return new (t || IgxSelectModule)(); }, providers: [], imports: [[
            CommonModule,
            FormsModule,
            IgxButtonModule,
            IgxDropDownModule,
            IgxIconModule,
            IgxInputGroupModule,
            IgxRippleModule,
            IgxToggleModule,
            ReactiveFormsModule
        ]] });

/**
 * @hidden
 */
function WatchChanges() {
    return (target, key, propDesc) => {
        const privateKey = '_' + key.toString();
        propDesc = propDesc || {
            configurable: true,
            enumerable: true,
        };
        propDesc.get = propDesc.get || (function () { return this[privateKey]; });
        const originalSetter = propDesc.set || (function (val) { this[privateKey] = val; });
        propDesc.set = function (val) {
            const init = this._init;
            const oldValue = this[key];
            if (val !== oldValue || (typeof val === 'object' && val === oldValue)) {
                originalSetter.call(this, val);
                if (this.ngOnChanges && !init) {
                    // in case wacthed prop changes trigger ngOnChanges manually
                    const changes = {
                        [key]: new SimpleChange(oldValue, val, false)
                    };
                    this.ngOnChanges(changes);
                }
            }
        };
        return propDesc;
    };
}
function WatchColumnChanges() {
    return (target, key, propDesc) => {
        const privateKey = '_' + key.toString();
        propDesc = propDesc || {
            configurable: true,
            enumerable: true,
        };
        propDesc.get = propDesc.get || (function () { return this[privateKey]; });
        const originalSetter = propDesc.set || (function (val) { this[privateKey] = val; });
        propDesc.set = function (val) {
            const oldValue = this[key];
            originalSetter.call(this, val);
            if (val !== oldValue || (typeof val === 'object' && val === oldValue)) {
                if (this.onColumnChange) {
                    this.onColumnChange.emit();
                }
            }
        };
        return propDesc;
    };
}
function notifyChanges(repaint = false) {
    return (_, key, propDesc) => {
        const privateKey = `__${key}`;
        propDesc = propDesc || {
            enumerable: true,
            configurable: true
        };
        const originalSetter = propDesc ? propDesc.set : null;
        propDesc.get = propDesc.get || (function () { return this[privateKey]; });
        propDesc.set = function (newValue) {
            if (originalSetter) {
                originalSetter.call(this, newValue);
                if (this.grid) {
                    this.grid.notifyChanges(repaint);
                }
            }
            else {
                if (newValue === this[key]) {
                    return;
                }
                this[privateKey] = newValue;
                if (this.grid) {
                    this.grid.notifyChanges(repaint);
                }
            }
        };
        return propDesc;
    };
}

const clear = (el) => el === 0 || Boolean(el);
const ɵ0$8 = clear;
const first = (arr) => arr[0];
const ɵ1$1 = first;
const last = (arr) => arr[arr.length - 1];
const ɵ2 = last;
class IgxSummaryOperand {
    /**
     * Counts all the records in the data source.
     * If filtering is applied, counts only the filtered records.
     * ```typescript
     * IgxSummaryOperand.count(dataSource);
     * ```
     * @memberof IgxSummaryOperand
     */
    static count(data) {
        return data.length;
    }
    /**
     * Executes the static `count` method and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomSummary extends IgxSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "test",
     *       label: "Test",
     *       summaryResult: IgxSummaryOperand.count(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomSummary;
     * ```
     * @memberof IgxSummaryOperand
     */
    operate(data = [], allData = [], fieldName, locale = 'en-US') {
        const pipe = new DecimalPipe(locale);
        return [{
                key: 'count',
                label: 'Count',
                summaryResult: pipe.transform(IgxSummaryOperand.count(data))
            }];
    }
}
// @dynamic
class IgxNumberSummaryOperand extends IgxSummaryOperand {
    /**
     * Returns the minimum numeric value in the provided data records.
     * If filtering is applied, returns the minimum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.min(data);
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    static min(data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => Math.min(a, b)) : 0;
    }
    /**
     * Returns the maximum numeric value in the provided data records.
     * If filtering is applied, returns the maximum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.max(data);
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    static max(data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => Math.max(a, b)) : 0;
    }
    /**
     * Returns the sum of the numeric values in the provided data records.
     * If filtering is applied, returns the sum of the numeric values in the data records.
     * ```typescript
     * IgxNumberSummaryOperand.sum(data);
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    static sum(data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => +a + +b) : 0;
    }
    /**
     * Returns the average numeric value in the data provided data records.
     * If filtering is applied, returns the average numeric value in the filtered data records.
     * ```typescript
     * IgxSummaryOperand.average(data);
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    static average(data) {
        return data.length && data.filter(clear).length ? this.sum(data) / this.count(data) : 0;
    }
    /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomNumberSummary extends IgxNumberSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data: any[], allData: any[], fieldName: string, locale: string, pipeArgs: IColumnPipeArgs): IgxSummaryResult[] {
     *     pipeArgs.digitsInfo = '1.1-2';
     *     const result = super.operate(data, allData, fieldName, locale, pipeArgs);
     *     result.push({
     *       key: "avg",
     *       label: "Avg",
     *       summaryResult: IgxNumberSummaryOperand.average(data)
     *     });
     *     result.push({
     *       key: 'mdn',
     *       label: 'Median',
     *       summaryResult: this.findMedian(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomNumberSummary;
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    operate(data = [], allData = [], fieldName, locale = 'en-US', pipeArgs = {}) {
        const result = super.operate(data, allData, fieldName, locale);
        const pipe = new DecimalPipe(locale);
        result.push({
            key: 'min',
            label: 'Min',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.min(data), pipeArgs.digitsInfo)
        });
        result.push({
            key: 'max',
            label: 'Max',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.max(data), pipeArgs.digitsInfo)
        });
        result.push({
            key: 'sum',
            label: 'Sum',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.sum(data), pipeArgs.digitsInfo)
        });
        result.push({
            key: 'average',
            label: 'Avg',
            summaryResult: pipe.transform(IgxNumberSummaryOperand.average(data), pipeArgs.digitsInfo)
        });
        return result;
    }
}
// @dynamic
class IgxDateSummaryOperand extends IgxSummaryOperand {
    /**
     * Returns the latest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.latest(data);
     * ```
     * @memberof IgxDateSummaryOperand
     */
    static latest(data) {
        return data.length && data.filter(clear).length ?
            first(data.filter(clear).sort((a, b) => new Date(b).valueOf() - new Date(a).valueOf())) : undefined;
    }
    /**
     * Returns the earliest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.earliest(data);
     * ```
     * @memberof IgxDateSummaryOperand
     */
    static earliest(data) {
        return data.length && data.filter(clear).length ?
            last(data.filter(clear).sort((a, b) => new Date(b).valueOf() - new Date(a).valueOf())) : undefined;
    }
    /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomDateSummary extends IgxDateSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data: any[], allData: any[], fieldName: string, locale: string, pipeArgs: IColumnPipeArgs): IgxSummaryResult[] {
     *     pipeArgs = {
     *        format: 'longDate',
     *        timezone: 'UTC'
     *     };
     *     const result = super.operate(data, allData, fieldName, locale, pipeArgs);
     *     result.push({
     *       key: "deadline",
     *       label: "Deadline Date",
     *       summaryResult: this.calculateDeadline(data);
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomDateSummary;
     * ```
     * @memberof IgxDateSummaryOperand
     */
    operate(data = [], allData = [], fieldName, locale = 'en-US', pipeArgs = {}) {
        const result = super.operate(data, allData, fieldName, locale);
        const pipe = new DatePipe(locale);
        result.push({
            key: 'earliest',
            label: 'Earliest',
            summaryResult: pipe.transform(IgxDateSummaryOperand.earliest(data), pipeArgs.format, pipeArgs.timezone)
        });
        result.push({
            key: 'latest',
            label: 'Latest',
            summaryResult: pipe.transform(IgxDateSummaryOperand.latest(data), pipeArgs.format, pipeArgs.timezone)
        });
        return result;
    }
}

class IgxFilterCellTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxFilterCellTemplateDirective.ɵfac = function IgxFilterCellTemplateDirective_Factory(t) { return new (t || IgxFilterCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxFilterCellTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxFilterCellTemplateDirective, selectors: [["", "igxFilterCellTemplate", ""]] });
IgxFilterCellTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxCellTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCellTemplateDirective.ɵfac = function IgxCellTemplateDirective_Factory(t) { return new (t || IgxCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCellTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCellTemplateDirective, selectors: [["", "igxCell", ""]] });
IgxCellTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxCellHeaderTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCellHeaderTemplateDirective.ɵfac = function IgxCellHeaderTemplateDirective_Factory(t) { return new (t || IgxCellHeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCellHeaderTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCellHeaderTemplateDirective, selectors: [["", "igxHeader", ""]] });
IgxCellHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
class IgxCellFooterTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCellFooterTemplateDirective.ɵfac = function IgxCellFooterTemplateDirective_Factory(t) { return new (t || IgxCellFooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCellFooterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCellFooterTemplateDirective, selectors: [["", "igxFooter", ""]] });
IgxCellFooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxCellEditorTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCellEditorTemplateDirective.ɵfac = function IgxCellEditorTemplateDirective_Factory(t) { return new (t || IgxCellEditorTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCellEditorTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCellEditorTemplateDirective, selectors: [["", "igxCellEditor", ""]] });
IgxCellEditorTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxCollapsibleIndicatorTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxCollapsibleIndicatorTemplateDirective.ɵfac = function IgxCollapsibleIndicatorTemplateDirective_Factory(t) { return new (t || IgxCollapsibleIndicatorTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCollapsibleIndicatorTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCollapsibleIndicatorTemplateDirective, selectors: [["", "igxCollapsibleIndicator", ""]] });
IgxCollapsibleIndicatorTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * This enumeration is used to configure whether the drop position is set before or after
 * the target.
 */
var DropPosition;
(function (DropPosition) {
    DropPosition[DropPosition["BeforeDropTarget"] = 0] = "BeforeDropTarget";
    DropPosition[DropPosition["AfterDropTarget"] = 1] = "AfterDropTarget";
})(DropPosition || (DropPosition = {}));
/**
 * @hidden
 * @internal
 */
class IgxColumnMovingService {
    get column() {
        return this._column;
    }
    set column(val) {
        if (val) {
            this._column = val;
        }
    }
    get icon() {
        return this._icon;
    }
    set icon(val) {
        if (val) {
            this._icon = val;
        }
    }
}
IgxColumnMovingService.ɵfac = function IgxColumnMovingService_Factory(t) { return new (t || IgxColumnMovingService)(); };
IgxColumnMovingService.ɵprov = ɵɵdefineInjectable({ factory: function IgxColumnMovingService_Factory() { return new IgxColumnMovingService(); }, token: IgxColumnMovingService, providedIn: "root" });

const DEFAULT_DATE_FORMAT = 'mediumDate';
const DEFAULT_DIGITS_INFO = '1.0-3';
/**
 * **Ignite UI for Angular Column** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid#columns-configuration)
 *
 * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
 * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
 * the column using `ng-template` which will be used for all cells within the column.
 */
class IgxColumnComponent {
    constructor(gridAPI, cdr) {
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        /**
         * Sets/gets the `header` value.
         * ```typescript
         * let columnHeader = this.column.header;
         * ```
         * ```html
         * <igx-column [header] = "'ID'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.header = '';
        /**
         * Sets/gets the `title` value.
         * ```typescript
         * let title = this.column.title;
         * ```
         * ```html
         * <igx-column [title] = "'Some column tooltip'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.title = '';
        /**
         * Sets/gets whether the column is sortable.
         * Default value is `false`.
         * ```typescript
         * let isSortable = this.column.sortable;
         * ```
         * ```html
         * <igx-column [sortable] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.sortable = false;
        /**
         * Sets/gets whether the column is groupable.
         * Default value is `false`.
         * ```typescript
         * let isGroupable = this.column.groupable;
         * ```
         * ```html
         * <igx-column [groupable] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.groupable = false;
        /**
         * Sets/gets whether the column is filterable.
         * Default value is `true`.
         * ```typescript
         * let isFilterable = this.column.filterable;
         * ```
         * ```html
         * <igx-column [filterable] = "false"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.filterable = true;
        /**
         * Sets/gets whether the column is resizable.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.resizable = false;
        /**
         * @hidden
         */
        this.hiddenChange = new EventEmitter();
        /** @hidden */
        this.expandedChange = new EventEmitter();
        /** @hidden */
        this.collapsibleChange = new EventEmitter();
        /** @hidden */
        this.visibleWhenCollapsedChange = new EventEmitter();
        /** @hidden */
        this.onColumnChange = new EventEmitter();
        /**
         * Gets whether the hiding is disabled.
         * ```typescript
         * let isHidingDisabled =  this.column.disableHiding;
         * ```
         * @memberof IgxColumnComponent
         */
        this.disableHiding = false;
        /**
         * Gets whether the pinning is disabled.
         * ```typescript
         * let isPinningDisabled =  this.column.disablePinning;
         * ```
         * @memberof IgxColumnComponent
         */
        this.disablePinning = false;
        /**
         * Sets/gets whether the column is movable.
         * Default value is `false`.
         * ```typescript
         * let isMovable = this.column.movable;
         * ```
         * ```html
         * <igx-column [movable] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.movable = false;
        /**
         * @hidden
         */
        this.widthChange = new EventEmitter();
        this._calcWidth = null;
        /**
         * @hidden
         */
        this._applySelectableClass = false;
        /**
         * Sets/gets the class selector of the column header.
         * ```typescript
         * let columnHeaderClass = this.column.headerClasses;
         * ```
         * ```html
         * <igx-column [headerClasses] = "'column-header'"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.headerClasses = '';
        /**
         * Sets/gets the class selector of the column group header.
         * ```typescript
         * let columnHeaderClass = this.column.headerGroupClasses;
         * ```
         * ```html
         * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.headerGroupClasses = '';
        /**
         * Sets conditional style properties on the column cells.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * As with `cellClasses` it accepts a callback function.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') : 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [cellStyles]="styles"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.cellStyles = null;
        /**
         * Sets/gets whether the column filtering should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let filteringIgnoreCase = this.column.filteringIgnoreCase;
         * ```
         * ```html
         * <igx-column [filteringIgnoreCase] = "false"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.filteringIgnoreCase = true;
        /**
         * Sets/gets whether the column sorting should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let sortingIgnoreCase = this.column.sortingIgnoreCase;
         * ```
         * ```html
         * <igx-column [sortingIgnoreCase] = "false"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.sortingIgnoreCase = true;
        /**
         * Sets/gets the data type of the column values.
         * Default value is `string`.
         * ```typescript
         * let columnDataType = this.column.dataType;
         * ```
         * ```html
         * <igx-column [dataType] = "'number'"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.dataType = DataType.String;
        /**
         * @hidden
         */
        this.pinnedChange = new EventEmitter();
        /**
         * Sets/gets whether the column is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.column.searchable';
         * ```
         * ```html
         *  <igx-column [searchable] = "false"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.searchable = true;
        this._columnPipeArgs = { format: DEFAULT_DATE_FORMAT, digitsInfo: DEFAULT_DIGITS_INFO };
        /**
         * Sets/gets the parent column.
         * ```typescript
         * let parentColumn = this.column.parent;
         * ```
         * ```typescript
         * this.column.parent = higherLevelColumn;
         * ```
         * @memberof IgxColumnComponent
         */
        this.parent = null;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        /**
         * @hidden
         */
        this._pinned = false;
        /**
         * @hidden
         */
        this._summaries = null;
        /**
         * @hidden
         */
        this._filters = null;
        /**
         * @hidden
         */
        this._sortStrategy = DefaultSortingStrategy.instance();
        /**
         * @hidden
         */
        this._hidden = false;
        /**
         * @hidden
         */
        this._disablePinning = false;
        /**
         * @hidden
         */
        this._defaultMinWidth = '';
        /**
         * @hidden
         */
        this._hasSummary = false;
        /**
         * @hidden
         */
        this._collapsible = false;
        /**
         * @hidden
         */
        this._expanded = true;
        /**
         * @hidden
         */
        this._selectable = true;
        this._vIndex = NaN;
    }
    /**
     * Returns if the column is selectable.
     * ```typescript
     * let columnSelectable = this.column.selectable;
     * ```
     * @memberof IgxColumnComponent
     */
    get selectable() {
        return this._selectable;
    }
    /**
     * Sets if the column is selectable.
     * Default value is `true`.
     * ```html
     * <igx-column [selectable] = "false"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set selectable(value) {
        this._selectable = value;
    }
    /**
     * Gets whether the column is editable.
     * Default value is `false`.
     * ```typescript
     * let isEditable = this.column.editable;
     * ```
     * @memberof IgxColumnComponent
     */
    get editable() {
        // Updating the primary key when grid has transactions (incl. row edit)
        // should not be allowed, as that can corrupt transaction state.
        const rowEditable = this.grid && this.grid.rowEditable;
        const hasTransactions = this.grid && this.grid.transactions.enabled;
        if (this.isPrimaryColumn && (rowEditable || hasTransactions)) {
            return false;
        }
        if (this._editable !== undefined) {
            return this._editable;
        }
        else {
            return rowEditable;
        }
    }
    /**
     * Sets whether the column is editable.
     * ```typescript
     * this.column.editable = true;
     * ```
     * ```html
     * <igx-column [editable] = "true"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set editable(editable) {
        this._editable = editable;
    }
    /**
     * Gets a value indicating whether the summary for the column is enabled.
     * ```typescript
     * let hasSummary = this.column.hasSummary;
     * ```
     * @memberof IgxColumnComponent
     */
    get hasSummary() {
        return this._hasSummary;
    }
    /**
     * Sets a value indicating whether the summary for the column is enabled.
     * Default value is `false`.
     * ```html
     * <igx-column [hasSummary] = "true"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set hasSummary(value) {
        this._hasSummary = value;
        if (this.grid) {
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets whether the column is hidden.
     * ```typescript
     * let isHidden = this.column.hidden;
     * ```
     * @memberof IgxColumnComponent
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column hidden property.
     * Default value is `false`.
     * ```html
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(hidden)] = "model.isHidden"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set hidden(value) {
        if (this._hidden !== value) {
            this._hidden = value;
            this.hiddenChange.emit(this._hidden);
            if (this.columnLayoutChild && this.parent.hidden !== value) {
                this.parent.hidden = value;
                return;
            }
            if (this.grid) {
                this.grid.endEdit(false);
                this.grid.summaryService.resetSummaryHeight();
                this.grid.filteringService.refreshExpressions();
                this.grid.filteringService.hideFilteringRowOnColumnVisibilityChange(this);
                this.grid.notifyChanges();
            }
        }
    }
    /**
     * Returns if the column is selected.
     * ```typescript
     * let isSelected = this.column.selected;
     * ```
     * @memberof IgxColumnComponent
     */
    get selected() {
        return this.grid.selectionService.isColumnSelected(this.field);
    }
    /**
     * Select/deselect a column.
     * Default value is `false`.
     * ```typescript
     * this.column.selected = true;
     * ```
     * @memberof IgxColumnComponent
     */
    set selected(value) {
        if (this.selectable && value !== this.selected) {
            value ? this.grid.selectionService.selectColumnsWithNoEvent([this.field]) :
                this.grid.selectionService.deselectColumnsWithNoEvent([this.field]);
            this.grid.notifyChanges();
        }
    }
    /**
     * Gets the `width` of the column.
     * ```typescript
     * let columnWidth = this.column.width;
     * ```
     * @memberof IgxColumnComponent
     */
    get width() {
        return this.widthSetByUser ? this._width : this.defaultWidth;
    }
    /**
     * Sets the `width` of the column.
     * ```html
     * <igx-column [width] = "'25%'"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(width)]="model.columns[0].width"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set width(value) {
        if (value) {
            this._calcWidth = null;
            this.calcPixelWidth = NaN;
            this.widthSetByUser = true;
            // width could be passed as number from the template
            // host bindings are not px affixed so we need to ensure we affix simple number strings
            if (typeof (value) === 'number' || value.match(/^[0-9]*$/)) {
                value = value + 'px';
            }
            this._width = value;
            if (this.grid) {
                this.cacheCalcWidth();
            }
            this.widthChange.emit(this._width);
        }
    }
    /**
     * @hidden
     */
    get calcWidth() {
        return this.getCalcWidth();
    }
    /**
     * @hidden
     */
    get maxWidthPx() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.maxWidth) / 100 * gridAvailableSize : parseFloat(this.maxWidth);
    }
    /**
     * @hidden
     */
    get maxWidthPercent() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.maxWidth) : parseFloat(this.maxWidth) / gridAvailableSize * 100;
    }
    /**
     * @hidden
     */
    get minWidthPx() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.minWidth) / 100 * gridAvailableSize : parseFloat(this.minWidth);
    }
    /**
     * @hidden
     */
    get minWidthPercent() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.minWidth) : parseFloat(this.minWidth) / gridAvailableSize * 100;
    }
    /**
     * Sets/gets the minimum `width` of the column.
     * Default value is `88`;
     * ```typescript
     * let columnMinWidth = this.column.minWidth;
     * ```
     * ```html
     * <igx-column [minWidth] = "'100px'"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set minWidth(value) {
        const minVal = parseFloat(value);
        if (Number.isNaN(minVal)) {
            return;
        }
        this._defaultMinWidth = value;
    }
    get minWidth() {
        return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;
    }
    /**
     * Gets the column index.
     * ```typescript
     * let columnIndex = this.column.index;
     * ```
     * @memberof IgxColumnComponent
     */
    get index() {
        return this.grid.columns.indexOf(this);
    }
    /**
     * Gets whether the column is `pinned`.
     * ```typescript
     * let isPinned = this.column.pinned;
     * ```
     * @memberof IgxColumnComponent
     */
    get pinned() {
        return this._pinned;
    }
    /**
     * Sets whether the column is pinned.
     * Default value is `false`.
     * ```html
     * <igx-column [pinned] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(pinned)] = "model.columns[0].isPinned"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set pinned(value) {
        if (this._pinned !== value) {
            if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {
                value ? this.pin() : this.unpin();
                return;
            }
            /* No grid/width available at initialization. `initPinning` in the grid
               will re-init the group (if present)
            */
            this._unpinnedIndex = this.grid ? this.grid.columns.filter(x => !x.pinned).indexOf(this) : 0;
            this._pinned = value;
            this.pinnedChange.emit(this._pinned);
        }
    }
    /**
     * Gets the column `summaries`.
     * ```typescript
     * let columnSummaries = this.column.summaries;
     * ```
     * @memberof IgxColumnComponent
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column `summaries`.
     * ```typescript
     * this.column.summaries = IgxNumberSummaryOperand;
     * ```
     * @memberof IgxColumnComponent
     */
    set summaries(classRef) {
        this._summaries = new classRef();
        if (this.grid) {
            this.grid.summaryService.removeSummariesCachePerColumn(this.field);
            this.grid._summaryPipeTrigger++;
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets the column `filters`.
     * ```typescript
     * let columnFilters = this.column.filters'
     * ```
     * @memberof IgxColumnComponent
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column `filters`.
     * ```typescript
     * this.column.filters = IgxBooleanFilteringOperand.instance().
     * ```
     * @memberof IgxColumnComponent
     */
    set filters(instance) {
        this._filters = instance;
    }
    /**
     * Gets the column `sortStrategy`.
     * ```typescript
     * let sortStrategy = this.column.sortStrategy
     * ```
     * @memberof IgxColumnComponent
     */
    get sortStrategy() {
        return this._sortStrategy;
    }
    /**
     * Sets the column `sortStrategy`.
     * ```typescript
     * this.column.sortStrategy = new CustomSortingStrategy().
     * class CustomSortingStrategy extends SortingStrategy {...}
     * ```
     * @memberof IgxColumnComponent
     */
    set sortStrategy(classRef) {
        this._sortStrategy = classRef;
    }
    /**
     * Gets the function that compares values for grouping.
     * ```typescript
     * let groupingComparer = this.column.groupingComparer'
     * ```
     * @memberof IgxColumnComponent
     */
    get groupingComparer() {
        return this._groupingComparer;
    }
    /**
     * Sets a custom function to compare values for grouping.
     * Subsequent values in the sorted data that the function returns 0 for are grouped.
     * ```typescript
     * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
     * ```
     * @memberof IgxColumnComponent
     */
    set groupingComparer(funcRef) {
        this._groupingComparer = funcRef;
    }
    /**
     * Gets the default minimum `width` of the column.
     * ```typescript
     * let defaultMinWidth =  this.column.defaultMinWidth;
     * ```
     * @memberof IgxColumnComponent
     */
    get defaultMinWidth() {
        if (!this.grid) {
            return '80';
        }
        switch (this.grid.displayDensity) {
            case DisplayDensity.cosy:
                return '64';
            case DisplayDensity.compact:
                return '56';
            default:
                return '80';
        }
    }
    /**
     * The reference to the `igx-grid` owner.
     * ```typescript
     * let gridComponent = this.column.grid;
     * ```
     * @memberof IgxColumnComponent
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Returns a reference to the `bodyTemplate`.
     * ```typescript
     * let bodyTemplate = this.column.bodyTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * Sets the body template.
     * ```html
     * <ng-template #bodyTemplate igxCell let-val>
     *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
     *       <span> {{val}} </span>
     *    </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'bodyTemplate'", {read: TemplateRef })
     * public bodyTemplate: TemplateRef<any>;
     * this.column.bodyTemplate = this.bodyTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    set bodyTemplate(template) {
        this._bodyTemplate = template;
    }
    /**
     * Returns a reference to the header template.
     * ```typescript
     * let headerTemplate = this.column.headerTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    get headerTemplate() {
        return this._headerTemplate;
    }
    /**
     * Sets the header template.
     * Note that the column header height is fixed and any content bigger than it will be cut off.
     * ```html
     * <ng-template #headerTemplate>
     *   <div style = "background-color:black" (click) = "changeColor(val)">
     *       <span style="color:red" >{{column.field}}</span>
     *   </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'headerTemplate'", {read: TemplateRef })
     * public headerTemplate: TemplateRef<any>;
     * this.column.headerTemplate = this.headerTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    set headerTemplate(template) {
        this._headerTemplate = template;
    }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.column.inlineEditorTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * Sets the inline editor template.
     * ```html
     * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
     *     <input type="string" [(ngModel)]="cell.value"/>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
     * public inlineEditorTemplate: TemplateRef<any>;
     * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    set inlineEditorTemplate(template) {
        this._inlineEditorTemplate = template;
    }
    /**
     * Returns a reference to the `filterCellTemplate`.
     * ```typescript
     * let filterCellTemplate = this.column.filterCellTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    get filterCellTemplate() {
        return this._filterCellTemplate;
    }
    /**
     * Sets the quick filter template.
     * ```html
     * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
     *    <input (input)="onInput()">
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'filterCellTemplate'", {read: TemplateRef })
     * public filterCellTemplate: TemplateRef<any>;
     * this.column.filterCellTemplate = this.filterCellTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    set filterCellTemplate(template) {
        this._filterCellTemplate = template;
    }
    /**
     * Gets the cells of the column.
     * ```typescript
     * let columnCells =  this.column.cells;
     * ```
     * @memberof IgxColumnComponent
     */
    get cells() {
        return this.grid.rowList.filter((row) => row instanceof IgxRowDirective)
            .map((row) => {
            if (row.cells) {
                return row.cells.filter((cell) => cell.columnIndex === this.index);
            }
        }).reduce((a, b) => a.concat(b), []);
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     * @memberof IgxColumnComponent
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => !c.columnGroup);
        const pinnedColumns = this.grid.pinnedColumns.filter(c => !c.columnGroup);
        let col = this;
        let vIndex = -1;
        if (this.columnGroup) {
            col = this.allChildren.filter(c => !c.columnGroup && !c.hidden)[0];
        }
        if (this.columnLayoutChild) {
            return this.parent.childrenVisibleIndexes.find(x => x.column === this).index;
        }
        if (!this.pinned) {
            const indexInCollection = unpinnedColumns.indexOf(col);
            vIndex = indexInCollection === -1 ?
                -1 :
                (this.grid.isPinningToStart ?
                    pinnedColumns.length + indexInCollection :
                    indexInCollection);
        }
        else {
            const indexInCollection = pinnedColumns.indexOf(col);
            vIndex = this.grid.isPinningToStart ?
                indexInCollection :
                unpinnedColumns.length + indexInCollection;
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     * @memberof IgxColumnComponent
     */
    get columnGroup() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     * @memberof IgxColumnComponent
     */
    get columnLayout() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnLayoutChild =  this.column.columnLayoutChild;
     * ```
     * @memberof IgxColumnComponent
     */
    get columnLayoutChild() {
        return this.parent && this.parent.columnLayout;
    }
    /**
     * Returns the children columns collection.
     * Returns an empty array if the column does not contain children columns.
     * ```typescript
     * let childrenColumns =  this.column.allChildren;
     * ```
     * @memberof IgxColumnComponent
     */
    get allChildren() {
        return [];
    }
    /**
     * Returns the level of the column in a column group.
     * Returns `0` if the column doesn't have a `parent`.
     * ```typescript
     * let columnLevel =  this.column.level;
     * ```
     * @memberof IgxColumnComponent
     */
    get level() {
        let ptr = this.parent;
        let lvl = 0;
        while (ptr) {
            lvl++;
            ptr = ptr.parent;
        }
        return lvl;
    }
    get isLastPinned() {
        return this.grid.isPinningToStart &&
            this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
    }
    get isFirstPinned() {
        const pinnedCols = this.grid.pinnedColumns.filter(x => !x.columnGroup);
        return !this.grid.isPinningToStart && pinnedCols[0] === this;
    }
    get rightPinnedOffset() {
        return this.pinned && !this.grid.isPinningToStart ?
            -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' :
            null;
    }
    get gridRowSpan() {
        return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
    }
    get gridColumnSpan() {
        return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
    }
    /**
     * Indicates whether the column will be visible when its parent is collapsed.
     * ```html
     * <igx-column-group>
     *   <igx-column [visibleWhenCollapsed]="true"></igx-column>
     * </igx-column-group>
     * ```
     * @memberof IgxColumnComponent
     */
    set visibleWhenCollapsed(value) {
        this._visibleWhenCollapsed = value;
        this.visibleWhenCollapsedChange.emit(this._visibleWhenCollapsed);
        if (this.parent) {
            this.parent.setExpandCollapseState();
        }
    }
    get visibleWhenCollapsed() {
        return this._visibleWhenCollapsed;
    }
    /**
     * @remarks
     * Pass optional parameters for DatePipe and/or DecimalPipe to format the display value for date and numeric columns.
     * Accepts an `IColumnPipeArgs` object with any of the `format`, `timezone` and `digitsInfo` properties.
     * For more details see https://angular.io/api/common/DatePipe and https://angular.io/api/common/DecimalPipe
     * @example
     * ```typescript
     * const pipeArgs: IColumnPipeArgs = {
     *      format: 'longDate',
     *      timezone: 'UTC',
     *      digitsInfo: '1.1-2'
     * }
     * ```
     * ```html
     * <igx-column dataType="date" [pipeArgs]="pipeArgs"></igx-column>
     * <igx-column dataType="number" [pipeArgs]="pipeArgs"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set pipeArgs(value) {
        this._columnPipeArgs = Object.assign(this._columnPipeArgs, value);
        this.grid.summaryService.clearSummaryCache();
        this.grid._pipeTrigger++;
        this.grid.notifyChanges();
    }
    get pipeArgs() {
        return this._columnPipeArgs;
    }
    /**
     * @hidden
     * @internal
     */
    get collapsible() { return false; }
    set collapsible(_value) { }
    /**
     * @hidden
     * @internal
     */
    get expanded() { return true; }
    set expanded(_value) { }
    /**
     * Returns the filteringExpressionsTree of the column.
     * ```typescript
     * let tree =  this.column.filteringExpressionsTree;
     * ```
     * @memberof IgxColumnComponent
     */
    get filteringExpressionsTree() {
        return this.grid.filteringExpressionsTree.find(this.field);
    }
    /**
     * @hidden
     */
    get isPrimaryColumn() {
        return this.field !== undefined && this.grid !== undefined && this.field === this.grid.primaryKey;
    }
    /**
     * @hidden
     * @internal
     */
    resetCaches() {
        this._vIndex = NaN;
        if (this.grid) {
            this.cacheCalcWidth();
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.cellTemplate) {
            this._bodyTemplate = this.cellTemplate.template;
        }
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        if (this.editorTemplate) {
            this._inlineEditorTemplate = this.editorTemplate.template;
        }
        if (this.filterCellTemplateDirective) {
            this._filterCellTemplate = this.filterCellTemplateDirective.template;
        }
        if (!this.summaries) {
            switch (this.dataType) {
                case DataType.String:
                case DataType.Boolean:
                    this.summaries = IgxSummaryOperand;
                    break;
                case DataType.Number:
                    this.summaries = IgxNumberSummaryOperand;
                    break;
                case DataType.Date:
                    this.summaries = IgxDateSummaryOperand;
                    break;
                default:
                    this.summaries = IgxSummaryOperand;
                    break;
            }
        }
        if (!this.filters) {
            switch (this.dataType) {
                case DataType.Boolean:
                    this.filters = IgxBooleanFilteringOperand.instance();
                    break;
                case DataType.Number:
                    this.filters = IgxNumberFilteringOperand.instance();
                    break;
                case DataType.Date:
                    this.filters = IgxDateFilteringOperand.instance();
                    break;
                case DataType.String:
                default:
                    this.filters = IgxStringFilteringOperand.instance();
                    break;
            }
        }
    }
    /**
     * @hidden
     */
    getGridTemplate(isRow, isIE) {
        if (isRow) {
            const rowsCount = this.grid.multiRowLayoutRowSize;
            return isIE ?
                `(1fr)[${rowsCount}]` :
                `repeat(${rowsCount},1fr)`;
        }
        else {
            return this.getColumnSizesString(this.children);
        }
    }
    getInitialChildColumnSizes(children) {
        const columnSizes = [];
        // find the smallest col spans
        children.forEach(col => {
            if (!col.colStart) {
                return;
            }
            const newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            const newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
            const bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
            const bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            if (columnSizes[col.colStart - 1] === undefined) {
                // If nothing is defined yet take any column at first
                // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (newWidthSet || (newSpanSmaller && ((bothWidthsSet) || (bothWidthsNotSet)))) {
                // If a column is set already it should either not have width defined or have width with bigger span than the new one.
                /**
                 *  If replaced column has bigger span, we want to fill the remaining columns
                 *  that the replacing column does not fill with the old one.
                 */
                if (bothWidthsSet && newSpanSmaller) {
                    // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                    // We have not yet replaced it so we can use it directly from the columnSizes collection.
                    // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                    for (let i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                        if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                            columnSizes[i] = columnSizes[col.colStart - 1];
                        }
                        else {
                            break;
                        }
                    }
                }
                // Replace the old column with the new one.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
                // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
                // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
                // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
                for (let i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {
                    if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                        columnSizes[i] = {
                            ref: col,
                            width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                            colSpan: col.gridColumnSpan,
                            colEnd: col.colStart + col.gridColumnSpan,
                            widthSetByUser: col.widthSetByUser
                        };
                    }
                    else {
                        break;
                    }
                }
            }
        });
        // Flatten columnSizes so there are not columns with colSpan > 1
        for (let i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && columnSizes[i].colSpan > 1) {
                let j = 1;
                // Replace all empty places depending on how much the current column spans starting from next col.
                for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                    if (columnSizes[i + j] &&
                        ((!columnSizes[i].width && columnSizes[i + j].width) ||
                            (!columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan) ||
                            (!!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan))) {
                        // If we reach an already defined column that has width and the current doesn't have or
                        // if the reached column has bigger colSpan we stop.
                        break;
                    }
                    else {
                        const width = columnSizes[i].widthSetByUser ?
                            columnSizes[i].width / columnSizes[i].colSpan :
                            columnSizes[i].width;
                        columnSizes[i + j] = {
                            ref: columnSizes[i].ref,
                            width: width,
                            colSpan: 1,
                            colEnd: columnSizes[i].colEnd,
                            widthSetByUser: columnSizes[i].widthSetByUser
                        };
                    }
                }
                // Update the current column width so it is divided between all columns it spans and set it to 1.
                columnSizes[i].width = columnSizes[i].widthSetByUser ?
                    columnSizes[i].width / columnSizes[i].colSpan :
                    columnSizes[i].width;
                columnSizes[i].colSpan = 1;
                // Update the index based on how much we have replaced. Subtract 1 because we started from 1.
                i += j - 1;
            }
        }
        return columnSizes;
    }
    getFilledChildColumnSizes(children) {
        const columnSizes = this.getInitialChildColumnSizes(children);
        // fill the gaps if there are any
        const result = [];
        for (let i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && !!columnSizes[i].width) {
                result.push(columnSizes[i].width + 'px');
            }
            else {
                result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
            }
        }
        return result;
    }
    getColumnSizesString(children) {
        const res = this.getFilledChildColumnSizes(children);
        return res.join(' ');
    }
    getResizableColUnderEnd() {
        if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {
            return [{ target: this, spanUsed: 1 }];
        }
        const columnSized = this.getInitialChildColumnSizes(this.parent.children);
        const targets = [];
        const colEnd = this.colEnd ? this.colEnd : this.colStart + 1;
        for (let i = 0; i < columnSized.length; i++) {
            if (this.colStart <= i + 1 && i + 1 < colEnd) {
                targets.push({ target: columnSized[i].ref, spanUsed: 1 });
            }
        }
        const targetsSquashed = [];
        for (let j = 0; j < targets.length; j++) {
            if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === targets[j].target.field) {
                targetsSquashed[targetsSquashed.length - 1].spanUsed++;
            }
            else {
                targetsSquashed.push(targets[j]);
            }
        }
        return targetsSquashed;
    }
    /**
     * Pins the column at the provided index in the pinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     * @memberof IgxColumnComponent
     */
    pin(index) {
        // TODO: Probably should the return type of the old functions
        // should be moved as a event parameter.
        if (this.grid) {
            this.grid.endEdit(true);
        }
        if (this._pinned) {
            return false;
        }
        if (this.parent && !this.parent.pinned) {
            return this.topLevelParent.pin(index);
        }
        const grid = this.grid;
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index >= grid.pinnedColumns.length)) {
            return false;
        }
        if (!this.parent && !this.pinnable) {
            return false;
        }
        this._pinned = true;
        this.pinnedChange.emit(this._pinned);
        this._unpinnedIndex = grid._unpinnedColumns.indexOf(this);
        const rootPinnedCols = grid._pinnedColumns.filter((c) => c.level === 0);
        index = index !== undefined ? index : rootPinnedCols.length;
        const targetColumn = grid._pinnedColumns[index];
        const args = { column: this, insertAtIndex: index, isPinned: true };
        grid.onColumnPinning.emit(args);
        if (grid._pinnedColumns.indexOf(this) === -1) {
            if (!grid.hasColumnGroups) {
                grid._pinnedColumns.splice(args.insertAtIndex, 0, this);
            }
            else {
                // insert based only on root collection
                rootPinnedCols.splice(args.insertAtIndex, 0, this);
                let allPinned = [];
                // re-create hierarchy
                rootPinnedCols.forEach(group => {
                    allPinned.push(group);
                    allPinned = allPinned.concat(group.allChildren);
                });
                grid._pinnedColumns = allPinned;
            }
            if (grid._unpinnedColumns.indexOf(this) !== -1) {
                const childrenCount = this.allChildren.length;
                grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1 + childrenCount);
            }
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.pin());
            grid.reinitPinStates();
        }
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        return true;
    }
    /**
     * Unpins the column and place it at the provided index in the unpinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     * @memberof IgxColumnComponent
     */
    unpin(index) {
        if (this.grid) {
            this.grid.endEdit(true);
        }
        if (!this._pinned) {
            return false;
        }
        if (this.parent && this.parent.pinned) {
            return this.topLevelParent.unpin(index);
        }
        const grid = this.grid;
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index >= grid._unpinnedColumns.length)) {
            return false;
        }
        index = (index !== undefined ? index :
            this._unpinnedIndex !== undefined ? this._unpinnedIndex : this.index);
        this._pinned = false;
        this.pinnedChange.emit(this._pinned);
        const targetColumn = grid._unpinnedColumns[index];
        if (!hasIndex) {
            grid._unpinnedColumns.splice(index, 0, this);
            if (grid._pinnedColumns.indexOf(this) !== -1) {
                grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
            }
        }
        if (hasIndex) {
            grid.moveColumn(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.unpin());
        }
        grid.reinitPinStates();
        grid.resetCaches();
        const insertAtIndex = grid._unpinnedColumns.indexOf(this);
        const args = { column: this, insertAtIndex, isPinned: false };
        grid.onColumnPinning.emit(args);
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        return true;
    }
    /**
     * Moves a column to the specified visible index.
     * If passed index is invalid, or if column would receive a different visible index after moving, moving is not performed.
     * If passed index would move the column to a different column group. moving is not performed.
     * @example
     * ```typescript
     * column.move(index);
     * ```
     * @memberof IgxColumnComponent
     */
    move(index) {
        let target;
        const grid = this.grid;
        let columns = grid.columnList.filter(c => c.visibleIndex > -1);
        // grid last visible index
        const li = columns.map(c => c.visibleIndex).reduce(function (a, b) {
            return Math.max(a, b);
        });
        const parent = this.parent;
        const isPreceding = this.visibleIndex < index;
        if (index === this.visibleIndex || index < 0 || index > li) {
            return;
        }
        if (parent) {
            columns = columns.filter(c => c.level >= this.level && c !== this && c.parent !== this &&
                c.topLevelParent === this.topLevelParent);
        }
        // tslint:disable:max-line-length
        // If isPreceding, find a target such that when the current column is placed after it, current colummn will receive a visibleIndex === index. This takes into account visible children of the columns.
        // If !isPreceding, finds a column of the same level and visible index that equals the passed index agument (c.visibleIndex === index). No need to consider the children here.
        // tslint:enable:max-line-length
        if (isPreceding) {
            columns = columns.filter(c => c.visibleIndex > this.visibleIndex);
            target = columns.find(c => c.level === this.level && c.visibleIndex + c.calcChildren() - this.calcChildren() === index);
        }
        else {
            columns = columns.filter(c => c.visibleIndex < this.visibleIndex);
            target = columns.find(c => c.level === this.level && c.visibleIndex === index);
        }
        if (!target || (target.pinned && this.disablePinning)) {
            return;
        }
        const pos = isPreceding ? DropPosition.AfterDropTarget : DropPosition.BeforeDropTarget;
        grid.moveColumn(this, target, pos);
    }
    /**
     * No children for the column, so will returns 1 or 0, if the column is hidden.
     * @hidden
     */
    calcChildren() {
        const children = this.hidden ? 0 : 1;
        return children;
    }
    /**
     * Returns a reference to the top level parent column.
     * ```typescript
     * let topLevelParent =  this.column.topLevelParent;
     * ```
     * @memberof IgxColumnComponent
     */
    get topLevelParent() {
        let parent = this.parent;
        while (parent && parent.parent) {
            parent = parent.parent;
        }
        return parent;
    }
    /**
     * Returns a reference to the header of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let headerCell = column.headerCell;
     * ```
     * @memberof IgxColumnComponent
     */
    get headerCell() {
        return this.grid.headerCellList.find((header) => header.column === this);
    }
    /**
     * Returns a reference to the filter cell of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let filterell = column.filterell;
     * ```
     * @memberof IgxColumnComponent
     */
    get filterCell() {
        return this.grid.filterCellList.find((filterCell) => filterCell.column === this);
    }
    /**
     * Returns a reference to the header group of the column.
     * @memberof IgxColumnComponent
     */
    get headerGroup() {
        return this.grid.headerGroupsList.find((headerGroup) => headerGroup.column === this);
    }
    /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     * @memberof IgxColumnComponent
     * @param byHeader Set if column should be autized based only on the header content
     */
    autosize(byHeader = false) {
        if (!this.columnGroup) {
            const size = this.getAutoSize(byHeader);
            this.width = size;
            this.grid.reflow();
        }
    }
    /**
     * @hidden
     */
    getAutoSize(byHeader = false) {
        const size = !byHeader ? this.getLargestCellWidth() :
            (Object.values(this.getHeaderCellWidths()).reduce((a, b) => a + b) + 'px');
        const gridAvailableSize = this.grid.calcWidth;
        let newWidth;
        const isPercentageWidth = this.width && typeof this.width === 'string' && this.width.indexOf('%') !== -1;
        if (isPercentageWidth) {
            const percentageSize = parseFloat(size) / gridAvailableSize * 100;
            newWidth = percentageSize + '%';
        }
        else {
            newWidth = size;
        }
        return newWidth;
    }
    /**
     * @hidden
     */
    getCalcWidth() {
        if (this._calcWidth && !isNaN(this.calcPixelWidth)) {
            return this._calcWidth;
        }
        this.cacheCalcWidth();
        return this._calcWidth;
    }
    /**
     * @hidden
     * Returns the width and padding of a header cell.
     */
    getHeaderCellWidths() {
        const range = this.grid.document.createRange();
        let headerWidth;
        if (this.headerTemplate && this.headerCell.elementRef.nativeElement.children[0].children.length > 0) {
            headerWidth = Math.max(...Array.from(this.headerCell.elementRef.nativeElement.children[0].children)
                .map((child) => getNodeSizeViaRange(range, child)));
        }
        else {
            headerWidth = getNodeSizeViaRange(range, this.headerCell.elementRef.nativeElement.children[0]);
        }
        if (this.sortable || this.filterable) {
            headerWidth += this.headerCell.elementRef.nativeElement.children[1].getBoundingClientRect().width;
        }
        const headerStyle = this.grid.document.defaultView.getComputedStyle(this.headerCell.elementRef.nativeElement);
        const headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) +
            parseFloat(headerStyle.borderRightWidth);
        // Take into consideration the header group element, since column pinning applies borders to it if its not a columnGroup.
        const headerGroupStyle = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement);
        const borderSize = !this.parent ? parseFloat(headerGroupStyle.borderRightWidth) + parseFloat(headerGroupStyle.borderLeftWidth) : 0;
        return { width: Math.ceil(headerWidth), padding: Math.ceil(headerPadding + borderSize) };
    }
    /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * @memberof IgxColumnComponent
     */
    getLargestCellWidth() {
        const range = this.grid.document.createRange();
        const largest = new Map();
        if (this.cells.length > 0) {
            let cellsContentWidths = [];
            if (this.cells[0].nativeElement.children.length > 0) {
                this.cells.forEach((cell) => cellsContentWidths.push(cell.calculateSizeToFit(range)));
            }
            else {
                cellsContentWidths = this.cells.map((cell) => getNodeSizeViaRange(range, cell.nativeElement));
            }
            const index = cellsContentWidths.indexOf(Math.max(...cellsContentWidths));
            const cellStyle = this.grid.document.defaultView.getComputedStyle(this.cells[index].nativeElement);
            const cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) +
                parseFloat(cellStyle.borderLeftWidth) + parseFloat(cellStyle.borderRightWidth);
            largest.set(Math.max(...cellsContentWidths), cellPadding);
        }
        if (this.headerCell) {
            const headerCellWidths = this.getHeaderCellWidths();
            largest.set(headerCellWidths.width, headerCellWidths.padding);
        }
        const largestCell = Math.max(...Array.from(largest.keys()));
        const width = Math.ceil(largestCell + largest.get(largestCell));
        if (Number.isNaN(width)) {
            return this.width;
        }
        else {
            return width + 'px';
        }
    }
    /**
     * @hidden
     */
    getCellWidth() {
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (this.columnLayoutChild) {
            return '';
        }
        if (colWidth && !isPercentageWidth) {
            let cellWidth = colWidth;
            if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
                cellWidth += 'px';
            }
            return cellWidth;
        }
        else {
            return colWidth;
        }
    }
    /**
     * @hidden
     * @internal
     */
    cacheCalcWidth() {
        const grid = this.gridAPI.grid;
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (isPercentageWidth) {
            this._calcWidth = parseFloat(colWidth) / 100 * grid.calcWidth;
        }
        else if (!colWidth) {
            // no width
            this._calcWidth = this.defaultWidth || grid.getPossibleColumnWidth();
        }
        else {
            this._calcWidth = this.width;
        }
        this.calcPixelWidth = parseFloat(this._calcWidth);
    }
    /**
     * @hidden
     * @internal
     */
    setExpandCollapseState() {
        this.children.filter(col => (col.visibleWhenCollapsed !== undefined)).forEach(c => {
            if (!this.collapsible) {
                c.hidden = this.hidden;
                return;
            }
            c.hidden = this._expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
        });
    }
    /**
     * @hidden
     * @internal
     */
    checkCollapsibleState() {
        if (!this.children) {
            return false;
        }
        const cols = this.children.map(child => child.visibleWhenCollapsed);
        return (cols.some(c => c === true) && cols.some(c => c === false));
    }
    /**
     * @hidden
     */
    get pinnable() {
        return this.grid._init || !this.pinned;
    }
    /**
     * @hidden
     */
    populateVisibleIndexes() { }
    /**
     * @hidden
     */
    get applySelectableClass() {
        return this._applySelectableClass;
    }
    /**
     * @hidden
     */
    set applySelectableClass(value) {
        if (this.selectable) {
            this._applySelectableClass = value;
        }
    }
}
IgxColumnComponent.ɵfac = function IgxColumnComponent_Factory(t) { return new (t || IgxColumnComponent)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxColumnComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxColumnComponent, selectors: [["igx-column"]], contentQueries: function IgxColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCellTemplateDirective, true, IgxCellTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCellEditorTemplateDirective, true, IgxCellEditorTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxFilterCellTemplateDirective, true, IgxFilterCellTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCollapsibleIndicatorTemplateDirective, true, IgxCollapsibleIndicatorTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCellHeaderTemplateDirective, false, IgxCellHeaderTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filterCellTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.collapseIndicatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headTemplate = _t);
    } }, inputs: { header: "header", title: "title", sortable: "sortable", groupable: "groupable", filterable: "filterable", resizable: "resizable", disableHiding: "disableHiding", disablePinning: "disablePinning", movable: "movable", headerClasses: "headerClasses", headerGroupClasses: "headerGroupClasses", cellStyles: "cellStyles", filteringIgnoreCase: "filteringIgnoreCase", sortingIgnoreCase: "sortingIgnoreCase", dataType: "dataType", searchable: "searchable", selectable: "selectable", editable: "editable", hasSummary: "hasSummary", hidden: "hidden", width: "width", minWidth: "minWidth", pinned: "pinned", summaries: "summaries", filters: "filters", sortStrategy: "sortStrategy", groupingComparer: "groupingComparer", bodyTemplate: ["cellTemplate", "bodyTemplate"], headerTemplate: "headerTemplate", inlineEditorTemplate: ["cellEditorTemplate", "inlineEditorTemplate"], filterCellTemplate: "filterCellTemplate", visibleWhenCollapsed: "visibleWhenCollapsed", pipeArgs: "pipeArgs", field: "field", maxWidth: "maxWidth", cellClasses: "cellClasses", formatter: "formatter", collapsibleIndicatorTemplate: "collapsibleIndicatorTemplate", rowEnd: "rowEnd", colEnd: "colEnd", rowStart: "rowStart", colStart: "colStart" }, outputs: { hiddenChange: "hiddenChange", expandedChange: "expandedChange", collapsibleChange: "collapsibleChange", visibleWhenCollapsedChange: "visibleWhenCollapsedChange", onColumnChange: "onColumnChange", widthChange: "widthChange", pinnedChange: "pinnedChange" }, decls: 0, vars: 0, template: function IgxColumnComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
IgxColumnComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef }
];
IgxColumnComponent.propDecorators = {
    field: [{ type: Input }],
    header: [{ type: Input }],
    title: [{ type: Input }],
    sortable: [{ type: Input }],
    selectable: [{ type: Input }],
    groupable: [{ type: Input }],
    editable: [{ type: Input }],
    filterable: [{ type: Input }],
    resizable: [{ type: Input }],
    hasSummary: [{ type: Input }],
    hidden: [{ type: Input }],
    hiddenChange: [{ type: Output }],
    expandedChange: [{ type: Output }],
    collapsibleChange: [{ type: Output }],
    visibleWhenCollapsedChange: [{ type: Output }],
    onColumnChange: [{ type: Output }],
    disableHiding: [{ type: Input }],
    disablePinning: [{ type: Input }],
    movable: [{ type: Input }],
    width: [{ type: Input }],
    widthChange: [{ type: Output }],
    maxWidth: [{ type: Input }],
    minWidth: [{ type: Input }],
    headerClasses: [{ type: Input }],
    headerGroupClasses: [{ type: Input }],
    cellClasses: [{ type: Input }],
    cellStyles: [{ type: Input }],
    formatter: [{ type: Input }],
    filteringIgnoreCase: [{ type: Input }],
    sortingIgnoreCase: [{ type: Input }],
    dataType: [{ type: Input }],
    pinned: [{ type: Input }],
    pinnedChange: [{ type: Output }],
    summaries: [{ type: Input }],
    searchable: [{ type: Input }],
    filters: [{ type: Input }],
    sortStrategy: [{ type: Input }],
    groupingComparer: [{ type: Input }],
    bodyTemplate: [{ type: Input, args: ['cellTemplate',] }],
    headerTemplate: [{ type: Input }],
    inlineEditorTemplate: [{ type: Input, args: ['cellEditorTemplate',] }],
    filterCellTemplate: [{ type: Input, args: ['filterCellTemplate',] }],
    collapsibleIndicatorTemplate: [{ type: Input }],
    rowEnd: [{ type: Input }],
    colEnd: [{ type: Input }],
    rowStart: [{ type: Input }],
    colStart: [{ type: Input }],
    visibleWhenCollapsed: [{ type: Input }],
    pipeArgs: [{ type: Input }],
    cellTemplate: [{ type: ContentChild, args: [IgxCellTemplateDirective, { read: IgxCellTemplateDirective },] }],
    headTemplate: [{ type: ContentChildren, args: [IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective, descendants: false },] }],
    editorTemplate: [{ type: ContentChild, args: [IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective },] }],
    filterCellTemplateDirective: [{ type: ContentChild, args: [IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective },] }],
    collapseIndicatorTemplate: [{ type: ContentChild, args: [IgxCollapsibleIndicatorTemplateDirective, { read: IgxCollapsibleIndicatorTemplateDirective, static: false },] }]
};
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "header", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "title", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "sortable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "selectable", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "groupable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "editable", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filterable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "resizable", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "hasSummary", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "hidden", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "disableHiding", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "disablePinning", void 0);
__decorate([
    WatchColumnChanges(),
    notifyChanges()
], IgxColumnComponent.prototype, "movable", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "width", null);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "maxWidth", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "minWidth", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerGroupClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "cellClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "cellStyles", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "formatter", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filteringIgnoreCase", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "sortingIgnoreCase", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "pinned", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "summaries", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "searchable", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "bodyTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "inlineEditorTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filterCellTemplate", null);
__decorate([
    notifyChanges(true)
], IgxColumnComponent.prototype, "visibleWhenCollapsed", null);

class IgxGridBodyDirective {
}
IgxGridBodyDirective.ɵfac = function IgxGridBodyDirective_Factory(t) { return new (t || IgxGridBodyDirective)(); };
IgxGridBodyDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridBodyDirective, selectors: [["", "igxGridBody", ""]], features: [ɵngcc0.ɵɵProvidersFeature([IgxForOfSyncService])] });
/**
 * @hidden
 */
class RowEditPositionStrategy extends ConnectedPositioningStrategy {
    constructor() {
        super(...arguments);
        this.isTop = false;
        this.isTopInitialPosition = null;
    }
    position(contentElement, size, document, initialCall, target) {
        const container = this.settings.container; // grid.tbody
        const targetElement = target || this.settings.target; // current grid.row
        // Position of the overlay depends on the available space in the grid.
        // If the bottom space is not enough then the the row overlay will show at the top of the row.
        // Once shown, either top or bottom, then this position stays until the overlay is closed (isTopInitialPosition property),
        // which means that when scrolling then overlay may hide, while the row is still visible (UX requirement).
        this.isTop = this.isTopInitialPosition !== null ?
            this.isTopInitialPosition :
            container.getBoundingClientRect().bottom <
                targetElement.getBoundingClientRect().bottom + contentElement.getBoundingClientRect().height;
        // Set width of the row editing overlay to equal row width, otherwise it fits 100% of the grid.
        contentElement.style.width = targetElement.clientWidth + 'px';
        this.settings.verticalStartPoint = this.settings.verticalDirection = this.isTop ? VerticalAlignment.Top : VerticalAlignment.Bottom;
        this.settings.openAnimation = this.isTop ? scaleInVerBottom : scaleInVerTop;
        super.position(contentElement, { width: targetElement.clientWidth, height: targetElement.clientHeight }, document, initialCall, targetElement);
    }
}

const FilterMode = mkenum({
    quickFilter: 'quickFilter',
    excelStyleFilter: 'excelStyleFilter'
});
const GridSummaryPosition = mkenum({
    top: 'top',
    bottom: 'bottom'
});
const GridSummaryCalculationMode = mkenum({
    rootLevelOnly: 'rootLevelOnly',
    childLevelsOnly: 'childLevelsOnly',
    rootAndChildLevels: 'rootAndChildLevels'
});
const GridSelectionMode = mkenum({
    none: 'none',
    single: 'single',
    multiple: 'multiple'
});
const ColumnDisplayOrder = mkenum({
    Alphabetical: 'Alphabetical',
    DisplayOrder: 'DisplayOrder'
});
var ColumnPinningPosition;
(function (ColumnPinningPosition) {
    ColumnPinningPosition[ColumnPinningPosition["Start"] = 0] = "Start";
    ColumnPinningPosition[ColumnPinningPosition["End"] = 1] = "End";
})(ColumnPinningPosition || (ColumnPinningPosition = {}));
var RowPinningPosition;
(function (RowPinningPosition) {
    RowPinningPosition[RowPinningPosition["Top"] = 0] = "Top";
    RowPinningPosition[RowPinningPosition["Bottom"] = 1] = "Bottom";
})(RowPinningPosition || (RowPinningPosition = {}));
var GridPagingMode;
(function (GridPagingMode) {
    GridPagingMode[GridPagingMode["local"] = 0] = "local";
    GridPagingMode[GridPagingMode["remote"] = 1] = "remote";
})(GridPagingMode || (GridPagingMode = {}));

let NEXT_ID$l = 0;
/**
 * Providing reference to `IgxColumnActionsComponent`:
 * ```typescript
 *  @ViewChild('columnActions', { read: IgxColumnActionsComponent })
 *  public columnActions: IgxColumnActionsComponent;
 */
class IgxColumnActionsComponent {
    constructor(differs) {
        this.differs = differs;
        this._differ = null;
        /**
         * @hidden @internal
         */
        this.actionableColumns = [];
        /**
         * @hidden @internal
         */
        this.filteredColumns = [];
        /**
         * Gets/sets the title of the column actions component.
         * @example
         * ```html
         * <igx-column-actions [title]="'Pin Columns'"></igx-column-actions>
         * ```
         */
        this.title = '';
        /**
         * @hidden @internal
         */
        this._filterColumnsPrompt = '';
        /**
         * Shows/hides the columns filtering input from the UI.
         * @example
         * ```html
         *  <igx-column-actions [hideFilter]="true"></igx-column-actions>
         * ```
         */
        this.hideFilter = false;
        /**
         * @hidden @internal
         */
        this._filterCriteria = '';
        /**
         * @hidden @internal
         */
        this._columnDisplayOrder = ColumnDisplayOrder.DisplayOrder;
        /**
         * Gets/sets the max height of the columns area.
         * @remarks
         * The default max height is 100%.
         * @example
         * ```html
         * <igx-column-actions [columnsAreaMaxHeight]="200px"></igx-column-actions>
         * ```
         */
        this.columnsAreaMaxHeight = '100%';
        /**
         * Gets/sets the indentation of columns in the column list based on their hierarchy level.
         * @example
         * ```
         * <igx-column-actions [indentation]="15"></igx-column-actions>
         * ```
         */
        this.indentation = 30;
        /**
         * An event that is emitted after a column's checked state is changed.
         * Provides references to the `column` and the `checked` properties as event arguments.
         * ```html
         *  <igx-column-actions (onColumnToggled)="onColumnToggled($event)"></igx-column-actions>
         * ```
         */
        this.onColumnToggled = new EventEmitter();
        /**
         * @hidden @internal
         */
        this._pipeTrigger = 0;
        /**
         * Sets/Gets the css class selector.
         * By default the value of the `class` attribute is `"igx-column-hiding"`.
         * ```typescript
         * let cssCLass =  this.columnHidingUI.cssClass;
         * ```
         * ```typescript
         * this.columnHidingUI.cssClass = 'column-chooser';
         * ```
         */
        this.cssClass = 'igx-column-actions';
        /**
         * @hidden @internal
         */
        this._id = `igx-column-actions-${NEXT_ID$l++}`;
        /**
         * @hidden @internal
         */
        this.trackChanges = (index, col) => {
            return col.field + '_' + this.actionsDirective.actionEnabledColumnsFilter(col, index, []);
        };
        this._differ = this.differs.find([]).create(this.trackChanges);
    }
    /**
     * Gets the grid columns to provide an action for.
     * @deprecated
     * @example
     * ```typescript
     * let gridColumns = this.columnActions.columns;
     * ```
     */
    get columns() {
        var _a;
        return (_a = this.grid) === null || _a === void 0 ? void 0 : _a.columns;
    }
    set columns(value) {
        if (value && value.length > 0) {
            this.grid = value[0].grid;
        }
    }
    /**
     * Gets the prompt that is displayed in the filter input.
     * @example
     * ```typescript
     * let filterColumnsPrompt = this.columnActions.filterColumnsPrompt;
     * ```
     */
    get filterColumnsPrompt() {
        return this._filterColumnsPrompt;
    }
    /**
     * Sets the prompt that is displayed in the filter input.
     * @example
     * ```html
     * <igx-column-actions [filterColumnsPrompt]="'Type here to search'"></igx-column-actions>
     * ```
     */
    set filterColumnsPrompt(value) {
        this._filterColumnsPrompt = value || '';
    }
    /**
     * Gets the value which filters the columns list.
     * @example
     * ```typescript
     * let filterCriteria =  this.columnActions.filterCriteria;
     * ```
     */
    get filterCriteria() {
        return this._filterCriteria;
    }
    /**
     * Sets the value which filters the columns list.
     * @example
     * ```html
     *  <igx-column-actions [filterCriteria]="'ID'"></igx-column-actions>
     * ```
     */
    set filterCriteria(value) {
        value = value || '';
        if (value !== this._filterCriteria) {
            this._filterCriteria = value;
            this._pipeTrigger++;
        }
    }
    /**
     * Gets the display order of the columns.
     * @example
     * ```typescript
     * let columnDisplayOrder = this.columnActions.columnDisplayOrder;
     * ```
     */
    get columnDisplayOrder() {
        return this._columnDisplayOrder;
    }
    /**
     * Sets the display order of the columns.
     * @example
     * ```typescript
     * this.columnActions.columnDisplayOrder = ColumnDisplayOrder.Alphabetical;
     * ```
     */
    set columnDisplayOrder(value) {
        if (value && value !== this._columnDisplayOrder) {
            this._columnDisplayOrder = value;
            this._pipeTrigger++;
        }
    }
    /**
     * Gets the text of the button that unchecks all columns.
     * @remarks
     * If unset it is obtained from the IgxColumnActionsBased derived directive applied.
     * @example
     * ```typescript
     * let uncheckAllText = this.columnActions.uncheckAllText;
     * ```
     */
    get uncheckAllText() {
        return this._uncheckAllText || this.actionsDirective.uncheckAllLabel;
    }
    /**
     * Sets the text of the button that unchecks all columns.
     * @example
     * ```html
     * <igx-column-actions [uncheckAllText]="'Show All'"></igx-column-actions>
     * ```
     */
    set uncheckAllText(value) {
        this._uncheckAllText = value;
    }
    /**
     * Gets the text of the button that checks all columns.
     * @remarks
     * If unset it is obtained from the IgxColumnActionsBased derived directive applied.
     * @example
     * ```typescript
     * let uncheckAllText = this.columnActions.uncheckAllText;
     * ```
     */
    get checkAllText() {
        return this._checkAllText || this.actionsDirective.checkAllLabel;
    }
    /**
     * Sets the text of the button that checks all columns.
     * @remarks
     * If unset it is obtained from the IgxColumnActionsBased derived directive applied.
     * @example
     * ```html
     * <igx-column-actions [checkAllText]="'Hide All'"></igx-column-actions>
     * ```
     */
    set checkAllText(value) {
        this._checkAllText = value;
    }
    /**
     * @hidden @internal
     */
    get pipeTrigger() {
        return this._pipeTrigger;
    }
    /**
     * @hidden @internal
     */
    get checkAllDisabled() {
        return !this.filteredColumns.some(col => !this.actionsDirective.columnChecked(col));
    }
    /**
     * @hidden @internal
     */
    get uncheckAllDisabled() {
        return !this.filteredColumns.some(col => this.actionsDirective.columnChecked(col));
    }
    /**
     * Gets/Sets the value of the `id` attribute.
     * @remarks
     * If not provided it will be automatically generated.
     * @example
     * ```html
     * <igx-column-actions [id]="'igx-actions-1'"></igx-column-actions>
     * ```
     */
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    /**
     * @hidden @internal
     */
    get titleID() {
        return this.id + '_title';
    }
    /**
     * @hidden @internal
     */
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.columns);
            if (changes) {
                this._pipeTrigger++;
            }
        }
    }
    /**
     * Unchecks all columns and performs the appropriate action.
     * @example
     * ```typescript
     * this.columnActions.uncheckAllColumns();
     * ```
     */
    uncheckAllColumns() {
        this.actionsDirective.uncheckAll();
    }
    /**
     * Checks all columns and performs the appropriate action.
     * @example
     * ```typescript
     * this.columnActions.checkAllColumns();
     * ```
     */
    checkAllColumns() {
        this.actionsDirective.checkAll();
    }
    /**
     * @hidden @internal
     */
    toggleColumn(event, column) {
        this.onColumnToggled.emit({
            column: column,
            checked: event.checked
        });
        this.actionsDirective.toggleColumn(column);
    }
}
IgxColumnActionsComponent.ɵfac = function IgxColumnActionsComponent_Factory(t) { return new (t || IgxColumnActionsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers)); };
IgxColumnActionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxColumnActionsComponent, selectors: [["igx-column-actions"]], viewQuery: function IgxColumnActionsComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxCheckboxComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnItems = _t);
    } }, hostVars: 2, hostBindings: function IgxColumnActionsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.cssClass)("id", ctx.id);
    } }, inputs: { title: "title", hideFilter: "hideFilter", columnsAreaMaxHeight: "columnsAreaMaxHeight", indentation: "indentation", columns: "columns", grid: "grid", filterColumnsPrompt: "filterColumnsPrompt", filterCriteria: "filterCriteria", columnDisplayOrder: "columnDisplayOrder", uncheckAllText: "uncheckAllText", checkAllText: "checkAllText", id: "id" }, outputs: { onColumnToggled: "onColumnToggled" }, decls: 13, vars: 21, consts: [[1, "igx-column-actions__header"], ["class", "igx-column-actions__header-title", 4, "ngIf"], ["class", "igx-column-actions__header-input", 4, "ngIf"], ["tabindex", "0", 1, "igx-column-actions__columns"], ["class", "igx-column-actions__columns-item", 3, "checked", "margin-left", "change", 4, "ngFor", "ngForOf"], [1, "igx-column-actions__buttons"], ["igxButton", "", "igxRipple", "", 3, "disabled", "click"], [1, "igx-column-actions__header-title"], [1, "igx-column-actions__header-input"], ["igxInput", "", "type", "text", "autocomplete", "off", 3, "ngModel", "placeholder", "ngModelChange"], [1, "igx-column-actions__columns-item", 3, "checked", "change"]], template: function IgxColumnActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxColumnActionsComponent_h4_1_Template, 2, 2, "h4", 1);
        ɵngcc0.ɵɵtemplate(2, IgxColumnActionsComponent_igx_input_group_2_Template, 2, 3, "igx-input-group", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, IgxColumnActionsComponent_igx_checkbox_4_Template, 2, 4, "igx-checkbox", 4);
        ɵngcc0.ɵɵpipe(5, "sortActionColumns");
        ɵngcc0.ɵɵpipe(6, "filterActionColumns");
        ɵngcc0.ɵɵpipe(7, "columnActionEnabled");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div", 5);
        ɵngcc0.ɵɵelementStart(9, "button", 6);
        ɵngcc0.ɵɵlistener("click", function IgxColumnActionsComponent_Template_button_click_9_listener() { return ctx.uncheckAllColumns(); });
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "button", 6);
        ɵngcc0.ɵɵlistener("click", function IgxColumnActionsComponent_Template_button_click_11_listener() { return ctx.checkAllColumns(); });
        ɵngcc0.ɵɵtext(12);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.hideFilter);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("max-height", ctx.columnsAreaMaxHeight);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind3(5, 9, ɵngcc0.ɵɵpipeBind3(6, 13, ɵngcc0.ɵɵpipeBind3(7, 17, ctx.columns, ctx.actionsDirective.actionEnabledColumnsFilter, ctx.pipeTrigger), ctx.filterCriteria, ctx.pipeTrigger), ctx.columnDisplayOrder, ctx.pipeTrigger));
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("disabled", ctx.uncheckAllDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.uncheckAllText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.checkAllDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.checkAllText);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgForOf, IgxButtonDirective, IgxRippleDirective, IgxInputGroupComponent, ɵngcc3.DefaultValueAccessor, IgxInputDirective, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxCheckboxComponent]; }, pipes: function () { return [IgxSortActionColumnsPipe, IgxFilterActionColumnsPipe, IgxColumnActionEnabledPipe]; }, encapsulation: 2 });
IgxColumnActionsComponent.ctorParameters = () => [
    { type: IterableDiffers }
];
IgxColumnActionsComponent.propDecorators = {
    columns: [{ type: Input }],
    title: [{ type: Input }],
    filterColumnsPrompt: [{ type: Input }],
    hideFilter: [{ type: Input }],
    columnItems: [{ type: ViewChildren, args: [IgxCheckboxComponent,] }],
    filterCriteria: [{ type: Input }],
    columnDisplayOrder: [{ type: Input }],
    columnsAreaMaxHeight: [{ type: Input }],
    uncheckAllText: [{ type: Input }],
    checkAllText: [{ type: Input }],
    indentation: [{ type: Input }],
    onColumnToggled: [{ type: Output }],
    cssClass: [{ type: HostBinding, args: ['attr.class',] }],
    grid: [{ type: Input }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }]
};
__decorate([
    DeprecateProperty(`Deprecated. Use 'grid' input instead.`)
], IgxColumnActionsComponent.prototype, "columns", null);

class IgxColumnActionsBaseDirective {
}
IgxColumnActionsBaseDirective.ɵfac = function IgxColumnActionsBaseDirective_Factory(t) { return new (t || IgxColumnActionsBaseDirective)(); };
IgxColumnActionsBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxColumnActionsBaseDirective });

class IgxColumnHidingDirective extends IgxColumnActionsBaseDirective {
    constructor(columnActions) {
        super();
        this.columnActions = columnActions;
        /**
         * @hidden @internal
         */
        this.actionEnabledColumnsFilter = c => !c.disableHiding;
        columnActions.actionsDirective = this;
    }
    /**
     * @hidden @internal
     */
    get checkAllLabel() {
        var _a, _b;
        return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_hiding_check_all_label) !== null && _b !== void 0 ? _b : 'Hide All';
    }
    /**
     * @hidden @internal
     */
    get uncheckAllLabel() {
        var _a, _b;
        return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_hiding_uncheck_all_label) !== null && _b !== void 0 ? _b : 'Show All';
    }
    /**
     * @hidden @internal
     */
    checkAll() {
        this.columnActions.filteredColumns.forEach(c => c.hidden = true);
    }
    /**
     * @hidden @internal
     */
    uncheckAll() {
        this.columnActions.filteredColumns.forEach(c => c.hidden = false);
    }
    /**
     * @hidden @internal
     */
    columnChecked(column) {
        return column.hidden;
    }
    /**
     * @hidden @internal
     */
    toggleColumn(column) {
        column.hidden = !column.hidden;
    }
}
IgxColumnHidingDirective.ɵfac = function IgxColumnHidingDirective_Factory(t) { return new (t || IgxColumnHidingDirective)(ɵngcc0.ɵɵdirectiveInject(IgxColumnActionsComponent)); };
IgxColumnHidingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxColumnHidingDirective, selectors: [["", "igxColumnHiding", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxColumnHidingDirective.ctorParameters = () => [
    { type: IgxColumnActionsComponent, decorators: [{ type: Inject, args: [IgxColumnActionsComponent,] }] }
];

class IgxColumnPinningDirective extends IgxColumnActionsBaseDirective {
    constructor(columnActions) {
        super();
        this.columnActions = columnActions;
        /**
         * @hidden @internal
         */
        this.actionEnabledColumnsFilter = c => !c.disablePinning && !c.level;
        columnActions.actionsDirective = this;
    }
    /**
     * @hidden @internal
     */
    get checkAllLabel() {
        var _a, _b;
        return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_pinning_check_all_label) !== null && _b !== void 0 ? _b : 'Pin All';
    }
    /**
     * @hidden @internal
     */
    get uncheckAllLabel() {
        var _a, _b;
        return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_pinning_uncheck_all_label) !== null && _b !== void 0 ? _b : 'Unpin All';
    }
    /**
     * @hidden @internal
     */
    checkAll() {
        this.columnActions.filteredColumns.forEach(c => c.pinned = true);
    }
    /**
     * @hidden @internal
     */
    uncheckAll() {
        this.columnActions.filteredColumns.forEach(c => c.pinned = false);
    }
    /**
     * @hidden @internal
     */
    columnChecked(column) {
        return column.pinned;
    }
    /**
     * @hidden @internal
     */
    toggleColumn(column) {
        column.pinned = !column.pinned;
    }
}
IgxColumnPinningDirective.ɵfac = function IgxColumnPinningDirective_Factory(t) { return new (t || IgxColumnPinningDirective)(ɵngcc0.ɵɵdirectiveInject(IgxColumnActionsComponent)); };
IgxColumnPinningDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxColumnPinningDirective, selectors: [["", "igxColumnPinning", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxColumnPinningDirective.ctorParameters = () => [
    { type: IgxColumnActionsComponent, decorators: [{ type: Inject, args: [IgxColumnActionsComponent,] }] }
];

/**
 * This class encapsulates the Toolbar's logic and is internally used by
 * the `IgxGridComponent`, `IgxTreeGridComponent` and `IgxHierarchicalGridComponent`.
 */
class IgxGridToolbarComponent extends DisplayDensityBase {
    constructor(gridAPI, cdr, excelExporter, csvExporter, _displayDensityOptions, iconService) {
        super(_displayDensityOptions);
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.excelExporter = excelExporter;
        this.csvExporter = csvExporter;
        this._displayDensityOptions = _displayDensityOptions;
        this.iconService = iconService;
        this._filterColumnsPrompt = this.grid.resourceStrings.igx_grid_toolbar_actions_filter_prompt;
        this._isExporting = false;
        /**
         * @hidden
         * @internal
         */
        this.class = '';
        this._positionSettings = {
            horizontalDirection: HorizontalAlignment.Left,
            horizontalStartPoint: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            verticalStartPoint: VerticalAlignment.Bottom
        };
        this._overlaySettings = {
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings),
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: true
        };
    }
    /**
     * Gets the default text shown in the filtering box.
     * ```typescript
     * const filterPrompt = this.grid.toolbar.filterColumnsPrompt;
     * ```
     */
    get filterColumnsPrompt() {
        return this._filterColumnsPrompt;
    }
    /**
     * Sets the default text shown in the filtering box.
     * ```typescript
     * this.grid.toolbar.filterColumnsPrompt('Filter columns ...');
     * ```
     */
    set filterColumnsPrompt(value) {
        this._filterColumnsPrompt = value;
    }
    /**
     * Gets the height for the `IgxGridToolbarComponent`'s drop down panels.
     * ```typescript
     * const dropdownHeight = this.grid.toolbar.defaultDropDownsMaxHeight;
     * ```
     */
    get defaultDropDownsMaxHeight() {
        const gridHeight = this.grid.totalHeight;
        return (gridHeight) ? gridHeight * 0.7 + 'px' : '100%';
    }
    /**
     * Returns a reference to the `IgxGridComponent` component, hosting the `IgxGridToolbarComponent`.
     * ```typescript
     * const grid = this.igxGrid1.toolbar.grid;
     * ```
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Returns whether the `IgxGridComponent` renders an export button.
     * ```typescript
     * const exportButton = this.igxGrid1.toolbar.shouldShowExportButton;
     * ```
     */
    get shouldShowExportButton() {
        return (this.grid != null && (this.grid.exportExcel || this.grid.exportCsv));
    }
    /**
     * @hidden @internal
     */
    get isExporting() {
        return this._isExporting;
    }
    /**
     * Returns whether the `IgxGridComponent` renders an Excel export button.
     * ```typescript
     * const exportExcelButton = this.igxGrid1.toolbar.shouldShowExportExcelButton;
     * ```
     */
    get shouldShowExportExcelButton() {
        return (this.grid != null && this.grid.exportExcel);
    }
    /**
     * Returns whether the `IgxGridComponent` renders an CSV export button.
     * ```typescript
     * const exportCSVButton = this.igxGrid1.toolbar.shouldShowExportCsvButton;
     * ```
     */
    get shouldShowExportCsvButton() {
        return (this.grid != null && this.grid.exportCsv);
    }
    /**
     * Returns how many columns are pinned.
     * ```typescript
     * const pinnedCount = this.igxGrid1.toolbar.pinnedColumnsCount;
     * ```
     */
    get pinnedColumnsCount() {
        return this.grid.pinnedColumns.filter(col => !col.columnLayout).length;
    }
    /**
     * Returns the theme of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarTheme = this.grid.toolbar.hostClass;
     * ```
     */
    get hostClass() {
        const classes = [this.getComponentDensityClass('igx-grid-toolbar')];
        // The custom classes should be at the end.
        classes.push(this.class);
        return classes.join(' ');
        return this.getComponentDensityClass('igx-grid-toolbar');
    }
    /**
     * Returns the title of `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarTitle = this.igxGrid1.toolbar.getTitle();
     * ```
     */
    getTitle() {
        return this.grid != null ? this.grid.toolbarTitle : '';
    }
    /**
     * Returns the text of the export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarExportText = this.igxGrid1.toolbar.getTitle();
     * ```
     */
    getExportText() {
        return this.grid != null ? this.grid.exportText : '';
    }
    /**
     * Returns the text of the Excel export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarExcelText = this.igxGrid1.toolbar.getExportExcelText();
     * ```
     */
    getExportExcelText() {
        return this.grid != null ? this.grid.exportExcelText : '';
    }
    /**
     * Returns the text of the CSV export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarCSVText = this.igxGrid1.toolbar.getExportCsvText();
     * ```
     */
    getExportCsvText() {
        return this.grid != null ? this.grid.exportCsvText : '';
    }
    /**
     * Toggles the export button's dropdown menu.
     * ```typescript
     * this.igxGrid1.toolbar.exportClicked();
     * ```
     */
    exportClicked() {
        this._overlaySettings.target = this.exportButton.nativeElement;
        this._overlaySettings.excludeFromOutsideClick = [this.exportButton.nativeElement];
        this._overlaySettings.outlet = this.grid.outlet;
        this.exportDropdown.toggle(this._overlaySettings);
    }
    /**
     * Exports the grid to excel.
     * ```typescript
     * this.igxGrid1.toolbar.exportToExcelClicked();
     * ```
     */
    exportToExcelClicked() {
        this.performExport(this.excelExporter, 'excel');
    }
    /**
     * Exports the grid to CSV.
     * ```typescript
     * this.igxGrid1.toolbar.exportToCsvClicked();
     * ```
     */
    exportToCsvClicked() {
        this.performExport(this.csvExporter, 'csv');
    }
    setIsExporting(isExporting) {
        this._isExporting = isExporting;
        this.cdr.detectChanges();
    }
    performExport(exp, exportType) {
        this.exportClicked();
        const fileName = 'ExportedData';
        const options = exportType === 'excel' ?
            new IgxExcelExporterOptions(fileName) :
            new IgxCsvExporterOptions(fileName, CsvFileTypes.CSV);
        const args = { grid: this.grid, exporter: exp, options: options, cancel: false };
        this.grid.onToolbarExporting.emit(args);
        if (args.cancel) {
            return;
        }
        let exportEnded = false;
        setTimeout(() => {
            if (!exportEnded) {
                this.setIsExporting(true);
            }
        }, 500);
        exp.onExportEnded.pipe(first$1()).subscribe(() => {
            exportEnded = true;
            this.setIsExporting(false);
        });
        exp.export(this.grid, options);
    }
    /**
     * Toggles the Column Hiding UI.
     * ```typescript
     * this.grid1.toolbar.toggleColumnHidingUI();
     * ```
     */
    toggleColumnHidingUI() {
        this._overlaySettings.target = this.columnHidingButton.nativeElement;
        this._overlaySettings.outlet = this.grid.outlet;
        this.columnHidingDropdown.toggle(this._overlaySettings);
    }
    /**
     * Toggles the Column Pinning UI.
     * ```typescript
     * this.grid1.toolbar.toggleColumnPinningUI();
     * ```
     */
    toggleColumnPinningUI() {
        this._overlaySettings.target = this.columnPinningButton.nativeElement;
        this._overlaySettings.outlet = this.grid.outlet;
        this.columnPinningDropdown.toggle(this._overlaySettings);
    }
    /**
     * @hidden @internal
     */
    showAdvancedFilteringUI() {
        this.grid.openAdvancedFilteringDialog();
    }
    /**
     * Returns the `context` object which represents the `template context` binding into the
     * `toolbar custom container` by providing references to the parent IgxGird and the toolbar itself.
     * ```typescript
     * const context =  this.igxGrid.toolbar.context;
     * ```
     */
    get context() {
        return {
            // $implicit: this
            grid: this.grid,
            toolbar: this
        };
    }
    /** @hidden */
    get customContentTemplate() {
        if (this.grid != null && this.grid.toolbarCustomContentTemplate != null) {
            return this.grid.toolbarCustomContentTemplate.template;
        }
        else {
            return null;
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngAfterViewInit() {
        this.iconService.addSvgIconFromText(pinLeft.name, pinLeft.value, 'imx-icons');
        this.iconService.addSvgIconFromText(unpinLeft.name, unpinLeft.value, 'imx-icons');
    }
    /**
     * @hidden @internal
     */
    onClosingColumnHiding(args) {
        const activeElem = document.activeElement;
        if (!args.event && activeElem !== this.grid.nativeElement &&
            !this.columnHidingButton.nativeElement.contains(activeElem)) {
            args.cancel = true;
        }
    }
    /**
     * @hidden @internal
     */
    onClosingColumnPinning(args) {
        const activeElem = document.activeElement;
        if (!args.event && activeElem !== this.grid.nativeElement &&
            !this.columnPinningButton.nativeElement.contains(activeElem)) {
            args.cancel = true;
        }
    }
}
IgxGridToolbarComponent.ɵfac = function IgxGridToolbarComponent_Factory(t) { return new (t || IgxGridToolbarComponent)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxExcelExporterService, 8), ɵngcc0.ɵɵdirectiveInject(IgxCsvExporterService, 8), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(IgxIconService)); };
IgxGridToolbarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridToolbarComponent, selectors: [["igx-grid-toolbar"]], viewQuery: function IgxGridToolbarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c83, true, IgxDropDownComponent);
        ɵngcc0.ɵɵviewQuery(IgxColumnHidingDirective, true, IgxColumnActionsComponent);
        ɵngcc0.ɵɵviewQuery(_c84, true, IgxButtonDirective);
        ɵngcc0.ɵɵviewQuery(_c85, true, IgxDropDownComponent);
        ɵngcc0.ɵɵviewQuery(_c86, true, IgxButtonDirective);
        ɵngcc0.ɵɵviewQuery(_c87, true, IgxDropDownComponent);
        ɵngcc0.ɵɵviewQuery(IgxColumnPinningDirective, true, IgxColumnActionsComponent);
        ɵngcc0.ɵɵviewQuery(_c88, true, IgxButtonDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnHidingDropdown = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnHidingUI = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnHidingButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.exportDropdown = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.exportButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnPinningDropdown = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnPinningUI = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnPinningButton = _t.first);
    } }, hostVars: 3, hostBindings: function IgxGridToolbarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.hostClass);
        ɵngcc0.ɵɵclassProp("igx-grid-toolbar", ctx.gridID);
    } }, inputs: { class: "class", filterColumnsPrompt: "filterColumnsPrompt", defaultDropDownsMaxHeight: "defaultDropDownsMaxHeight", gridID: "gridID" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 8, vars: 7, consts: [["class", "igx-grid-toolbar__title", 4, "ngIf"], ["class", "igx-grid-toolbar__custom-content", 4, "ngIf"], [1, "igx-grid-toolbar__actions"], [4, "ngIf"], ["class", "igx-grid-toolbar__dropdown", "id", "btnExport", 4, "ngIf"], ["class", "igx-grid-toolbar__progress-bar", 4, "ngIf"], [1, "igx-grid-toolbar__title"], [1, "igx-grid-toolbar__custom-content"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["igxButton", "outlined", "name", "btnAdvancedFiltering", "igxRipple", "", 3, "displayDensity", "ngClass", "click"], ["advancedFilteringButton", ""], [1, "igx-grid-toolbar__button-space"], ["igxButton", "outlined", "name", "btnColumnHiding", "igxRipple", "", 3, "displayDensity", "click"], ["columnHidingButton", ""], [3, "onClosing"], ["columnHidingDropdown", ""], ["igxColumnHiding", "", 3, "grid", "title", "filterColumnsPrompt", "columnsAreaMaxHeight"], ["igxButton", "outlined", "name", "btnColumnPinning", "igxRipple", "", 3, "displayDensity", "click"], ["columnPinningButton", ""], ["fontSet", "imx-icons", "name", "pin-left", 4, "ngIf"], ["fontSet", "imx-icons", "name", "unpin-left", 4, "ngIf"], ["columnPinningDropdown", ""], ["igxColumnPinning", "", 3, "grid", "title", "filterColumnsPrompt", "columnsAreaMaxHeight"], ["fontSet", "imx-icons", "name", "pin-left"], ["fontSet", "imx-icons", "name", "unpin-left"], ["id", "btnExport", 1, "igx-grid-toolbar__dropdown"], ["igxButton", "outlined", "igxRipple", "", 3, "displayDensity", "disabled", "click"], ["btnExport", ""], ["fontSet", "material"], ["exportDropdown", ""], [1, "igx-grid-toolbar__dd-list"], ["class", "igx-grid-toolbar__dd-list-items", "igxRipple", "", "id", "btnExportExcel", 3, "click", 4, "ngIf"], ["class", "igx-grid-toolbar__dd-list-items", "igxRipple", "", "id", "btnExportCsv", 3, "click", 4, "ngIf"], ["igxRipple", "", "id", "btnExportExcel", 1, "igx-grid-toolbar__dd-list-items", 3, "click"], ["igxRipple", "", "id", "btnExportCsv", 1, "igx-grid-toolbar__dd-list-items", 3, "click"], [1, "igx-grid-toolbar__progress-bar"], [3, "indeterminate"]], template: function IgxGridToolbarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridToolbarComponent_span_0_Template, 2, 1, "span", 0);
        ɵngcc0.ɵɵtemplate(1, IgxGridToolbarComponent_div_1_Template, 2, 2, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵtemplate(3, IgxGridToolbarComponent_div_3_Template, 8, 3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, IgxGridToolbarComponent_div_4_Template, 13, 9, "div", 3);
        ɵngcc0.ɵɵtemplate(5, IgxGridToolbarComponent_div_5_Template, 14, 9, "div", 3);
        ɵngcc0.ɵɵtemplate(6, IgxGridToolbarComponent_div_6_Template, 15, 5, "div", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, IgxGridToolbarComponent_div_7_Template, 2, 1, "div", 5);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.getTitle());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.customContentTemplate != null);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.grid.allowAdvancedFiltering);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.grid.columnHiding);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.grid.columnPinning);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldShowExportButton);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isExporting);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, IgxButtonDirective, IgxRippleDirective, ɵngcc2.NgClass, IgxIconComponent, IgxDropDownComponent, IgxColumnActionsComponent, IgxColumnHidingDirective, IgxColumnPinningDirective, IgxLinearProgressBarComponent], encapsulation: 2 });
IgxGridToolbarComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: IgxExcelExporterService, decorators: [{ type: Optional }] },
    { type: IgxCsvExporterService, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: IgxIconService }
];
IgxGridToolbarComponent.propDecorators = {
    gridID: [{ type: HostBinding, args: ['class.igx-grid-toolbar',] }, { type: Input }],
    filterColumnsPrompt: [{ type: Input }],
    class: [{ type: Input }],
    defaultDropDownsMaxHeight: [{ type: Input }],
    columnHidingDropdown: [{ type: ViewChild, args: ['columnHidingDropdown', { read: IgxDropDownComponent },] }],
    columnHidingUI: [{ type: ViewChild, args: [IgxColumnHidingDirective, { read: IgxColumnActionsComponent },] }],
    columnHidingButton: [{ type: ViewChild, args: ['columnHidingButton', { read: IgxButtonDirective },] }],
    exportDropdown: [{ type: ViewChild, args: ['exportDropdown', { read: IgxDropDownComponent },] }],
    exportButton: [{ type: ViewChild, args: ['btnExport', { read: IgxButtonDirective },] }],
    columnPinningDropdown: [{ type: ViewChild, args: ['columnPinningDropdown', { read: IgxDropDownComponent },] }],
    columnPinningUI: [{ type: ViewChild, args: [IgxColumnPinningDirective, { read: IgxColumnActionsComponent },] }],
    columnPinningButton: [{ type: ViewChild, args: ['columnPinningButton', { read: IgxButtonDirective },] }],
    hostClass: [{ type: HostBinding, args: ['attr.class',] }]
};

/** @hidden @internal */
class IgxRowEditTemplateDirective {
}
IgxRowEditTemplateDirective.ɵfac = function IgxRowEditTemplateDirective_Factory(t) { return new (t || IgxRowEditTemplateDirective)(); };
IgxRowEditTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowEditTemplateDirective, selectors: [["", "igxRowEdit", ""]] });
/** @hidden @internal */
class IgxRowEditTextDirective {
}
IgxRowEditTextDirective.ɵfac = function IgxRowEditTextDirective_Factory(t) { return new (t || IgxRowEditTextDirective)(); };
IgxRowEditTextDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowEditTextDirective, selectors: [["", "igxRowEditText", ""]] });
/** @hidden @internal */
class IgxRowEditActionsDirective {
}
IgxRowEditActionsDirective.ɵfac = function IgxRowEditActionsDirective_Factory(t) { return new (t || IgxRowEditActionsDirective)(); };
IgxRowEditActionsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowEditActionsDirective, selectors: [["", "igxRowEditActions", ""]] });
// TODO: Refactor circular ref, deps and logic
/** @hidden @internal */
class IgxRowEditTabStopDirective {
    constructor(api, element) {
        this.api = api;
        this.element = element;
    }
    get grid() {
        return this.api.grid;
    }
    handleTab(event) {
        event.stopPropagation();
        if ((this.grid.rowEditTabs.last === this && !event.shiftKey) ||
            (this.grid.rowEditTabs.first === this && event.shiftKey)) {
            this.move(event);
        }
    }
    handleEscape(event) {
        this.grid.endEdit(false, event);
        this.grid.tbody.nativeElement.focus();
    }
    handleEnter(event) {
        event.stopPropagation();
    }
    /**
     * Moves focus to first/last editable cell in the editable row and put the cell in edit mode.
     * If cell is out of view first scrolls to the cell
     * @param event keyboard event containing information about whether SHIFT key was pressed
     */
    move(event) {
        event.preventDefault();
        this.currentCellIndex = event.shiftKey ? this.grid.lastEditableColumnIndex : this.grid.firstEditableColumnIndex;
        this.grid.navigation.activeNode.row = this.grid.rowInEditMode.index;
        this.grid.navigation.activeNode.column = this.currentCellIndex;
        this.grid.navigateTo(this.grid.rowInEditMode.index, this.currentCellIndex, (obj) => {
            obj.target.activate(event);
            this.grid.cdr.detectChanges();
        });
    }
}
IgxRowEditTabStopDirective.ɵfac = function IgxRowEditTabStopDirective_Factory(t) { return new (t || IgxRowEditTabStopDirective)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxRowEditTabStopDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowEditTabStopDirective, selectors: [["", "igxRowEditTabStop", ""]], hostBindings: function IgxRowEditTabStopDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.Tab", function IgxRowEditTabStopDirective_keydown_Tab_HostBindingHandler($event) { return ctx.handleTab($event); })("keydown.Shift.Tab", function IgxRowEditTabStopDirective_keydown_Shift_Tab_HostBindingHandler($event) { return ctx.handleTab($event); })("keydown.Escape", function IgxRowEditTabStopDirective_keydown_Escape_HostBindingHandler($event) { return ctx.handleEscape($event); })("keydown.Enter", function IgxRowEditTabStopDirective_keydown_Enter_HostBindingHandler($event) { return ctx.handleEnter($event); });
    } } });
IgxRowEditTabStopDirective.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ElementRef }
];
IgxRowEditTabStopDirective.propDecorators = {
    handleTab: [{ type: HostListener, args: ['keydown.Tab', [`$event`],] }, { type: HostListener, args: ['keydown.Shift.Tab', [`$event`],] }],
    handleEscape: [{ type: HostListener, args: ['keydown.Escape', [`$event`],] }],
    handleEnter: [{ type: HostListener, args: ['keydown.Enter', ['$event'],] }]
};

/**
 * @hidden
 */
class FilterListItem {
    constructor() {
        this.isSpecial = false;
        this.isBlanks = false;
    }
}
class IgxExcelStyleColumnOperationsTemplateDirective {
    constructor() { }
}
IgxExcelStyleColumnOperationsTemplateDirective.ɵfac = function IgxExcelStyleColumnOperationsTemplateDirective_Factory(t) { return new (t || IgxExcelStyleColumnOperationsTemplateDirective)(); };
IgxExcelStyleColumnOperationsTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExcelStyleColumnOperationsTemplateDirective, selectors: [["igx-excel-style-column-operations"], ["", "igxExcelStyleColumnOperations", ""]] });
IgxExcelStyleColumnOperationsTemplateDirective.ctorParameters = () => [];
class IgxExcelStyleFilterOperationsTemplateDirective {
    constructor() { }
}
IgxExcelStyleFilterOperationsTemplateDirective.ɵfac = function IgxExcelStyleFilterOperationsTemplateDirective_Factory(t) { return new (t || IgxExcelStyleFilterOperationsTemplateDirective)(); };
IgxExcelStyleFilterOperationsTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExcelStyleFilterOperationsTemplateDirective, selectors: [["igx-excel-style-filter-operations"], ["", "igxExcelStyleFilterOperations", ""]] });
IgxExcelStyleFilterOperationsTemplateDirective.ctorParameters = () => [];
/**
 * A component used for presenting Excel style filtering UI for a specific column.
 * It is used internally in the Grid, but could also be hosted in a container outside of it.
 *
 * Example:
 * ```html
 * <igx-grid-excel-style-filtering
 *     [column]="grid1.columns[0]">
 * </igx-grid-excel-style-filtering>
 * ```
 */
class IgxGridExcelStyleFilteringComponent {
    constructor(cdr, element, gridAPI) {
        this.cdr = cdr;
        this.element = element;
        this.gridAPI = gridAPI;
        this.destroy$ = new Subject();
        this.containsNullOrEmpty = false;
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        this.filterValues = new Set();
        /**
         * @hidden @internal
         */
        this.expressionsList = new Array();
        /**
         * @hidden @internal
         */
        this.listData = new Array();
        /**
         * @hidden @internal
         */
        this.uniqueValues = [];
        /**
         * @hidden @internal
         */
        this.className = 'igx-excel-filter';
        /**
         * @hidden @internal
         */
        this.inline = true;
        /**
         * @hidden @internal
         */
        this.loadingStart = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.loadingEnd = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.initialized = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.sortingChanged = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.columnChange = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.listDataLoaded = new EventEmitter();
    }
    /**
     * An @Input property that sets the column.
     */
    set column(value) {
        this._column = value;
        this.listData = new Array();
        this.columnChange.emit(this._column);
        if (this._columnPinning) {
            this._columnPinning.unsubscribe();
        }
        if (this._columnVisibilityChanged) {
            this._columnVisibilityChanged.unsubscribe();
        }
        if (this._sortingChanged) {
            this._sortingChanged.unsubscribe();
        }
        if (this._filteringChanged) {
            this._filteringChanged.unsubscribe();
        }
        if (this._densityChanged) {
            this._densityChanged.unsubscribe();
        }
        if (this._columnMoved) {
            this._columnMoved.unsubscribe();
        }
        if (this._column) {
            this._column.grid.filteringService.registerSVGIcons();
            this.init();
            this.sortingChanged.emit();
            this._columnPinning = this.grid.onColumnPinning.pipe(takeUntil(this.destroy$)).subscribe(() => {
                requestAnimationFrame(() => {
                    if (!this.cdr.destroyed) {
                        this.cdr.detectChanges();
                    }
                });
            });
            this._columnVisibilityChanged = this.grid.onColumnVisibilityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.cdr.detectChanges();
            });
            this._sortingChanged = this.grid.sortingExpressionsChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.sortingChanged.emit();
            });
            this._filteringChanged = this.grid.filteringExpressionsTreeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.init();
            });
            this._densityChanged = this.grid.onDensityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.cdr.detectChanges();
            });
            this._columnMoved = this.grid.onColumnMovingEnd.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.cdr.detectChanges();
            });
        }
    }
    /**
     * Returns the current column.
     */
    get column() {
        return this._column;
    }
    /**
     * @hidden @internal
     */
    get filteringService() {
        return this.grid.filteringService;
    }
    /**
     * Gets the minimum height.
     */
    get minHeight() {
        if (this._minHeight || this._minHeight === 0) {
            return this._minHeight;
        }
        if (!this.inline) {
            let minHeight = 645;
            switch (this.displayDensity) {
                case DisplayDensity.cosy:
                    minHeight = 465;
                    break;
                case DisplayDensity.compact:
                    minHeight = 330;
                    break;
                default: break;
            }
            return `${minHeight}px`;
        }
    }
    /**
     * Sets the minimum height.
     */
    set minHeight(value) {
        this._minHeight = value;
    }
    /**
     * Gets the maximum height.
     */
    get maxHeight() {
        if (this._maxHeight) {
            return this._maxHeight;
        }
        if (!this.inline) {
            let maxHeight = 775;
            switch (this.displayDensity) {
                case DisplayDensity.cosy:
                    maxHeight = 565;
                    break;
                case DisplayDensity.compact:
                    maxHeight = 405;
                    break;
                default: break;
            }
            return `${maxHeight}px`;
        }
    }
    /**
     * Sets the maximum height.
     */
    set maxHeight(value) {
        this._maxHeight = value;
    }
    /**
     * @hidden @internal
     */
    get grid() {
        var _a, _b, _c;
        return (_b = (_a = this.gridAPI) === null || _a === void 0 ? void 0 : _a.grid) !== null && _b !== void 0 ? _b : (_c = this.column) === null || _c === void 0 ? void 0 : _c.grid;
    }
    /**
     * @hidden @internal
     */
    get displayDensity() {
        var _a;
        return (_a = this.grid) === null || _a === void 0 ? void 0 : _a.displayDensity;
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    init() {
        this.expressionsList = new Array();
        this.filteringService.generateExpressionsList(this.column.filteringExpressionsTree, this.grid.filteringLogic, this.expressionsList);
        this.populateColumnData();
    }
    /**
     * @hidden @internal
     */
    selectedClass() {
        return this.column.selected ? 'igx-excel-filter__actions-selected' : 'igx-excel-filter__actions-select';
    }
    /**
     * @hidden @internal
     */
    initialize(column, overlayService, overlayComponentId) {
        this.inline = false;
        this.column = column;
        this.overlayService = overlayService;
        this.overlayComponentId = overlayComponentId;
        if (this._originalDisplay) {
            this.element.nativeElement.style.display = this._originalDisplay;
        }
        this.initialized.emit();
        this.grid.onColumnMoving.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.closeDropdown();
        });
    }
    /**
     * @hidden @internal
     */
    onPin() {
        this.column.pinned = !this.column.pinned;
        this.closeDropdown();
    }
    /**
     * @hidden @internal
     */
    onSelect() {
        if (!this.column.selected) {
            this.grid.selectionService.selectColumn(this.column.field, this.grid.columnSelection === GridSelectionMode.single);
        }
        else {
            this.grid.selectionService.deselectColumn(this.column.field);
        }
        this.grid.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    columnSelectable() {
        var _a, _b;
        return ((_a = this.grid) === null || _a === void 0 ? void 0 : _a.columnSelection) !== GridSelectionMode.none && ((_b = this.column) === null || _b === void 0 ? void 0 : _b.selectable);
    }
    /**
     * @hidden @internal
     */
    onHideToggle() {
        this.column.hidden = !this.column.hidden;
        this.grid.onColumnVisibilityChanged.emit({ column: this.column, newValue: this.column.hidden });
        this.closeDropdown();
    }
    areExpressionsSelectable() {
        if (this.expressionsList.length === 1 &&
            (this.expressionsList[0].expression.condition.name === 'equals' ||
                this.expressionsList[0].expression.condition.name === 'true' ||
                this.expressionsList[0].expression.condition.name === 'false' ||
                this.expressionsList[0].expression.condition.name === 'empty' ||
                this.expressionsList[0].expression.condition.name === 'in')) {
            return true;
        }
        const selectableExpressionsCount = this.expressionsList.filter(exp => (exp.beforeOperator === 1 || exp.afterOperator === 1) &&
            (exp.expression.condition.name === 'equals' ||
                exp.expression.condition.name === 'true' ||
                exp.expression.condition.name === 'false' ||
                exp.expression.condition.name === 'empty' ||
                exp.expression.condition.name === 'in')).length;
        return selectableExpressionsCount === this.expressionsList.length;
    }
    areExpressionsValuesInTheList() {
        if (this.column.dataType === DataType.Boolean) {
            return true;
        }
        if (this.filterValues.size === 1) {
            const firstValue = this.filterValues.values().next().value;
            if (!firstValue && firstValue !== 0) {
                return true;
            }
        }
        for (let index = 0; index < this.uniqueValues.length; index++) {
            const value = this.column.dataType === DataType.Date ? this.uniqueValues[index].label : this.uniqueValues[index];
            if (this.filterValues.has(value)) {
                return true;
            }
        }
        return false;
    }
    populateColumnData() {
        if (this.grid.uniqueColumnValuesStrategy) {
            this.cdr.detectChanges();
            this.renderColumnValuesRemotely();
        }
        else {
            this.renderColumnValuesFromData();
        }
    }
    renderColumnValuesRemotely() {
        this.loadingStart.emit();
        const expressionsTree = this.getColumnFilterExpressionsTree();
        const prevColumn = this.column;
        this.grid.uniqueColumnValuesStrategy(this.column, expressionsTree, (colVals) => {
            if (!this.column || this.column !== prevColumn) {
                return;
            }
            const columnValues = (this.column.dataType === DataType.Date) ?
                colVals.map(value => {
                    const label = this.getFilterItemLabel(value);
                    return { label, value };
                }) : colVals;
            this.renderValues(columnValues);
            this.loadingEnd.emit();
        });
    }
    renderColumnValuesFromData() {
        let data = this.column.gridAPI.get_all_data(this.grid.id);
        const expressionsTree = this.getColumnFilterExpressionsTree();
        if (expressionsTree.filteringOperands.length) {
            const state = { expressionsTree: expressionsTree };
            data = DataUtil.filter(cloneArray(data), state, this.grid);
        }
        const columnField = this.column.field;
        const columnValues = (this.column.dataType === DataType.Date) ?
            data.map(record => {
                const value = (resolveNestedPath(record, columnField));
                const label = this.getFilterItemLabel(value);
                return { label, value };
            }) : data.map(record => resolveNestedPath(record, columnField));
        this.renderValues(columnValues);
    }
    renderValues(columnValues) {
        this.generateUniqueValues(columnValues);
        this.generateFilterValues(this.column.dataType === DataType.Date);
        this.generateListData();
    }
    generateUniqueValues(columnValues) {
        if (this.column.dataType === DataType.String && this.column.filteringIgnoreCase) {
            const filteredUniqueValues = columnValues.map(s => s === null || s === void 0 ? void 0 : s.toString().toLowerCase())
                .reduce((map, val, i) => map.get(val) ? map : map.set(val, columnValues[i]), new Map);
            this.uniqueValues = Array.from(filteredUniqueValues.values());
        }
        else {
            this.uniqueValues = this.column.dataType === DataType.Date ? uniqueDates(columnValues) : Array.from(new Set(columnValues));
        }
    }
    generateFilterValues(isDateColumn = false) {
        if (isDateColumn) {
            this.filterValues = new Set(this.expressionsList.reduce((arr, e) => {
                if (e.expression.condition.name === 'in') {
                    return [...arr, ...Array.from(e.expression.searchVal.values()).map(v => this.getFilterItemLabel(v))];
                }
                return [...arr, ...[e.expression.searchVal ? this.getFilterItemLabel(e.expression.searchVal) : e.expression.searchVal]];
            }, []));
        }
        else {
            this.filterValues = new Set(this.expressionsList.reduce((arr, e) => {
                if (e.expression.condition.name === 'in') {
                    return [...arr, ...Array.from(e.expression.searchVal.values())];
                }
                return [...arr, ...[e.expression.searchVal]];
            }, []));
        }
    }
    generateListData() {
        this.listData = new Array();
        const shouldUpdateSelection = this.areExpressionsSelectable() && this.areExpressionsValuesInTheList();
        if (this.column.dataType === DataType.Boolean) {
            this.addBooleanItems();
        }
        else {
            this.addItems(shouldUpdateSelection);
        }
        this.listData.sort((a, b) => this.sortData(a, b));
        if (this.containsNullOrEmpty) {
            this.addBlanksItem(shouldUpdateSelection);
        }
        if (this.listData.length > 0) {
            this.addSelectAllItem();
        }
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
        this.listDataLoaded.emit();
    }
    getColumnFilterExpressionsTree() {
        const gridExpressionsTree = this.grid.filteringExpressionsTree;
        const expressionsTree = new FilteringExpressionsTree(gridExpressionsTree.operator, gridExpressionsTree.fieldName);
        for (const operand of gridExpressionsTree.filteringOperands) {
            if (operand instanceof FilteringExpressionsTree) {
                const columnExprTree = operand;
                if (columnExprTree.fieldName === this.column.field) {
                    break;
                }
            }
            expressionsTree.filteringOperands.push(operand);
        }
        return expressionsTree;
    }
    addBooleanItems() {
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        this.uniqueValues.forEach(element => {
            const filterListItem = new FilterListItem();
            if (element !== undefined && element !== null && element !== '') {
                if (this.column.filteringExpressionsTree) {
                    if (element === true && this.expressionsList.find(exp => exp.expression.condition.name === 'true')) {
                        filterListItem.isSelected = true;
                        filterListItem.isFiltered = true;
                        this.selectAllIndeterminate = true;
                    }
                    else if (element === false && this.expressionsList.find(exp => exp.expression.condition.name === 'false')) {
                        filterListItem.isSelected = true;
                        filterListItem.isFiltered = true;
                        this.selectAllIndeterminate = true;
                    }
                    else {
                        filterListItem.isSelected = false;
                        filterListItem.isFiltered = false;
                    }
                }
                else {
                    filterListItem.isSelected = true;
                    filterListItem.isFiltered = true;
                }
                filterListItem.value = element;
                filterListItem.label = element;
                filterListItem.indeterminate = false;
                this.listData.push(filterListItem);
            }
            else {
                this.containsNullOrEmpty = true;
            }
        });
    }
    addItems(shouldUpdateSelection) {
        this.selectAllSelected = true;
        this.containsNullOrEmpty = false;
        this.selectAllIndeterminate = false;
        this.uniqueValues.forEach(element => {
            const hasValue = (element !== undefined && element !== null && element !== '' && this.column.dataType !== DataType.Date)
                || !!(element && element.label);
            if (hasValue) {
                const filterListItem = new FilterListItem();
                filterListItem.isSelected = true;
                filterListItem.isFiltered = true;
                if (this.column.filteringExpressionsTree) {
                    filterListItem.isSelected = false;
                    filterListItem.isFiltered = false;
                    if (shouldUpdateSelection) {
                        if (this.filterValues.has(element.label || element)) {
                            filterListItem.isSelected = true;
                            filterListItem.isFiltered = true;
                        }
                        this.selectAllIndeterminate = true;
                    }
                    else {
                        this.selectAllSelected = false;
                    }
                }
                filterListItem.value = this.getFilterItemValue(element);
                filterListItem.label = this.getFilterItemLabel(element);
                filterListItem.indeterminate = false;
                this.listData.push(filterListItem);
            }
        });
        this.containsNullOrEmpty = this.uniqueValues.length > this.listData.length;
    }
    addSelectAllItem() {
        const selectAll = new FilterListItem();
        selectAll.isSelected = this.selectAllSelected;
        selectAll.value = this.grid.resourceStrings.igx_grid_excel_select_all;
        selectAll.label = this.grid.resourceStrings.igx_grid_excel_select_all;
        selectAll.indeterminate = this.selectAllIndeterminate;
        selectAll.isSpecial = true;
        selectAll.isFiltered = this.selectAllSelected;
        this.listData.unshift(selectAll);
    }
    addBlanksItem(shouldUpdateSelection) {
        const blanks = new FilterListItem();
        if (this.column.filteringExpressionsTree) {
            if (shouldUpdateSelection) {
                if (this.filterValues.has(null)) {
                    blanks.isSelected = true;
                    blanks.isFiltered = true;
                }
                else {
                    blanks.isSelected = false;
                    blanks.isFiltered = false;
                }
            }
        }
        else {
            blanks.isSelected = true;
            blanks.isFiltered = true;
        }
        blanks.value = null;
        blanks.label = this.grid.resourceStrings.igx_grid_excel_blanks;
        blanks.indeterminate = false;
        blanks.isSpecial = true;
        blanks.isBlanks = true;
        this.listData.unshift(blanks);
    }
    sortData(a, b) {
        let valueA = a.value;
        let valueB = b.value;
        if (typeof (a) === DataType.String) {
            valueA = a.value.toUpperCase();
            valueB = b.value.toUpperCase();
        }
        if (valueA < valueB) {
            return -1;
        }
        else if (valueA > valueB) {
            return 1;
        }
        else {
            return 0;
        }
    }
    getFilterItemLabel(element) {
        if (this.column.dataType === DataType.Date) {
            return element && element.label ? element.label : this.column.formatter ?
                this.column.formatter(element) :
                this.grid.datePipe.transform(element, this.column.pipeArgs.format, this.column.pipeArgs.timezone, this.grid.locale);
        }
        if (this.column.dataType === DataType.Number) {
            return this.column.formatter ?
                this.column.formatter(element) :
                this.grid.decimalPipe.transform(element, this.column.pipeArgs.digitsInfo, this.grid.locale);
        }
        return this.column.formatter ?
            this.column.formatter(element) :
            element;
    }
    getFilterItemValue(element) {
        if (this.column.dataType === DataType.Date) {
            element = parseDate(element.value);
        }
        return element;
    }
    // TODO: sort members by access modifier
    /**
     * @hidden @internal
     */
    cancel() {
        if (!this.overlayComponentId) {
            this.init();
        }
        this.closeDropdown();
    }
    /**
     * @hidden @internal
     */
    closeDropdown() {
        if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
            this.overlayComponentId = null;
        }
    }
    /**
     * @hidden @internal
     */
    onKeyDown(eventArgs) {
        if (eventArgs.key === "Escape" /* ESCAPE */ || eventArgs.key === "Esc" /* ESCAPE_IE */ ||
            eventArgs.ctrlKey && eventArgs.shiftKey && eventArgs.key.toLowerCase() === 'l') {
            this.closeDropdown();
        }
        eventArgs.stopPropagation();
    }
    /**
     * @hidden @internal
     */
    hide() {
        this._originalDisplay = document.defaultView.getComputedStyle(this.element.nativeElement).display;
        this.element.nativeElement.style.display = 'none';
    }
    /**
     * @hidden @internal
     */
    detectChanges() {
        this.cdr.detectChanges();
    }
}
IgxGridExcelStyleFilteringComponent.ɵfac = function IgxGridExcelStyleFilteringComponent_Factory(t) { return new (t || IgxGridExcelStyleFilteringComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService, 9)); };
IgxGridExcelStyleFilteringComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridExcelStyleFilteringComponent, selectors: [["igx-grid-excel-style-filtering"]], contentQueries: function IgxGridExcelStyleFilteringComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExcelStyleColumnOperationsTemplateDirective, true, IgxExcelStyleColumnOperationsTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExcelStyleFilterOperationsTemplateDirective, true, IgxExcelStyleFilterOperationsTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.excelColumnOperationsDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.excelFilterOperationsDirective = _t.first);
    } }, viewQuery: function IgxGridExcelStyleFilteringComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c89, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c90, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(_c91, true, ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExcelColumnOperations = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExcelFilterOperations = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.mainDropdown = _t.first);
    } }, hostVars: 6, hostBindings: function IgxGridExcelStyleFilteringComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("max-height", ctx.maxHeight);
        ɵngcc0.ɵɵclassProp("igx-excel-filter", ctx.className)("igx-excel-filter--inline", ctx.inline);
    } }, inputs: { column: "column", minHeight: "minHeight", maxHeight: "maxHeight" }, outputs: { loadingStart: "loadingStart", loadingEnd: "loadingEnd", initialized: "initialized", sortingChanged: "sortingChanged", columnChange: "columnChange", listDataLoaded: "listDataLoaded" }, ngContentSelectors: _c94, decls: 8, vars: 13, consts: [["defaultExcelColumnOperations", ""], ["defaultExcelFilterOperations", ""], [1, "igx-excel-filter__menu", 3, "ngClass", "id", "keydown"], ["mainDropdown", ""], [4, "ngIf", "ngIfElse"], [3, "showHiding", "showPinning", "showSelecting"], [4, "ngIf"]], template: function IgxGridExcelStyleFilteringComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c92);
        ɵngcc0.ɵɵtemplate(0, IgxGridExcelStyleFilteringComponent_ng_template_0_Template, 6, 8, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxGridExcelStyleFilteringComponent_ng_template_2_Template, 3, 0, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(4, "article", 2, 3);
        ɵngcc0.ɵɵlistener("keydown", function IgxGridExcelStyleFilteringComponent_Template_article_keydown_4_listener($event) { return ctx.onKeyDown($event); });
        ɵngcc0.ɵɵtemplate(6, IgxGridExcelStyleFilteringComponent_ng_container_6_Template, 2, 0, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(7, IgxGridExcelStyleFilteringComponent_ng_container_7_Template, 2, 0, "ng-container", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r0 = ɵngcc0.ɵɵreference(1);
        const _r2 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵstyleProp("min-height", ctx.minHeight)("max-height", ctx.maxHeight);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(10, _c93, ctx.displayDensity === "cosy", ctx.displayDensity === "compact"))("id", ctx.overlayComponentId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.excelColumnOperationsDirective)("ngIfElse", _r0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.excelFilterOperationsDirective)("ngIfElse", _r2);
    } }, directives: function () { return [ɵngcc2.NgClass, ɵngcc2.NgIf, IgxExcelStyleHeaderComponent, IgxExcelStyleSortingComponent, IgxExcelStyleMovingComponent, IgxExcelStylePinningComponent, IgxExcelStyleHidingComponent, IgxExcelStyleSelectingComponent, IgxExcelStyleClearFiltersComponent, IgxExcelStyleConditionalFilterComponent, IgxExcelStyleSearchComponent]; }, encapsulation: 2, changeDetection: 0 });
IgxGridExcelStyleFilteringComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: GridBaseAPIService, decorators: [{ type: Host }, { type: Optional }] }
];
IgxGridExcelStyleFilteringComponent.propDecorators = {
    column: [{ type: Input }],
    minHeight: [{ type: Input }],
    maxHeight: [{ type: Input }, { type: HostBinding, args: ['style.max-height',] }],
    className: [{ type: HostBinding, args: ['class.igx-excel-filter',] }],
    inline: [{ type: HostBinding, args: ['class.igx-excel-filter--inline',] }],
    loadingStart: [{ type: Output }],
    loadingEnd: [{ type: Output }],
    initialized: [{ type: Output }],
    sortingChanged: [{ type: Output }],
    columnChange: [{ type: Output }],
    listDataLoaded: [{ type: Output }],
    defaultExcelColumnOperations: [{ type: ViewChild, args: ['defaultExcelColumnOperations', { read: TemplateRef, static: true },] }],
    defaultExcelFilterOperations: [{ type: ViewChild, args: ['defaultExcelFilterOperations', { read: TemplateRef, static: true },] }],
    mainDropdown: [{ type: ViewChild, args: ['mainDropdown', { read: ElementRef },] }],
    excelColumnOperationsDirective: [{ type: ContentChild, args: [IgxExcelStyleColumnOperationsTemplateDirective, { read: IgxExcelStyleColumnOperationsTemplateDirective },] }],
    excelFilterOperationsDirective: [{ type: ContentChild, args: [IgxExcelStyleFilterOperationsTemplateDirective, { read: IgxExcelStyleFilterOperationsTemplateDirective },] }]
};

/** @hidden */
class IgxGridNavigationService {
    constructor() {
        this._activeNode = {};
        this.pendingNavigation = false;
    }
    get activeNode() {
        return this._activeNode;
    }
    set activeNode(value) {
        this._activeNode = value;
    }
    handleNavigation(event) {
        const key = event.key.toLowerCase();
        if (event.repeat && SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) {
            event.preventDefault();
        }
        event.repeat ? setTimeout(() => this.dispatchEvent(event), 1) : this.dispatchEvent(event);
    }
    dispatchEvent(event) {
        const key = event.key.toLowerCase();
        if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) &&
            !this.grid.crudService.rowEditingBlocked && !this.grid.rowInEditMode) {
            return;
        }
        const shift = event.shiftKey;
        const ctrl = event.ctrlKey;
        if (NAVIGATION_KEYS.has(key) && this.pendingNavigation) {
            event.preventDefault();
            return;
        }
        const type = this.isDataRow(this.activeNode.row) ? 'dataCell' :
            this.isDataRow(this.activeNode.row, true) ? 'summaryCell' : 'groupRow';
        if (this.emitKeyDown(type, this.activeNode.row, event)) {
            return;
        }
        if (event.altKey) {
            this.handleAlt(key, event);
            return;
        }
        if ([' ', 'spacebar', 'space'].indexOf(key) === -1) {
            this.grid.selectionService.keyboardStateOnKeydown(this.activeNode, shift, shift && key === 'tab');
        }
        if (this.grid.crudService.cell && NAVIGATION_KEYS.has(key)) {
            return;
        }
        const position = this.getNextPosition(this.activeNode.row, this.activeNode.column, key, shift, ctrl, event);
        if (NAVIGATION_KEYS.has(key)) {
            event.preventDefault();
            this.navigateInBody(position.rowIndex, position.colIndex, (obj) => {
                obj.target.activate(event);
                this.grid.cdr.detectChanges();
            });
        }
        this.grid.cdr.detectChanges();
    }
    getNextPosition(rowIndex, colIndex, key, shift, ctrl, event) {
        if (!this.isDataRow(rowIndex, true) && (key.indexOf('down') < 0 || key.indexOf('up') < 0) && ctrl) {
            return { rowIndex, colIndex };
        }
        switch (key) {
            case 'pagedown':
            case 'pageup':
                event.preventDefault();
                key === 'pagedown' ? this.grid.verticalScrollContainer.scrollNextPage() :
                    this.grid.verticalScrollContainer.scrollPrevPage();
                const editCell = this.grid.crudService.cell;
                this.grid.verticalScrollContainer.onChunkLoad
                    .pipe(first$1()).subscribe(() => {
                    if (editCell && this.grid.rowList.map(r => r.index).indexOf(editCell.rowIndex) < 0) {
                        this.grid.tbody.nativeElement.focus({ preventScroll: true });
                    }
                });
                break;
            case 'tab':
                this.handleEditing(shift, event);
                break;
            case 'end':
                rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row;
                colIndex = this.lastColumnIndex;
                break;
            case 'home':
                rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row;
                colIndex = 0;
                break;
            case 'arrowleft':
            case 'left':
                colIndex = ctrl ? 0 : this.activeNode.column - 1;
                break;
            case 'arrowright':
            case 'right':
                colIndex = ctrl ? this.lastColumnIndex : this.activeNode.column + 1;
                break;
            case 'arrowup':
            case 'up':
                if (ctrl && !this.isDataRow(rowIndex) || (this.grid.rowEditable && this.grid.crudService.rowEditingBlocked)) {
                    break;
                }
                colIndex = this.activeNode.column !== undefined ? this.activeNode.column : 0;
                rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row - 1;
                break;
            case 'arrowdown':
            case 'down':
                if ((ctrl && !this.isDataRow(rowIndex)) || (this.grid.rowEditable && this.grid.crudService.rowEditingBlocked)) {
                    break;
                }
                colIndex = this.activeNode.column !== undefined ? this.activeNode.column : 0;
                rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row + 1;
                break;
            case 'enter':
            case 'f2':
                const cell = this.grid.getCellByColumnVisibleIndex(this.activeNode.row, this.activeNode.column);
                if (!this.isDataRow(rowIndex) || !cell.editable) {
                    break;
                }
                this.grid.crudService.enterEditMode(cell);
                break;
            case 'escape':
            case 'esc':
                if (!this.isDataRow(rowIndex)) {
                    break;
                }
                if (this.grid.crudService.isInCompositionMode) {
                    return;
                }
                if (this.grid.crudService.cellInEditMode || this.grid.crudService.rowInEditMode) {
                    this.grid.endEdit(false);
                    if (isEdge()) {
                        this.grid.cdr.detectChanges();
                    }
                    this.grid.tbody.nativeElement.focus();
                }
                break;
            case ' ':
            case 'spacebar':
            case 'space':
                const rowObj = this.grid.getRowByIndex(this.activeNode.row);
                if (this.grid.isRowSelectable && this.isDataRow(rowIndex)) {
                    rowObj && rowObj.selected ? this.grid.selectionService.deselectRow(rowObj.rowID, event) :
                        this.grid.selectionService.selectRowById(rowObj.rowID, false, event);
                }
                break;
            default:
                return;
        }
        return { rowIndex, colIndex };
    }
    summaryNav(event) {
        if (this.grid.hasSummarizedColumns) {
            this.horizontalNav(event, event.key.toLowerCase(), this.grid.dataView.length, 'summaryCell');
        }
    }
    headerNavigation(event) {
        const key = event.key.toLowerCase();
        if (!HEADER_KEYS.has(key)) {
            return;
        }
        event.preventDefault();
        const ctrl = event.ctrlKey;
        const shift = event.shiftKey;
        const alt = event.altKey;
        this.performHeaderKeyCombination(this.currentActiveColumn, key, shift, ctrl, alt, event);
        if (shift || alt || (ctrl && (key.includes('down') || key.includes('down')))) {
            return;
        }
        !this.grid.hasColumnGroups ? this.horizontalNav(event, key, -1, 'headerCell') : this.handleMCHeaderNav(key, ctrl);
    }
    horizontalNav(event, key, rowIndex, tag) {
        const ctrl = event.ctrlKey;
        if (!HORIZONTAL_NAV_KEYS.has(event.key.toLowerCase())) {
            return;
        }
        event.preventDefault();
        this.activeNode.row = rowIndex;
        if (rowIndex > 0) {
            if (this.emitKeyDown('summaryCell', this.activeNode.row, event)) {
                return;
            }
        }
        const newActiveNode = {
            column: this.activeNode.column,
            mchCache: {
                level: this.activeNode.level,
                visibleIndex: this.activeNode.column
            }
        };
        if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {
            newActiveNode.column = ctrl || key === 'home' ? 0 : this.activeNode.column - 1;
        }
        if ((key.includes('right') || key === 'end') && this.activeNode.column < this.lastColumnIndex) {
            newActiveNode.column = ctrl || key === 'end' ? this.lastColumnIndex : this.activeNode.column + 1;
        }
        if (tag === 'headerCell') {
            const column = this.grid.getColumnByVisibleIndex(newActiveNode.column);
            newActiveNode.mchCache.level = column.level;
            newActiveNode.mchCache.visibleIndex = column.visibleIndex;
        }
        this.setActiveNode({ row: this.activeNode.row, column: newActiveNode.column, mchCache: newActiveNode.mchCache });
        this.performHorizontalScrollToCell(this.activeNode.column);
    }
    focusTbody(event) {
        var _a;
        const gridRows = (_a = this.grid.verticalScrollContainer.totalItemCount) !== null && _a !== void 0 ? _a : this.grid.dataView.length;
        if (gridRows < 1) {
            this.activeNode = null;
            return;
        }
        if (!Object.keys(this.activeNode).length || this.activeNode.row < 0 || this.activeNode.row > gridRows - 1) {
            this.grid.navigateTo(0, 0, (obj) => {
                this.grid.clearCellSelection();
                obj.target.activate(event);
            });
        }
    }
    focusFirstCell(header = true) {
        if ((header || this.grid.dataView.length) && this.activeNode &&
            (this.activeNode.row === -1 || this.activeNode.row === this.grid.dataView.length ||
                (!header && !this.grid.hasSummarizedColumns))) {
            return;
        }
        this.setActiveNode({
            row: header ? -1 : this.grid.dataView.length, column: 0,
            level: this.grid.hasColumnLayouts ? 1 : 0, mchCache: { level: 0, visibleIndex: 0 }
        });
        this.performHorizontalScrollToCell(0);
    }
    get lastColumnIndex() {
        return Math.max(...this.grid.visibleColumns.map(col => col.visibleIndex));
    }
    get displayContainerWidth() {
        return Math.round(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth);
    }
    get displayContainerScrollLeft() {
        return Math.ceil(this.grid.headerContainer.scrollPosition);
    }
    get containerTopOffset() {
        return parseInt(this.grid.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement.style.top, 10);
    }
    isColumnFullyVisible(columnIndex) {
        if (columnIndex < 0 || this.isColumnPinned(columnIndex, this.forOfDir())) {
            return true;
        }
        const index = this.getColumnUnpinnedIndex(columnIndex);
        const width = this.forOfDir().getColumnScrollLeft(index + 1) - this.forOfDir().getColumnScrollLeft(index);
        if (this.displayContainerWidth < width && this.displayContainerScrollLeft === this.forOfDir().getColumnScrollLeft(index)) {
            return true;
        }
        return this.displayContainerWidth >= this.forOfDir().getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft &&
            this.displayContainerScrollLeft <= this.forOfDir().getColumnScrollLeft(index);
    }
    getColumnUnpinnedIndex(visibleColumnIndex) {
        const column = this.grid.unpinnedColumns.find((col) => !col.columnGroup && col.visibleIndex === visibleColumnIndex);
        return this.grid.pinnedColumns.length ? this.grid.unpinnedColumns.filter((c) => !c.columnGroup).indexOf(column) :
            visibleColumnIndex;
    }
    forOfDir() {
        const forOfDir = this.grid.dataRowList.length > 0 ? this.grid.dataRowList.first.virtDirRow : this.grid.headerContainer;
        return forOfDir;
    }
    handleAlt(key, event) {
        event.preventDefault();
        const row = this.grid.getRowByIndex(this.activeNode.row);
        if (!(this.isToggleKey(key) || this.isAddKey(key)) || !row) {
            return;
        }
        if (this.isAddKey(key)) {
            if (!this.grid.rowEditable) {
                console.warn('The grid must be in row edit mode to perform row adding!');
                return;
            }
            if (event.shiftKey && row.treeRow !== undefined) {
                row.beginAddChild();
            }
            else if (!event.shiftKey) {
                row.beginAddRow();
            }
        }
        else if (!row.expanded && ROW_EXPAND_KEYS.has(key)) {
            row.rowID === undefined ? row.toggle() :
                this.grid.gridAPI.set_row_expansion_state(row.rowID, true, event);
        }
        else if (row.expanded && ROW_COLLAPSE_KEYS.has(key)) {
            row.rowID === undefined ? row.toggle() :
                this.grid.gridAPI.set_row_expansion_state(row.rowID, false, event);
        }
        this.grid.notifyChanges();
    }
    handleEditing(shift, event) {
        var _a;
        const next = shift ? this.grid.getPreviousCell(this.activeNode.row, this.activeNode.column, col => col.editable) :
            this.grid.getNextCell(this.activeNode.row, this.activeNode.column, col => col.editable);
        if (!this.grid.rowInEditMode && this.isActiveNode(next.rowIndex, next.visibleColumnIndex)) {
            this.grid.endEdit(true);
            return;
        }
        event.preventDefault();
        if ((this.grid.rowInEditMode && this.grid.rowEditTabs.length) &&
            (this.activeNode.row !== next.rowIndex || this.isActiveNode(next.rowIndex, next.visibleColumnIndex))) {
            if ((_a = this.grid.crudService.row) === null || _a === void 0 ? void 0 : _a.isAddRow) {
                this.grid.gridAPI.submit_add_value();
                const row = this.grid.rowList.find(r => r.rowID === this.grid.crudService.row.id);
                row.rowData = this.grid.crudService.row.data;
            }
            else {
                this.grid.gridAPI.submit_value();
            }
            shift ? this.grid.rowEditTabs.last.element.nativeElement.focus() :
                this.grid.rowEditTabs.first.element.nativeElement.focus();
            return;
        }
        if (this.grid.rowInEditMode && !this.grid.rowEditTabs.length) {
            if (shift && next.rowIndex === this.activeNode.row && next.visibleColumnIndex === this.activeNode.column) {
                next.visibleColumnIndex = this.grid.lastEditableColumnIndex;
            }
            else if (!shift && next.rowIndex === this.activeNode.row && next.visibleColumnIndex === this.activeNode.column) {
                next.visibleColumnIndex = this.grid.firstEditableColumnIndex;
            }
            else {
                next.rowIndex = this.activeNode.row;
            }
        }
        this.navigateInBody(next.rowIndex, next.visibleColumnIndex, (obj) => {
            obj.target.activate(event);
            this.grid.cdr.detectChanges();
        });
    }
    shouldPerformHorizontalScroll(visibleColIndex, rowIndex = -1) {
        if (visibleColIndex < 0 || visibleColIndex > this.grid.visibleColumns.length - 1) {
            return false;
        }
        if (rowIndex < 0 || rowIndex > this.grid.dataView.length - 1) {
            return !this.isColumnFullyVisible(visibleColIndex);
        }
        const row = this.grid.dataView[rowIndex];
        return row.expression || row.detailsData ? false : !this.isColumnFullyVisible(visibleColIndex);
    }
    shouldPerformVerticalScroll(targetRowIndex, visibleColIndex) {
        if (this.grid.isRecordPinnedByViewIndex(targetRowIndex)) {
            return false;
        }
        const scrollRowIndex = this.grid.hasPinnedRecords && this.grid.isRowPinningToTop ?
            targetRowIndex - this.grid.pinnedDataView.length : targetRowIndex;
        const targetRow = this.getRowElementByIndex(targetRowIndex);
        const rowHeight = this.grid.verticalScrollContainer.getSizeAt(scrollRowIndex);
        const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        const endTopOffset = targetRow ? targetRow.offsetTop + rowHeight + this.containerTopOffset : containerHeight + rowHeight;
        // this is workaround: endTopOffset - containerHeight > 5 and should be replaced with: containerHeight < endTopOffset
        // when the page is zoomed the grid does not scroll the row completely in the view
        return !targetRow || targetRow.offsetTop < Math.abs(this.containerTopOffset)
            || containerHeight && endTopOffset - containerHeight > 5;
    }
    navigateInBody(rowIndex, visibleColIndex, cb = null) {
        if (!this.isValidPosition(rowIndex, visibleColIndex) || this.isActiveNode(rowIndex, visibleColIndex)) {
            return;
        }
        this.grid.navigateTo(rowIndex, visibleColIndex, cb);
    }
    performVerticalScrollToCell(rowIndex, visibleColIndex = -1, cb) {
        if (!this.shouldPerformVerticalScroll(rowIndex, visibleColIndex)) {
            return;
        }
        this.pendingNavigation = true;
        // Only for top pinning we need to subtract pinned count because virtualization indexing doesn't count pinned rows.
        const scrollRowIndex = this.grid.hasPinnedRecords && this.grid.isRowPinningToTop ?
            rowIndex - this.grid.pinnedDataView.length : rowIndex;
        this.grid.verticalScrollContainer.scrollTo(scrollRowIndex);
        this.grid.verticalScrollContainer.onChunkLoad
            .pipe(first$1()).subscribe(() => {
            this.pendingNavigation = false;
            if (cb) {
                cb();
            }
        });
    }
    performHorizontalScrollToCell(visibleColumnIndex, cb) {
        if (!this.shouldPerformHorizontalScroll(visibleColumnIndex)) {
            return;
        }
        this.pendingNavigation = true;
        this.grid.parentVirtDir.onChunkLoad
            .pipe(first$1())
            .subscribe(() => {
            this.pendingNavigation = false;
            if (cb) {
                cb();
            }
        });
        this.forOfDir().scrollTo(this.getColumnUnpinnedIndex(visibleColumnIndex));
    }
    isDataRow(rowIndex, includeSummary = false) {
        if (rowIndex < 0 || rowIndex > this.grid.dataView.length - 1) {
            return false;
        }
        const curRow = this.grid.dataView[rowIndex];
        return curRow && !this.grid.isGroupByRecord(curRow) && !this.grid.isDetailRecord(curRow)
            && !curRow.childGridsData && (includeSummary || !curRow.summaries);
    }
    setActiveNode(activeNode) {
        if (!this.isActiveNodeChanged(activeNode)) {
            return;
        }
        if (!this.activeNode) {
            this.activeNode = activeNode;
        }
        Object.assign(this.activeNode, activeNode);
        const currRow = this.grid.dataView[activeNode.row];
        const type = activeNode.row < 0 ? 'headerCell' :
            this.isDataRow(activeNode.row) ? 'dataCell' :
                currRow && this.grid.isGroupByRecord(currRow) ? 'groupRow' :
                    currRow && this.grid.isDetailRecord(currRow) ? 'masterDetailRow' : 'summaryCell';
        const args = {
            row: this.activeNode.row,
            column: this.activeNode.column,
            level: this.activeNode.level,
            tag: type
        };
        this.grid.activeNodeChange.emit(args);
    }
    isActiveNodeChanged(activeNode) {
        let isChanged = false;
        const checkInnerProp = (aciveNode, prop) => {
            if (!aciveNode) {
                isChanged = true;
                return;
            }
            props = Object.getOwnPropertyNames(aciveNode);
            for (let i = 0; i < props.length; i++) {
                const propName = props[i];
                if (this.activeNode[prop][propName] !== aciveNode[propName]) {
                    isChanged = true;
                }
            }
        };
        if (!this.activeNode) {
            return isChanged = true;
        }
        let props = Object.getOwnPropertyNames(activeNode);
        for (let i = 0; i < props.length; i++) {
            const propName = props[i];
            if (!!this.activeNode[propName] && typeof this.activeNode[propName] === 'object') {
                checkInnerProp(activeNode[propName], propName);
            }
            else if (this.activeNode[propName] !== activeNode[propName]) {
                isChanged = true;
            }
        }
        return isChanged;
    }
    emitKeyDown(type, rowIndex, event) {
        var _a, _b;
        const row = this.grid.summariesRowList.toArray().concat(this.grid.rowList.toArray()).find(r => r.index === rowIndex);
        if (!row) {
            return;
        }
        const target = type === 'groupRow' ? row :
            type === 'dataCell' ? (_a = row.cells) === null || _a === void 0 ? void 0 : _a.find(c => c.visibleColumnIndex === this.activeNode.column) : (_b = row.summaryCells) === null || _b === void 0 ? void 0 : _b.find(c => c.visibleColumnIndex === this.activeNode.column);
        const keydownArgs = { targetType: type, event: event, cancel: false, target: target };
        this.grid.onGridKeydown.emit(keydownArgs);
        if (keydownArgs.cancel && type === 'dataCell') {
            this.grid.selectionService.clear();
            this.grid.selectionService.keyboardState.active = true;
            return keydownArgs.cancel;
        }
    }
    isColumnPinned(columnIndex, forOfDir) {
        var _a;
        const horizontalScroll = forOfDir.getScroll();
        return (!horizontalScroll.clientWidth || ((_a = this.grid.getColumnByVisibleIndex(columnIndex)) === null || _a === void 0 ? void 0 : _a.pinned));
    }
    findFirstDataRowIndex() {
        return this.grid.dataView.findIndex(rec => !this.grid.isGroupByRecord(rec) && !this.grid.isDetailRecord(rec));
    }
    findLastDataRowIndex() {
        if (this.grid.totalItemCount) {
            return this.grid.totalItemCount - 1;
        }
        let i = this.grid.dataView.length;
        while (i--) {
            if (this.isDataRow(i)) {
                return i;
            }
        }
    }
    getRowElementByIndex(index) {
        var _a;
        if (this.grid.hasDetails) {
            const detail = this.grid.nativeElement.querySelector(`[detail="true"][data-rowindex="${index}"]`);
            if (detail) {
                return detail;
            }
        }
        return (_a = this.grid.rowList.toArray().concat(this.grid.summariesRowList.toArray()).find(r => r.index === index)) === null || _a === void 0 ? void 0 : _a.nativeElement;
    }
    isValidPosition(rowIndex, colIndex) {
        var _a;
        const length = (_a = this.grid.totalItemCount) !== null && _a !== void 0 ? _a : this.grid.dataView.length;
        if (rowIndex < 0 || colIndex < 0 || length - 1 < rowIndex || this.lastColumnIndex < colIndex) {
            return false;
        }
        return this.activeNode.column !== colIndex && !this.isDataRow(rowIndex, true) ? false : true;
    }
    performHeaderKeyCombination(column, key, shift, ctrl, alt, event) {
        var _a;
        let direction = (_a = this.grid.sortingExpressions.find(expr => expr.fieldName === column.field)) === null || _a === void 0 ? void 0 : _a.dir;
        if (ctrl && key.includes('up') && column.sortable && !column.columnGroup) {
            direction = direction === SortingDirection.Asc ? SortingDirection.None : SortingDirection.Asc;
            this.grid.sort({ fieldName: column.field, dir: direction, ignoreCase: false });
            return;
        }
        if (ctrl && key.includes('down') && column.sortable && !column.columnGroup) {
            direction = direction === SortingDirection.Desc ? SortingDirection.None : SortingDirection.Desc;
            this.grid.sort({ fieldName: column.field, dir: direction, ignoreCase: false });
            return;
        }
        if (shift && alt && this.isToggleKey(key) && !column.columnGroup && column.groupable) {
            direction = direction ? SortingDirection.Desc : SortingDirection.Asc;
            key.includes('right') ? this.grid.groupBy({ fieldName: column.field, dir: direction, ignoreCase: false }) :
                this.grid.clearGrouping(column.field);
            this.activeNode.column = key.includes('right') && this.grid.hideGroupedColumns &&
                column.visibleIndex === this.lastColumnIndex ? this.lastColumnIndex - 1 : this.activeNode.column;
            return;
        }
        if (alt && (ROW_EXPAND_KEYS.has(key) || ROW_COLLAPSE_KEYS.has(key))) {
            this.handleMCHExpandCollapse(key, column);
            return;
        }
        if ([' ', 'spacebar', 'space'].indexOf(key) !== -1) {
            this.handleColumnSelection(column, event);
        }
        if (alt && (key === 'l' || key === '¬') && this.grid.allowAdvancedFiltering) {
            this.grid.openAdvancedFilteringDialog();
        }
        if (ctrl && shift && key === 'l' && this.grid.allowFiltering && !column.columnGroup && column.filterable) {
            if (this.grid.filterMode === FilterMode.excelStyleFilter) {
                const headerEl = this.grid.nativeElement.querySelector(`.igx-grid__th--active`);
                this.grid.filteringService.toggleFilterDropdown(headerEl, column, IgxGridExcelStyleFilteringComponent);
            }
            else {
                this.performHorizontalScrollToCell(column.visibleIndex);
                this.grid.filteringService.filteredColumn = column;
                this.grid.filteringService.isFilterRowVisible = true;
            }
        }
    }
    handleMCHeaderNav(key, ctrl) {
        const newHeaderNode = {
            visibleIndex: this.activeNode.mchCache.visibleIndex,
            level: this.activeNode.mchCache.level
        };
        const activeCol = this.currentActiveColumn;
        const lastGroupIndex = Math.max(...this.grid.visibleColumns.
            filter(c => c.level <= this.activeNode.level).map(col => col.visibleIndex));
        let nextCol = activeCol;
        if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {
            const index = ctrl || key === 'home' ? 0 : this.activeNode.column - 1;
            nextCol = this.getNextColumnMCH(index);
            newHeaderNode.visibleIndex = nextCol.visibleIndex;
        }
        if ((key.includes('right') || key === 'end') && activeCol.visibleIndex < lastGroupIndex) {
            const nextVIndex = activeCol.children ? Math.max(...activeCol.allChildren.map(c => c.visibleIndex)) + 1 :
                activeCol.visibleIndex + 1;
            nextCol = ctrl || key === 'end' ? this.getNextColumnMCH(this.lastColumnIndex) : this.getNextColumnMCH(nextVIndex);
            newHeaderNode.visibleIndex = nextCol.visibleIndex;
        }
        if (!ctrl && key.includes('up') && this.activeNode.level > 0) {
            nextCol = activeCol.parent;
            newHeaderNode.level = nextCol.level;
        }
        if (!ctrl && key.includes('down') && activeCol.children) {
            nextCol = activeCol.children.find(c => c.visibleIndex === newHeaderNode.visibleIndex) ||
                activeCol.children.toArray().sort((a, b) => b.visibleIndex - a.visibleIndex)
                    .filter(col => col.visibleIndex < newHeaderNode.visibleIndex)[0];
            newHeaderNode.level = nextCol.level;
        }
        this.setActiveNode({
            row: this.activeNode.row,
            column: nextCol.visibleIndex,
            level: nextCol.level,
            mchCache: newHeaderNode
        });
        this.performHorizontalScrollToCell(nextCol.visibleIndex);
    }
    handleMCHExpandCollapse(key, column) {
        if (!column.children || !column.collapsible) {
            return;
        }
        if (!column.expanded && ROW_EXPAND_KEYS.has(key)) {
            column.expanded = true;
        }
        else if (column.expanded && ROW_COLLAPSE_KEYS.has(key)) {
            column.expanded = false;
        }
    }
    handleColumnSelection(column, event) {
        if (!column.selectable || this.grid.columnSelection === GridSelectionMode.none) {
            return;
        }
        const clearSelection = this.grid.columnSelection === GridSelectionMode.single;
        const columnsToSelect = !column.children ? [column.field] :
            column.allChildren.filter(c => !c.hidden && c.selectable && !c.columnGroup).map(c => c.field);
        column.selected ? this.grid.selectionService.deselectColumns(columnsToSelect, event) :
            this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, false, event);
    }
    getNextColumnMCH(visibleIndex) {
        let col = this.grid.getColumnByVisibleIndex(visibleIndex);
        let parent = col.parent;
        while (parent && col.level > this.activeNode.mchCache.level) {
            col = col.parent;
            parent = col.parent;
        }
        return col;
    }
    get currentActiveColumn() {
        return this.grid.visibleColumns.find(c => c.visibleIndex === this.activeNode.column && c.level === this.activeNode.level);
    }
    isActiveNode(rIndex, cIndex) {
        return this.activeNode ? this.activeNode.row === rIndex && this.activeNode.column === cIndex : false;
    }
    isToggleKey(key) {
        return ROW_COLLAPSE_KEYS.has(key) || ROW_EXPAND_KEYS.has(key);
    }
    isAddKey(key) {
        return ROW_ADD_KEYS.has(key);
    }
}
IgxGridNavigationService.ɵfac = function IgxGridNavigationService_Factory(t) { return new (t || IgxGridNavigationService)(); };
IgxGridNavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxGridNavigationService, factory: IgxGridNavigationService.ɵfac });

/** @hidden */
class ExcelStylePositionStrategy extends AutoPositionStrategy {
    shouldFitInViewPort(connectedFit) {
        return true;
    }
    fitInViewport(element, connectedFit) {
        const heightOverflow = connectedFit.contentElementRect.height - connectedFit.viewPortRect.height;
        if (heightOverflow > 0) {
            element.style.width = 'auto';
            element.style.height = `${connectedFit.viewPortRect.height}px`;
        }
        else {
            element.style.height = `${Math.max(connectedFit.viewPortRect.height - connectedFit.targetRect.bottom - 1, connectedFit.contentElementRect.height)}px`;
        }
        super.fitInViewport(element, connectedFit);
    }
}

/**
 * @hidden
 */
class ExpressionUI {
    constructor() {
        this.isSelected = false;
        this.isVisible = true;
    }
}
/**
 * @hidden
 */
class IgxFilteringService {
    constructor(gridAPI, _moduleRef, iconService, _overlayService) {
        this.gridAPI = gridAPI;
        this._moduleRef = _moduleRef;
        this.iconService = iconService;
        this._overlayService = _overlayService;
        this.columnsWithComplexFilter = new Set();
        this.areEventsSubscribed = false;
        this.destroy$ = new Subject();
        this.isFiltering = false;
        this.columnToExpressionsMap = new Map();
        this.columnStartIndex = -1;
        this.isFilterRowVisible = false;
        this.filteredColumn = null;
        this.selectedExpression = null;
        this.columnToMoreIconHidden = new Map();
        this.activeFilterCell = 0;
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    toggleFilterDropdown(element, column, classRef) {
        if (!this._componentOverlayId || (this.column && this.column.field !== column.field)) {
            this.initFilteringSettings();
            this.column = column;
            const filterIcon = this.column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';
            const filterIconTarget = element.querySelector('.' + filterIcon);
            this._filterMenuOverlaySettings.target = filterIconTarget;
            this._filterMenuOverlaySettings.outlet = this.grid.outlet;
            if (this.grid.excelStyleFilteringComponent) {
                this._componentOverlayId =
                    this._overlayService.attach(this.grid.excelStyleFilteringComponent.element, this._filterMenuOverlaySettings);
            }
            else {
                this._componentOverlayId =
                    this._overlayService.attach(classRef, this._filterMenuOverlaySettings, this._moduleRef);
            }
            this._overlayService.show(this._componentOverlayId, this._filterMenuOverlaySettings);
        }
    }
    initFilteringSettings() {
        this._filterMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Bottom,
            openAnimation: useAnimation(fadeIn, { params: { duration: '250ms' } }),
            closeAnimation: null
        };
        this._filterMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new ExcelStylePositionStrategy(this._filterMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        this._overlayService.onOpening.pipe(first$1((overlay) => overlay.id === this._componentOverlayId), takeUntil(this.destroy$)).subscribe((eventArgs) => {
            const instance = this.grid.excelStyleFilteringComponent ?
                this.grid.excelStyleFilteringComponent :
                eventArgs.componentRef.instance;
            if (instance) {
                this.lastActiveNode = this.grid.navigation.activeNode;
                instance.initialize(this.column, this._overlayService, eventArgs.id);
            }
        });
        this._overlayService.onClosed.pipe(first$1((overlay) => overlay.id === this._componentOverlayId), takeUntil(this.destroy$)).subscribe((eventArgs) => {
            const instance = this.grid.excelStyleFilteringComponent ?
                this.grid.excelStyleFilteringComponent :
                eventArgs.componentRef.instance;
            if (instance) {
                instance.column = null;
            }
            this._componentOverlayId = null;
            this.grid.navigation.activeNode = this.lastActiveNode;
            this.grid.theadRow.nativeElement.focus();
        });
    }
    hideExcelFiltering() {
        if (this._componentOverlayId) {
            this._overlayService.hide(this._componentOverlayId);
        }
    }
    /**
     * Subscribe to grid's events.
     */
    subscribeToEvents() {
        if (!this.areEventsSubscribed) {
            this.areEventsSubscribed = true;
            this.grid.onColumnResized.pipe(takeUntil(this.destroy$)).subscribe((eventArgs) => {
                this.updateFilteringCell(eventArgs.column);
            });
            this.grid.parentVirtDir.onChunkLoad.pipe(takeUntil(this.destroy$)).subscribe((eventArgs) => {
                if (eventArgs.startIndex !== this.columnStartIndex) {
                    this.columnStartIndex = eventArgs.startIndex;
                    this.grid.filterCellList.forEach((filterCell) => {
                        filterCell.updateFilterCellArea();
                    });
                }
            });
            this.grid.onColumnMovingEnd.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.grid.filterCellList.forEach((filterCell) => {
                    filterCell.updateFilterCellArea();
                });
            });
        }
    }
    /**
     * Close filtering row if a column is hidden.
     */
    hideFilteringRowOnColumnVisibilityChange(col) {
        const filteringRow = this.grid.filteringRow;
        if (filteringRow && filteringRow.column && filteringRow.column === col) {
            filteringRow.close();
        }
    }
    /**
     * Internal method to create expressionsTree and filter grid used in both filter modes.
     */
    filterInternal(field, expressions = null) {
        this.isFiltering = true;
        let expressionsTree;
        if (expressions instanceof FilteringExpressionsTree) {
            expressionsTree = expressions;
        }
        else {
            expressionsTree = this.createSimpleFilteringTree(field, expressions);
        }
        if (expressionsTree.filteringOperands.length === 0) {
            this.clearFilter(field);
        }
        else {
            this.filter(field, null, expressionsTree);
        }
        this.isFiltering = false;
    }
    /**
     * Execute filtering on the grid.
     */
    filter(field, value, conditionOrExpressionTree, ignoreCase) {
        const col = this.gridAPI.get_column_by_name(field);
        const filteringIgnoreCase = ignoreCase || (col ? col.filteringIgnoreCase : false);
        if (conditionOrExpressionTree) {
            this.gridAPI.filter(field, value, conditionOrExpressionTree, filteringIgnoreCase);
        }
        else {
            const expressionsTreeForColumn = this.grid.filteringExpressionsTree.find(field);
            if (!expressionsTreeForColumn) {
                throw new Error('Invalid condition or Expression Tree!');
            }
            else if (expressionsTreeForColumn instanceof FilteringExpressionsTree) {
                this.gridAPI.filter(field, value, expressionsTreeForColumn, filteringIgnoreCase);
            }
            else {
                const expressionForColumn = expressionsTreeForColumn;
                this.gridAPI.filter(field, value, expressionForColumn.condition, filteringIgnoreCase);
            }
        }
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.grid.onFilteringDone.emit(col.filteringExpressionsTree));
    }
    /**
     * Clears the filter of a given column if name is provided. Otherwise clears the filters of all columns.
     */
    clearFilter(field) {
        if (field) {
            const column = this.gridAPI.get_column_by_name(field);
            if (!column) {
                return;
            }
        }
        this.isFiltering = true;
        this.gridAPI.clear_filter(field);
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.grid.onFilteringDone.emit(null));
        if (field) {
            const expressions = this.getExpressions(field);
            expressions.length = 0;
        }
        else {
            this.grid.columns.forEach(c => {
                const expressions = this.getExpressions(c.field);
                expressions.length = 0;
            });
        }
        this.isFiltering = false;
    }
    /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     */
    filterGlobal(value, condition, ignoreCase) {
        this.gridAPI.filter_global(value, condition, ignoreCase);
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.grid.onFilteringDone.emit(this.grid.filteringExpressionsTree));
    }
    /**
     * Register filtering SVG icons in the icon service.
     */
    registerSVGIcons() {
        const editorIcons = editor;
        editorIcons.forEach(icon => this.iconService.addSvgIconFromText(icon.name, icon.value, 'imx-icons'));
        this.iconService.addSvgIconFromText(pinLeft.name, pinLeft.value, 'imx-icons');
        this.iconService.addSvgIconFromText(unpinLeft.name, unpinLeft.value, 'imx-icons');
    }
    /**
     * Returns the ExpressionUI array for a given column.
     */
    getExpressions(columnId) {
        if (!this.columnToExpressionsMap.has(columnId)) {
            const column = this.grid.columns.find((col) => col.field === columnId);
            const expressionUIs = new Array();
            if (column) {
                this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, expressionUIs);
                this.columnToExpressionsMap.set(columnId, expressionUIs);
            }
            return expressionUIs;
        }
        return this.columnToExpressionsMap.get(columnId);
    }
    /**
     * Recreates all ExpressionUIs for all columns. Executed after filtering to refresh the cache.
     */
    refreshExpressions() {
        if (!this.isFiltering) {
            this.columnsWithComplexFilter.clear();
            this.columnToExpressionsMap.forEach((value, key) => {
                const column = this.grid.columns.find((col) => col.field === key);
                if (column) {
                    value.length = 0;
                    this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, value);
                    const isComplex = this.isFilteringTreeComplex(column.filteringExpressionsTree);
                    if (isComplex) {
                        this.columnsWithComplexFilter.add(key);
                    }
                    this.updateFilteringCell(column);
                }
                else {
                    this.columnToExpressionsMap.delete(key);
                }
            });
        }
    }
    /**
     * Remove an ExpressionUI for a given column.
     */
    removeExpression(columnId, indexToRemove) {
        const expressionsList = this.getExpressions(columnId);
        if (indexToRemove === 0 && expressionsList.length > 1) {
            expressionsList[1].beforeOperator = null;
        }
        else if (indexToRemove === expressionsList.length - 1) {
            expressionsList[indexToRemove - 1].afterOperator = null;
        }
        else {
            expressionsList[indexToRemove - 1].afterOperator = expressionsList[indexToRemove + 1].beforeOperator;
            expressionsList[0].beforeOperator = null;
            expressionsList[expressionsList.length - 1].afterOperator = null;
        }
        expressionsList.splice(indexToRemove, 1);
    }
    /**
     * Generate filtering tree for a given column from existing ExpressionUIs.
     */
    createSimpleFilteringTree(columnId, expressionUIList = null) {
        const expressionsList = expressionUIList ? expressionUIList : this.getExpressions(columnId);
        const expressionsTree = new FilteringExpressionsTree(FilteringLogic.Or, columnId);
        let currAndBranch;
        let currExpressionUI;
        for (let i = 0; i < expressionsList.length; i++) {
            currExpressionUI = expressionsList[i];
            if (!currExpressionUI.expression.condition.isUnary && currExpressionUI.expression.searchVal === null) {
                if (currExpressionUI.afterOperator === FilteringLogic.And && !currAndBranch) {
                    currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);
                    expressionsTree.filteringOperands.push(currAndBranch);
                }
                continue;
            }
            if ((currExpressionUI.beforeOperator === undefined || currExpressionUI.beforeOperator === null ||
                currExpressionUI.beforeOperator === FilteringLogic.Or) &&
                currExpressionUI.afterOperator === FilteringLogic.And) {
                currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);
                expressionsTree.filteringOperands.push(currAndBranch);
                currAndBranch.filteringOperands.push(currExpressionUI.expression);
            }
            else if (currExpressionUI.beforeOperator === FilteringLogic.And) {
                currAndBranch.filteringOperands.push(currExpressionUI.expression);
            }
            else {
                expressionsTree.filteringOperands.push(currExpressionUI.expression);
                currAndBranch = null;
            }
        }
        return expressionsTree;
    }
    /**
     * Returns whether a complex filter is applied to a given column.
     */
    isFilterComplex(columnId) {
        if (this.columnsWithComplexFilter.has(columnId)) {
            return true;
        }
        const column = this.grid.columns.find((col) => col.field === columnId);
        const isComplex = column && this.isFilteringTreeComplex(column.filteringExpressionsTree);
        if (isComplex) {
            this.columnsWithComplexFilter.add(columnId);
        }
        return isComplex;
    }
    /**
     * Returns the string representation of the FilteringLogic operator.
     */
    getOperatorAsString(operator) {
        if (operator === 0) {
            return this.grid.resourceStrings.igx_grid_filter_operator_and;
        }
        else {
            return this.grid.resourceStrings.igx_grid_filter_operator_or;
        }
    }
    /**
     * Generate the label of a chip from a given filtering expression.
     */
    getChipLabel(expression) {
        if (expression.condition.isUnary) {
            return this.grid.resourceStrings[`igx_grid_filter_${expression.condition.name}`] || expression.condition.name;
        }
        else if (expression.searchVal instanceof Date) {
            const pipeArgs = this.grid.getColumnByName(expression.fieldName).pipeArgs;
            return this.grid.datePipe.transform(expression.searchVal, pipeArgs.format, undefined, this.grid.locale);
        }
        else {
            return expression.searchVal;
        }
    }
    /**
     * Updates the content of a filterCell.
     */
    updateFilteringCell(column) {
        const filterCell = column.filterCell;
        if (filterCell) {
            filterCell.updateFilterCellArea();
        }
    }
    get filteredData() {
        return this.grid.filteredData;
    }
    isFilteringTreeComplex(expressions) {
        if (!expressions) {
            return false;
        }
        if (expressions instanceof FilteringExpressionsTree) {
            const expressionsTree = expressions;
            if (expressionsTree.operator === FilteringLogic.Or) {
                const andOperatorsCount = this.getChildAndOperatorsCount(expressionsTree);
                // having more that 'And' and operator in the sub-tree means that the filter could not be represented without parentheses.
                return andOperatorsCount > 1;
            }
            let isComplex = false;
            for (let i = 0; i < expressionsTree.filteringOperands.length; i++) {
                isComplex = isComplex || this.isFilteringTreeComplex(expressionsTree.filteringOperands[i]);
            }
            return isComplex;
        }
        return false;
    }
    getChildAndOperatorsCount(expressions) {
        let count = 0;
        let operand;
        for (let i = 0; i < expressions.filteringOperands.length; i++) {
            operand = expressions[i];
            if (operand instanceof FilteringExpressionsTree) {
                if (operand.operator === FilteringLogic.And) {
                    count++;
                }
                count = count + this.getChildAndOperatorsCount(operand);
            }
        }
        return count;
    }
    generateExpressionsList(expressions, operator, expressionsUIs) {
        this.generateExpressionsListRecursive(expressions, operator, expressionsUIs);
        // The beforeOperator of the first expression and the afterOperator of the last expression should be null
        if (expressionsUIs.length) {
            expressionsUIs[expressionsUIs.length - 1].afterOperator = null;
        }
    }
    generateExpressionsListRecursive(expressions, operator, expressionsUIs) {
        if (!expressions) {
            return;
        }
        if (expressions instanceof FilteringExpressionsTree) {
            const expressionsTree = expressions;
            for (let i = 0; i < expressionsTree.filteringOperands.length; i++) {
                this.generateExpressionsListRecursive(expressionsTree.filteringOperands[i], expressionsTree.operator, expressionsUIs);
            }
            if (expressionsUIs.length) {
                expressionsUIs[expressionsUIs.length - 1].afterOperator = operator;
            }
        }
        else {
            const exprUI = new ExpressionUI();
            exprUI.expression = expressions;
            exprUI.afterOperator = operator;
            const prevExprUI = expressionsUIs[expressionsUIs.length - 1];
            if (prevExprUI) {
                exprUI.beforeOperator = prevExprUI.afterOperator;
            }
            expressionsUIs.push(exprUI);
        }
    }
    isFilteringExpressionsTreeEmpty(expressionTree) {
        if (FilteringExpressionsTree.empty(expressionTree)) {
            return true;
        }
        let expr;
        for (let i = 0; i < expressionTree.filteringOperands.length; i++) {
            expr = expressionTree.filteringOperands[i];
            if ((expr instanceof FilteringExpressionsTree)) {
                const exprTree = expr;
                if (exprTree.filteringOperands && exprTree.filteringOperands.length) {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        return true;
    }
}
IgxFilteringService.ɵfac = function IgxFilteringService_Factory(t) { return new (t || IgxFilteringService)(ɵngcc0.ɵɵinject(GridBaseAPIService), ɵngcc0.ɵɵinject(ɵngcc0.NgModuleRef), ɵngcc0.ɵɵinject(IgxIconService), ɵngcc0.ɵɵinject(IgxOverlayService)); };
IgxFilteringService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxFilteringService, factory: IgxFilteringService.ɵfac });
IgxFilteringService.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: NgModuleRef },
    { type: IgxIconService },
    { type: IgxOverlayService }
];

/**
 * @hidden
 * @internal
 */
class IgxColumnResizingService {
    constructor(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = null;
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    /**
     * @hidden
     */
    get resizerHeight() {
        let height = this.column.grid.getVisibleContentHeight();
        // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
        let columnHeightMultiplier = 1;
        if (this.column.columnLayoutChild) {
            columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
        }
        if (this.column.level !== 0) {
            height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
        }
        return height;
    }
    /**
     * Returns the minimal possible width to which the column can be resized.
     */
    get restrictResizeMin() {
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const minWidth = this.column.minWidthPx < actualWidth ? this.column.minWidthPx : actualWidth;
        return actualWidth - minWidth;
    }
    /**
     * Returns the maximal possible width to which the column can be resized.
     */
    get restrictResizeMax() {
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const maxWidth = this.column.maxWidthPx;
        if (this.column.maxWidth) {
            return maxWidth - actualWidth;
        }
        else {
            return Number.MAX_SAFE_INTEGER;
        }
    }
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     */
    autosizeColumnOnDblClick() {
        const currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const isPercentageWidth = this.column.width && typeof this.column.width === 'string' && this.column.width.indexOf('%') !== -1;
        let size = this.column.getAutoSize();
        const maxWidth = isPercentageWidth ? this.column.maxWidthPercent : this.column.maxWidthPx;
        const minWidth = isPercentageWidth ? this.column.minWidthPercent : this.column.minWidthPx;
        if (this.column.maxWidth && (parseFloat(size) > maxWidth)) {
            size = isPercentageWidth ? maxWidth + '%' : maxWidth + 'px';
        }
        else if (parseFloat(size) < minWidth) {
            size = isPercentageWidth ? minWidth + '%' : minWidth + 'px';
        }
        this.column.width = size;
        this.zone.run(() => { });
        this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    }
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     */
    resizeColumn(event) {
        this.showResizer = false;
        const diff = event.clientX - this.startResizePos;
        const colWidth = this.column.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        let currentColWidth = parseFloat(colWidth);
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) ? parseFloat(actualWidth) : currentColWidth;
        if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
        }
        else if (isPercentageWidth) {
            this._handlePercentageResize(diff, this.column);
        }
        else {
            this._handlePixelResize(diff, this.column);
        }
        this.zone.run(() => { });
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: isPercentageWidth ? currentColWidth + '%' : currentColWidth + 'px',
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    }
    _handlePixelResize(diff, column) {
        const currentColWidth = parseFloat(column.width);
        const colMinWidth = column.minWidthPx;
        const colMaxWidth = column.maxWidthPx;
        if (currentColWidth + diff < colMinWidth) {
            column.width = colMinWidth + 'px';
        }
        else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
            column.width = colMaxWidth + 'px';
        }
        else {
            column.width = (currentColWidth + diff) + 'px';
        }
    }
    _handlePercentageResize(diff, column) {
        const currentPercentWidth = parseFloat(column.width);
        const gridAvailableSize = column.grid.calcWidth;
        const diffPercentage = (diff / gridAvailableSize) * 100;
        const colMinWidth = column.minWidthPercent;
        const colMaxWidth = column.maxWidthPercent;
        if (currentPercentWidth + diffPercentage < colMinWidth) {
            column.width = colMinWidth + '%';
        }
        else if (colMaxWidth && (currentPercentWidth + diffPercentage > colMaxWidth)) {
            column.width = colMaxWidth + '%';
        }
        else {
            column.width = (currentPercentWidth + diffPercentage) + '%';
        }
    }
    getColMinWidth(column) {
        let currentColWidth = parseFloat(column.width);
        const actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        const actualMinWidth = parseFloat(column.minWidth);
        return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;
    }
    resizeColumnLayoutFor(column, diff) {
        const relativeColumns = column.getResizableColUnderEnd();
        const combinedSpan = relativeColumns.reduce((acc, col) => acc + col.spanUsed, 0);
        // Resize first those who might reach min/max width
        let columnsToResize = [...relativeColumns];
        let updatedDiff = diff;
        let updatedCombinedSpan = combinedSpan;
        let setMinMaxCols = false;
        do {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            let newCombinedSpan = updatedCombinedSpan;
            const newColsToResize = [];
            columnsToResize.forEach((col) => {
                const currentResizeWidth = parseFloat(col.target.calcWidth);
                const resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                const colWidth = col.target.width;
                const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
                const minWidth = col.target.minWidthPx;
                const maxWidth = col.target.maxWidthPx;
                if (currentResizeWidth + resizeScaled < minWidth) {
                    col.target.width = isPercentageWidth ? col.target.minWidthPercent + '%' : minWidth + 'px';
                    updatedDiff += (currentResizeWidth - minWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                    col.target.width = isPercentageWidth ? col.target.maxWidthPercent + '%' : col.target.maxWidthPx + 'px';
                    updatedDiff -= (maxWidth - currentResizeWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else {
                    // Save new ones that can be resized
                    newColsToResize.push(col);
                }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
        } while (setMinMaxCols);
        // Those left that don't reach min/max size resize them normally.
        columnsToResize.forEach((col) => {
            const resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
            const colWidth = col.target.width;
            const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
            if (isPercentageWidth) {
                this._handlePercentageResize(resizeScaled, col.target);
            }
            else {
                this._handlePixelResize(resizeScaled, col.target);
            }
        });
    }
}
IgxColumnResizingService.ɵfac = function IgxColumnResizingService_Factory(t) { return new (t || IgxColumnResizingService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
IgxColumnResizingService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxColumnResizingService, factory: IgxColumnResizingService.ɵfac });
IgxColumnResizingService.ctorParameters = () => [
    { type: NgZone }
];

/**
 * @hidden
 */
class IgxGridHeaderComponent {
    constructor(gridAPI, colResizingService, cdr, elementRef, zone) {
        this.gridAPI = gridAPI;
        this.colResizingService = colResizingService;
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.zone = zone;
        this._destroy$ = new Subject();
        this.hostRole = 'columnheader';
        this.sortDirection = SortingDirection.None;
    }
    /**
     * Returns the `aria-selected` of the header.
     */
    get ariaSelected() {
        return this.column.selected;
    }
    get styleClasses() {
        const defaultClasses = [
            'igx-grid__th--fw',
            this.column.headerClasses
        ];
        const classList = {
            'igx-grid__th': !this.column.columnGroup,
            'asc': this.ascending,
            'desc': this.descending,
            'igx-grid__th--number': this.column.dataType === DataType.Number,
            'igx-grid__th--sortable': this.column.sortable,
            'igx-grid__th--selectable': this.selectable,
            'igx-grid__th--filtrable': this.column.filterable && this.grid.filteringService.isFilterRowVisible,
            'igx-grid__th--sorted': this.sorted,
            'igx-grid__th--selected': this.selected
        };
        for (const klass of Object.keys(classList)) {
            if (classList[klass]) {
                defaultClasses.push(klass);
            }
        }
        return defaultClasses.join(' ');
    }
    get height() {
        if (this.grid.hasColumnGroups) {
            return (this.grid.maxLevelHeaderDepth + 1 - this.column.level) * this.grid.defaultRowHeight / this.grid._baseFontSize;
        }
        return null;
    }
    get ascending() {
        return this.sortDirection === SortingDirection.Asc;
    }
    get descending() {
        return this.sortDirection === SortingDirection.Desc;
    }
    get sortingIcon() {
        if (this.sortDirection !== SortingDirection.None) {
            // arrow_downward and arrow_upward
            // are material icons ligature strings
            return this.sortDirection === SortingDirection.Asc ? 'arrow_upward' : 'arrow_downward';
        }
        return 'arrow_upward';
    }
    get sorted() {
        return this.sortDirection !== SortingDirection.None;
    }
    get filterIconClassName() {
        return this.column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';
    }
    get selectable() {
        return this.grid.columnSelection !== GridSelectionMode.none &&
            this.column.applySelectableClass &&
            !this.column.selected &&
            !this.grid.filteringService.isFilterRowVisible;
    }
    get selected() {
        return this.column.selected
            && (!this.grid.filteringService.isFilterRowVisible || this.grid.filteringService.filteredColumn !== this.column);
    }
    get columnTitle() {
        return this.column.title || this.column.header || this.column.field;
    }
    get headerID() {
        return `${this.gridID}_${this.column.field}`;
    }
    ngDoCheck() {
        this.getSortDirection();
        this.cdr.markForCheck();
    }
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
        this.grid.filteringService.hideExcelFiltering();
    }
    onClick(event) {
        if (!this.colResizingService.isColumnResizing) {
            if (this.grid.filteringService.isFilterRowVisible) {
                if (this.column.filterCellTemplate) {
                    this.grid.filteringRow.close();
                    return;
                }
                if (this.column.filterable && !this.column.columnGroup &&
                    !this.grid.filteringService.isFilterComplex(this.column.field)) {
                    this.grid.filteringService.filteredColumn = this.column;
                }
            }
            else if (this.grid.columnSelection !== GridSelectionMode.none && this.column.selectable) {
                const clearSelection = this.grid.columnSelection === GridSelectionMode.single || !event.ctrlKey;
                const rangeSelection = this.grid.columnSelection === GridSelectionMode.multiple && event.shiftKey;
                if (!this.column.selected || (this.grid.selectionService.getSelectedColumns().length > 1 && clearSelection)) {
                    this.grid.selectionService.selectColumn(this.column.field, clearSelection, rangeSelection, event);
                }
                else {
                    this.grid.selectionService.deselectColumn(this.column.field, event);
                }
            }
        }
        this.grid.theadRow.nativeElement.focus();
    }
    onFilteringIconClick(event) {
        event.stopPropagation();
        this.grid.filteringService.toggleFilterDropdown(this.elementRef.nativeElement, this.column, IgxGridExcelStyleFilteringComponent);
    }
    get grid() {
        return this.gridAPI.grid;
    }
    getSortDirection() {
        const expr = this.gridAPI.grid.sortingExpressions.find((x) => x.fieldName === this.column.field);
        this.sortDirection = expr ? expr.dir : SortingDirection.None;
    }
    onSortingIconClick(event) {
        event.stopPropagation();
        this.triggerSort();
    }
    triggerSort() {
        const groupingExpr = this.grid.groupingExpressions ?
            this.grid.groupingExpressions.find((expr) => expr.fieldName === this.column.field) : null;
        const sortDir = groupingExpr ?
            this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.Asc : SortingDirection.Desc
            : this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.None : this.sortDirection + 1;
        this.sortDirection = sortDir;
        this.grid.sort({
            fieldName: this.column.field, dir: this.sortDirection, ignoreCase: this.column.sortingIgnoreCase,
            strategy: this.column.sortStrategy
        });
    }
    /**
     * @hidden
     */
    onPinterEnter() {
        this.column.applySelectableClass = true;
    }
    /**
     * @hidden
     */
    onPointerLeave() {
        this.column.applySelectableClass = false;
    }
}
IgxGridHeaderComponent.ɵfac = function IgxGridHeaderComponent_Factory(t) { return new (t || IgxGridHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxGridHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridHeaderComponent, selectors: [["igx-grid-header"]], hostVars: 7, hostBindings: function IgxGridHeaderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxGridHeaderComponent_click_HostBindingHandler($event) { return ctx.onClick($event); })("pointerenter", function IgxGridHeaderComponent_pointerenter_HostBindingHandler() { return ctx.onPinterEnter(); })("pointerleave", function IgxGridHeaderComponent_pointerleave_HostBindingHandler() { return ctx.onPointerLeave(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.hostRole)("aria-selected", ctx.ariaSelected)("id", ctx.headerID);
        ɵngcc0.ɵɵclassMap(ctx.styleClasses);
        ɵngcc0.ɵɵstyleProp("height", ctx.height, "rem");
    } }, inputs: { column: "column", gridID: "gridID" }, decls: 5, vars: 6, consts: [["defaultColumn", ""], [1, "igx-grid__th-title"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "igx-grid__th-icons", 4, "ngIf"], [3, "title"], [1, "igx-grid__th-icons"], ["class", "sort-icon", 3, "click", 4, "ngIf"], [3, "ngClass", "click", 4, "ngIf"], [1, "sort-icon", 3, "click"], [3, "ngClass", "click"]], template: function IgxGridHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridHeaderComponent_ng_template_0_Template, 2, 2, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(2, "span", 1);
        ɵngcc0.ɵɵtemplate(3, IgxGridHeaderComponent_ng_container_3_Template, 1, 0, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, IgxGridHeaderComponent_div_4_Template, 3, 2, "div", 3);
    } if (rf & 2) {
        const _r0 = ɵngcc0.ɵɵreference(1);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.column.headerTemplate ? ctx.column.headerTemplate : _r0)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(3, _c95, ctx.column, ctx.column));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.column.columnGroup);
    } }, directives: function () { return [ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxIconComponent, ɵngcc2.NgClass]; }, pipes: function () { return [SortingIndexPipe]; }, encapsulation: 2, changeDetection: 0 });
IgxGridHeaderComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxColumnResizingService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
IgxGridHeaderComponent.propDecorators = {
    column: [{ type: Input }],
    gridID: [{ type: Input }],
    ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
    styleClasses: [{ type: HostBinding, args: ['class',] }],
    height: [{ type: HostBinding, args: ['style.height.rem',] }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }],
    headerID: [{ type: HostBinding, args: ['attr.id',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onPinterEnter: [{ type: HostListener, args: ['pointerenter',] }],
    onPointerLeave: [{ type: HostListener, args: ['pointerleave',] }]
};

/**
 * @hidden
 */
class IgxGridFilteringCellComponent {
    constructor(cdr, filteringService) {
        this.cdr = cdr;
        this.filteringService = filteringService;
        this.baseClass = 'igx-grid__filtering-cell-indicator';
        this.moreFiltersCount = 0;
        this.filteringService.subscribeToEvents();
    }
    get styleClasses() {
        let classes = this.column && this.column.selected ?
            'igx-grid__filtering-cell--selected' :
            'igx-grid__filtering-cell';
        switch (this.column.grid.displayDensity) {
            case DisplayDensity.compact:
                classes = classes + ' igx-grid__filtering-cell--compact';
                break;
            case DisplayDensity.cosy:
                classes = classes + ' igx-grid__filtering-cell--cosy';
                break;
        }
        return classes;
    }
    ngOnInit() {
        this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
    }
    ngAfterViewInit() {
        this.updateFilterCellArea();
    }
    ngDoCheck() {
        this.updateFilterCellArea();
    }
    /**
     * Returns whether a chip with a given index is visible or not.
     */
    isChipVisible(index) {
        const expression = this.expressionsList[index];
        return !!(expression && expression.isVisible);
    }
    /**
     * Updates the filtering cell area.
     */
    updateFilterCellArea() {
        this.expressionsList = this.filteringService.getExpressions(this.column.field);
        this.updateVisibleFilters();
    }
    get displayDensity() {
        return this.column.grid.displayDensity === DisplayDensity.comfortable ? DisplayDensity.cosy : this.column.grid.displayDensity;
    }
    get template() {
        if (!this.column.filterable) {
            return null;
        }
        if (this.column.filterCellTemplate) {
            return this.column.filterCellTemplate;
        }
        const expressionTree = this.column.filteringExpressionsTree;
        if (!expressionTree || expressionTree.filteringOperands.length === 0) {
            return this.emptyFilter;
        }
        if (this.filteringService.isFilterComplex(this.column.field)) {
            return this.complexFilter;
        }
        return this.defaultFilter;
    }
    /**
     * Gets the context passed to the filter template.
     * @memberof IgxGridFilteringCellComponent
     */
    get context() {
        return { column: this.column };
    }
    /**
     * Chip clicked event handler.
     */
    onChipClicked(expression) {
        if (expression) {
            this.expressionsList.forEach((item) => {
                item.isSelected = (item.expression === expression);
            });
        }
        else if (this.expressionsList.length > 0) {
            this.expressionsList.forEach((item) => {
                item.isSelected = false;
            });
            this.expressionsList[0].isSelected = true;
        }
        this.filteringService.grid.navigation.performHorizontalScrollToCell(this.column.visibleIndex);
        this.filteringService.filteredColumn = this.column;
        this.filteringService.isFilterRowVisible = true;
        this.filteringService.selectedExpression = expression;
    }
    /**
     * Chip removed event handler.
     */
    onChipRemoved(eventArgs, item) {
        const indexToRemove = this.expressionsList.indexOf(item);
        this.removeExpression(indexToRemove);
        this.filteringService.grid.theadRow.nativeElement.focus();
    }
    /**
     * Clears the filtering.
     */
    clearFiltering() {
        this.filteringService.clearFilter(this.column.field);
        this.cdr.detectChanges();
    }
    /**
     * Returns the filtering indicator class.
     */
    filteringIndicatorClass() {
        return {
            [this.baseClass]: !this.isMoreIconHidden(),
            [`${this.baseClass}--hidden`]: this.isMoreIconHidden()
        };
    }
    removeExpression(indexToRemove) {
        if (indexToRemove === 0 && this.expressionsList.length === 1) {
            this.clearFiltering();
            return;
        }
        this.filteringService.removeExpression(this.column.field, indexToRemove);
        this.updateVisibleFilters();
        this.filteringService.filterInternal(this.column.field);
    }
    isMoreIconHidden() {
        return this.filteringService.columnToMoreIconHidden.get(this.column.field);
    }
    updateVisibleFilters() {
        this.expressionsList.forEach((ex) => ex.isVisible = true);
        if (this.moreIcon) {
            this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
        }
        this.cdr.detectChanges();
        if (this.chipsArea && this.expressionsList.length > 1) {
            const areaWidth = this.chipsArea.element.nativeElement.offsetWidth;
            let viewWidth = 0;
            const chipsAreaElements = this.chipsArea.element.nativeElement.children;
            let visibleChipsCount = 0;
            const moreIconWidth = this.moreIcon.nativeElement.offsetWidth -
                parseInt(document.defaultView.getComputedStyle(this.moreIcon.nativeElement)['margin-left'], 10);
            for (let index = 0; index < chipsAreaElements.length - 1; index++) {
                if (viewWidth + chipsAreaElements[index].offsetWidth < areaWidth) {
                    viewWidth += chipsAreaElements[index].offsetWidth;
                    if (index % 2 === 0) {
                        visibleChipsCount++;
                    }
                    else {
                        viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-left'], 10);
                        viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-right'], 10);
                    }
                }
                else {
                    if (index % 2 !== 0 && viewWidth + moreIconWidth > areaWidth) {
                        visibleChipsCount--;
                    }
                    else if (visibleChipsCount > 0 && viewWidth - chipsAreaElements[index - 1].offsetWidth + moreIconWidth > areaWidth) {
                        visibleChipsCount--;
                    }
                    this.moreFiltersCount = this.expressionsList.length - visibleChipsCount;
                    this.filteringService.columnToMoreIconHidden.set(this.column.field, false);
                    break;
                }
            }
            for (let i = visibleChipsCount; i < this.expressionsList.length; i++) {
                this.expressionsList[i].isVisible = false;
            }
            this.cdr.detectChanges();
        }
    }
}
IgxGridFilteringCellComponent.ɵfac = function IgxGridFilteringCellComponent_Factory(t) { return new (t || IgxGridFilteringCellComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxFilteringService)); };
IgxGridFilteringCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridFilteringCellComponent, selectors: [["igx-grid-filtering-cell"]], viewQuery: function IgxGridFilteringCellComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c96, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c97, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c98, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(_c99, true, IgxChipsAreaComponent);
        ɵngcc0.ɵɵviewQuery(_c100, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c101, true, IgxChipComponent);
        ɵngcc0.ɵɵviewQuery(_c102, true, IgxChipComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.emptyFilter = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultFilter = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.complexFilter = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chipsArea = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.moreIcon = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ghostChip = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.complexChip = _t.first);
    } }, hostVars: 2, hostBindings: function IgxGridFilteringCellComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.styleClasses);
    } }, inputs: { column: "column" }, decls: 7, vars: 2, consts: [["emptyFilter", ""], ["defaultFilter", ""], ["complexFilter", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-filtering-chips"], ["tabIndex", "-1", 3, "displayDensity", "click"], ["ghostChip", ""], ["igxPrefix", ""], ["chipsArea", ""], [4, "ngFor", "ngForOf"], [3, "ngClass", "click"], ["moreIcon", ""], [3, "value"], ["tabIndex", "-1", 3, "removable", "displayDensity", "click", "onRemove", 4, "ngIf"], ["class", "igx-filtering-chips__connector", 4, "ngIf"], ["tabIndex", "-1", 3, "removable", "displayDensity", "click", "onRemove"], ["igxPrefix", "", "fontSet", "imx-icons", 3, "name"], ["label", ""], [1, "igx-filtering-chips__connector"], ["tabIndex", "-1", 3, "removable", "displayDensity", "onRemove"], ["complexChip", ""]], template: function IgxGridFilteringCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridFilteringCellComponent_ng_template_0_Template, 7, 6, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxGridFilteringCellComponent_ng_template_2_Template, 8, 3, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxGridFilteringCellComponent_ng_template_4_Template, 6, 3, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxGridFilteringCellComponent_ng_container_6_Template, 1, 0, "ng-container", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
    } }, directives: [ɵngcc2.NgTemplateOutlet, IgxChipsAreaComponent, IgxChipComponent, IgxIconComponent, IgxPrefixDirective, ɵngcc2.NgForOf, ɵngcc2.NgClass, IgxBadgeComponent, ɵngcc2.NgIf], encapsulation: 2, changeDetection: 0 });
IgxGridFilteringCellComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: IgxFilteringService }
];
IgxGridFilteringCellComponent.propDecorators = {
    column: [{ type: Input }],
    emptyFilter: [{ type: ViewChild, args: ['emptyFilter', { read: TemplateRef, static: true },] }],
    defaultFilter: [{ type: ViewChild, args: ['defaultFilter', { read: TemplateRef, static: true },] }],
    complexFilter: [{ type: ViewChild, args: ['complexFilter', { read: TemplateRef, static: true },] }],
    chipsArea: [{ type: ViewChild, args: ['chipsArea', { read: IgxChipsAreaComponent },] }],
    moreIcon: [{ type: ViewChild, args: ['moreIcon', { read: ElementRef },] }],
    ghostChip: [{ type: ViewChild, args: ['ghostChip', { read: IgxChipComponent },] }],
    complexChip: [{ type: ViewChild, args: ['complexChip', { read: IgxChipComponent },] }],
    styleClasses: [{ type: HostBinding, args: ['class',] }]
};

const Z_INDEX = 9999;
/**
 * @hidden
 */
class IgxGridHeaderGroupComponent {
    constructor(cdr, gridAPI, element, colResizingService, filteringService) {
        this.cdr = cdr;
        this.gridAPI = gridAPI;
        this.element = element;
        this.colResizingService = colResizingService;
        this.filteringService = filteringService;
    }
    get gridRowSpan() {
        return this.column.gridRowSpan;
    }
    get gridColumnSpan() {
        return this.column.gridColumnSpan;
    }
    get rowEnd() {
        return this.column.rowEnd;
    }
    get colEnd() {
        return this.column.colEnd;
    }
    get rowStart() {
        return this.column.rowStart;
    }
    get colStart() {
        return this.column.colStart;
    }
    get active() {
        const node = this.grid.navigation.activeNode;
        return node && !this.column.columnGroup ?
            node.row === -1 && node.column === this.column.visibleIndex && node.level === this.column.level : false;
    }
    get activeGroup() {
        const node = this.grid.navigation.activeNode;
        return node ? node.row === -1 && node.column === this.column.visibleIndex && node.level === this.column.level : false;
    }
    /**
     * Gets the width of the header group.
     * @memberof IgxGridHeaderGroupComponent
     */
    get width() {
        return this.grid.getHeaderGroupWidth(this.column);
    }
    /**
     * Gets the style classes of the header group.
     * @memberof IgxGridHeaderGroupComponent
     */
    get styleClasses() {
        const defaultClasses = [
            'igx-grid__thead-item',
            this.column.headerGroupClasses
        ];
        const classList = {
            'igx-grid__th--pinned': this.isPinned,
            'igx-grid__th--pinned-last': this.isLastPinned,
            'igx-grid__th--pinned-first': this.isFirstPinned,
            'igx-grid__drag-col-header': this.isHeaderDragged,
            'igx-grid__th--filtering': this.isFiltered
        };
        for (const className of Object.keys(classList)) {
            if (classList[className]) {
                defaultClasses.push(className);
            }
        }
        return defaultClasses.join(' ');
    }
    /**
     * @hidden
     */
    get zIndex() {
        if (!this.column.pinned) {
            return null;
        }
        return Z_INDEX - this.grid.pinnedColumns.indexOf(this.column);
    }
    /**
     * Gets the grid of the header group.
     * @memberof IgxGridHeaderGroupComponent
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Gets whether the header group belongs to a column that is filtered.
     * @memberof IgxGridHeaderGroupComponent
     */
    get isFiltered() {
        return this.filteringService.filteredColumn === this.column;
    }
    /**
     * Gets whether the header group is stored in the last column in the pinned area.
     * @memberof IgxGridHeaderGroupComponent
     */
    get isLastPinned() {
        return !this.grid.hasColumnLayouts ? this.column.isLastPinned : false;
    }
    /**
     * Gets whether the header group is stored in the first column of the right pinned area.
     */
    get isFirstPinned() {
        return !this.grid.hasColumnLayouts ? this.column.isFirstPinned : false;
    }
    get groupDisplayStyle() {
        return this.grid.hasColumnLayouts && this.column.children && !isIE() ? 'flex' : '';
    }
    /**
     * Gets whether the header group is stored in a pinned column.
     * @memberof IgxGridHeaderGroupComponent
     */
    get isPinned() {
        return this.column.pinned;
    }
    /**
     * Gets whether the header group belongs to a column that is moved.
     * @memberof IgxGridHeaderGroupComponent
     */
    get isHeaderDragged() {
        return this.grid.draggedColumn === this.column;
    }
    /**
     * @hidden
     */
    get hasLastPinnedChildColumn() {
        return this.column.allChildren.some(child => child.isLastPinned);
    }
    /**
     * @hidden
     */
    get hasFirstPinnedChildColumn() {
        return this.column.allChildren.some(child => child.isFirstPinned);
    }
    /**
     * @hidden
     */
    get selectable() {
        const selectableChildren = this.column.allChildren.filter(c => !c.hidden && c.selectable && !c.columnGroup);
        return this.grid.columnSelection !== GridSelectionMode.none &&
            this.column.applySelectableClass
            && !this.selected && selectableChildren.length > 0
            && !this.grid.filteringService.isFilterRowVisible;
    }
    /**
     * @hidden
     */
    get selected() {
        return this.column.selected;
    }
    /**
     * @hidden
     */
    get height() {
        return this.element.nativeElement.getBoundingClientRect().height;
    }
    /**
     * @hidden
     */
    get columnTitle() {
        return this.column.title || this.column.header;
    }
    /**
     * @hidden
     */
    groupClicked(event) {
        const columnsToSelect = this.column.allChildren.filter(c => !c.hidden && c.selectable && !c.columnGroup).map(c => c.field);
        if (this.grid.columnSelection !== GridSelectionMode.none
            && columnsToSelect.length > 0 && !this.grid.filteringService.isFilterRowVisible) {
            const clearSelection = this.grid.columnSelection === GridSelectionMode.single || !event.ctrlKey;
            const rangeSelection = this.grid.columnSelection === GridSelectionMode.multiple && event.shiftKey;
            if (!this.selected) {
                this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, rangeSelection, event);
            }
            else {
                const selectedFields = this.grid.selectionService.getSelectedColumns();
                if ((selectedFields.length === columnsToSelect.length) && selectedFields.every(el => columnsToSelect.includes(el))
                    || !clearSelection) {
                    this.grid.selectionService.deselectColumns(columnsToSelect, event);
                }
                else {
                    this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, rangeSelection, event);
                }
            }
        }
    }
    /**
     * @hidden
     */
    toggleExpandState(event) {
        event.stopPropagation();
        this.column.expanded = !this.column.expanded;
    }
    /**
     * @hidden
     */
    onMouseDown(event) {
        // hack for preventing text selection in IE and Edge while dragging the resizer
        event.preventDefault();
    }
    /**
     * @hidden
     */
    // @HostListener('pointerdown', ['$event'])
    pointerdown(event) {
        event.stopPropagation();
        this.activate();
        this.grid.theadRow.nativeElement.focus();
    }
    /*
     * This method is necessary due to some specifics related with implementation of column moving
     * @hidden
     */
    activate() {
        this.grid.navigation.setActiveNode(this.activeNode);
        this.grid.theadRow.nativeElement.focus();
    }
    ngDoCheck() {
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    onPinterEnter() {
        this.column.applySelectableClass = true;
    }
    /**
     * @hidden
     */
    onPointerLeave() {
        this.column.applySelectableClass = false;
    }
    get activeNode() {
        return { row: -1, column: this.column.visibleIndex, level: this.column.level,
            mchCache: { level: this.column.level, visibleIndex: this.column.visibleIndex },
            layout: this.column.columnLayoutChild ? {
                rowStart: this.column.rowStart,
                colStart: this.column.colStart,
                rowEnd: this.column.rowEnd,
                colEnd: this.column.colEnd,
                columnVisibleIndex: this.column.visibleIndex
            } : null };
    }
}
IgxGridHeaderGroupComponent.ɵfac = function IgxGridHeaderGroupComponent_Factory(t) { return new (t || IgxGridHeaderGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService), ɵngcc0.ɵɵdirectiveInject(IgxFilteringService)); };
IgxGridHeaderGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridHeaderGroupComponent, selectors: [["igx-grid-header-group"]], viewQuery: function IgxGridHeaderGroupComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxGridHeaderComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxGridFilteringCellComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxGridHeaderGroupComponent, true, IgxGridHeaderGroupComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerCell = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filterCell = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, hostVars: 24, hostBindings: function IgxGridHeaderGroupComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function IgxGridHeaderGroupComponent_mousedown_HostBindingHandler($event) { return ctx.onMouseDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.styleClasses);
        ɵngcc0.ɵɵstyleProp("-ms-grid-row-span", ctx.gridRowSpan)("-ms-grid-column-span", ctx.gridColumnSpan)("grid-row-end", ctx.rowEnd)("grid-column-end", ctx.colEnd)("-ms-grid-row", ctx.rowStart)("grid-row-start", ctx.rowStart)("-ms-grid-column", ctx.colStart)("grid-column-start", ctx.colStart)("z-index", ctx.zIndex)("display", ctx.groupDisplayStyle);
        ɵngcc0.ɵɵclassProp("igx-grid__th--active", ctx.active);
    } }, inputs: { column: "column", gridID: "gridID" }, decls: 7, vars: 3, consts: [[4, "ngIf"], ["defaultColumn", ""], ["defaultCollapseIndicator", ""], ["class", "igx-grid__th-drop-indicator-left", 4, "ngIf"], [1, "igx-grid__thead-group", "igx-grid__mrl-block", 3, "ngClass", "ngStyle"], [4, "ngFor", "ngForOf"], ["class", "igx-grid__th-drop-indicator-right", 4, "ngIf"], [1, "igx-grid__th-drop-indicator-left"], ["class", "igx-grid__thead-subgroup", 3, "column", "gridID", "igxColumnMovingDrag", "ghostHost", "igxColumnMovingDrop", 4, "ngIf"], [1, "igx-grid__thead-subgroup", 3, "column", "gridID", "igxColumnMovingDrag", "ghostHost", "igxColumnMovingDrop"], [1, "igx-grid__th-drop-indicator-right"], [1, "igx-grid__th-group-title", 3, "title"], ["role", "columnheader", 1, "igx-grid__thead-title", 3, "ngClass", "igxColumnMovingDrag", "ghostHost", "igxColumnMovingDrop", "pointerdown", "click", "pointerenter", "pointerleave"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-grid__thead-group"], [1, "igx-grid__th-expander", 3, "click"], ["class", "igx-grid__thead-subgroup", 3, "column", "gridID", "min-width", "flex-basis", 4, "ngIf"], [1, "igx-grid__thead-subgroup", 3, "column", "gridID"], [3, "igxColumnMovingDrag", "ghostHost", "igxColumnMovingDrop", "gridID", "column", "pointerdown"], [3, "column", 4, "ngIf"], ["class", "igx-grid__th-resize-handle", 3, "igxResizeHandle", "cursor", 4, "ngIf"], [3, "column"], [1, "igx-grid__th-resize-handle", 3, "igxResizeHandle"]], template: function IgxGridHeaderGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridHeaderGroupComponent_ng_container_0_Template, 5, 13, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_template_1_Template, 2, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(3, IgxGridHeaderGroupComponent_ng_template_3_Template, 2, 2, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, IgxGridHeaderGroupComponent_ng_container_5_Template, 8, 24, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(6, IgxGridHeaderGroupComponent_ng_container_6_Template, 6, 10, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.grid.hasColumnLayouts && ctx.column.columnGroup);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.grid.hasColumnLayouts && ctx.column.columnGroup);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.column.columnGroup);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgClass, ɵngcc2.NgStyle, ɵngcc2.NgForOf, IgxGridHeaderGroupComponent, IgxColumnMovingDragDirective, IgxColumnMovingDropDirective, IgxIconComponent, ɵngcc2.NgTemplateOutlet, IgxGridHeaderComponent, IgxGridFilteringCellComponent, IgxResizeHandleDirective]; }, encapsulation: 2, changeDetection: 0 });
IgxGridHeaderGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: GridBaseAPIService },
    { type: ElementRef },
    { type: IgxColumnResizingService },
    { type: IgxFilteringService }
];
IgxGridHeaderGroupComponent.propDecorators = {
    gridRowSpan: [{ type: HostBinding, args: ['style.-ms-grid-row-span',] }],
    gridColumnSpan: [{ type: HostBinding, args: ['style.-ms-grid-column-span',] }],
    rowEnd: [{ type: HostBinding, args: ['style.grid-row-end',] }],
    colEnd: [{ type: HostBinding, args: ['style.grid-column-end',] }],
    rowStart: [{ type: HostBinding, args: ['style.-ms-grid-row',] }, { type: HostBinding, args: ['style.grid-row-start',] }],
    colStart: [{ type: HostBinding, args: ['style.-ms-grid-column',] }, { type: HostBinding, args: ['style.grid-column-start',] }],
    column: [{ type: Input }],
    gridID: [{ type: Input }],
    active: [{ type: HostBinding, args: ['class.igx-grid__th--active',] }],
    headerCell: [{ type: ViewChild, args: [IgxGridHeaderComponent,] }],
    filterCell: [{ type: ViewChild, args: [IgxGridFilteringCellComponent,] }],
    children: [{ type: ViewChildren, args: [forwardRef(() => IgxGridHeaderGroupComponent), { read: IgxGridHeaderGroupComponent },] }],
    styleClasses: [{ type: HostBinding, args: ['class',] }],
    zIndex: [{ type: HostBinding, args: ['style.z-index',] }],
    groupDisplayStyle: [{ type: HostBinding, args: ['style.display',] }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
};

/** @hidden */
class IgxGridSummaryService {
    constructor() {
        this.summaryCacheMap = new Map();
        this.rootSummaryID = 'igxGridRootSummary';
        this.summaryHeight = 0;
        this.maxSummariesLenght = 0;
        this.groupingExpressions = [];
        this.retriggerRootPipe = 0;
        this.deleteOperation = false;
    }
    recalculateSummaries() {
        this.resetSummaryHeight();
        this.grid.notifyChanges(true);
    }
    clearSummaryCache(args) {
        if (!this.summaryCacheMap.size) {
            return;
        }
        if (!args) {
            this.summaryCacheMap.clear();
            if (this.grid && this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
            return;
        }
        if (args.data) {
            const rowID = this.grid.primaryKey ? args.data[this.grid.primaryKey] : args.data;
            this.removeSummaries(rowID);
        }
        if (args.rowID !== undefined && args.rowID !== null) {
            let columnName = args.cellID ? this.grid.columnList.find(col => col.index === args.cellID.columnID).field : undefined;
            if (columnName && this.grid.rowEditable) {
                return;
            }
            const isGroupedColumn = this.grid.groupingExpressions &&
                this.grid.groupingExpressions.map(expr => expr.fieldName).indexOf(columnName) !== -1;
            if (columnName && isGroupedColumn) {
                columnName = undefined;
            }
            this.removeSummaries(args.rowID, columnName);
        }
    }
    removeSummaries(rowID, columnName) {
        this.deleteSummaryCache(this.rootSummaryID, columnName);
        if (this.summaryCacheMap.size === 1 && this.summaryCacheMap.has(this.rootSummaryID)) {
            return;
        }
        if (this.isTreeGrid) {
            if (this.grid.transactions.enabled && this.deleteOperation) {
                this.deleteOperation = false;
                // TODO: this.removeChildRowSummaries(rowID, columnName);
                this.summaryCacheMap.clear();
                return;
            }
            this.removeAllTreeGridSummaries(rowID, columnName);
        }
        else if (this.isHierarchicalGrid) {
            if (this.grid.transactions.enabled && this.deleteOperation) {
                this.deleteOperation = false;
                this.summaryCacheMap.clear();
            }
        }
        else {
            const summaryIds = this.getSummaryID(rowID, this.grid.groupingExpressions);
            summaryIds.forEach(id => {
                this.deleteSummaryCache(id, columnName);
            });
        }
    }
    removeSummariesCachePerColumn(columnName) {
        this.summaryCacheMap.forEach((cache) => {
            if (cache.get(columnName)) {
                cache.delete(columnName);
            }
        });
        if (this.grid.rootSummariesEnabled) {
            this.retriggerRootPipe++;
        }
    }
    calcMaxSummaryHeight() {
        if (this.summaryHeight) {
            return this.summaryHeight;
        }
        if (!this.grid.data) {
            return this.summaryHeight = 0;
        }
        let maxSummaryLength = 0;
        this.grid.columnList.filter((col) => col.hasSummary && !col.hidden).forEach((column) => {
            const getCurrentSummaryColumn = column.summaries.operate([], [], column.field).length;
            if (getCurrentSummaryColumn) {
                if (maxSummaryLength < getCurrentSummaryColumn) {
                    maxSummaryLength = getCurrentSummaryColumn;
                }
            }
        });
        this.maxSummariesLenght = maxSummaryLength;
        this.summaryHeight = maxSummaryLength * this.grid.defaultSummaryHeight;
        return this.summaryHeight;
    }
    calculateSummaries(rowID, data) {
        let rowSummaries = this.summaryCacheMap.get(rowID);
        if (!rowSummaries) {
            rowSummaries = new Map();
            this.summaryCacheMap.set(rowID, rowSummaries);
        }
        if (!this.hasSummarizedColumns || !data) {
            return rowSummaries;
        }
        this.grid.columnList.filter(col => col.hasSummary).forEach((column) => {
            if (!rowSummaries.get(column.field)) {
                const summaryResult = column.summaries.operate(data.map(r => resolveNestedPath(r, column.field)), data, column.field, this.grid.locale, column.pipeArgs);
                rowSummaries.set(column.field, summaryResult);
            }
        });
        return rowSummaries;
    }
    resetSummaryHeight() {
        this.summaryHeight = 0;
        this.grid._summaryPipeTrigger++;
        if (this.grid.rootSummariesEnabled) {
            this.retriggerRootPipe++;
        }
    }
    updateSummaryCache(groupingArgs) {
        if (this.summaryCacheMap.size === 0 || !this.hasSummarizedColumns) {
            return;
        }
        if (this.groupingExpressions.length === 0) {
            this.groupingExpressions = groupingArgs.expressions.map(record => record.fieldName);
            return;
        }
        if (groupingArgs.length === 0) {
            this.groupingExpressions = [];
            this.clearSummaryCache();
            return;
        }
        this.compareGroupingExpressions(this.groupingExpressions, groupingArgs);
        this.groupingExpressions = groupingArgs.expressions.map(record => record.fieldName);
    }
    get hasSummarizedColumns() {
        const summarizedColumns = this.grid.columnList.filter(col => col.hasSummary && !col.hidden);
        return summarizedColumns.length > 0;
    }
    deleteSummaryCache(id, columnName) {
        if (this.summaryCacheMap.get(id)) {
            const filteringApplied = columnName && this.grid.filteringExpressionsTree &&
                this.grid.filteringExpressionsTree.filteringOperands.map((expr) => expr.fieldName).indexOf(columnName) !== -1;
            if (columnName && this.summaryCacheMap.get(id).get(columnName) && !filteringApplied) {
                this.summaryCacheMap.get(id).delete(columnName);
            }
            else {
                this.summaryCacheMap.delete(id);
            }
            if (id === this.rootSummaryID && this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
        }
    }
    getSummaryID(rowID, groupingExpressions) {
        if (groupingExpressions.length === 0) {
            return [];
        }
        const summaryIDs = [];
        let data = this.grid.data;
        if (this.grid.transactions.enabled) {
            data = DataUtil.mergeTransactions(cloneArray(this.grid.data), this.grid.transactions.getAggregatedChanges(true), this.grid.primaryKey);
        }
        const rowData = this.grid.primaryKey ? data.find(rec => rec[this.grid.primaryKey] === rowID) : rowID;
        let id = '{ ';
        groupingExpressions.forEach(expr => {
            id += `'${expr.fieldName}': '${rowData[expr.fieldName]}'`;
            summaryIDs.push(id.concat(' }'));
            id += ', ';
        });
        return summaryIDs;
    }
    removeAllTreeGridSummaries(rowID, columnName) {
        let row = this.grid.records.get(rowID);
        if (!row) {
            return;
        }
        row = row.children ? row : row.parent;
        while (row) {
            rowID = row.rowID;
            this.deleteSummaryCache(rowID, columnName);
            row = row.parent;
        }
    }
    // TODO: remove only deleted rows
    removeChildRowSummaries(rowID, columnName) {
    }
    compareGroupingExpressions(current, groupingArgs) {
        const newExpressions = groupingArgs.expressions.map(record => record.fieldName);
        const removedCols = groupingArgs.ungroupedColumns;
        if (current.length <= newExpressions.length) {
            const newExpr = newExpressions.slice(0, current.length).toString();
            if (current.toString() !== newExpr) {
                this.clearSummaryCache();
            }
        }
        else {
            const currExpr = current.slice(0, newExpressions.length).toString();
            if (currExpr !== newExpressions.toString()) {
                this.clearSummaryCache();
                return;
            }
            removedCols.map(col => col.field).forEach(colName => {
                this.summaryCacheMap.forEach((cache, id) => {
                    if (id.indexOf(colName) !== -1) {
                        this.summaryCacheMap.delete(id);
                    }
                });
            });
        }
    }
    get isTreeGrid() {
        return this.grid.nativeElement.tagName.toLowerCase() === 'igx-tree-grid';
    }
    get isHierarchicalGrid() {
        return this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
    }
}
IgxGridSummaryService.ɵfac = function IgxGridSummaryService_Factory(t) { return new (t || IgxGridSummaryService)(); };
IgxGridSummaryService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxGridSummaryService, factory: IgxGridSummaryService.ɵfac });

class IgxSummaryCellComponent {
    constructor(element) {
        this.element = element;
        this.firstCellIndentation = 0;
        this.hasSummary = false;
    }
    get visibleColumnIndex() {
        return this.column.visibleIndex;
    }
    get attrCellID() {
        return `${this.grid.id}_${this.rowIndex}_${this.visibleColumnIndex}`;
    }
    activate() {
        const currNode = this.grid.navigation.activeNode;
        if (currNode && this.rowIndex === currNode.row && this.visibleColumnIndex === currNode.column) {
            return;
        }
        this.grid.navigation.setActiveNode({ row: this.rowIndex, column: this.visibleColumnIndex }, 'summaryCell');
        this.grid.cdr.detectChanges();
    }
    get selectionNode() {
        return {
            row: this.rowIndex,
            column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
            isSummaryRow: true
        };
    }
    get width() {
        return this.column.getCellWidth();
    }
    get nativeElement() {
        return this.element.nativeElement;
    }
    get columnDatatype() {
        return this.column.dataType;
    }
    get itemHeight() {
        return this.column.grid.defaultSummaryHeight;
    }
    /**
     * @hidden
     */
    get grid() {
        return this.column.grid;
    }
    translateSummary(summary) {
        return this.grid.resourceStrings[`igx_grid_summary_${summary.key}`] || summary.label;
    }
}
IgxSummaryCellComponent.ɵfac = function IgxSummaryCellComponent_Factory(t) { return new (t || IgxSummaryCellComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxSummaryCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSummaryCellComponent, selectors: [["igx-grid-summary-cell"]], hostVars: 5, hostBindings: function IgxSummaryCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("pointerdown", function IgxSummaryCellComponent_pointerdown_HostBindingHandler() { return ctx.activate(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-visibleIndex", ctx.visibleColumnIndex)("id", ctx.attrCellID)("data-rowIndex", ctx.rowIndex);
        ɵngcc0.ɵɵclassProp("igx-grid-summary--active", ctx.active);
    } }, inputs: { firstCellIndentation: "firstCellIndentation", hasSummary: "hasSummary", summaryResults: "summaryResults", column: "column", density: "density", active: "active", rowIndex: "rowIndex" }, decls: 1, vars: 1, consts: [[4, "ngIf"], [4, "ngFor", "ngForOf"], [1, "igx-grid-summary__item"], [1, "igx-grid-summary__label", 3, "title"], [1, "igx-grid-summary__result", 3, "title"], [1, "igx-grid__tree-grouping-indicator", 2, "visibility", "hidden"], ["indicator", ""], ["fontSet", "material"]], template: function IgxSummaryCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxSummaryCellComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasSummary);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgForOf, IgxIconComponent], encapsulation: 2, changeDetection: 0 });
IgxSummaryCellComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxSummaryCellComponent.propDecorators = {
    summaryResults: [{ type: Input }],
    column: [{ type: Input }],
    firstCellIndentation: [{ type: Input }],
    hasSummary: [{ type: Input }],
    density: [{ type: Input }],
    active: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid-summary--active',] }],
    rowIndex: [{ type: Input }, { type: HostBinding, args: ['attr.data-rowIndex',] }],
    visibleColumnIndex: [{ type: HostBinding, args: ['attr.data-visibleIndex',] }],
    attrCellID: [{ type: HostBinding, args: ['attr.id',] }],
    activate: [{ type: HostListener, args: ['pointerdown',] }]
};

class IgxSummaryRowComponent {
    constructor(gridAPI, element, cdr) {
        this.gridAPI = gridAPI;
        this.element = element;
        this.cdr = cdr;
        this.firstCellIndentation = -1;
    }
    get dataRowIndex() {
        return this.index;
    }
    get minHeight() {
        return this.grid.summaryService.calcMaxSummaryHeight() - 1;
    }
    get summaryCells() {
        const res = new QueryList();
        if (!this._summaryCells) {
            return res;
        }
        const cList = this._summaryCells.filter(c => c.nativeElement.isConnected);
        res.reset(cList);
        return res;
    }
    set summaryCells(cells) { }
    ngDoCheck() {
        this.cdr.markForCheck();
    }
    get grid() {
        return this.gridAPI.grid;
    }
    get nativeElement() {
        return this.element.nativeElement;
    }
    getColumnSummaries(columnName) {
        if (!this.summaries.get(columnName)) {
            return [];
        }
        return this.summaries.get(columnName);
    }
    /**
     * @hidden
     * @internal
     */
    isCellActive(visibleColumnIndex) {
        const node = this.grid.navigation.activeNode;
        return node ? node.row === this.index && node.column === visibleColumnIndex : false;
    }
    /**
     * @hidden
     */
    get pinnedColumns() {
        return this.grid.pinnedColumns;
    }
    /**
     * @hidden
     */
    get unpinnedColumns() {
        return this.grid.unpinnedColumns;
    }
    getContext(row) {
        return {
            $implicit: row
        };
    }
}
IgxSummaryRowComponent.ɵfac = function IgxSummaryRowComponent_Factory(t) { return new (t || IgxSummaryRowComponent)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxSummaryRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSummaryRowComponent, selectors: [["igx-grid-summary-row"]], viewQuery: function IgxSummaryRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c14, true, IgxGridForOfDirective);
        ɵngcc0.ɵɵviewQuery(IgxSummaryCellComponent, true, IgxSummaryCellComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtDirRow = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._summaryCells = _t);
    } }, hostVars: 1, hostBindings: function IgxSummaryRowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-rowIndex", ctx.dataRowIndex);
    } }, inputs: { firstCellIndentation: "firstCellIndentation", summaries: "summaries", gridID: "gridID", index: "index" }, features: [ɵngcc0.ɵɵProvidersFeature([IgxForOfSyncService])], decls: 3, vars: 1, consts: [[4, "ngIf"], ["summaryCellTemplate", ""], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollContainer", "igxForScrollOrientation", "igxForContainerSize", "igxForTrackBy", "igxForSizePropName"], ["igxDirRef", ""], [1, "igx-grid__summaries-patch", 3, "pointerdown"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "cell", 1, "igx-grid-summary", "igx-grid-summary--fw", 3, "column", "rowIndex", "firstCellIndentation", "summaryResults", "hasSummary", "density", "active"], ["role", "cell", "class", "igx-grid-summary igx-grid-summary--fw igx-grid-summary--pinned", 3, "igx-grid-summary--cosy", "igx-grid-summary--compact", "igx-grid-summary--empty", "igx-grid-summary--pinned-first", "igx-grid-summary--pinned-last", "column", "firstCellIndentation", "rowIndex", "summaryResults", "hasSummary", "density", "active", "max-height", "min-height", "min-width", "max-width", "flex-basis", "left", 4, "ngFor", "ngForOf"], ["role", "cell", 1, "igx-grid-summary", "igx-grid-summary--fw", "igx-grid-summary--pinned", 3, "column", "firstCellIndentation", "rowIndex", "summaryResults", "hasSummary", "density", "active"]], template: function IgxSummaryRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxSummaryRowComponent_ng_container_0_Template, 7, 11, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, IgxSummaryRowComponent_ng_template_1_Template, 2, 3, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.summaries.size);
    } }, directives: function () { return [ɵngcc2.NgIf, IgxGridForOfDirective, ɵngcc2.NgTemplateOutlet, IgxSummaryCellComponent, ɵngcc2.NgForOf]; }, pipes: function () { return [IgxGridNotGroupedPipe, IgxStringReplacePipe]; }, encapsulation: 2, changeDetection: 0 });
IgxSummaryRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxSummaryRowComponent.propDecorators = {
    summaries: [{ type: Input }],
    gridID: [{ type: Input }],
    index: [{ type: Input }],
    firstCellIndentation: [{ type: Input }],
    dataRowIndex: [{ type: HostBinding, args: ['attr.data-rowIndex',] }],
    _summaryCells: [{ type: ViewChildren, args: [IgxSummaryCellComponent, { read: IgxSummaryCellComponent },] }],
    virtDirRow: [{ type: ViewChild, args: ['igxDirRef', { read: IgxGridForOfDirective },] }]
};

var DragScrollDirection;
(function (DragScrollDirection) {
    DragScrollDirection[DragScrollDirection["NONE"] = 0] = "NONE";
    DragScrollDirection[DragScrollDirection["LEFT"] = 1] = "LEFT";
    DragScrollDirection[DragScrollDirection["TOP"] = 2] = "TOP";
    DragScrollDirection[DragScrollDirection["RIGHT"] = 3] = "RIGHT";
    DragScrollDirection[DragScrollDirection["BOTTOM"] = 4] = "BOTTOM";
    DragScrollDirection[DragScrollDirection["TOPLEFT"] = 5] = "TOPLEFT";
    DragScrollDirection[DragScrollDirection["TOPRIGHT"] = 6] = "TOPRIGHT";
    DragScrollDirection[DragScrollDirection["BOTTOMLEFT"] = 7] = "BOTTOMLEFT";
    DragScrollDirection[DragScrollDirection["BOTTOMRIGHT"] = 8] = "BOTTOMRIGHT";
})(DragScrollDirection || (DragScrollDirection = {}));
class IgxGridDragSelectDirective {
    constructor(ref, zone) {
        this.ref = ref;
        this.zone = zone;
        this.onDragStop = new EventEmitter();
        this.onDragScroll = new EventEmitter();
        this.end$ = new Subject();
        this.lastDirection = DragScrollDirection.NONE;
        this.startDragSelection = (ev) => {
            if (!this.activeDrag) {
                return;
            }
            const x = ev.clientX;
            const y = ev.clientY;
            const direction = this._measureDimensions(x, y);
            if (direction === this.lastDirection) {
                return;
            }
            this.unsubscribe();
            this._sub = this._interval$.subscribe(() => this.onDragScroll.emit(direction));
            this.lastDirection = direction;
        };
        this.stopDragSelection = () => {
            if (!this.activeDrag) {
                return;
            }
            this.onDragStop.emit(false);
            this.unsubscribe();
            this.lastDirection = DragScrollDirection.NONE;
        };
        this._interval$ = interval(100).pipe(takeUntil(this.end$), filter(() => this.activeDrag));
    }
    get activeDrag() {
        return this._activeDrag;
    }
    set activeDrag(val) {
        if (val !== this._activeDrag) {
            this.unsubscribe();
            this._activeDrag = val;
        }
    }
    get nativeElement() {
        return this.ref.nativeElement;
    }
    get clientRect() {
        return this.nativeElement.getBoundingClientRect();
    }
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.addEventListener('pointerover', this.startDragSelection);
            this.nativeElement.addEventListener('pointerleave', this.stopDragSelection);
        });
    }
    ngOnDestroy() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.removeEventListener('pointerover', this.startDragSelection);
            this.nativeElement.removeEventListener('pointerleave', this.stopDragSelection);
        });
        this.unsubscribe();
        this.end$.complete();
    }
    _measureDimensions(x, y) {
        let direction;
        const rect = this.clientRect;
        const RATIO = 0.15;
        const offsetX = Math.trunc(x - rect.left);
        const offsetY = Math.trunc(y - rect.top);
        const left = offsetX <= rect.width * RATIO;
        const right = offsetX >= rect.width * (1 - RATIO);
        const top = offsetY <= rect.height * RATIO;
        const bottom = offsetY >= rect.height * (1 - RATIO);
        if (top && left) {
            direction = DragScrollDirection.TOPLEFT;
        }
        else if (top && right) {
            direction = DragScrollDirection.TOPRIGHT;
        }
        else if (bottom && left) {
            direction = DragScrollDirection.BOTTOMLEFT;
        }
        else if (bottom && right) {
            direction = DragScrollDirection.BOTTOMRIGHT;
        }
        else if (top) {
            direction = DragScrollDirection.TOP;
        }
        else if (bottom) {
            direction = DragScrollDirection.BOTTOM;
        }
        else if (left) {
            direction = DragScrollDirection.LEFT;
        }
        else if (right) {
            direction = DragScrollDirection.RIGHT;
        }
        else {
            direction = DragScrollDirection.NONE;
        }
        return direction;
    }
    unsubscribe() {
        if (this._sub) {
            this._sub.unsubscribe();
        }
    }
}
IgxGridDragSelectDirective.ɵfac = function IgxGridDragSelectDirective_Factory(t) { return new (t || IgxGridDragSelectDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxGridDragSelectDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridDragSelectDirective, selectors: [["", "igxGridDragSelect", ""]], inputs: { activeDrag: ["igxGridDragSelect", "activeDrag"] }, outputs: { onDragStop: "onDragStop", onDragScroll: "onDragScroll" } });
IgxGridDragSelectDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
IgxGridDragSelectDirective.propDecorators = {
    activeDrag: [{ type: Input, args: ['igxGridDragSelect',] }],
    onDragStop: [{ type: Output }],
    onDragScroll: [{ type: Output }]
};

/** @hidden */
class IgxListBaseDirective extends DisplayDensityBase {
    constructor(_displayDensityOptions) {
        super(_displayDensityOptions);
        this._displayDensityOptions = _displayDensityOptions;
    }
}
IgxListBaseDirective.ɵfac = function IgxListBaseDirective_Factory(t) { return new (t || IgxListBaseDirective)(ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxListBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListBaseDirective, selectors: [["", "igxListBase", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxListBaseDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
var IgxListPanState;
(function (IgxListPanState) {
    IgxListPanState[IgxListPanState["NONE"] = 0] = "NONE";
    IgxListPanState[IgxListPanState["LEFT"] = 1] = "LEFT";
    IgxListPanState[IgxListPanState["RIGHT"] = 2] = "RIGHT";
})(IgxListPanState || (IgxListPanState = {}));
class IgxEmptyListTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxEmptyListTemplateDirective.ɵfac = function IgxEmptyListTemplateDirective_Factory(t) { return new (t || IgxEmptyListTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxEmptyListTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxEmptyListTemplateDirective, selectors: [["", "igxEmptyList", ""]] });
IgxEmptyListTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxDataLoadingTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxDataLoadingTemplateDirective.ɵfac = function IgxDataLoadingTemplateDirective_Factory(t) { return new (t || IgxDataLoadingTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxDataLoadingTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDataLoadingTemplateDirective, selectors: [["", "igxDataLoading", ""]] });
IgxDataLoadingTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxListItemLeftPanningTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxListItemLeftPanningTemplateDirective.ɵfac = function IgxListItemLeftPanningTemplateDirective_Factory(t) { return new (t || IgxListItemLeftPanningTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxListItemLeftPanningTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListItemLeftPanningTemplateDirective, selectors: [["", "igxListItemLeftPanning", ""]] });
IgxListItemLeftPanningTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxListItemRightPanningTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxListItemRightPanningTemplateDirective.ɵfac = function IgxListItemRightPanningTemplateDirective_Factory(t) { return new (t || IgxListItemRightPanningTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxListItemRightPanningTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListItemRightPanningTemplateDirective, selectors: [["", "igxListItemRightPanning", ""]] });
IgxListItemRightPanningTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

const EVENT_SUFFIX = 'precise';
/**
 * Touch gestures manager based on Hammer.js
 * Use with caution, this will track references for single manager per element. Very TBD. Much TODO.
 * @hidden
 */
class HammerGesturesManager {
    constructor(_zone, doc, platformUtil) {
        this._zone = _zone;
        this.doc = doc;
        this.platformUtil = platformUtil;
        /**
         * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.
         */
        this.hammerOptions = {};
        this._hammerManagers = [];
        this.platformBrowser = this.platformUtil.isBrowser;
        if (this.platformBrowser) {
            this.hammerOptions = {
                // D.P. #447 Force TouchInput due to PointerEventInput bug (https://github.com/hammerjs/hammer.js/issues/1065)
                // see https://github.com/IgniteUI/igniteui-angular/issues/447#issuecomment-324601803
                inputClass: Hammer.TouchInput,
                recognizers: [
                    [Hammer.Pan, { threshold: 0 }],
                    [Hammer.Swipe, {
                            direction: Hammer.DIRECTION_HORIZONTAL
                        }],
                    [Hammer.Tap],
                    [Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']]
                ]
            };
        }
    }
    supports(eventName) {
        return eventName.toLowerCase().endsWith('.' + EVENT_SUFFIX);
    }
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     */
    addEventListener(element, eventName, eventHandler, options = null) {
        if (!this.platformBrowser) {
            return;
        }
        // Creating the manager bind events, must be done outside of angular
        return this._zone.runOutsideAngular(() => {
            let mc = this.getManagerForElement(element);
            if (mc === null) {
                // new Hammer is a shortcut for Manager with defaults
                mc = new Hammer(element, Object.assign(this.hammerOptions, options));
                this.addManagerForElement(element, mc);
            }
            const handler = (eventObj) => { this._zone.run(() => { eventHandler(eventObj); }); };
            mc.on(eventName, handler);
            return () => { mc.off(eventName, handler); };
        });
    }
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     *
     * @param target Can be one of either window, body or document(fallback default).
     */
    addGlobalEventListener(target, eventName, eventHandler) {
        if (!this.platformBrowser) {
            return;
        }
        const element = this.getGlobalEventTarget(target);
        // Creating the manager bind events, must be done outside of angular
        return this.addEventListener(element, eventName, eventHandler);
    }
    /**
     * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.
     * Supported: window, document, body. Defaults to document for invalid args.
     * @param target Target name
     */
    getGlobalEventTarget(target) {
        return ɵgetDOM().getGlobalEventTarget(this.doc, target);
    }
    /**
     * Set HammerManager options.
     *
     * @param element The DOM element used to create the manager on.
     *
     * ### Example
     *
     * ```ts
     * manager.setManagerOption(myElem, "pan", { pointers: 1 });
     * ```
     */
    setManagerOption(element, event, options) {
        const manager = this.getManagerForElement(element);
        manager.get(event).set(options);
    }
    /**
     * Add an element and manager map to the internal collection.
     *
     * @param element The DOM element used to create the manager on.
     */
    addManagerForElement(element, manager) {
        this._hammerManagers.push({ element, manager });
    }
    /**
     * Get HammerManager for the element or null
     *
     * @param element The DOM element used to create the manager on.
     */
    getManagerForElement(element) {
        const result = this._hammerManagers.filter((value, index, array) => {
            return value.element === element;
        });
        return result.length ? result[0].manager : null;
    }
    /**
     * Destroys the HammerManager for the element, removing event listeners in the process.
     *
     * @param element The DOM element used to create the manager on.
     */
    removeManagerForElement(element) {
        let index = null;
        for (let i = 0; i < this._hammerManagers.length; i++) {
            if (element === this._hammerManagers[i].element) {
                index = i;
                break;
            }
        }
        if (index !== null) {
            const item = this._hammerManagers.splice(index, 1)[0];
            // destroy also
            item.manager.destroy();
        }
    }
    /** Destroys all internally tracked HammerManagers, removing event listeners in the process. */
    destroy() {
        for (const item of this._hammerManagers) {
            item.manager.destroy();
        }
        this._hammerManagers = [];
    }
}
HammerGesturesManager.ɵfac = function HammerGesturesManager_Factory(t) { return new (t || HammerGesturesManager)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(PlatformUtil)); };
HammerGesturesManager.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: HammerGesturesManager, factory: HammerGesturesManager.ɵfac });
HammerGesturesManager.ctorParameters = () => [
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: PlatformUtil }
];

/**
 * The Ignite UI List Item component is a container intended for row items in the Ignite UI for Angular List component.
 *
 * Example:
 * ```html
 * <igx-list>
 *   <igx-list-item isHeader="true">Contacts</igx-list-item>
 *   <igx-list-item *ngFor="let contact of contacts">
 *     <span class="name">{{ contact.name }}</span>
 *     <span class="phone">{{ contact.phone }}</span>
 *   </igx-list-item>
 * </igx-list>
 * ```
 */
class IgxListItemComponent {
    constructor(list, elementRef, _renderer) {
        this.list = list;
        this.elementRef = elementRef;
        this._renderer = _renderer;
        /**
         * @hidden
         */
        this._panState = IgxListPanState.NONE;
        /**
         * @hidden
         */
        this.panOffset = 0;
        /**
         * @hidden
         */
        this._index = null;
        /**
         * @hidden
         */
        this.lastPanDir = IgxListPanState.NONE;
        /**
         * Sets/gets whether the `list item` is hidden.
         * By default the `hidden` value is `false`.
         * ```html
         * <igx-list-item [hidden] = "true">Hidden Item</igx-list-item>
         * ```
         * ```typescript
         * let isHidden =  this.listItem.hidden;
         * ```
         * @memberof IgxListItemComponent
         */
        this.hidden = false;
        /**
         * Gets the `touch-action` style of the `list item`.
         * ```typescript
         * let touchAction = this.listItem.touchAction;
         * ```
         */
        this.touchAction = 'pan-y';
    }
    /**
     * Gets the `role` attribute of the `list item`.
     * ```typescript
     * let itemRole =  this.listItem.role;
     * ```
     * @memberof IgxListItemComponent
     */
    get role() {
        return this.isHeader ? 'separator' : 'listitem';
    }
    /**
     * Indicates whether `list item` should have header style.
     * ```typescript
     * let headerStyle =  this.listItem.headerStyle;
     * ```
     * @memberof IgxListItemComponent
     */
    get headerStyle() {
        return this.isHeader;
    }
    /**
     * Applies the inner style of the `list item` if the item is not counted as header.
     * ```typescript
     * let innerStyle =  this.listItem.innerStyle;
     * ```
     * @memberof IgxListItemComponent
     */
    get innerStyle() {
        return !this.isHeader;
    }
    /**
     * Returns string value which describes the display mode of the `list item`.
     * ```typescript
     * let isHidden = this.listItem.display;
     * ```
     * @memberof IgxListItemComponent
     */
    get display() {
        return this.hidden ? 'none' : '';
    }
    /**
     * @hidden
     */
    clicked(evt) {
        this.list.onItemClicked.emit({ item: this, event: evt, direction: this.lastPanDir });
        this.lastPanDir = IgxListPanState.NONE;
    }
    /**
     * @hidden
     */
    panStart(ev) {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
    }
    /**
     * @hidden
     */
    panMove(ev) {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
        const isPanningToLeft = ev.deltaX < 0;
        if (isPanningToLeft && this.isTrue(this.list.allowLeftPanning)) {
            this.showLeftPanTemplate();
            this.setContentElementLeft(Math.max(this.maxLeft, ev.deltaX));
        }
        else if (!isPanningToLeft && this.isTrue(this.list.allowRightPanning)) {
            this.showRightPanTemplate();
            this.setContentElementLeft(Math.min(this.maxRight, ev.deltaX));
        }
    }
    /**
     * @hidden
     */
    panEnd(ev) {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
        // the translation offset of the current list item content
        const relativeOffset = this.panOffset;
        const widthTriggeringGrip = this.width * this.list.panEndTriggeringThreshold;
        if (relativeOffset === 0) {
            return; // no panning has occured
        }
        const dir = relativeOffset > 0 ? IgxListPanState.RIGHT : IgxListPanState.LEFT;
        this.lastPanDir = dir;
        const oldPanState = this._panState;
        if (Math.abs(relativeOffset) < widthTriggeringGrip) {
            this.setContentElementLeft(0);
            this._panState = IgxListPanState.NONE;
            this.hideLeftAndRightPanTemplates();
            return;
        }
        const args = { item: this, direction: dir, keepItem: false };
        if (dir === IgxListPanState.LEFT) {
            this.list.onLeftPan.emit(args);
        }
        else {
            this.list.onRightPan.emit(args);
        }
        if (args.keepItem === true) {
            this.setContentElementLeft(0);
            this._panState = IgxListPanState.NONE;
        }
        else {
            if (dir === IgxListPanState.LEFT) {
                this.setContentElementLeft(this.maxLeft);
                this._panState = IgxListPanState.LEFT;
            }
            else {
                this.setContentElementLeft(this.maxRight);
                this._panState = IgxListPanState.RIGHT;
            }
        }
        if (oldPanState !== this._panState) {
            const args2 = { oldState: oldPanState, newState: this._panState, item: this };
            this.list.onPanStateChange.emit(args2);
        }
        this.hideLeftAndRightPanTemplates();
    }
    /**
     * @hidden
     */
    showLeftPanTemplate() {
        this.setLeftAndRightTemplatesVisibility('visible', 'hidden');
    }
    /**
     * @hidden
     */
    showRightPanTemplate() {
        this.setLeftAndRightTemplatesVisibility('hidden', 'visible');
    }
    /**
     * @hidden
     */
    hideLeftAndRightPanTemplates() {
        setTimeout(() => {
            this.setLeftAndRightTemplatesVisibility('hidden', 'hidden');
        }, 500);
    }
    /**
     * @hidden
     */
    setLeftAndRightTemplatesVisibility(leftVisibility, rightVisibility) {
        if (this.leftPanningTemplateElement && this.leftPanningTemplateElement.nativeElement) {
            this.leftPanningTemplateElement.nativeElement.style.visibility = leftVisibility;
        }
        if (this.rightPanningTemplateElement && this.rightPanningTemplateElement.nativeElement) {
            this.rightPanningTemplateElement.nativeElement.style.visibility = rightVisibility;
        }
    }
    /**
     * Gets the `panState` of a `list item`.
     * ```typescript
     * let itemPanState =  this.listItem.panState;
     * ```
     * @memberof IgxListItemComponent
     */
    get panState() {
        return this._panState;
    }
    /**
     * Gets the `index` of a `list item`.
     * ```typescript
     * let itemIndex =  this.listItem.index;
     * ```
     * @memberof IgxListItemComponent
     */
    get index() {
        return this._index !== null ? this._index : this.list.children.toArray().indexOf(this);
    }
    /**
     * Sets the `index` of the `list item`.
     * ```typescript
     * this.listItem.index = index;
     * ```
     * @memberof IgxListItemComponent
     */
    set index(value) {
        this._index = value;
    }
    /**
     * Returns an element reference to the list item.
     * ```typescript
     * let listItemElement =  this.listItem.element.
     * ```
     * @memberof IgxListItemComponent
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * Returns a reference container which contains the list item's content.
     * ```typescript
     * let listItemContainer =  this.listItem.contentElement.
     * ```
     * @memberof IgxListItemComponent
     */
    get contentElement() {
        const candidates = this.element.getElementsByClassName('igx-list__item-content');
        return (candidates && candidates.length > 0) ? candidates[0] : null;
    }
    /**
     * Returns the `context` object which represents the `template context` binding into the `list item container`
     * by providing the `$implicit` declaration which is the `IgxListItemComponent` itself.
     * ```typescript
     * let listItemComponent = this.listItem.context;
     * ```
     */
    get context() {
        return {
            $implicit: this
        };
    }
    /**
     * Gets the width of a `list item`.
     * ```typescript
     * let itemWidth = this.listItem.width;
     * ```
     * @memberof IgxListItemComponent
     */
    get width() {
        if (this.element) {
            return this.element.offsetWidth;
        }
    }
    /**
     * Gets the maximum left position of the `list item`.
     * ```typescript
     * let maxLeft = this.listItem.maxLeft;
     * ```
     * @memberof IgxListItemComponent
     */
    get maxLeft() {
        return -this.width;
    }
    /**
     * Gets the maximum right position of the `list item`.
     * ```typescript
     * let maxRight = this.listItem.maxRight;
     * ```
     * @memberof IgxListItemComponent
     */
    get maxRight() {
        return this.width;
    }
    /**
     * @hidden
     */
    setContentElementLeft(value) {
        this.panOffset = value;
        this.contentElement.style.transform = 'translateX(' + value + 'px)';
    }
    /**
     * @hidden
     */
    isTrue(value) {
        if (typeof (value) === 'boolean') {
            return value;
        }
        else {
            return value === 'true';
        }
    }
}
IgxListItemComponent.ɵfac = function IgxListItemComponent_Factory(t) { return new (t || IgxListItemComponent)(ɵngcc0.ɵɵdirectiveInject(IgxListBaseDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IgxListItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxListItemComponent, selectors: [["igx-list-item"]], viewQuery: function IgxListItemComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c106, true);
        ɵngcc0.ɵɵviewQuery(_c107, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.leftPanningTemplateElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rightPanningTemplateElement = _t.first);
    } }, hostVars: 10, hostBindings: function IgxListItemComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxListItemComponent_click_HostBindingHandler($event) { return ctx.clicked($event); })("panstart", function IgxListItemComponent_panstart_HostBindingHandler($event) { return ctx.panStart($event); })("panmove", function IgxListItemComponent_panmove_HostBindingHandler($event) { return ctx.panMove($event); })("panend", function IgxListItemComponent_panend_HostBindingHandler($event) { return ctx.panEnd($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("aria-label", ctx.ariaLabel);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.touchAction)("display", ctx.display);
        ɵngcc0.ɵɵclassProp("igx-list__header", ctx.headerStyle)("igx-list__item-base", ctx.innerStyle);
    } }, inputs: { hidden: "hidden", index: "index", isHeader: "isHeader" }, features: [ɵngcc0.ɵɵProvidersFeature([HammerGesturesManager])], ngContentSelectors: _c109, decls: 12, vars: 4, consts: [["class", "igx-list__item-right", 3, "width", "height", 4, "ngIf"], ["class", "igx-list__item-left", 3, "width", "height", 4, "ngIf"], ["itemsContent", ""], ["itemThumbnails", ""], ["itemLines", ""], ["itemActions", ""], [4, "ngIf"], [1, "igx-list__item-right"], ["leftPanningTmpl", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-list__item-left"], ["rightPanningTmpl", ""], [1, "igx-list__item-thumbnail"], [1, "igx-list__item-lines"], [1, "igx-list__item-actions"], [4, "ngTemplateOutlet"], [1, "igx-list__item-content"]], template: function IgxListItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c108);
        ɵngcc0.ɵɵtemplate(0, IgxListItemComponent_div_0_Template, 3, 6, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxListItemComponent_div_1_Template, 3, 6, "div", 1);
        ɵngcc0.ɵɵtemplate(2, IgxListItemComponent_ng_template_2_Template, 1, 0, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxListItemComponent_ng_template_4_Template, 2, 0, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxListItemComponent_ng_template_6_Template, 2, 0, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, IgxListItemComponent_ng_template_8_Template, 2, 0, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(10, IgxListItemComponent_ng_container_10_Template, 2, 1, "ng-container", 6);
        ɵngcc0.ɵɵtemplate(11, IgxListItemComponent_ng_container_11_Template, 6, 4, "ng-container", 6);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isHeader && ctx.list.listItemLeftPanningTemplate != null);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isHeader && ctx.list.listItemRightPanningTemplate != null);
        ɵngcc0.ɵɵadvance(9);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isHeader);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isHeader);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
IgxListItemComponent.ctorParameters = () => [
    { type: IgxListBaseDirective },
    { type: ElementRef },
    { type: Renderer2 }
];
IgxListItemComponent.propDecorators = {
    leftPanningTemplateElement: [{ type: ViewChild, args: ['leftPanningTmpl',] }],
    rightPanningTemplateElement: [{ type: ViewChild, args: ['rightPanningTmpl',] }],
    isHeader: [{ type: Input }],
    hidden: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    ariaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],
    touchAction: [{ type: HostBinding, args: ['style.touch-action',] }],
    headerStyle: [{ type: HostBinding, args: ['class.igx-list__header',] }],
    innerStyle: [{ type: HostBinding, args: ['class.igx-list__item-base',] }],
    display: [{ type: HostBinding, args: ['style.display',] }],
    clicked: [{ type: HostListener, args: ['click', ['$event'],] }],
    panStart: [{ type: HostListener, args: ['panstart', ['$event'],] }],
    panMove: [{ type: HostListener, args: ['panmove', ['$event'],] }],
    panEnd: [{ type: HostListener, args: ['panend', ['$event'],] }],
    index: [{ type: Input }]
};

let NEXT_ID$m = 0;
/**
 * igxListThumbnail is container for the List media
 * Use it to wrap anything you want to be used as a thumbnail.
 */
class IgxListThumbnailDirective {
}
IgxListThumbnailDirective.ɵfac = function IgxListThumbnailDirective_Factory(t) { return new (t || IgxListThumbnailDirective)(); };
IgxListThumbnailDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListThumbnailDirective, selectors: [["", "igxListThumbnail", ""]] });
/**
 * igxListAction is container for the List action
 * Use it to wrap anything you want to be used as a list action: icon, checkbox...
 */
class IgxListActionDirective {
}
IgxListActionDirective.ɵfac = function IgxListActionDirective_Factory(t) { return new (t || IgxListActionDirective)(); };
IgxListActionDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListActionDirective, selectors: [["", "igxListAction", ""]] });
/**
 * igxListLine is container for the List text content
 * Use it to wrap anything you want to be used as a plane text.
 */
class IgxListLineDirective {
}
IgxListLineDirective.ɵfac = function IgxListLineDirective_Factory(t) { return new (t || IgxListLineDirective)(); };
IgxListLineDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListLineDirective, selectors: [["", "igxListLine", ""]] });
/**
 * igxListLineTitle is a directive that add class to the target element
 * Use it to make anything to look like list Title.
 */
class IgxListLineTitleDirective {
    constructor() {
        this.cssClass = 'igx-list__item-line-title';
    }
}
IgxListLineTitleDirective.ɵfac = function IgxListLineTitleDirective_Factory(t) { return new (t || IgxListLineTitleDirective)(); };
IgxListLineTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListLineTitleDirective, selectors: [["", "igxListLineTitle", ""]], hostVars: 2, hostBindings: function IgxListLineTitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-list__item-line-title", ctx.cssClass);
    } } });
IgxListLineTitleDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-list__item-line-title',] }]
};
/**
 * igxListLineSubTitle is a directive that add class to the target element
 * Use it to make anything to look like list Subtitle.
 */
class IgxListLineSubTitleDirective {
    constructor() {
        this.cssClass = 'igx-list__item-line-subtitle';
    }
}
IgxListLineSubTitleDirective.ɵfac = function IgxListLineSubTitleDirective_Factory(t) { return new (t || IgxListLineSubTitleDirective)(); };
IgxListLineSubTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListLineSubTitleDirective, selectors: [["", "igxListLineSubTitle", ""]], hostVars: 2, hostBindings: function IgxListLineSubTitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-list__item-line-subtitle", ctx.cssClass);
    } } });
IgxListLineSubTitleDirective.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-list__item-line-subtitle',] }]
};
/**
 * Displays a collection of data items in a templatable list format
 *
 * @igxModule IgxListModule
 *
 * @igxTheme igx-list-theme
 *
 * @igxKeywords list, data
 *
 * @igxGroup Grids & Lists
 *
 * @remarks
 * The Ignite UI List displays rows of items and supports one or more header items as well as search and filtering
 * of list items. Each list item is completely templatable and will support any valid HTML or Angular component.
 *
 * @example
 * ```html
 * <igx-list>
 *   <igx-list-item isHeader="true">Contacts</igx-list-item>
 *   <igx-list-item *ngFor="let contact of contacts">
 *     <span class="name">{{ contact.name }}</span>
 *     <span class="phone">{{ contact.phone }}</span>
 *   </igx-list-item>
 * </igx-list>
 * ```
 */
class IgxListComponent extends IgxListBaseDirective {
    constructor(element, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.element = element;
        this._displayDensityOptions = _displayDensityOptions;
        this._resourceStrings = CurrentResourceStrings.ListResStrings;
        /**
         * Provides a threshold after which the item's panning will be completed automatically.
         *
         * @remarks
         * By default this property is set to 0.5 which is 50% of the list item's width.
         *
         * @example
         * ```html
         * <igx-list [panEndTriggeringThreshold]="0.8"></igx-list>
         * ```
         */
        this.panEndTriggeringThreshold = 0.5;
        /**
         * Sets/gets the `id` of the list.
         *
         * @remarks
         * If not set, the `id` of the first list component will be `"igx-list-0"`.
         *
         * @example
         * ```html
         * <igx-list id="my-first-list"></igx-list>
         * ```
         * ```typescript
         * let listId = this.list.id;
         * ```
         */
        this.id = `igx-list-${NEXT_ID$m++}`;
        /**
         * Sets/gets whether the left panning of an item is allowed.
         *
         * @remarks
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-list [allowLeftPanning]="true"></igx-list>
         * ```
         * ```typescript
         * let isLeftPanningAllowed = this.list.allowLeftPanning;
         * ```
         */
        this.allowLeftPanning = false;
        /**
         * Sets/gets whether the right panning of an item is allowed.
         *
         * @remarks
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-list [allowRightPanning]="true"></igx-list>
         * ```
         * ```typescript
         * let isRightPanningAllowed = this.list.allowRightPanning;
         * ```
         */
        this.allowRightPanning = false;
        /**
         * Sets/gets whether the list is currently loading data.
         *
         * @remarks
         * Set it to display the dataLoadingTemplate while data is being retrieved.
         * Default value is `false`.
         *
         * @example
         * ```html
         *  <igx-list [isLoading]="true"></igx-list>
         * ```
         * ```typescript
         * let isLoading = this.list.isLoading;
         * ```
         */
        this.isLoading = false;
        /**
         * Event emitted when a left pan gesture is executed on a list item.
         *
         * @remarks
         * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
         *
         * @example
         * ```html
         * <igx-list [allowLeftPanning]="true" (onLeftPan)="onLeftPan($event)"></igx-list>
         * ```
         */
        this.onLeftPan = new EventEmitter();
        /**
         * Event emitted when a right pan gesture is executed on a list item.
         *
         * @remarks
         * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
         *
         * @example
         * ```html
         * <igx-list [allowRightPanning]="true" (onRightPan)="onRightPan($event)"></igx-list>
         * ```
         */
        this.onRightPan = new EventEmitter();
        /**
         *
         * Event emitted when a pan gesture is executed on a list item.
         *
         * @remarks
         * Provides references to the `IgxListItemComponent` and `IgxListPanState` as event arguments.
         *
         * @example
         * ```html
         * <igx-list (onPanStateChange)="onPanStateChange($event)"></igx-list>
         * ```
         */
        this.onPanStateChange = new EventEmitter();
        /**
         * Event emitted when a list item is clicked.
         *
         * @remarks
         * Provides references to the `IgxListItemComponent` and `Event` as event arguments.
         *
         * @example
         * ```html
         * <igx-list (onItemClicked)="onItemClicked($event)"></igx-list>
         * ```
         */
        this.onItemClicked = new EventEmitter();
    }
    /**
     * Sets the resource strings.
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * Returns the resource strings.
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /**
     * @hidden
     * @internal
     */
    get sortedChildren() {
        if (this.children !== undefined) {
            return this.children.toArray()
                .sort((a, b) => {
                return a.index - b.index;
            });
        }
        return null;
    }
    /**
     * Gets the `role` attribute value.
     *
     * @example
     * ```typescript
     * let listRole =  this.list.role;
     * ```
     */
    get role() {
        return 'list';
    }
    /**
     * Gets a boolean indicating if the list is empty.
     *
     * @example
     * ```typescript
     * let isEmpty =  this.list.isListEmpty;
     * ```
     */
    get isListEmpty() {
        return !this.children || this.children.length === 0;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClass() {
        return !this.isListEmpty && this.displayDensity === DisplayDensity.comfortable;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCompact() {
        return !this.isListEmpty && this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCosy() {
        return !this.isListEmpty && this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * Gets the list `items` excluding the header ones.
     *
     * @example
     * ```typescript
     * let listItems: IgxListItemComponent[] = this.list.items;
     * ```
     */
    get items() {
        const items = [];
        if (this.children !== undefined) {
            for (const child of this.sortedChildren) {
                if (!child.isHeader) {
                    items.push(child);
                }
            }
        }
        return items;
    }
    /**
     * Gets the header list `items`.
     *
     * @example
     * ```typescript
     * let listHeaders: IgxListItemComponent[] =  this.list.headers;
     * ```
     */
    get headers() {
        const headers = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (child.isHeader) {
                    headers.push(child);
                }
            }
        }
        return headers;
    }
    /**
     * Gets the `context` object of the template binding.
     *
     * @remark
     * Gets the `context` object which represents the `template context` binding into the `list container`
     * by providing the `$implicit` declaration which is the `IgxListComponent` itself.
     *
     * @example
     * ```typescript
     * let listComponent =  this.list.context;
     * ```
     */
    get context() {
        return {
            $implicit: this
        };
    }
    /**
     * Gets a `TemplateRef` to the currently used template.
     *
     * @example
     * ```typescript
     * let listTemplate = this.list.template;
     * ```
     */
    get template() {
        if (this.isLoading) {
            return this.dataLoadingTemplate ? this.dataLoadingTemplate.template : this.defaultDataLoadingTemplate;
        }
        else {
            return this.emptyListTemplate ? this.emptyListTemplate.template : this.defaultEmptyListTemplate;
        }
    }
}
IgxListComponent.ɵfac = function IgxListComponent_Factory(t) { return new (t || IgxListComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxListComponent, selectors: [["igx-list"]], contentQueries: function IgxListComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxEmptyListTemplateDirective, true, IgxEmptyListTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDataLoadingTemplateDirective, true, IgxDataLoadingTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxListItemLeftPanningTemplateDirective, true, IgxListItemLeftPanningTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxListItemRightPanningTemplateDirective, true, IgxListItemRightPanningTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxListItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.emptyListTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dataLoadingTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.listItemLeftPanningTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.listItemRightPanningTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, viewQuery: function IgxListComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c110, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c111, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultEmptyListTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultDataLoadingTemplate = _t.first);
    } }, hostVars: 10, hostBindings: function IgxListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-list-empty", ctx.isListEmpty)("igx-list", ctx.cssClass)("igx-list--compact", ctx.cssClassCompact)("igx-list--cosy", ctx.cssClassCosy);
    } }, inputs: { panEndTriggeringThreshold: "panEndTriggeringThreshold", id: "id", allowLeftPanning: "allowLeftPanning", allowRightPanning: "allowRightPanning", isLoading: "isLoading", resourceStrings: "resourceStrings" }, outputs: { onLeftPan: "onLeftPan", onRightPan: "onRightPan", onPanStateChange: "onPanStateChange", onItemClicked: "onItemClicked" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxListBaseDirective, useExisting: IgxListComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 6, vars: 1, consts: [["defaultEmptyList", ""], ["defaultDataLoading", ""], [4, "ngIf"], [1, "message"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function IgxListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, IgxListComponent_ng_template_1_Template, 2, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(3, IgxListComponent_ng_template_3_Template, 2, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, IgxListComponent_ng_container_5_Template, 2, 2, "ng-container", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.children || ctx.children.length === 0 || ctx.isLoading);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
IgxListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxListComponent.propDecorators = {
    resourceStrings: [{ type: Input }],
    children: [{ type: ContentChildren, args: [forwardRef(() => IgxListItemComponent), { descendants: true },] }],
    emptyListTemplate: [{ type: ContentChild, args: [IgxEmptyListTemplateDirective, { read: IgxEmptyListTemplateDirective },] }],
    dataLoadingTemplate: [{ type: ContentChild, args: [IgxDataLoadingTemplateDirective, { read: IgxDataLoadingTemplateDirective },] }],
    listItemLeftPanningTemplate: [{ type: ContentChild, args: [IgxListItemLeftPanningTemplateDirective, { read: IgxListItemLeftPanningTemplateDirective },] }],
    listItemRightPanningTemplate: [{ type: ContentChild, args: [IgxListItemRightPanningTemplateDirective, { read: IgxListItemRightPanningTemplateDirective },] }],
    panEndTriggeringThreshold: [{ type: Input }],
    defaultEmptyListTemplate: [{ type: ViewChild, args: ['defaultEmptyList', { read: TemplateRef, static: true },] }],
    defaultDataLoadingTemplate: [{ type: ViewChild, args: ['defaultDataLoading', { read: TemplateRef, static: true },] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    allowLeftPanning: [{ type: Input }],
    allowRightPanning: [{ type: Input }],
    isLoading: [{ type: Input }],
    onLeftPan: [{ type: Output }],
    onRightPan: [{ type: Output }],
    onPanStateChange: [{ type: Output }],
    onItemClicked: [{ type: Output }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    isListEmpty: [{ type: HostBinding, args: ['class.igx-list-empty',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-list',] }],
    cssClassCompact: [{ type: HostBinding, args: ['class.igx-list--compact',] }],
    cssClassCosy: [{ type: HostBinding, args: ['class.igx-list--cosy',] }]
};
/**
 * @hidden
 */
class IgxListModule {
}
IgxListModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxListModule });
IgxListModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxListModule_Factory(t) { return new (t || IgxListModule)(); }, imports: [[
            CommonModule,
            IgxRippleModule
        ]] });

class IgxExcelStyleLoadingValuesTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxExcelStyleLoadingValuesTemplateDirective.ɵfac = function IgxExcelStyleLoadingValuesTemplateDirective_Factory(t) { return new (t || IgxExcelStyleLoadingValuesTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxExcelStyleLoadingValuesTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExcelStyleLoadingValuesTemplateDirective, selectors: [["", "igxExcelStyleLoading", ""]] });
IgxExcelStyleLoadingValuesTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * A component used for presenting Excel style search UI.
 */
class IgxExcelStyleSearchComponent {
    constructor(cdr, esf) {
        this.cdr = cdr;
        this.esf = esf;
        this.destroy$ = new Subject();
        /**
         * @hidden @internal
         */
        this.class = 'igx-excel-filter__menu-main';
        esf.loadingStart.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.displayedListData = [];
            this.isLoading = true;
        });
        esf.loadingEnd.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.isLoading = false;
            this.refreshSize();
        });
        esf.initialized.pipe(takeUntil(this.destroy$)).subscribe(() => {
            requestAnimationFrame(() => {
                this.searchInput.nativeElement.focus();
            });
        });
        esf.columnChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.virtDir.resetScrollPosition();
        });
        esf.listDataLoaded.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.searchValue ?
                this.clearInput() :
                this.filterListData();
        });
    }
    /**
     * @hidden @internal
     */
    get addToCurrentFilter() {
        if (!this._addToCurrentFilter) {
            const addToCurrentFilterItem = {
                isSelected: false,
                isFiltered: false,
                indeterminate: false,
                isSpecial: true,
                isBlanks: false,
                value: this.esf.grid.resourceStrings.igx_grid_excel_add_to_filter,
                label: this.esf.grid.resourceStrings.igx_grid_excel_add_to_filter
            };
            this._addToCurrentFilter = addToCurrentFilterItem;
        }
        return this._addToCurrentFilter;
    }
    /**
     * @hidden @internal
     */
    get isLoading() {
        return this._isLoading;
    }
    /**
     * @hidden @internal
     */
    set isLoading(value) {
        this._isLoading = value;
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
    /**
     * @hidden @internal
     */
    get valuesLoadingTemplate() {
        var _a;
        if ((_a = this.esf.grid) === null || _a === void 0 ? void 0 : _a.excelStyleLoadingValuesTemplateDirective) {
            return this.esf.grid.excelStyleLoadingValuesTemplateDirective.template;
        }
        else {
            return this.defaultExcelStyleLoadingValuesTemplate;
        }
    }
    ngAfterViewInit() {
        this.refreshSize();
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden @internal
     */
    refreshSize() {
        requestAnimationFrame(() => {
            var _a;
            (_a = this.virtDir) === null || _a === void 0 ? void 0 : _a.recalcUpdateSizes();
        });
    }
    /**
     * @hidden @internal
     */
    clearInput() {
        this.searchValue = null;
        this.filterListData();
    }
    /**
     * @hidden @internal
     */
    onCheckboxChange(eventArgs) {
        const selectedIndex = this.displayedListData.indexOf(eventArgs.checkbox.value);
        const selectAllBtn = this.displayedListData[0];
        if (selectedIndex === 0) {
            this.displayedListData.forEach(element => {
                if (element === this.addToCurrentFilter) {
                    return;
                }
                element.isSelected = eventArgs.checked;
            });
            selectAllBtn.indeterminate = false;
        }
        else {
            eventArgs.checkbox.value.isSelected = eventArgs.checked;
            const indexToStartSlicing = this.displayedListData.indexOf(this.addToCurrentFilter) > -1 ? 2 : 1;
            const slicedArray = this.displayedListData.slice(indexToStartSlicing, this.displayedListData.length);
            if (!slicedArray.find(el => el.isSelected === false)) {
                selectAllBtn.indeterminate = false;
                selectAllBtn.isSelected = true;
            }
            else if (!slicedArray.find(el => el.isSelected === true)) {
                selectAllBtn.indeterminate = false;
                selectAllBtn.isSelected = false;
            }
            else {
                selectAllBtn.indeterminate = true;
            }
        }
        eventArgs.checkbox.nativeCheckbox.nativeElement.blur();
    }
    /**
     * @hidden @internal
     */
    get itemSize() {
        let itemSize = '40px';
        switch (this.esf.displayDensity) {
            case DisplayDensity.cosy:
                itemSize = '32px';
                break;
            case DisplayDensity.compact:
                itemSize = '24px';
                break;
            default: break;
        }
        return itemSize;
    }
    /**
     * @hidden @internal
     */
    get containerSize() {
        if (this.list) {
            return this.list.element.nativeElement.offsetHeight;
        }
    }
    /**
     * @hidden @internal
     */
    get applyButtonDisabled() {
        return this.esf.listData[0] && !this.esf.listData[0].isSelected && !this.esf.listData[0].indeterminate ||
            this.displayedListData && this.displayedListData.length === 0;
    }
    /**
     * @hidden @internal
     */
    onInputKeyDown(event) {
        switch (event.key) {
            case "Enter" /* ENTER */:
                event.preventDefault();
                this.applyFilter();
                return;
            case "Escape" /* ESCAPE */ || "Esc" /* ESCAPE_IE */:
                if (this.searchValue) {
                    event.stopPropagation();
                    this.clearInput();
                }
                return;
        }
    }
    /**
     * @hidden @internal
     */
    filterListData() {
        if (!this.esf.listData || !this.esf.listData.length) {
            this.displayedListData = [];
            return;
        }
        const searchAllBtn = this.esf.listData[0];
        if (!this.searchValue) {
            const anyFiltered = this.esf.listData.some(i => i.isFiltered);
            const anyUnfiltered = this.esf.listData.some(i => !i.isFiltered);
            if (anyFiltered && anyUnfiltered) {
                searchAllBtn.indeterminate = true;
            }
            this.esf.listData.forEach(i => i.isSelected = i.isFiltered);
            this.displayedListData = this.esf.listData;
            searchAllBtn.label = this.esf.grid.resourceStrings.igx_grid_excel_select_all;
            return;
        }
        const searchVal = this.searchValue.toLowerCase();
        this.displayedListData = this.esf.listData.filter((it, i) => (i === 0 && it.isSpecial) ||
            (it.label !== null && it.label !== undefined) &&
                !it.isBlanks &&
                it.label.toString().toLowerCase().indexOf(searchVal) > -1);
        this.esf.listData.forEach(i => i.isSelected = false);
        this.displayedListData.forEach(i => i.isSelected = true);
        this.displayedListData.splice(1, 0, this.addToCurrentFilter);
        searchAllBtn.indeterminate = false;
        searchAllBtn.label = this.esf.grid.resourceStrings.igx_grid_excel_select_all_search_results;
        if (this.displayedListData.length === 2) {
            this.displayedListData = [];
        }
    }
    /**
     * @hidden @internal
     */
    applyFilter() {
        const filterTree = new FilteringExpressionsTree(FilteringLogic.Or, this.esf.column.field);
        const item = this.displayedListData[1];
        const addToCurrentFilterOptionVisible = item === this.addToCurrentFilter;
        const selectedItems = addToCurrentFilterOptionVisible && item.isSelected ?
            this.esf.listData.slice(1, this.esf.listData.length).filter(el => el.isSelected || el.isFiltered) :
            this.esf.listData.slice(1, this.esf.listData.length).filter(el => el.isSelected);
        const unselectedItem = this.esf.listData.slice(1, this.esf.listData.length).find(el => el.isSelected === false);
        if (unselectedItem) {
            if (selectedItems.length <= IgxExcelStyleSearchComponent.filterOptimizationThreshold) {
                selectedItems.forEach(element => {
                    let condition = null;
                    if (element.value !== null && element.value !== undefined) {
                        if (this.esf.column.dataType === DataType.Boolean) {
                            condition = this.createCondition(element.value.toString());
                        }
                        else {
                            condition = this.createCondition('equals');
                        }
                    }
                    else {
                        condition = this.createCondition('empty');
                    }
                    filterTree.filteringOperands.push({
                        condition: condition,
                        fieldName: this.esf.column.field,
                        ignoreCase: this.esf.column.filteringIgnoreCase,
                        searchVal: element.value
                    });
                });
            }
            else {
                const blanksItemIndex = selectedItems.findIndex(e => e.value === null || e.value === undefined);
                let blanksItem;
                if (blanksItemIndex >= 0) {
                    blanksItem = selectedItems[blanksItemIndex];
                    selectedItems.splice(blanksItemIndex, 1);
                }
                filterTree.filteringOperands.push({
                    condition: this.createCondition('in'),
                    fieldName: this.esf.column.field,
                    ignoreCase: this.esf.column.filteringIgnoreCase,
                    searchVal: new Set(this.esf.column.dataType === DataType.Date ?
                        selectedItems.map(d => d.value.toISOString()) :
                        selectedItems.map(e => e.value))
                });
                if (blanksItem) {
                    filterTree.filteringOperands.push({
                        condition: this.createCondition('empty'),
                        fieldName: this.esf.column.field,
                        ignoreCase: this.esf.column.filteringIgnoreCase,
                        searchVal: blanksItem.value
                    });
                }
            }
            this.esf.grid.filteringService.filterInternal(this.esf.column.field, filterTree);
            this.esf.expressionsList = new Array();
            this.esf.grid.filteringService.generateExpressionsList(this.esf.column.filteringExpressionsTree, this.esf.grid.filteringLogic, this.esf.expressionsList);
        }
        else {
            this.esf.grid.filteringService.clearFilter(this.esf.column.field);
        }
        this.esf.closeDropdown();
    }
    createCondition(conditionName) {
        switch (this.esf.column.dataType) {
            case DataType.Boolean:
                return IgxBooleanFilteringOperand.instance().condition(conditionName);
            case DataType.Number:
                return IgxNumberFilteringOperand.instance().condition(conditionName);
            case DataType.Date:
                return IgxDateFilteringOperand.instance().condition(conditionName);
            default:
                return IgxStringFilteringOperand.instance().condition(conditionName);
        }
    }
}
IgxExcelStyleSearchComponent.ɵfac = function IgxExcelStyleSearchComponent_Factory(t) { return new (t || IgxExcelStyleSearchComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxGridExcelStyleFilteringComponent)); };
IgxExcelStyleSearchComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleSearchComponent, selectors: [["igx-excel-style-search"]], viewQuery: function IgxExcelStyleSearchComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c77, true, IgxInputDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c112, true, IgxListComponent);
        ɵngcc0.ɵɵstaticViewQuery(IgxForOfDirective, true);
        ɵngcc0.ɵɵviewQuery(_c113, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.list = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExcelStyleLoadingValuesTemplate = _t.first);
    } }, hostVars: 2, hostBindings: function IgxExcelStyleSearchComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.class);
    } }, decls: 18, vars: 19, consts: [["type", "box", 3, "displayDensity"], ["igxPrefix", ""], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "ngModel", "placeholder", "ngModelChange", "keydown"], ["input", ""], ["igxSuffix", "", "tabindex", "0", 3, "click", 4, "ngIf"], [3, "displayDensity", "isLoading"], ["list", ""], [4, "igxFor", "igxForOf", "igxForScrollOrientation", "igxForContainerSize", "igxForItemSize"], ["igxDataLoading", ""], ["defaultExcelStyleLoadingValuesTemplate", ""], [1, "igx-excel-filter__menu-footer"], ["igxButton", "", 3, "displayDensity", "click"], ["igxButton", "raised", 3, "displayDensity", "disabled", "click"], ["igxSuffix", "", "tabindex", "0", 3, "click"], ["tabindex", "-1", 3, "value", "checked", "disableRipple", "indeterminate", "disableTransitions", "change"], [1, "igx-excel-filter__loading"], [4, "ngTemplateOutlet"], [3, "indeterminate"]], template: function IgxExcelStyleSearchComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "igx-input-group", 0);
        ɵngcc0.ɵɵelementStart(1, "igx-icon", 1);
        ɵngcc0.ɵɵtext(2, "search");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "input", 2, 3);
        ɵngcc0.ɵɵlistener("ngModelChange", function IgxExcelStyleSearchComponent_Template_input_ngModelChange_3_listener($event) { return ctx.searchValue = $event; })("ngModelChange", function IgxExcelStyleSearchComponent_Template_input_ngModelChange_3_listener() { return ctx.filterListData(); })("keydown", function IgxExcelStyleSearchComponent_Template_input_keydown_3_listener($event) { return ctx.onInputKeyDown($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, IgxExcelStyleSearchComponent_igx_icon_5_Template, 2, 0, "igx-icon", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "igx-list", 5, 6);
        ɵngcc0.ɵɵelementStart(8, "div");
        ɵngcc0.ɵɵtemplate(9, IgxExcelStyleSearchComponent_igx_list_item_9_Template, 3, 6, "igx-list-item", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, IgxExcelStyleSearchComponent_ng_template_10_Template, 2, 1, "ng-template", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, IgxExcelStyleSearchComponent_ng_template_11_Template, 1, 1, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(13, "footer", 10);
        ɵngcc0.ɵɵelementStart(14, "button", 11);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleSearchComponent_Template_button_click_14_listener() { return ctx.esf.cancel(); });
        ɵngcc0.ɵɵtext(15);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(16, "button", 12);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleSearchComponent_Template_button_click_16_listener() { return ctx.applyFilter(); });
        ɵngcc0.ɵɵtext(17);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("displayDensity", ctx.esf.displayDensity);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngModel", ctx.searchValue)("placeholder", ctx.esf.column == null ? null : ctx.esf.column.grid.resourceStrings.igx_grid_excel_search_placeholder);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.searchValue || ctx.searchValue === 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.esf.displayDensity)("isLoading", ctx.isLoading);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("overflow", "hidden")("position", "relative");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxForOf", ctx.displayedListData)("igxForScrollOrientation", "vertical")("igxForContainerSize", ctx.containerSize)("igxForItemSize", ctx.itemSize);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.esf.displayDensity);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.esf.grid == null ? null : ctx.esf.grid.resourceStrings.igx_grid_excel_cancel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.esf.displayDensity)("disabled", ctx.applyButtonDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.esf.grid == null ? null : ctx.esf.grid.resourceStrings.igx_grid_excel_apply);
    } }, directives: [IgxInputGroupComponent, IgxIconComponent, IgxPrefixDirective, ɵngcc3.DefaultValueAccessor, IgxInputDirective, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, ɵngcc2.NgIf, IgxListComponent, IgxForOfDirective, IgxDataLoadingTemplateDirective, IgxButtonDirective, IgxSuffixDirective, IgxListItemComponent, IgxCheckboxComponent, ɵngcc2.NgTemplateOutlet, IgxCircularProgressBarComponent], encapsulation: 2 });
IgxExcelStyleSearchComponent.filterOptimizationThreshold = 2;
IgxExcelStyleSearchComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: IgxGridExcelStyleFilteringComponent }
];
IgxExcelStyleSearchComponent.propDecorators = {
    class: [{ type: HostBinding, args: ['class',] }],
    searchInput: [{ type: ViewChild, args: ['input', { read: IgxInputDirective, static: true },] }],
    list: [{ type: ViewChild, args: ['list', { read: IgxListComponent, static: true },] }],
    virtDir: [{ type: ViewChild, args: [IgxForOfDirective, { static: true },] }],
    defaultExcelStyleLoadingValuesTemplate: [{ type: ViewChild, args: ['defaultExcelStyleLoadingValuesTemplate', { read: TemplateRef },] }]
};

/**
 * @hidden
 * @internal
 */
class IgxColumnResizerDirective {
    constructor(element, document, zone) {
        this.element = element;
        this.document = document;
        this.zone = zone;
        this.restrictHResizeMin = Number.MIN_SAFE_INTEGER;
        this.restrictHResizeMax = Number.MAX_SAFE_INTEGER;
        this.resizeEnd = new Subject();
        this.resizeStart = new Subject();
        this.resize = new Subject();
        this._destroy = new Subject();
        this.resizeStart.pipe(map((event) => event.clientX), takeUntil(this._destroy), switchMap((offset) => this.resize.pipe(map((event) => event.clientX - offset), takeUntil(this.resizeEnd), takeUntil(this._destroy)))).subscribe((pos) => {
            const left = this._left + pos;
            const min = this._left - this.restrictHResizeMin;
            const max = this._left + this.restrictHResizeMax;
            this.left = left < min ? min : left;
            if (left > max) {
                this.left = max;
            }
        });
    }
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            fromEvent(this.document.defaultView, 'mousemove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onMousemove(res));
            fromEvent(this.document.defaultView, 'mouseup').pipe(takeUntil(this._destroy))
                .subscribe((res) => this.onMouseup(res));
        });
    }
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
    }
    set left(val) {
        requestAnimationFrame(() => this.element.nativeElement.style.left = val + 'px');
    }
    set top(val) {
        requestAnimationFrame(() => this.element.nativeElement.style.top = val + 'px');
    }
    onMouseup(event) {
        this.resizeEnd.next(event);
        this.resizeEnd.complete();
    }
    onMousedown(event) {
        event.preventDefault();
        const parent = this.element.nativeElement.parentElement.parentElement;
        this.left = this._left = event.clientX - parent.getBoundingClientRect().left;
        this.top = event.target.getBoundingClientRect().top - parent.getBoundingClientRect().top;
        this.resizeStart.next(event);
    }
    onMousemove(event) {
        event.preventDefault();
        this.resize.next(event);
    }
}
IgxColumnResizerDirective.ɵfac = function IgxColumnResizerDirective_Factory(t) { return new (t || IgxColumnResizerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxColumnResizerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxColumnResizerDirective, selectors: [["", "igxResizer", ""]], inputs: { restrictHResizeMin: "restrictHResizeMin", restrictHResizeMax: "restrictHResizeMax" }, outputs: { resizeEnd: "resizeEnd", resizeStart: "resizeStart", resize: "resize" } });
IgxColumnResizerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone }
];
IgxColumnResizerDirective.propDecorators = {
    restrictHResizeMin: [{ type: Input }],
    restrictHResizeMax: [{ type: Input }],
    resizeEnd: [{ type: Output }],
    resizeStart: [{ type: Output }],
    resize: [{ type: Output }]
};

class IgxGridColumnResizerComponent {
    constructor(colResizingService) {
        this.colResizingService = colResizingService;
    }
}
IgxGridColumnResizerComponent.ɵfac = function IgxGridColumnResizerComponent_Factory(t) { return new (t || IgxGridColumnResizerComponent)(ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService)); };
IgxGridColumnResizerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridColumnResizerComponent, selectors: [["igx-grid-column-resizer"]], viewQuery: function IgxGridColumnResizerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(IgxColumnResizerDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resizer = _t.first);
    } }, decls: 1, vars: 6, consts: [["igxResizer", "", 1, "igx-grid__th-resize-line", 3, "restrictHResizeMax", "restrictHResizeMin", "resizeEnd"]], template: function IgxGridColumnResizerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("resizeEnd", function IgxGridColumnResizerComponent_Template_div_resizeEnd_0_listener($event) { return ctx.colResizingService.resizeColumn($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("left", -99999, "px")("height", ctx.colResizingService.resizerHeight, "px");
        ɵngcc0.ɵɵproperty("restrictHResizeMax", ctx.colResizingService.restrictResizeMax)("restrictHResizeMin", ctx.colResizingService.restrictResizeMin);
    } }, directives: [IgxColumnResizerDirective], encapsulation: 2, changeDetection: 0 });
IgxGridColumnResizerComponent.ctorParameters = () => [
    { type: IgxColumnResizingService }
];
IgxGridColumnResizerComponent.propDecorators = {
    resizer: [{ type: ViewChild, args: [IgxColumnResizerDirective, { static: true },] }]
};

/**
 * @hidden
 */
class IgxGridFilteringRowComponent {
    constructor(filteringService, element, cdr) {
        this.filteringService = filteringService;
        this.element = element;
        this.cdr = cdr;
        this._positionSettings = {
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom
        };
        this._conditionsOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
        };
        this._operatorsOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
        };
        this.chipAreaScrollOffset = 0;
        this._column = null;
        this.isKeyPressed = false;
        this.isComposing = false;
        this._cancelChipClick = false;
    }
    get column() {
        return this._column;
    }
    set column(val) {
        if (this._column) {
            this.expressionsList.forEach(exp => exp.isSelected = false);
        }
        if (val) {
            this._column = val;
            this.expressionsList = this.filteringService.getExpressions(this._column.field);
            this.resetExpression();
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
        }
    }
    get value() {
        return this.expression ? this.expression.searchVal : null;
    }
    set value(val) {
        if (!val && val !== 0) {
            this.expression.searchVal = null;
            this.showHideArrowButtons();
        }
        else {
            this.expression.searchVal = DataUtil.parseValue(this.column.dataType, val);
            if (this.expressionsList.find(item => item.expression === this.expression) === undefined) {
                this.addExpression(true);
            }
        }
        this.filter();
    }
    get displayDensity() {
        return this.column.grid.displayDensity === DisplayDensity.comfortable ? DisplayDensity.cosy : this.column.grid.displayDensity;
    }
    get styleClasses() {
        let classes = 'igx-grid__filtering-row';
        switch (this.column.grid.displayDensity) {
            case DisplayDensity.compact:
                classes = classes + ' igx-grid__filtering-row--compact';
                break;
            case DisplayDensity.cosy:
                classes = classes + ' igx-grid__filtering-row--cosy';
                break;
        }
        return classes;
    }
    ngAfterViewInit() {
        this._conditionsOverlaySettings.outlet = this.column.grid.outlet;
        this._operatorsOverlaySettings.outlet = this.column.grid.outlet;
        const selectedItem = this.expressionsList.find(expr => expr.isSelected === true);
        if (selectedItem) {
            this.expression = selectedItem.expression;
        }
        this.input.nativeElement.focus();
    }
    onKeydownHandler(evt) {
        if (evt.key === "Escape" /* ESCAPE */ || evt.key === "Esc" /* ESCAPE_IE */ ||
            evt.ctrlKey && evt.shiftKey && evt.key.toLowerCase() === 'l') {
            evt.preventDefault();
            evt.stopPropagation();
            this.close();
        }
    }
    get disabled() {
        return !(this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0);
    }
    get template() {
        if (this.column.dataType === DataType.Date) {
            return this.defaultDateUI;
        }
        return this.defaultFilterUI;
    }
    get type() {
        switch (this.column.dataType) {
            case DataType.String:
            case DataType.Boolean:
                return 'text';
            case DataType.Number:
                return 'number';
        }
    }
    get conditions() {
        return this.column.filters.conditionList();
    }
    get isUnaryCondition() {
        if (this.expression.condition) {
            return this.expression.condition.isUnary;
        }
        else {
            return true;
        }
    }
    get placeholder() {
        if (this.expression.condition && this.expression.condition.isUnary) {
            return this.filteringService.getChipLabel(this.expression);
        }
        else if (this.column.dataType === DataType.Date) {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_date_placeholder;
        }
        else if (this.column.dataType === DataType.Boolean) {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_boolean_placeholder;
        }
        else {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_placeholder;
        }
    }
    /**
     * Event handler for keydown on the input group's prefix.
     */
    onPrefixKeyDown(event) {
        if ((event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) && this.dropDownConditions.collapsed) {
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
            event.stopImmediatePropagation();
        }
        else if (event.key === "Tab" /* TAB */ && !this.dropDownConditions.collapsed) {
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
        }
    }
    /**
     * Event handler for keydown on the input.
     */
    onInputKeyDown(event) {
        this.isKeyPressed = true;
        event.stopPropagation();
        if (this.column.dataType === DataType.Boolean) {
            if (event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) {
                this.inputGroupPrefix.nativeElement.focus();
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
                return;
            }
        }
        if (event.key === "Enter" /* ENTER */) {
            if (this.isComposing) {
                return;
            }
            this.commitInput();
        }
        else if (event.altKey && (event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */)) {
            this.inputGroupPrefix.nativeElement.focus();
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
        }
        else if (event.key === "Escape" /* ESCAPE */ || event.key === "Esc" /* ESCAPE_IE */ ||
            event.ctrlKey && event.shiftKey && event.key.toLowerCase() === 'l') {
            this.close();
        }
    }
    /**
     * Event handler for keyup on the input.
     */
    onInputKeyUp(eventArgs) {
        this.isKeyPressed = false;
    }
    /**
     * Event handler for input on the input.
     */
    onInput(eventArgs) {
        // The 'iskeyPressed' flag is needed for a case in IE, because the input event is fired on focus and for some reason,
        // when you have a japanese character as a placeholder, on init the value here is empty string .
        const target = eventArgs.target;
        if (isEdge() && target.type !== 'number' || this.isKeyPressed && isIE() || target.value || target.checkValidity()) {
            this.value = target.value;
        }
    }
    /**
     * Event handler for compositionstart on the input.
     */
    onCompositionStart() {
        this.isComposing = true;
    }
    /**
     * Event handler for compositionend on the input.
     */
    onCompositionEnd() {
        this.isComposing = false;
    }
    /**
     * Event handler for input click event.
     */
    onInputClick() {
        if (this.column.dataType === DataType.Boolean && this.dropDownConditions.collapsed) {
            this.inputGroupPrefix.nativeElement.focus();
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
        }
    }
    /**
     * Event handler for datepicker's close.
     */
    datePickerClose() {
        this.input.nativeElement.focus();
    }
    /**
     * Returns the filtering operation condition for a given value.
     */
    getCondition(value) {
        return this.column.filters.condition(value);
    }
    /**
     * Returns the translated condition name for a given value.
     */
    translateCondition(value) {
        return this.filteringService.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;
    }
    /**
     * Returns the icon name of the current condition.
     */
    getIconName() {
        if (this.column.dataType === DataType.Boolean && this.expression.condition === null) {
            return this.getCondition(this.conditions[0]).iconName;
        }
        else {
            return this.expression.condition.iconName;
        }
    }
    /**
     * Returns whether a given condition is selected in dropdown.
     */
    isConditionSelected(conditionName) {
        if (this.expression.condition) {
            return this.expression.condition.name === conditionName;
        }
        else {
            return false;
        }
    }
    /**
     * Clears the current filtering.
     */
    clearFiltering() {
        this.filteringService.clearFilter(this.column.field);
        this.resetExpression();
        if (this.input) {
            this.input.nativeElement.focus();
        }
        this.cdr.detectChanges();
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
    }
    /**
     * Commits the value of the input.
     */
    commitInput() {
        const selectedItem = this.expressionsList.filter(ex => ex.isSelected === true);
        selectedItem.forEach(e => e.isSelected = false);
        let indexToDeselect = -1;
        for (let index = 0; index < this.expressionsList.length; index++) {
            const expression = this.expressionsList[index].expression;
            if (expression.searchVal === null && !expression.condition.isUnary) {
                indexToDeselect = index;
            }
        }
        if (indexToDeselect !== -1) {
            this.removeExpression(indexToDeselect, this.expression);
        }
        this.resetExpression();
        this.scrollChipsWhenAddingExpression();
    }
    /**
     * Clears the value of the input.
     */
    clearInput() {
        this.value = null;
    }
    /**
     * Event handler for keydown on clear button.
     */
    onClearKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            this.clearInput();
            this.input.nativeElement.focus();
        }
    }
    /**
     * Event handler for click on clear button.
     */
    onClearClick() {
        this.clearInput();
        this.input.nativeElement.focus();
    }
    /**
     * Event handler for keydown on commit button.
     */
    onCommitKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            this.commitInput();
            this.input.nativeElement.focus();
        }
    }
    /**
     * Event handler for click on commit button.
     */
    onCommitClick() {
        this.commitInput();
        this.input.nativeElement.focus();
    }
    /**
     * Event handler for focusout on the input group.
     */
    onInputGroupFocusout() {
        if (!this.value && this.value !== 0 &&
            this.expression.condition && !this.expression.condition.isUnary) {
            return;
        }
        requestAnimationFrame(() => {
            const focusedElement = document.activeElement;
            if (focusedElement.className === 'igx-chip__remove' || focusedElement.tagName === 'IGX-DAY-ITEM') {
                return;
            }
            if (!(focusedElement && this.inputGroup.nativeElement.contains(focusedElement))
                && this.dropDownConditions.collapsed) {
                this.commitInput();
            }
        });
    }
    /**
     * Closes the filtering edit row.
     */
    close() {
        if (this.expressionsList.length === 1 &&
            this.expressionsList[0].expression.searchVal === null &&
            this.expressionsList[0].expression.condition.isUnary === false) {
            this.filteringService.getExpressions(this.column.field).pop();
            this.filter();
        }
        else {
            const condToRemove = this.expressionsList.filter(ex => ex.expression.searchVal === null && !ex.expression.condition.isUnary);
            if (condToRemove && condToRemove.length > 0) {
                condToRemove.forEach(c => this.filteringService.removeExpression(this.column.field, this.expressionsList.indexOf(c)));
                this.filter();
            }
        }
        this.filteringService.isFilterRowVisible = false;
        this.filteringService.updateFilteringCell(this.column);
        this.filteringService.filteredColumn = null;
        this.filteringService.selectedExpression = null;
        this.filteringService.grid.theadRow.nativeElement.focus();
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
    }
    /*
    * noop
    */
    noop() { }
    /**
     *  Event handler for date picker's selection.
     */
    onDateSelected(value) {
        this.value = value;
    }
    /** @hidden @internal */
    inputGroupPrefixClick(event) {
        event.stopPropagation();
        event.currentTarget.focus();
        this.toggleConditionsDropDown(event.currentTarget);
    }
    /**
     * Opens the conditions dropdown.
     */
    toggleConditionsDropDown(target) {
        this._conditionsOverlaySettings.target = target;
        this._conditionsOverlaySettings.excludeFromOutsideClick = [target];
        this.dropDownConditions.toggle(this._conditionsOverlaySettings);
    }
    /**
     * Opens the logic operators dropdown.
     */
    toggleOperatorsDropDown(eventArgs, index) {
        this._operatorsOverlaySettings.target = eventArgs.target.parentElement;
        this._operatorsOverlaySettings.excludeFromOutsideClick = [eventArgs.target.parentElement];
        this.dropDownOperators.toArray()[index].toggle(this._operatorsOverlaySettings);
    }
    /**
     * Event handler for change event in conditions dropdown.
     */
    onConditionsChanged(eventArgs) {
        const value = eventArgs.newSelection.value;
        this.expression.condition = this.getCondition(value);
        if (this.expression.condition.isUnary) {
            // update grid's filtering on the next cycle to ensure the drop-down is closed
            // if the drop-down is not closed this event handler will be invoked multiple times
            requestAnimationFrame(() => this.unaryConditionChangedCallback());
        }
        else {
            requestAnimationFrame(() => this.conditionChangedCallback());
        }
        if (this.input) {
            // Add requestAnimationFrame becasue of an issue in IE, where you are still able to write in the input,
            // if it has been focused and then set to readonly.
            requestAnimationFrame(() => this.input.nativeElement.focus());
        }
    }
    onChipPointerdown(args, chip) {
        const activeElement = document.activeElement;
        this._cancelChipClick = chip.selected && activeElement &&
            this.inputGroup.nativeElement.contains(activeElement);
    }
    onChipClick(args, item) {
        if (this._cancelChipClick) {
            this._cancelChipClick = false;
            return;
        }
        this.expressionsList.forEach(ex => ex.isSelected = false);
        this.toggleChip(item);
    }
    toggleChip(item) {
        item.isSelected = !item.isSelected;
        if (item.isSelected) {
            this.expression = item.expression;
            if (this.input) {
                this.input.nativeElement.focus();
            }
        }
    }
    /**
     * Event handler for chip keydown event.
     */
    onChipKeyDown(eventArgs, item) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            eventArgs.preventDefault();
            this.toggleChip(item);
        }
    }
    /**
     * Scrolls the first chip into view if the tab key is pressed on the left arrow.
     */
    onLeftArrowKeyDown(event) {
        if (event.key === "Tab" /* TAB */) {
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
        }
    }
    /**
     * Event handler for chip removed event.
     */
    onChipRemoved(eventArgs, item) {
        const indexToRemove = this.expressionsList.indexOf(item);
        this.removeExpression(indexToRemove, item.expression);
        this.scrollChipsOnRemove();
    }
    /**
     * Event handler for logic operator changed event.
     */
    onLogicOperatorChanged(eventArgs, expression) {
        if (eventArgs.oldSelection) {
            expression.afterOperator = eventArgs.newSelection.value;
            this.expressionsList[this.expressionsList.indexOf(expression) + 1].beforeOperator = expression.afterOperator;
            // update grid's filtering on the next cycle to ensure the drop-down is closed
            // if the drop-down is not closed this event handler will be invoked multiple times
            requestAnimationFrame(() => this.filter());
        }
    }
    /**
     * Scrolls the chips into the chip area when left or right arrows are pressed.
     */
    scrollChipsOnArrowPress(arrowPosition) {
        let count = 0;
        const chipAraeChildren = this.chipsArea.element.nativeElement.children;
        const containerRect = this.container.nativeElement.getBoundingClientRect();
        if (arrowPosition === 'right') {
            for (let index = 0; index < chipAraeChildren.length; index++) {
                if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().right) < Math.ceil(containerRect.right)) {
                    count++;
                }
            }
            if (count < chipAraeChildren.length) {
                this.chipAreaScrollOffset -= Math.ceil(chipAraeChildren[count].getBoundingClientRect().right) -
                    Math.ceil(containerRect.right) + 1;
                this.transform(this.chipAreaScrollOffset);
            }
        }
        if (arrowPosition === 'left') {
            for (let index = 0; index < chipAraeChildren.length; index++) {
                if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().left) < Math.ceil(containerRect.left)) {
                    count++;
                }
            }
            if (count > 0) {
                this.chipAreaScrollOffset += Math.ceil(containerRect.left) -
                    Math.ceil(chipAraeChildren[count - 1].getBoundingClientRect().left) + 1;
                this.transform(this.chipAreaScrollOffset);
            }
        }
    }
    showHideArrowButtons() {
        requestAnimationFrame(() => {
            if (this.filteringService.isFilterRowVisible) {
                const containerWidth = this.container.nativeElement.getBoundingClientRect().width;
                this.chipsAreaWidth = this.chipsArea.element.nativeElement.getBoundingClientRect().width;
                this.showArrows = this.chipsAreaWidth >= containerWidth && this.isColumnFiltered;
                // TODO: revise the cdr.detectChanges() usage here
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
            }
        });
    }
    addExpression(isSelected) {
        const exprUI = new ExpressionUI();
        exprUI.expression = this.expression;
        exprUI.beforeOperator = this.expressionsList.length > 0 ? FilteringLogic.And : null;
        exprUI.isSelected = isSelected;
        this.expressionsList.push(exprUI);
        const length = this.expressionsList.length;
        if (this.expressionsList[length - 2]) {
            this.expressionsList[length - 2].afterOperator = this.expressionsList[length - 1].beforeOperator;
        }
        this.showHideArrowButtons();
    }
    removeExpression(indexToRemove, expression) {
        if (indexToRemove === 0 && this.expressionsList.length === 1) {
            this.clearFiltering();
            return;
        }
        this.filteringService.removeExpression(this.column.field, indexToRemove);
        this.filter();
        if (this.expression === expression) {
            this.resetExpression();
        }
        this.showHideArrowButtons();
    }
    resetExpression() {
        this.expression = {
            fieldName: this.column.field,
            condition: null,
            searchVal: null,
            ignoreCase: this.column.filteringIgnoreCase
        };
        if (this.column.dataType !== DataType.Boolean) {
            this.expression.condition = this.getCondition(this.conditions[0]);
        }
        if (this.column.dataType === DataType.Date && this.input) {
            this.input.nativeElement.value = null;
        }
        this.showHideArrowButtons();
    }
    scrollChipsWhenAddingExpression() {
        const chipAraeChildren = this.chipsArea.element.nativeElement.children;
        if (!chipAraeChildren || chipAraeChildren.length === 0) {
            return;
        }
        const containerRectRight = Math.ceil(this.container.nativeElement.getBoundingClientRect().right);
        const lastChipRectRight = Math.ceil(chipAraeChildren[chipAraeChildren.length - 1].getBoundingClientRect().right);
        if (lastChipRectRight >= containerRectRight) {
            this.chipAreaScrollOffset -= lastChipRectRight - containerRectRight;
            this.transform(this.chipAreaScrollOffset);
        }
    }
    /**
     * @hidden
     * Resets the chips area
     * @memberof IgxGridFilteringRowComponent
     */
    resetChipsArea() {
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
        this.showHideArrowButtons();
    }
    transform(offset) {
        requestAnimationFrame(() => {
            this.chipsArea.element.nativeElement.style.transform = `translate(${offset}px)`;
        });
    }
    scrollChipsOnRemove() {
        let count = 0;
        const chipAraeChildren = this.chipsArea.element.nativeElement.children;
        const containerRect = this.container.nativeElement.getBoundingClientRect();
        for (let index = 0; index < chipAraeChildren.length; index++) {
            if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().right) < Math.ceil(containerRect.left)) {
                count++;
            }
        }
        if (count <= 2) {
            this.chipAreaScrollOffset = 0;
        }
        else {
            const dif = chipAraeChildren[count].id === 'chip' ? count - 2 : count - 1;
            this.chipAreaScrollOffset += Math.ceil(containerRect.left) - Math.ceil(chipAraeChildren[dif].getBoundingClientRect().left) + 1;
        }
        this.transform(this.chipAreaScrollOffset);
    }
    conditionChangedCallback() {
        if (!!this.expression.searchVal || this.expression.searchVal === 0) {
            this.filter();
        }
        else if (this.value) {
            this.value = null;
        }
    }
    unaryConditionChangedCallback() {
        if (this.value) {
            this.value = null;
        }
        if (this.expressionsList.find(item => item.expression === this.expression) === undefined) {
            this.addExpression(true);
        }
        this.filter();
    }
    filter() {
        this.filteringService.filterInternal(this.column.field);
    }
    get isColumnFiltered() {
        return this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0;
    }
    get isNarrowWidth() {
        return this.element.nativeElement.offsetWidth < 432;
    }
}
IgxGridFilteringRowComponent.ɵfac = function IgxGridFilteringRowComponent_Factory(t) { return new (t || IgxGridFilteringRowComponent)(ɵngcc0.ɵɵdirectiveInject(IgxFilteringService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxGridFilteringRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridFilteringRowComponent, selectors: [["igx-grid-filtering-row"]], viewQuery: function IgxGridFilteringRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c114, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c115, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(_c77, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c116, true, IgxDropDownComponent);
        ɵngcc0.ɵɵstaticViewQuery(_c99, true, IgxChipsAreaComponent);
        ɵngcc0.ɵɵviewQuery(_c59, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c117, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c5, true);
        ɵngcc0.ɵɵviewQuery(_c118, true);
        ɵngcc0.ɵɵstaticViewQuery(_c119, true);
        ɵngcc0.ɵɵviewQuery(_c120, true, IgxDropDownComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultFilterUI = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultDateUI = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropDownConditions = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chipsArea = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputGroupPrefix = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.operand = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.closeButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropDownOperators = _t);
    } }, hostVars: 2, hostBindings: function IgxGridFilteringRowComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function IgxGridFilteringRowComponent_keydown_HostBindingHandler($event) { return ctx.onKeydownHandler($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.styleClasses);
    } }, inputs: { column: "column", value: "value" }, decls: 27, vars: 19, consts: [[3, "displayDensity", "height", "onSelection"], ["inputGroupConditions", ""], [3, "value", "selected", 4, "ngFor", "ngForOf"], ["defaultFilterUI", ""], ["defaultDateUI", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["igxButton", "icon", "class", "igx-grid__filtering-row-scroll-start", 3, "keydown", "click", 4, "ngIf"], [1, "igx-grid__filtering-row-main"], ["container", ""], ["chipsArea", ""], ["tabindex", "0", 4, "ngFor", "ngForOf"], ["igxButton", "icon", "class", "igx-grid__filtering-row-scroll-end", 3, "click", 4, "ngIf"], [3, "ngClass"], ["buttonsContainer", ""], ["igxRipple", "", 3, "displayDensity", "igxButton", "disabled", "tabindex", "click"], ["igxRipple", "", 3, "displayDensity", "igxButton", "click"], ["closeButton", ""], [3, "value", "selected"], [1, "igx-grid__filtering-dropdown-items"], ["fontSet", "imx-icons", 3, "name"], [1, "igx-grid__filtering-dropdown-text"], ["type", "box", 3, "displayDensity", "focusout"], ["inputGroup", ""], ["tabindex", "0", 3, "igxDropDownItemNavigation", "click", "keydown"], ["inputGroupPrefix", ""], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "placeholder", "value", "type", "readonly", "input", "click", "compositionstart", "compositionend", "keydown", "keyup"], ["input", ""], [4, "ngIf"], ["tabindex", "0", 3, "keydown", "click"], ["tabindex", "0", "mode", "dropdown", 3, "value", "outlet", "locale", "onSelection", "onClosed"], ["igxDatePickerTemplate", ""], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "placeholder", "value", "readonly", "click", "keydown"], ["igxButton", "icon", 1, "igx-grid__filtering-row-scroll-start", 3, "keydown", "click"], ["tabindex", "0"], ["id", "chip", 3, "selectable", "selected", "displayDensity", "removable", "pointerdown", "click", "keydown", "onRemove"], ["chip", ""], ["igxPrefix", "", "fontSet", "imx-icons", 3, "name"], ["id", "operand", 4, "ngIf"], ["id", "operand"], ["igxButton", "", 3, "igxDropDownItemNavigation", "displayDensity", "click"], [3, "displayDensity", "onSelection"], ["operators", ""], ["igxButton", "icon", 1, "igx-grid__filtering-row-scroll-end", 3, "click"]], template: function IgxGridFilteringRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "igx-drop-down", 0, 1);
        ɵngcc0.ɵɵlistener("onSelection", function IgxGridFilteringRowComponent_Template_igx_drop_down_onSelection_0_listener($event) { return ctx.onConditionsChanged($event); });
        ɵngcc0.ɵɵtemplate(2, IgxGridFilteringRowComponent_igx_drop_down_item_2_Template, 5, 4, "igx-drop-down-item", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, IgxGridFilteringRowComponent_ng_template_3_Template, 8, 8, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, IgxGridFilteringRowComponent_ng_template_5_Template, 2, 3, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(7, IgxGridFilteringRowComponent_ng_container_7_Template, 1, 0, "ng-container", 5);
        ɵngcc0.ɵɵtemplate(8, IgxGridFilteringRowComponent_button_8_Template, 3, 0, "button", 6);
        ɵngcc0.ɵɵelementStart(9, "div", 7, 8);
        ɵngcc0.ɵɵelementStart(11, "div");
        ɵngcc0.ɵɵelementStart(12, "igx-chips-area", null, 9);
        ɵngcc0.ɵɵtemplate(14, IgxGridFilteringRowComponent_ng_container_14_Template, 7, 7, "ng-container", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(15, IgxGridFilteringRowComponent_button_15_Template, 3, 0, "button", 11);
        ɵngcc0.ɵɵelementStart(16, "div", 12, 13);
        ɵngcc0.ɵɵelementStart(18, "button", 14);
        ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_Template_button_click_18_listener() { return ctx.clearFiltering(); });
        ɵngcc0.ɵɵelementStart(19, "igx-icon");
        ɵngcc0.ɵɵtext(20, "refresh");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtext(21);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(22, "button", 15, 16);
        ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_Template_button_click_22_listener() { return ctx.close(); });
        ɵngcc0.ɵɵelementStart(24, "igx-icon");
        ɵngcc0.ɵɵtext(25, "close");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtext(26);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity)("height", "200px");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.conditions);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(17, _c17, ctx));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showArrows);
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.expressionsList);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showArrows);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.isNarrowWidth ? "igx-grid__filtering-row-editing-buttons--small" : "igx-grid__filtering-row-editing-buttons");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.column.grid.displayDensity)("igxButton", ctx.isNarrowWidth ? "icon" : "flat")("disabled", ctx.disabled)("tabindex", ctx.disabled);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.isNarrowWidth ? "" : ctx.filteringService.grid.resourceStrings.igx_grid_filter_row_reset, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.column.grid.displayDensity)("igxButton", ctx.isNarrowWidth ? "icon" : "flat");
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.isNarrowWidth ? "" : ctx.filteringService.grid.resourceStrings.igx_grid_filter_row_close, " ");
    } }, directives: [IgxDropDownComponent, ɵngcc2.NgForOf, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxChipsAreaComponent, ɵngcc2.NgClass, IgxRippleDirective, IgxButtonDirective, IgxIconComponent, IgxDropDownItemComponent, IgxInputGroupComponent, IgxPrefixDirective, IgxDropDownItemNavigationDirective, IgxInputDirective, IgxSuffixDirective, IgxDatePickerComponent, IgxDatePickerTemplateDirective, IgxChipComponent], pipes: [ɵngcc2.DatePipe], encapsulation: 2, changeDetection: 0 });
IgxGridFilteringRowComponent.ctorParameters = () => [
    { type: IgxFilteringService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxGridFilteringRowComponent.propDecorators = {
    column: [{ type: Input }],
    value: [{ type: Input }],
    defaultFilterUI: [{ type: ViewChild, args: ['defaultFilterUI', { read: TemplateRef, static: true },] }],
    defaultDateUI: [{ type: ViewChild, args: ['defaultDateUI', { read: TemplateRef, static: true },] }],
    input: [{ type: ViewChild, args: ['input', { read: ElementRef },] }],
    dropDownConditions: [{ type: ViewChild, args: ['inputGroupConditions', { read: IgxDropDownComponent, static: true },] }],
    chipsArea: [{ type: ViewChild, args: ['chipsArea', { read: IgxChipsAreaComponent, static: true },] }],
    dropDownOperators: [{ type: ViewChildren, args: ['operators', { read: IgxDropDownComponent },] }],
    inputGroup: [{ type: ViewChild, args: ['inputGroup', { read: ElementRef },] }],
    inputGroupPrefix: [{ type: ViewChild, args: ['inputGroupPrefix', { read: ElementRef },] }],
    container: [{ type: ViewChild, args: ['container', { static: true },] }],
    operand: [{ type: ViewChild, args: ['operand',] }],
    closeButton: [{ type: ViewChild, args: ['closeButton', { static: true },] }],
    styleClasses: [{ type: HostBinding, args: ['class',] }],
    onKeydownHandler: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * @hidden
 * @internal
 */
class IgxColumnMovingDragDirective extends IgxDragDirective {
    constructor(element, viewContainer, zone, renderer, cdr, cms) {
        super(cdr, element, viewContainer, zone, renderer);
        this.element = element;
        this.viewContainer = viewContainer;
        this.zone = zone;
        this.renderer = renderer;
        this.cdr = cdr;
        this.cms = cms;
        this._ghostClass = 'igx-grid__drag-ghost-image';
        this.ghostImgIconClass = 'igx-grid__drag-ghost-image-icon';
        this.ghostImgIconGroupClass = 'igx-grid__drag-ghost-image-icon-group';
        this.columnSelectedClass = 'igx-grid__th--selected';
    }
    get column() {
        return this.data;
    }
    get draggable() {
        return this.column && (this.column.movable || (this.column.groupable && !this.column.columnGroup));
    }
    get icon() {
        return this.cms.icon;
    }
    ngOnDestroy() {
        this._unsubscribe();
    }
    onEscape(event) {
        this.cms.cancelDrop = true;
        this.onPointerUp(event);
    }
    onPointerDown(event) {
        if (!this.draggable || event.target.getAttribute('draggable') === 'false') {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._removeOnDestroy = false;
        this.cms.column = this.column;
        this.ghostClass = this._ghostClass;
        super.onPointerDown(event);
        this.cms.isColumnMoving = true;
        this.column.grid.cdr.detectChanges();
        const args = {
            source: this.column
        };
        this.column.grid.onColumnMovingStart.emit(args);
        this.subscription$ = fromEvent(this.column.grid.document.defaultView, 'keydown').subscribe((ev) => {
            if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                this.onEscape(ev);
            }
        });
    }
    onPointerMove(event) {
        event.preventDefault();
        super.onPointerMove(event);
        if (this._dragStarted && this.ghostElement && !this.column.grid.draggedColumn) {
            this.column.grid.draggedColumn = this.column;
            this.column.grid.cdr.detectChanges();
        }
        if (this.cms.isColumnMoving) {
            const args = {
                source: this.column,
                cancel: false
            };
            this.column.grid.onColumnMoving.emit(args);
            if (args.cancel) {
                this.onEscape(event);
            }
        }
    }
    onPointerUp(event) {
        // Run it explicitly inside the zone because sometimes onPointerUp executes after the code below.
        this.zone.run(() => {
            super.onPointerUp(event);
            this.cms.isColumnMoving = false;
            this.column.grid.draggedColumn = null;
            this.column.grid.cdr.detectChanges();
        });
        this._unsubscribe();
    }
    createGhost(pageX, pageY) {
        super.createGhost(pageX, pageY);
        this.ghostElement.style.height = null;
        this.ghostElement.style.minWidth = null;
        this.ghostElement.style.flexBasis = null;
        this.ghostElement.style.position = null;
        this.renderer.removeClass(this.ghostElement, this.columnSelectedClass);
        const icon = document.createElement('i');
        const text = document.createTextNode('block');
        icon.appendChild(text);
        icon.classList.add('material-icons');
        this.cms.icon = icon;
        if (!this.column.columnGroup) {
            this.renderer.addClass(icon, this.ghostImgIconClass);
            this.ghostElement.insertBefore(icon, this.ghostElement.firstElementChild);
            this.ghostLeft = this._ghostStartX = pageX - ((this.ghostElement.getBoundingClientRect().width / 3) * 2);
            this.ghostTop = this._ghostStartY = pageY - ((this.ghostElement.getBoundingClientRect().height / 3) * 2);
        }
        else {
            this.ghostElement.insertBefore(icon, this.ghostElement.childNodes[0]);
            this.renderer.addClass(icon, this.ghostImgIconGroupClass);
            this.ghostElement.children[0].style.paddingLeft = '0px';
            this.ghostLeft = this._ghostStartX = pageX - ((this.ghostElement.getBoundingClientRect().width / 3) * 2);
            this.ghostTop = this._ghostStartY = pageY - ((this.ghostElement.getBoundingClientRect().height / 3) * 2);
        }
    }
    _unsubscribe() {
        if (this.subscription$) {
            this.subscription$.unsubscribe();
            this.subscription$ = null;
        }
    }
}
IgxColumnMovingDragDirective.ɵfac = function IgxColumnMovingDragDirective_Factory(t) { return new (t || IgxColumnMovingDragDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxColumnMovingService)); };
IgxColumnMovingDragDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxColumnMovingDragDirective, selectors: [["", "igxColumnMovingDrag", ""]], inputs: { data: ["igxColumnMovingDrag", "data"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxColumnMovingDragDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: NgZone },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: IgxColumnMovingService }
];
IgxColumnMovingDragDirective.propDecorators = {
    data: [{ type: Input, args: ['igxColumnMovingDrag',] }]
};

/**
 * @hidden
 */
class IgxGroupByRowTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxGroupByRowTemplateDirective.ɵfac = function IgxGroupByRowTemplateDirective_Factory(t) { return new (t || IgxGroupByRowTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxGroupByRowTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGroupByRowTemplateDirective, selectors: [["", "igxGroupByRow", ""]] });
IgxGroupByRowTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
class IgxGridDetailTemplateDirective {
}
IgxGridDetailTemplateDirective.ɵfac = function IgxGridDetailTemplateDirective_Factory(t) { return new (t || IgxGridDetailTemplateDirective)(); };
IgxGridDetailTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridDetailTemplateDirective, selectors: [["", "igxGridDetail", ""]] });
/**
 * @hidden
 */
class IgxRowExpandedIndicatorDirective {
}
IgxRowExpandedIndicatorDirective.ɵfac = function IgxRowExpandedIndicatorDirective_Factory(t) { return new (t || IgxRowExpandedIndicatorDirective)(); };
IgxRowExpandedIndicatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowExpandedIndicatorDirective, selectors: [["", "igxRowExpandedIndicator", ""]] });
/**
 * @hidden
 */
class IgxRowCollapsedIndicatorDirective {
}
IgxRowCollapsedIndicatorDirective.ɵfac = function IgxRowCollapsedIndicatorDirective_Factory(t) { return new (t || IgxRowCollapsedIndicatorDirective)(); };
IgxRowCollapsedIndicatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowCollapsedIndicatorDirective, selectors: [["", "igxRowCollapsedIndicator", ""]] });
/**
 * @hidden
 */
class IgxHeaderExpandIndicatorDirective {
}
IgxHeaderExpandIndicatorDirective.ɵfac = function IgxHeaderExpandIndicatorDirective_Factory(t) { return new (t || IgxHeaderExpandIndicatorDirective)(); };
IgxHeaderExpandIndicatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxHeaderExpandIndicatorDirective, selectors: [["", "igxHeaderExpandedIndicator", ""]] });
/**
 * @hidden
 */
class IgxHeaderCollapseIndicatorDirective {
}
IgxHeaderCollapseIndicatorDirective.ɵfac = function IgxHeaderCollapseIndicatorDirective_Factory(t) { return new (t || IgxHeaderCollapseIndicatorDirective)(); };
IgxHeaderCollapseIndicatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxHeaderCollapseIndicatorDirective, selectors: [["", "igxHeaderCollapsedIndicator", ""]] });
/**
 * @hidden
 */
class IgxGroupAreaDropDirective extends IgxDropDirective {
    constructor(elementRef, renderer, zone) {
        super(elementRef, renderer, zone);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        this.hovered = false;
    }
    onDragEnter(event) {
        const drag = event.detail.owner;
        const column = drag.column;
        if (!this.columnBelongsToGrid(column)) {
            return;
        }
        const grid = column.grid;
        const isGrouped = grid.groupingExpressions.findIndex((item) => item.fieldName === column.field) !== -1;
        if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {
            drag.icon.innerText = 'group_work';
            this.hovered = true;
        }
        else {
            drag.icon.innerText = 'block';
            this.hovered = false;
        }
    }
    onDragLeave(event) {
        const drag = event.detail.owner;
        const column = drag.column;
        if (!this.columnBelongsToGrid(column)) {
            return;
        }
        event.detail.owner.icon.innerText = 'block';
        this.hovered = false;
    }
    onDragDrop(event) {
        const drag = event.detail.owner;
        if (drag instanceof IgxColumnMovingDragDirective) {
            const column = drag.column;
            if (!this.columnBelongsToGrid(column)) {
                return;
            }
            const grid = column.grid;
            const isGrouped = grid.groupingExpressions.findIndex((item) => item.fieldName === column.field) !== -1;
            if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {
                grid.groupBy({ fieldName: column.field, dir: SortingDirection.Asc, ignoreCase: column.sortingIgnoreCase,
                    strategy: column.sortStrategy, groupingComparer: column.groupingComparer });
            }
        }
    }
    closestParentByAttr(elem, attr) {
        return elem.hasAttribute(attr) ?
            elem :
            this.closestParentByAttr(elem.parentElement, attr);
    }
    columnBelongsToGrid(column) {
        const elem = this.elementRef.nativeElement;
        const closestGridID = this.closestParentByAttr(elem, 'igxGroupAreaDrop').getAttribute('gridId');
        if (!column) {
            return false;
        }
        else {
            const grid = column.grid;
            if (!grid || grid.id !== closestGridID) {
                return false;
            }
            return true;
        }
    }
}
IgxGroupAreaDropDirective.ɵfac = function IgxGroupAreaDropDirective_Factory(t) { return new (t || IgxGroupAreaDropDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxGroupAreaDropDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGroupAreaDropDirective, selectors: [["", "igxGroupAreaDrop", ""]], hostVars: 2, hostBindings: function IgxGroupAreaDropDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-drop-area--hover", ctx.hovered);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxGroupAreaDropDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
IgxGroupAreaDropDirective.propDecorators = {
    hovered: [{ type: HostBinding, args: ['class.igx-drop-area--hover',] }]
};

/**
 * @hidden
 */
class ExpressionItem {
    constructor(parent) {
        this.parent = parent;
    }
}
/**
 * @hidden
 */
class ExpressionGroupItem extends ExpressionItem {
    constructor(operator, parent) {
        super(parent);
        this.operator = operator;
        this.children = [];
    }
}
/**
 * @hidden
 */
class ExpressionOperandItem extends ExpressionItem {
    constructor(expression, parent) {
        super(parent);
        this.expression = expression;
    }
}
/**
 * A component used for presenting advanced filtering UI for a Grid.
 * It is used internally in the Grid, but could also be hosted in a container outside of it.
 *
 * Example:
 * ```html
 * <igx-advanced-filtering-dialog
 *     [grid]="grid1">
 * </igx-advanced-filtering-dialog>
 * ```
 */
class IgxAdvancedFilteringDialogComponent {
    constructor(cdr) {
        this.cdr = cdr;
        /**
         * @hidden @internal
         */
        this.inline = true;
        /**
         * @hidden @internal
         */
        this.selectedExpressions = [];
        /**
         * @hidden @internal
         */
        this.selectedGroups = [];
        this._positionSettings = {
            horizontalStartPoint: HorizontalAlignment.Right,
            verticalStartPoint: VerticalAlignment.Top
        };
        this._overlaySettings = {
            closeOnOutsideClick: false,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings),
            scrollStrategy: new CloseScrollStrategy()
        };
        /**
         * @hidden @internal
         */
        this.columnSelectOverlaySettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: false
        };
        /**
         * @hidden @internal
         */
        this.conditionSelectOverlaySettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: false
        };
        /**
         * @hidden @internal
         */
        this.display = 'block';
        this.destroy$ = new Subject();
        this._dblClickDelay = 200;
        this._preventChipClick = false;
    }
    /**
     * @hidden @internal
     */
    set editingInputsContainer(value) {
        if ((value && !this._editingInputsContainer) ||
            (value && this._editingInputsContainer && this._editingInputsContainer.nativeElement !== value.nativeElement)) {
            requestAnimationFrame(() => {
                this.scrollElementIntoView(value.nativeElement);
            });
        }
        this._editingInputsContainer = value;
    }
    /**
     * @hidden @internal
     */
    get editingInputsContainer() {
        return this._editingInputsContainer;
    }
    /**
     * @hidden @internal
     */
    set addModeContainer(value) {
        if ((value && !this._addModeContainer) ||
            (value && this._addModeContainer && this._addModeContainer.nativeElement !== value.nativeElement)) {
            requestAnimationFrame(() => {
                this.scrollElementIntoView(value.nativeElement);
            });
        }
        this._addModeContainer = value;
    }
    /**
     * @hidden @internal
     */
    get addModeContainer() {
        return this._addModeContainer;
    }
    /**
     * @hidden @internal
     */
    set currentGroupButtonsContainer(value) {
        if ((value && !this._currentGroupButtonsContainer) ||
            (value && this._currentGroupButtonsContainer && this._currentGroupButtonsContainer.nativeElement !== value.nativeElement)) {
            requestAnimationFrame(() => {
                this.scrollElementIntoView(value.nativeElement);
            });
        }
        this._currentGroupButtonsContainer = value;
    }
    /**
     * @hidden @internal
     */
    get currentGroupButtonsContainer() {
        return this._currentGroupButtonsContainer;
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        this._overlaySettings.outlet = this.overlayOutlet;
        this.columnSelectOverlaySettings.outlet = this.overlayOutlet;
        this.conditionSelectOverlaySettings.outlet = this.overlayOutlet;
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden @internal
     */
    get displayDensity() {
        return this.grid.displayDensity;
    }
    /**
     * @hidden @internal
     */
    get selectedColumn() {
        return this._selectedColumn;
    }
    /**
     * @hidden @internal
     */
    set selectedColumn(value) {
        const oldValue = this._selectedColumn;
        if (this._selectedColumn !== value) {
            this._selectedColumn = value;
            if (oldValue && this._selectedColumn && this._selectedColumn.dataType !== oldValue.dataType) {
                this.selectedCondition = null;
                this.searchValue = null;
                this.cdr.detectChanges();
            }
        }
    }
    /**
     * An @Input property that sets the grid.
     */
    set grid(grid) {
        this._grid = grid;
        if (this._filteringChange) {
            this._filteringChange.unsubscribe();
        }
        if (this._grid) {
            this._grid.filteringService.registerSVGIcons();
            this._filteringChange = this._grid.advancedFilteringExpressionsTreeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.init();
            });
            this.init();
        }
    }
    /**
     * Returns the grid.
     */
    get grid() {
        return this._grid;
    }
    /**
     * @hidden @internal
     */
    get filterableColumns() {
        return this.grid.columns.filter((col) => !col.columnGroup && col.filterable);
    }
    /**
     * @hidden @internal
     */
    dragStart(dragArgs) {
        if (!this._overlayComponentId) {
            dragArgs.cancel = true;
            return;
        }
        if (!this.contextMenuToggle.collapsed) {
            this.contextMenuToggle.element.style.display = 'none';
        }
    }
    /**
     * @hidden @internal
     */
    dragEnd(dragArgs) {
        if (!this.contextMenuToggle.collapsed) {
            this.calculateContextMenuTarget();
            this.contextMenuToggle.reposition();
            this.contextMenuToggle.element.style.display = '';
        }
    }
    /**
     * @hidden @internal
     */
    onDragMove(e) {
        const deltaX = e.nextPageX - e.pageX;
        const deltaY = e.nextPageY - e.pageY;
        e.cancel = true;
        this._overlayService.setOffset(this._overlayComponentId, deltaX, deltaY);
    }
    /**
     * @hidden @internal
     */
    addCondition(parent, afterExpression) {
        this.cancelOperandAdd();
        const operandItem = new ExpressionOperandItem({
            fieldName: null,
            condition: null,
            ignoreCase: true,
            searchVal: null
        }, parent);
        if (afterExpression) {
            const index = parent.children.indexOf(afterExpression);
            parent.children.splice(index + 1, 0, operandItem);
        }
        else {
            parent.children.push(operandItem);
        }
        this.enterExpressionEdit(operandItem);
    }
    /**
     * @hidden @internal
     */
    addAndGroup(parent, afterExpression) {
        this.addGroup(FilteringLogic.And, parent, afterExpression);
    }
    /**
     * @hidden @internal
     */
    addOrGroup(parent, afterExpression) {
        this.addGroup(FilteringLogic.Or, parent, afterExpression);
    }
    /**
     * @hidden @internal
     */
    endGroup(groupItem) {
        this.currentGroup = groupItem.parent;
    }
    /**
     * @hidden @internal
     */
    commitOperandEdit() {
        if (this.editedExpression) {
            this.editedExpression.expression.fieldName = this.selectedColumn.field;
            this.editedExpression.expression.condition = this.selectedColumn.filters.condition(this.selectedCondition);
            this.editedExpression.expression.searchVal = DataUtil.parseValue(this.selectedColumn.dataType, this.searchValue);
            this.editedExpression.columnHeader = this.selectedColumn.header;
            this.editedExpression.inEditMode = false;
            this.editedExpression = null;
        }
    }
    /**
     * @hidden @internal
     */
    cancelOperandAdd() {
        if (this.addModeExpression) {
            this.addModeExpression.inAddMode = false;
            this.addModeExpression = null;
        }
    }
    /**
     * @hidden @internal
     */
    cancelOperandEdit() {
        if (this.editedExpression) {
            this.editedExpression.inEditMode = false;
            if (!this.editedExpression.expression.fieldName) {
                this.deleteItem(this.editedExpression);
            }
            this.editedExpression = null;
        }
    }
    /**
     * @hidden @internal
     */
    operandCanBeCommitted() {
        return this.selectedColumn && this.selectedCondition &&
            (!!this.searchValue || this.selectedColumn.filters.condition(this.selectedCondition).isUnary);
    }
    /**
     * @hidden @internal
     */
    exitOperandEdit() {
        if (!this.editedExpression) {
            return;
        }
        if (this.operandCanBeCommitted()) {
            this.commitOperandEdit();
        }
        else {
            this.cancelOperandEdit();
        }
    }
    /**
     * @hidden @internal
     */
    isExpressionGroup(expression) {
        return expression instanceof ExpressionGroupItem;
    }
    addGroup(operator, parent, afterExpression) {
        this.cancelOperandAdd();
        const groupItem = new ExpressionGroupItem(operator, parent);
        if (parent) {
            if (afterExpression) {
                const index = parent.children.indexOf(afterExpression);
                parent.children.splice(index + 1, 0, groupItem);
            }
            else {
                parent.children.push(groupItem);
            }
        }
        else {
            this.rootGroup = groupItem;
        }
        this.addCondition(groupItem);
        this.currentGroup = groupItem;
    }
    createExpressionGroupItem(expressionTree, parent) {
        let groupItem;
        if (expressionTree) {
            groupItem = new ExpressionGroupItem(expressionTree.operator, parent);
            for (const expr of expressionTree.filteringOperands) {
                if (expr instanceof FilteringExpressionsTree) {
                    groupItem.children.push(this.createExpressionGroupItem(expr, groupItem));
                }
                else {
                    const filteringExpr = expr;
                    const exprCopy = {
                        fieldName: filteringExpr.fieldName,
                        condition: filteringExpr.condition,
                        searchVal: filteringExpr.searchVal,
                        ignoreCase: filteringExpr.ignoreCase
                    };
                    const operandItem = new ExpressionOperandItem(exprCopy, groupItem);
                    const column = this.grid.getColumnByName(filteringExpr.fieldName);
                    operandItem.columnHeader = column.header;
                    groupItem.children.push(operandItem);
                }
            }
        }
        return groupItem;
    }
    createExpressionsTreeFromGroupItem(groupItem) {
        if (!groupItem) {
            return null;
        }
        const expressionsTree = new FilteringExpressionsTree(groupItem.operator);
        for (const item of groupItem.children) {
            if (item instanceof ExpressionGroupItem) {
                const subTree = this.createExpressionsTreeFromGroupItem(item);
                expressionsTree.filteringOperands.push(subTree);
            }
            else {
                expressionsTree.filteringOperands.push(item.expression);
            }
        }
        return expressionsTree;
    }
    /**
     * @hidden @internal
     */
    onChipRemove(expressionItem) {
        this.deleteItem(expressionItem);
    }
    /**
     * @hidden @internal
     */
    onChipClick(expressionItem) {
        this._clickTimer = setTimeout(() => {
            if (!this._preventChipClick) {
                this.onToggleExpression(expressionItem);
            }
            this._preventChipClick = false;
        }, this._dblClickDelay);
    }
    /**
     * @hidden @internal
     */
    onChipDblClick(expressionItem) {
        clearTimeout(this._clickTimer);
        this._preventChipClick = true;
        this.enterExpressionEdit(expressionItem);
    }
    /**
     * @hidden @internal
     */
    enterExpressionEdit(expressionItem) {
        this.clearSelection();
        this.exitOperandEdit();
        this.cancelOperandAdd();
        if (this.editedExpression) {
            this.editedExpression.inEditMode = false;
        }
        expressionItem.hovered = false;
        this.selectedColumn = expressionItem.expression.fieldName ?
            this.grid.getColumnByName(expressionItem.expression.fieldName) : null;
        this.selectedCondition = expressionItem.expression.condition ?
            expressionItem.expression.condition.name : null;
        this.searchValue = expressionItem.expression.searchVal;
        expressionItem.inEditMode = true;
        this.editedExpression = expressionItem;
        this.cdr.detectChanges();
        this.columnSelectOverlaySettings.target = this.columnSelect.element;
        this.columnSelectOverlaySettings.excludeFromOutsideClick = [this.columnSelect.element];
        this.columnSelectOverlaySettings.positionStrategy = new AutoPositionStrategy();
        this.conditionSelectOverlaySettings.target = this.conditionSelect.element;
        this.conditionSelectOverlaySettings.excludeFromOutsideClick = [this.conditionSelect.element];
        this.conditionSelectOverlaySettings.positionStrategy = new AutoPositionStrategy();
        if (!this.selectedColumn) {
            this.columnSelect.input.nativeElement.focus();
        }
        else if (this.selectedColumn.filters.condition(this.selectedCondition).isUnary) {
            this.conditionSelect.input.nativeElement.focus();
        }
        else {
            this.searchValueInput.nativeElement.focus();
        }
    }
    /**
     * @hidden @internal
     */
    clearSelection() {
        for (const group of this.selectedGroups) {
            group.selected = false;
        }
        this.selectedGroups = [];
        for (const expr of this.selectedExpressions) {
            expr.selected = false;
        }
        this.selectedExpressions = [];
        this.toggleContextMenu();
    }
    /**
     * @hidden @internal
     */
    enterExpressionAdd(expressionItem) {
        this.clearSelection();
        this.exitOperandEdit();
        if (this.addModeExpression) {
            this.addModeExpression.inAddMode = false;
        }
        expressionItem.inAddMode = true;
        this.addModeExpression = expressionItem;
        if (expressionItem.selected) {
            this.toggleExpression(expressionItem);
        }
    }
    onToggleExpression(expressionItem) {
        this.exitOperandEdit();
        this.toggleExpression(expressionItem);
        this.toggleContextMenu();
    }
    toggleExpression(expressionItem) {
        expressionItem.selected = !expressionItem.selected;
        if (expressionItem.selected) {
            this.selectedExpressions.push(expressionItem);
        }
        else {
            const index = this.selectedExpressions.indexOf(expressionItem);
            this.selectedExpressions.splice(index, 1);
            this.deselectParentRecursive(expressionItem);
        }
    }
    /**
     * @hidden @internal
     */
    contextMenuClosed() {
        this.contextualGroup = null;
    }
    toggleContextMenu() {
        const contextualGroup = this.findSingleSelectedGroup();
        if (contextualGroup || this.selectedExpressions.length > 1) {
            this.contextualGroup = contextualGroup;
            if (contextualGroup) {
                this.filteringLogics = [
                    {
                        label: this.grid.resourceStrings.igx_grid_filter_operator_and,
                        selected: contextualGroup.operator === FilteringLogic.And
                    },
                    {
                        label: this.grid.resourceStrings.igx_grid_filter_operator_or,
                        selected: contextualGroup.operator === FilteringLogic.Or
                    }
                ];
            }
        }
        else if (this.contextMenuToggle) {
            this.contextMenuToggle.close();
        }
    }
    findSingleSelectedGroup() {
        for (const group of this.selectedGroups) {
            const containsAllSelectedExpressions = this.selectedExpressions.every(op => this.isInsideGroup(op, group));
            if (containsAllSelectedExpressions) {
                return group;
            }
        }
        return null;
    }
    isInsideGroup(item, group) {
        if (!item) {
            return false;
        }
        if (item.parent === group) {
            return true;
        }
        return this.isInsideGroup(item.parent, group);
    }
    deleteItem(expressionItem) {
        if (!expressionItem.parent) {
            this.rootGroup = null;
            this.currentGroup = null;
            return;
        }
        if (expressionItem === this.currentGroup) {
            this.currentGroup = this.currentGroup.parent;
        }
        const children = expressionItem.parent.children;
        const index = children.indexOf(expressionItem);
        children.splice(index, 1);
        if (!children.length) {
            this.deleteItem(expressionItem.parent);
        }
    }
    /**
     * @hidden @internal
     */
    onKeyDown(eventArgs) {
        eventArgs.stopPropagation();
        const key = eventArgs.key;
        if (!this.contextMenuToggle.collapsed && (key === "Escape" /* ESCAPE */ || key === "Esc" /* ESCAPE_IE */)) {
            this.clearSelection();
        }
        else if (key === "Escape" /* ESCAPE */ || key === "Esc" /* ESCAPE_IE */) {
            this.closeDialog();
        }
    }
    /**
     * @hidden @internal
     */
    createAndGroup() {
        this.createGroup(FilteringLogic.And);
    }
    /**
     * @hidden @internal
     */
    createOrGroup() {
        this.createGroup(FilteringLogic.Or);
    }
    createGroup(operator) {
        const chips = this.chips.toArray();
        const minIndex = this.selectedExpressions.reduce((i, e) => Math.min(i, chips.findIndex(c => c.data === e)), Number.MAX_VALUE);
        const firstExpression = chips[minIndex].data;
        const parent = firstExpression.parent;
        const groupItem = new ExpressionGroupItem(operator, parent);
        const index = parent.children.indexOf(firstExpression);
        parent.children.splice(index, 0, groupItem);
        for (const expr of this.selectedExpressions) {
            this.deleteItem(expr);
            groupItem.children.push(expr);
            expr.parent = groupItem;
        }
        this.clearSelection();
    }
    /**
     * @hidden @internal
     */
    deleteFilters() {
        for (const expr of this.selectedExpressions) {
            this.deleteItem(expr);
        }
        this.clearSelection();
    }
    /**
     * @hidden @internal
     */
    onGroupClick(groupItem) {
        this.toggleGroup(groupItem);
    }
    toggleGroup(groupItem) {
        this.exitOperandEdit();
        if (groupItem.children && groupItem.children.length) {
            this.toggleGroupRecursive(groupItem, !groupItem.selected);
            if (!groupItem.selected) {
                this.deselectParentRecursive(groupItem);
            }
            this.toggleContextMenu();
        }
    }
    toggleGroupRecursive(groupItem, selected) {
        if (groupItem.selected !== selected) {
            groupItem.selected = selected;
            if (groupItem.selected) {
                this.selectedGroups.push(groupItem);
            }
            else {
                const index = this.selectedGroups.indexOf(groupItem);
                this.selectedGroups.splice(index, 1);
            }
        }
        for (const expr of groupItem.children) {
            if (expr instanceof ExpressionGroupItem) {
                this.toggleGroupRecursive(expr, selected);
            }
            else {
                const operandExpression = expr;
                if (operandExpression.selected !== selected) {
                    this.toggleExpression(operandExpression);
                }
            }
        }
    }
    deselectParentRecursive(expressionItem) {
        const parent = expressionItem.parent;
        if (parent) {
            if (parent.selected) {
                parent.selected = false;
                const index = this.selectedGroups.indexOf(parent);
                this.selectedGroups.splice(index, 1);
            }
            this.deselectParentRecursive(parent);
        }
    }
    calculateContextMenuTarget() {
        const containerRect = this.expressionsContainer.nativeElement.getBoundingClientRect();
        const chips = this.chips.filter(c => this.selectedExpressions.indexOf(c.data) !== -1);
        let minTop = chips.reduce((t, c) => Math.min(t, c.elementRef.nativeElement.getBoundingClientRect().top), Number.MAX_VALUE);
        minTop = Math.max(containerRect.top, minTop);
        minTop = Math.min(containerRect.bottom, minTop);
        let maxRight = chips.reduce((r, c) => Math.max(r, c.elementRef.nativeElement.getBoundingClientRect().right), 0);
        maxRight = Math.max(maxRight, containerRect.left);
        maxRight = Math.min(maxRight, containerRect.right);
        this._overlaySettings.target = new Point(maxRight, minTop);
    }
    scrollElementIntoView(target) {
        const container = this.expressionsContainer.nativeElement;
        const targetOffset = target.offsetTop - container.offsetTop;
        const delta = 10;
        if (container.scrollTop + delta > targetOffset) {
            container.scrollTop = targetOffset - delta;
        }
        else if (container.scrollTop + container.clientHeight < targetOffset + target.offsetHeight + delta) {
            container.scrollTop = targetOffset + target.offsetHeight + delta - container.clientHeight;
        }
    }
    /**
     * @hidden @internal
     */
    ungroup() {
        const selectedGroup = this.contextualGroup;
        const parent = selectedGroup.parent;
        if (parent) {
            const index = parent.children.indexOf(selectedGroup);
            parent.children.splice(index, 1, ...selectedGroup.children);
            for (const expr of selectedGroup.children) {
                expr.parent = parent;
            }
        }
        this.clearSelection();
    }
    /**
     * @hidden @internal
     */
    deleteGroup() {
        const selectedGroup = this.contextualGroup;
        const parent = selectedGroup.parent;
        if (parent) {
            const index = parent.children.indexOf(selectedGroup);
            parent.children.splice(index, 1);
        }
        else {
            this.rootGroup = null;
        }
        this.clearSelection();
    }
    /**
     * @hidden @internal
     */
    selectFilteringLogic(event) {
        this.contextualGroup.operator = event.index;
    }
    /**
     * @hidden @internal
     */
    getConditionFriendlyName(name) {
        return this.grid.resourceStrings[`igx_grid_filter_${name}`] || name;
    }
    /**
     * @hidden @internal
     */
    isDate(value) {
        return value instanceof Date;
    }
    /**
     * @hidden @internal
     */
    onExpressionsScrolled() {
        if (!this.contextMenuToggle.collapsed) {
            this.calculateContextMenuTarget();
            this.contextMenuToggle.reposition();
        }
    }
    /**
     * @hidden @internal
     */
    invokeClick(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            eventArgs.currentTarget.click();
        }
    }
    /**
     * @hidden @internal
     */
    onOutletPointerDown(event) {
        // This prevents closing the select's dropdown when clicking the scroll
        event.preventDefault();
    }
    /**
     * @hidden @internal
     */
    getConditionList() {
        return this.selectedColumn ? this.selectedColumn.filters.conditionList() : [];
    }
    /**
     * @hidden @internal
     */
    initialize(grid, overlayService, overlayComponentId) {
        this.inline = false;
        this.grid = grid;
        this._overlayService = overlayService;
        this._overlayComponentId = overlayComponentId;
    }
    /**
     * @hidden @internal
     */
    getFormat(field) {
        return this.grid.getColumnByName(field).pipeArgs.format;
    }
    /**
     * @hidden @internal
     */
    getTimezone(field) {
        return this.grid.getColumnByName(field).pipeArgs.timezone;
    }
    /**
     * @hidden @internal
     */
    setAddButtonFocus() {
        if (this.addRootAndGroupButton) {
            this.addRootAndGroupButton.nativeElement.focus();
        }
        else if (this.addConditionButton) {
            this.addConditionButton.nativeElement.focus();
        }
    }
    init() {
        this.clearSelection();
        this.cancelOperandAdd();
        this.cancelOperandEdit();
        this.rootGroup = this.createExpressionGroupItem(this.grid.advancedFilteringExpressionsTree);
        this.currentGroup = this.rootGroup;
    }
    /**
     * @hidden @internal
     */
    context(expression, afterExpression) {
        return {
            $implicit: expression,
            afterExpression
        };
    }
    /**
     * @hidden @internal
     */
    onClearButtonClick() {
        this.grid.endEdit(false);
        this.grid.advancedFilteringExpressionsTree = null;
    }
    /**
     * @hidden @internal
     */
    closeDialog() {
        if (this._overlayComponentId) {
            this._overlayService.hide(this._overlayComponentId);
        }
        this.grid.navigation.activeNode = this.lastActiveNode;
        if (this.grid.navigation.activeNode && this.grid.navigation.activeNode.row === -1) {
            this.grid.theadRow.nativeElement.focus();
        }
    }
    /**
     * @hidden @internal
     */
    applyChanges() {
        this.grid.endEdit(false);
        this.exitOperandEdit();
        this.grid.advancedFilteringExpressionsTree = this.createExpressionsTreeFromGroupItem(this.rootGroup);
    }
    /**
     * @hidden @internal
     */
    cancelChanges() {
        if (!this._overlayComponentId) {
            this.init();
        }
        this.closeDialog();
    }
    /**
     * @hidden @internal
     */
    onApplyButtonClick() {
        this.applyChanges();
        this.closeDialog();
    }
    /**
     * @hidden @internal
     */
    onChipSelectionEnd() {
        const contextualGroup = this.findSingleSelectedGroup();
        if (contextualGroup || this.selectedExpressions.length > 1) {
            this.contextualGroup = contextualGroup;
            this.calculateContextMenuTarget();
            if (this.contextMenuToggle.collapsed) {
                this.contextMenuToggle.open(this._overlaySettings);
            }
            else {
                this.contextMenuToggle.reposition();
            }
        }
    }
}
IgxAdvancedFilteringDialogComponent.ɵfac = function IgxAdvancedFilteringDialogComponent_Factory(t) { return new (t || IgxAdvancedFilteringDialogComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxAdvancedFilteringDialogComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxAdvancedFilteringDialogComponent, selectors: [["igx-advanced-filtering-dialog"]], viewQuery: function IgxAdvancedFilteringDialogComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c121, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c122, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c123, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c124, true, IgxSelectComponent);
        ɵngcc0.ɵɵviewQuery(_c125, true, IgxSelectComponent);
        ɵngcc0.ɵɵviewQuery(_c126, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c127, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c128, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(IgxToggleDirective, true);
        ɵngcc0.ɵɵviewQuery(_c129, true);
        ɵngcc0.ɵɵstaticViewQuery(_c130, true, IgxOverlayOutletDirective);
        ɵngcc0.ɵɵviewQuery(IgxChipComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editingInputsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.addModeContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.currentGroupButtonsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnSelect = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.conditionSelect = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchValueInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.addRootAndGroupButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.addConditionButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contextMenuToggle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.expressionsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overlayOutlet = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chips = _t);
    } }, hostVars: 2, hostBindings: function IgxAdvancedFilteringDialogComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.display);
    } }, inputs: { grid: "grid" }, decls: 3, vars: 1, consts: [["class", "igx-advanced-filter", "igxDrag", "", 3, "ghost", "dragTolerance", "ngClass", "dragStart", "dragEnd", "dragMove", "keydown", 4, "ngIf"], ["igxOverlayOutlet", "", 1, "igx-advanced-filter__outlet", 3, "pointerdown"], ["overlayOutlet", ""], ["igxDrag", "", 1, "igx-advanced-filter", 3, "ghost", "dragTolerance", "ngClass", "dragStart", "dragEnd", "dragMove", "keydown"], ["igxDragHandle", "", 1, "igx-advanced-filter__header"], [1, "igx-typography__h6", 2, "pointer-events", "none"], [1, "igx-filter-legend"], [1, "igx-filter-legend__item--and"], [1, "igx-filter-legend__item--or"], [1, "igx-advanced-filter__main", 3, "scroll"], ["expressionsContainer", ""], [4, "ngIf"], ["addExpressionsTemplate", ""], ["filterOperandTemplate", ""], ["expressionTreeTemplate", ""], ["igxToggle", "", 1, "igx-filter-contextual-menu", 3, "ngClass", "keydown", "onClosed"], ["igxButton", "icon", 1, "igx-filter-contextual-menu__close-btn", 3, "click"], [1, "igx-excel-filter__secondary-footer"], ["igxButton", "", 3, "displayDensity", "click"], ["igxButton", "raised", 3, "displayDensity", "click"], ["igxButton", "outlined", 3, "displayDensity", "click"], ["addRootAndGroupButton", ""], ["fontSet", "material"], [1, "igx-filter-empty"], [1, "igx-filter-empty__title"], ["igxButton", "outlined", 3, "displayDensity", "disabled", "click"], ["addConditionButton", ""], ["class", "igx-filter-tree__expression-item", 3, "mouseenter", "mouseleave", 4, "ngIf"], ["class", "igx-filter-tree__inputs", 4, "ngIf"], ["class", "igx-filter-tree__buttons", 4, "ngIf"], [1, "igx-filter-tree__expression-item", 3, "mouseenter", "mouseleave"], [3, "data", "displayDensity", "removable", "selected", "keydown", "click", "dblclick", "onRemove", "onSelectionDone"], ["igxPrefix", "", 1, "igx-filter-tree__expression-column"], ["fontSet", "imx-icons", 3, "name"], [1, "igx-filter-tree__expression-condition"], ["igxSuffix", "", 4, "ngIf"], ["class", "igx-filter-tree__expression-actions", 4, "ngIf"], ["igxSuffix", ""], [1, "igx-filter-tree__expression-actions"], ["tabindex", "0", 3, "keydown", "click"], ["tabindex", "0", 3, "keydown", "click", 4, "ngIf"], [1, "igx-filter-tree__inputs"], ["editingInputsContainer", ""], ["type", "box", 3, "displayDensity", "overlaySettings", "placeholder", "ngModel", "ngModelChange"], ["columnSelect", ""], [3, "value", 4, "ngFor", "ngForOf"], ["type", "box", 3, "displayDensity", "overlaySettings", "placeholder", "ngModel", "disabled", "ngModelChange"], ["conditionSelect", ""], ["type", "box", 3, "disabled", "displayDensity", 4, "ngIf"], ["mode", "dropdown", 3, "ngModel", "locale", "outlet", "ngModelChange", 4, "ngIf"], [1, "igx-filter-tree__inputs-actions"], ["igxButton", "icon", 3, "displayDensity", "disabled", "click"], ["igxButton", "icon", 3, "displayDensity", "click"], [3, "value"], [1, "igx-grid__filtering-dropdown-items"], [1, "igx-grid__filtering-dropdown-text"], ["type", "box", 3, "disabled", "displayDensity"], ["igxInput", "", 3, "type", "placeholder", "ngModel", "ngModelChange"], ["searchValueInput", ""], ["mode", "dropdown", 3, "ngModel", "locale", "outlet", "ngModelChange"], ["igxDatePickerTemplate", ""], ["type", "box", 3, "displayDensity"], ["dropDownTarget", ""], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "placeholder", "value", "readonly", "disabled", "keydown", "click"], [1, "igx-filter-tree__buttons"], ["addModeContainer", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-filter-tree"], ["tabindex", "0", 1, "igx-filter-tree__line", 3, "ngClass", "keydown", "click"], [1, "igx-filter-tree__expression"], [4, "ngFor", "ngForOf"], ["currentGroupButtonsContainer", ""], ["igxButton", "outlined", 3, "displayDensity", "disabled", "click", 4, "ngIf"], ["type", "outline", 3, "displayDensity", "multiSelection", "values", "onSelect"], ["fontSet", "imx-icons", "name", "ungroup"], ["igxButton", "outlined", 1, "igx-filter-contextual-menu__delete-btn", 3, "displayDensity", "click"]], template: function IgxAdvancedFilteringDialogComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxAdvancedFilteringDialogComponent_article_0_Template, 35, 24, "article", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵlistener("pointerdown", function IgxAdvancedFilteringDialogComponent_Template_div_pointerdown_1_listener($event) { return ctx.onOutletPointerDown($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.grid);
    } }, directives: [ɵngcc2.NgIf, IgxOverlayOutletDirective, IgxDragDirective, ɵngcc2.NgClass, IgxDragHandleDirective, IgxToggleDirective, IgxButtonDirective, IgxIconComponent, IgxChipComponent, IgxPrefixDirective, IgxSuffixDirective, IgxSelectComponent, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, ɵngcc2.NgForOf, IgxSelectItemComponent, IgxInputGroupComponent, ɵngcc3.DefaultValueAccessor, IgxInputDirective, IgxDatePickerComponent, IgxDatePickerTemplateDirective, ɵngcc2.NgTemplateOutlet, IgxButtonGroupComponent], pipes: [ɵngcc2.DatePipe], encapsulation: 2 });
IgxAdvancedFilteringDialogComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
IgxAdvancedFilteringDialogComponent.propDecorators = {
    columnSelect: [{ type: ViewChild, args: ['columnSelect', { read: IgxSelectComponent },] }],
    conditionSelect: [{ type: ViewChild, args: ['conditionSelect', { read: IgxSelectComponent },] }],
    searchValueInput: [{ type: ViewChild, args: ['searchValueInput', { read: ElementRef },] }],
    addRootAndGroupButton: [{ type: ViewChild, args: ['addRootAndGroupButton', { read: ElementRef },] }],
    addConditionButton: [{ type: ViewChild, args: ['addConditionButton', { read: ElementRef },] }],
    editingInputsContainer: [{ type: ViewChild, args: ['editingInputsContainer', { read: ElementRef },] }],
    addModeContainer: [{ type: ViewChild, args: ['addModeContainer', { read: ElementRef },] }],
    currentGroupButtonsContainer: [{ type: ViewChild, args: ['currentGroupButtonsContainer', { read: ElementRef },] }],
    contextMenuToggle: [{ type: ViewChild, args: [IgxToggleDirective,] }],
    chips: [{ type: ViewChildren, args: [IgxChipComponent,] }],
    expressionsContainer: [{ type: ViewChild, args: ['expressionsContainer',] }],
    overlayOutlet: [{ type: ViewChild, args: ['overlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    display: [{ type: HostBinding, args: ['style.display',] }],
    grid: [{ type: Input }]
};

/**
 * @hidden
 * @internal
 */
class IgxRowSelectorDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
IgxRowSelectorDirective.ɵfac = function IgxRowSelectorDirective_Factory(t) { return new (t || IgxRowSelectorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxRowSelectorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowSelectorDirective, selectors: [["", "igxRowSelector", ""]] });
IgxRowSelectorDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 * @internal
 */
class IgxHeadSelectorDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
IgxHeadSelectorDirective.ɵfac = function IgxHeadSelectorDirective_Factory(t) { return new (t || IgxHeadSelectorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxHeadSelectorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxHeadSelectorDirective, selectors: [["", "igxHeadSelector", ""]] });
IgxHeadSelectorDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * The IgxGridToolbarCustomContentDirective directive is used to mark an 'ng-template' (with
 * the 'igxToolbarCustomContent' selector) defined in the IgxGrid which is used to provide
 * custom content for cener part of the IgxGridToolbar.
 */
class IgxGridToolbarCustomContentDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxGridToolbarCustomContentDirective.ɵfac = function IgxGridToolbarCustomContentDirective_Factory(t) { return new (t || IgxGridToolbarCustomContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxGridToolbarCustomContentDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridToolbarCustomContentDirective, selectors: [["", "igxToolbarCustomContent", ""]] });
IgxGridToolbarCustomContentDirective.ctorParameters = () => [
    { type: TemplateRef }
];

class IgxColumnGroupComponent extends IgxColumnComponent {
    constructor() {
        super(...arguments);
        this.children = new QueryList();
        /**
         * Sets/gets whether the column group is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.columnGroup.searchable;
         * ```
         * ```html
         *  <igx-column-group [searchable] = "false"></igx-column-group>
         * ```
         * @memberof IgxColumnGroupComponent
         */
        this.searchable = true;
        /**
         * @hidden
         */
        this.hiddenChange = new EventEmitter();
    }
    /**
     * Set if the column group is collapsible.
     * Default value is `false`
     * ```html
     *  <igx-column-group [collapsible] = "true"></igx-column-group>
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set collapsible(value) {
        this._collapsible = value;
        this.collapsibleChange.emit(this._collapsible);
        if (this.children && !this.hidden) {
            if (this._collapsible) {
                this.setExpandCollapseState();
            }
            else {
                this.children.forEach(child => child.hidden = false);
            }
        }
    }
    get collapsible() {
        return this._collapsible && this.checkCollapsibleState();
    }
    /**
     * Set whether the group is expanded or collapsed initially.
     * Applied only if the collapsible property is set to `true`
     * Default value is `true`
     * ```html
     *  const state = false
     *  <igx-column-group [(expand)] = "state"></igx-column-group>
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set expanded(value) {
        this._expanded = value;
        this.expandedChange.emit(this._expanded);
        if (!this.collapsible) {
            return;
        }
        if (!this.hidden && this.children) {
            this.setExpandCollapseState();
        }
    }
    get expanded() {
        return this._expanded;
    }
    /**
     * Gets the column group `summaries`.
     * ```typescript
     * let columnGroupSummaries = this.columnGroup.summaries;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column group `summaries`.
     * ```typescript
     * this.columnGroup.summaries = IgxNumberSummaryOperand;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set summaries(classRef) { }
    /**
     * Gets the column group `filters`.
     * ```typescript
     * let columnGroupFilters = this.columnGroup.filters;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column group `filters`.
     * ```typescript
     * this.columnGroup.filters = IgxStringFilteringOperand;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set filters(classRef) { }
    /**
     * Returns if the column group is selectable
     * ```typescript
     * let columnGroupSelectable = this.columnGroup.selectable;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get selectable() {
        return this.children && this.children.some(child => child.selectable);
    }
    set selectable(value) { }
    /**
     * Returns a reference to the body template.
     * ```typescript
     * let bodyTemplate = this.columnGroup.bodyTemplate;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * @hidden
     */
    set bodyTemplate(template) { }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.columnGroup.inlineEditorTemplate;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * @hidden
     */
    set inlineEditorTemplate(template) { }
    /**
     * Gets the column group cells.
     * ```typescript
     * let columnCells = this.columnGroup.cells;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get cells() {
        return [];
    }
    /**
     * Gets whether the column group is hidden.
     * ```typescript
     * let isHidden = this.columnGroup.hidden;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get hidden() {
        return this.allChildren.every(c => c.hidden);
    }
    /**
     * Sets the column group hidden property.
     * ```html
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     *
     * Two-way data binding
     * ```html
     * <igx-column [(hidden)] = "model.columns[0].isHidden"></igx-column>
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set hidden(value) {
        this._hidden = value;
        this.hiddenChange.emit(this._hidden);
        if (this._hidden || !this.collapsible) {
            this.children.forEach(child => child.hidden = this._hidden);
        }
        else {
            this.children.forEach(c => {
                if (c.visibleWhenCollapsed === undefined) {
                    c.hidden = false;
                    return;
                }
                c.hidden = this.expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
            });
        }
    }
    /**
     * Returns if the column group is selected.
     * ```typescript
     * let isSelected = this.columnGroup.selected;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get selected() {
        const selectableChildren = this.allChildren.filter(c => !c.columnGroup && c.selectable && !c.hidden);
        return selectableChildren.length > 0 && selectableChildren.every(c => c.selected);
    }
    /**
     * Select/deselect the column group.
     * ```typescript
     * this.columnGroup.selected = true;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set selected(value) {
        if (this.selectable) {
            this.children.forEach(c => {
                c.selected = value;
            });
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        /*
            @ContentChildren with descendants still returns the `parent`
            component in the query list.
        */
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        if (this.collapseIndicatorTemplate) {
            this.collapsibleIndicatorTemplate = this.collapseIndicatorTemplate.template;
        }
        // currently only ivy fixes the issue, we have to slice only if the first child is group
        if (this.children.first === this) {
            this.children.reset(this.children.toArray().slice(1));
        }
        this.children.forEach(child => {
            child.parent = this;
        });
        if (this.collapsible) {
            this.setExpandCollapseState();
        }
    }
    /**
     * Returns the children columns collection.
     * ```typescript
     * let columns =  this.columnGroup.allChildren;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get allChildren() {
        return flatten(this.children.toArray());
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let isColumnGroup =  this.columnGroup.columnGroup
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get columnGroup() {
        return true;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     * @memberof IgxColumnComponent
     */
    get columnLayout() {
        return false;
    }
    /**
     * Gets the width of the column group.
     * ```typescript
     * let columnGroupWidth = this.columnGroup.width;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get width() {
        let width;
        width = `${this.children.reduce((acc, val) => {
            if (val.hidden) {
                return acc;
            }
            return acc + parseInt(val.calcWidth, 10);
        }, 0)}`;
        return width + 'px';
    }
    set width(val) { }
    /**
     * @hidden
     */
    get applySelectableClass() {
        return this._applySelectableClass;
    }
    /**
     * @hidden
     */
    set applySelectableClass(value) {
        if (this.selectable) {
            this._applySelectableClass = value;
            this.children.forEach(c => {
                c.applySelectableClass = value;
            });
        }
    }
    // constructor(public gridAPI: GridBaseAPIService<IgxGridBaseDirective & IGridDataBindable>, public cdr: ChangeDetectorRef) {
    //     // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
    //     super(gridAPI, cdr);
    // }
    /**
     * @hidden
     * Calculates the number of visible columns, based on indexes of first and last visible columns.
     */
    calcChildren() {
        const visibleChildren = this.allChildren.filter(c => c.visibleIndex > -1);
        const fi = visibleChildren[0].visibleIndex;
        const li = visibleChildren[visibleChildren.length - 1].visibleIndex;
        return li - fi + 1;
    }
}
IgxColumnGroupComponent.ɵfac = function IgxColumnGroupComponent_Factory(t) { return ɵIgxColumnGroupComponent_BaseFactory(t || IgxColumnGroupComponent); };
IgxColumnGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxColumnGroupComponent, selectors: [["igx-column-group"]], contentQueries: function IgxColumnGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxColumnComponent, false, IgxColumnComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, inputs: { searchable: "searchable", collapsible: "collapsible", expanded: "expanded", summaries: "summaries", filters: "filters", hidden: "hidden", collapsibleIndicatorTemplate: "collapsibleIndicatorTemplate" }, outputs: { hiddenChange: "hiddenChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxColumnComponent, useExisting: forwardRef(() => IgxColumnGroupComponent) }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IgxColumnGroupComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
IgxColumnGroupComponent.propDecorators = {
    children: [{ type: ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent },] }],
    collapsible: [{ type: Input }],
    expanded: [{ type: Input }],
    summaries: [{ type: Input }],
    searchable: [{ type: Input }],
    filters: [{ type: Input }],
    collapsibleIndicatorTemplate: [{ type: Input }],
    hidden: [{ type: Input }],
    hiddenChange: [{ type: Output }]
};

const ghostBackgroundClass = 'igx-grid__tr--ghost';
const gridCellClass = 'igx-grid__td';
const rowSelectedClass = 'igx-grid__tr--selected';
const cellSelectedClass = 'igx-grid__td--selected';
const cellActiveClass = 'igx-grid__td--active';
/**
 * @hidden
 */
class IgxRowDragDirective extends IgxDragDirective {
    constructor() {
        super(...arguments);
        this._rowDragStarted = false;
        this.transitionEndEvent = (evt) => {
            if (this.ghostElement) {
                this.ghostElement.removeEventListener('transitionend', this.transitionEndEvent, false);
            }
            this.endDragging();
        };
    }
    get row() {
        return this.data;
    }
    onPointerDown(event) {
        event.preventDefault();
        this._rowDragStarted = false;
        this._removeOnDestroy = false;
        super.onPointerDown(event);
    }
    onPointerMove(event) {
        super.onPointerMove(event);
        if (this._dragStarted && !this._rowDragStarted) {
            this._rowDragStarted = true;
            const args = {
                dragDirective: this,
                dragData: this.row,
                cancel: false,
                owner: this.row.grid
            };
            this.row.grid.onRowDragStart.emit(args);
            if (args.cancel) {
                this.ghostElement.parentNode.removeChild(this.ghostElement);
                this.ghostElement = null;
                this._dragStarted = false;
                this._clicked = false;
                return;
            }
            this.row.grid.dragRowID = this.row.rowID;
            this.row.grid.rowDragging = true;
            this.row.grid.markForCheck();
            this.subscription$ = fromEvent(this.row.grid.document.defaultView, 'keydown').subscribe((ev) => {
                if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                    this._lastDropArea = false;
                    this.onPointerUp(event);
                }
            });
        }
    }
    onPointerUp(event) {
        if (!this._clicked) {
            return;
        }
        const args = {
            dragDirective: this,
            dragData: this.row,
            animation: false,
            owner: this.row.grid
        };
        this.zone.run(() => {
            this.row.grid.onRowDragEnd.emit(args);
        });
        const dropArea = this._lastDropArea;
        super.onPointerUp(event);
        if (!dropArea && this.ghostElement) {
            this.ghostElement.addEventListener('transitionend', this.transitionEndEvent, false);
        }
        else {
            this.endDragging();
        }
    }
    createGhost(pageX, pageY) {
        this.row.grid.endEdit(true);
        this.row.grid.markForCheck();
        this.ghostContext = {
            $implicit: this.row.rowData,
            data: this.row.rowData,
            grid: this.row.grid
        };
        super.createGhost(pageX, pageY, this.row.nativeElement);
        // check if there is an expander icon and create the ghost at the corresponding position
        if (this.isHierarchicalGrid) {
            const row = this.row;
            if (row.expander) {
                const expanderWidth = row.expander.nativeElement.getBoundingClientRect().width;
                this._ghostHostX += expanderWidth;
            }
        }
        const ghost = this.ghostElement;
        const gridRect = this.row.grid.nativeElement.getBoundingClientRect();
        const rowRect = this.row.nativeElement.getBoundingClientRect();
        ghost.style.overflow = 'hidden';
        ghost.style.width = gridRect.width + 'px';
        ghost.style.height = rowRect.height + 'px';
        this.renderer.addClass(ghost, ghostBackgroundClass);
        this.renderer.removeClass(ghost, rowSelectedClass);
        const ghostCells = ghost.getElementsByClassName(gridCellClass);
        for (let index = 0; index < ghostCells.length; index++) {
            this.renderer.removeClass(ghostCells[index], cellSelectedClass);
            this.renderer.removeClass(ghostCells[index], cellActiveClass);
        }
    }
    _unsubscribe() {
        if (this.subscription$ && !this.subscription$.closed) {
            this.subscription$.unsubscribe();
        }
    }
    endDragging() {
        this.onTransitionEnd(null);
        this.row.grid.dragRowID = null;
        this.row.grid.rowDragging = false;
        this.row.grid.markForCheck();
        this._unsubscribe();
    }
    get isHierarchicalGrid() {
        return this.row.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
    }
}
IgxRowDragDirective.ɵfac = function IgxRowDragDirective_Factory(t) { return ɵIgxRowDragDirective_BaseFactory(t || IgxRowDragDirective); };
IgxRowDragDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowDragDirective, selectors: [["", "igxRowDrag", ""]], inputs: { data: ["igxRowDrag", "data"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxRowDragDirective.propDecorators = {
    data: [{ type: Input, args: ['igxRowDrag',] }]
};
/**
 * @hidden
 */
class IgxDragIndicatorIconDirective {
}
IgxDragIndicatorIconDirective.ɵfac = function IgxDragIndicatorIconDirective_Factory(t) { return new (t || IgxDragIndicatorIconDirective)(); };
IgxDragIndicatorIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDragIndicatorIconDirective, selectors: [["", "igxDragIndicatorIcon", ""]] });
/**
 * @hidden
 */
class IgxRowDragGhostDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
IgxRowDragGhostDirective.ɵfac = function IgxRowDragGhostDirective_Factory(t) { return new (t || IgxRowDragGhostDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxRowDragGhostDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowDragGhostDirective, selectors: [["", "igxRowDragGhost", ""]] });
IgxRowDragGhostDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxRowDragModule {
}
IgxRowDragModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxRowDragModule });
IgxRowDragModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxRowDragModule_Factory(t) { return new (t || IgxRowDragModule)(); }, imports: [[]] });

let NEXT_ID$n = 0;
/**
 * **Ignite UI for Angular Snackbar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/snackbar.html)
 *
 * The Ignite UI Snack Bar provides feedback about an operation with a single-line message, which can
 * include a link to an action such as Undo.
 *
 * Example:
 * ```html
 * <button (click)="snackbar.show()">Send message</button>
 * <div>
 *   <igx-snackbar #snackbar message="Message sent">
 *   </igx-snackbar>
 * </div>
 * ```
 */
class IgxSnackbarComponent {
    constructor(zone) {
        this.zone = zone;
        /**
         * Sets/gets the `id` of the snackbar.
         * If not set, the `id` of the first snackbar component  will be `"igx-snackbar-0"`;
         * ```html
         * <igx-snackbar id = "Snackbar1"></igx-snackbar>
         * ```
         * ```typescript
         * let snackbarId = this.snackbar.id;
         * ```
         * @memberof IgxSnackbarComponent
         */
        this.id = `igx-snackbar-${NEXT_ID$n++}`;
        /**
         * Enables/Disables the visibility of the snackbar.
         * If not set, the `isVisible` attribute will have value `false`.
         * ```html
         * <igx-snackbar [isVisible] = "true"></igx-snackbar>
         * ```
         * ```typescript
         * let isVisible =  this.snackbar.isVisible;
         * ```
         */
        this.isVisible = false;
        /**
         * Sets/gets if the snackbar will be automatically hidden after the `displayTime` is over.
         * Default value is `true`.
         * ```html
         * <igx-snackbar [autoHide] = "false"></igx-snackbar>
         * ```
         * ```typescript
         * let autoHide =  this.snackbar.autoHide;
         * ```
         */
        this.autoHide = true;
        /**
         * Sets/gets the duration of time(in milliseconds) in which the snackbar will be visible after it is being shown.
         * Default value is 4000.
         * ```html
         * <igx-snackbar [displayTime] = "2000"></igx-snackbar>
         * ```
         * ```typescript
         * let displayTime = this.snackbar.displayTime;
         * ```
         */
        this.displayTime = 4000;
        /**
         * An event that will be emitted when the action is executed.
         * Provides reference to the `IgxSnackbarComponent` as an argument.
         * ```html
         * <igx-snackbar (onAction) = "onAction($event)"></igx-snackbar>
         * ```
         */
        this.onAction = new EventEmitter();
        /**
         * An event that will be emitted when the snackbar animation starts.
         * Provides reference to the `AnimationEvent` interface as an argument.
         * ```html
         * <igx-snackbar (animationStarted) = "animationStarted($event)"></igx-snackbar>
         * ```
         */
        this.animationStarted = new EventEmitter();
        /**
         * An event that will be emitted when the snackbar animation ends.
         * Provides reference to the `AnimationEvent` interface as an argument.
         * ```html
         * <igx-snackbar (animationDone) = "animationDone($event)"></igx-snackbar>
         * ```
         */
        this.animationDone = new EventEmitter();
        /**
         * @hidden
         * @internal
         */
        this.snackbarMessage = '';
    }
    /**
     * Sets/gets the `message` attribute.
     * ```html
     * <igx-snackbar [message] = "'Snackbar Component'"></igx-snackbar>
     * ```
     * ```typescript
     * let message =  this.snackbar.message;
     * ```
     */
    set message(value) {
        this.snackbarMessage = value;
    }
    get message() {
        return this.snackbarMessage;
    }
    /**
     * Shows the snackbar and hides it after the `displayTime` is over if `autoHide` is set to `true`.
     * ```typescript
     * this.snackbar.show();
     * ```
     */
    show(message) {
        clearTimeout(this.timeoutId);
        if (message !== undefined) {
            this.snackbarMessage = message;
        }
        setTimeout(this.timeoutId);
        this.isVisible = true;
        if (this.autoHide) {
            this.timeoutId = setTimeout(() => {
                this.hide();
            }, this.displayTime);
        }
    }
    /**
     * Hides the snackbar.
     * ```typescript
     * this.snackbar.hide();
     * ```
     */
    hide() {
        this.isVisible = false;
        clearTimeout(this.timeoutId);
    }
    /**
     * @hidden
     */
    triggerAction() {
        this.onAction.emit(this);
    }
    /**
     * @hidden
     * @memberof IgxSnackbarComponent
     */
    snackbarAnimationStarted(evt) {
        if (evt.fromState === 'void') {
            this.animationStarted.emit(evt);
        }
    }
    /**
     * @hidden
     * @memberof IgxSnackbarComponent
     */
    snackbarAnimationDone(evt) {
        if (evt.fromState === 'show') {
            this.animationDone.emit(evt);
        }
    }
}
IgxSnackbarComponent.ɵfac = function IgxSnackbarComponent_Factory(t) { return new (t || IgxSnackbarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxSnackbarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSnackbarComponent, selectors: [["igx-snackbar"]], hostVars: 1, hostBindings: function IgxSnackbarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { id: "id", isVisible: "isVisible", autoHide: "autoHide", displayTime: "displayTime", message: "message", actionText: "actionText" }, outputs: { onAction: "onAction", animationStarted: "animationStarted", animationDone: "animationDone" }, ngContentSelectors: _c2, decls: 1, vars: 1, consts: [["class", "igx-snackbar", 4, "ngIf"], [1, "igx-snackbar"], [1, "igx-snackbar__message"], ["class", "igx-snackbar__button", "igxRipple", "white", 3, "click", 4, "ngIf"], ["igxRipple", "white", 1, "igx-snackbar__button", 3, "click"]], template: function IgxSnackbarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, IgxSnackbarComponent_div_0_Template, 5, 4, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isVisible);
    } }, directives: [ɵngcc2.NgIf], styles: [_c80], data: { animation: [
            trigger('slideInOut', [
                transition('void => *', [
                    useAnimation(slideInBottom, {
                        params: {
                            duration: '.35s',
                            easing: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
                            fromPosition: 'translateY(100%)',
                            toPosition: 'translateY(0)'
                        }
                    })
                ]),
                transition('* => void', [
                    useAnimation(slideOutBottom, {
                        params: {
                            duration: '.2s',
                            easing: 'cubic-bezier(0.4, 0.0, 1, 1)',
                            fromPosition: 'translateY(0)',
                            toOpacity: 1,
                            toPosition: 'translateY(100%)'
                        }
                    })
                ])
            ]),
            trigger('fadeInOut', [
                transition('void => *', [
                    useAnimation(fadeIn, {
                        params: {
                            duration: '.35s',
                            easing: 'ease-out'
                        }
                    })
                ]),
                transition('* => void', [
                    useAnimation(fadeOut, {
                        params: {
                            duration: '.2s',
                            easing: 'ease-out'
                        }
                    })
                ])
            ])
        ] } });
IgxSnackbarComponent.ctorParameters = () => [
    { type: NgZone }
];
IgxSnackbarComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    message: [{ type: Input }],
    isVisible: [{ type: Input }],
    autoHide: [{ type: Input }],
    displayTime: [{ type: Input }],
    actionText: [{ type: Input }],
    onAction: [{ type: Output }],
    animationStarted: [{ type: Output }],
    animationDone: [{ type: Output }]
};
__decorate([
    DeprecateProperty(`'message' property is deprecated.
    You can use place the message in the snackbar content or pass a message parameter to the show method instead.`)
], IgxSnackbarComponent.prototype, "message", null);
/**
 * @hidden
 */
class IgxSnackbarModule {
}
IgxSnackbarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxSnackbarModule });
IgxSnackbarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxSnackbarModule_Factory(t) { return new (t || IgxSnackbarModule)(); }, imports: [[CommonModule]] });

let FAKE_ROW_ID = -1;
const MINIMUM_COLUMN_WIDTH = 136;
const FILTER_ROW_HEIGHT = 50;
// By default row editing overlay outlet is inside grid body so that overlay is hidden below grid header when scrolling.
// In cases when grid has 1-2 rows there isn't enough space in grid body and row editing overlay should be shown above header.
// Default row editing overlay height is higher then row height that is why the case is valid also for row with 2 rows.
// More accurate calculation is not possible, cause row editing overlay is still not shown and we don't know its height,
// but in the same time we need to set row editing overlay outlet before opening the overlay itself.
const MIN_ROW_EDITING_COUNT_THRESHOLD = 2;
const IgxGridTransaction = new InjectionToken('IgxGridTransaction');
class IgxGridBaseDirective extends DisplayDensityBase {
    constructor(selectionService, crudService, colResizingService, gridAPI, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId) {
        super(_displayDensityOptions);
        this.selectionService = selectionService;
        this.crudService = crudService;
        this.colResizingService = colResizingService;
        this.gridAPI = gridAPI;
        this._transactions = _transactions;
        this.elementRef = elementRef;
        this.zone = zone;
        this.document = document;
        this.cdr = cdr;
        this.resolver = resolver;
        this.differs = differs;
        this.viewRef = viewRef;
        this.navigation = navigation;
        this.filteringService = filteringService;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        this.localeId = localeId;
        this._init = true;
        this._cdrRequests = false;
        this._cdrRequestRepaint = false;
        this._resourceStrings = CurrentResourceStrings.GridResStrings;
        this._emptyGridMessage = null;
        this._emptyFilteredGridMessage = null;
        this._isLoading = false;
        this._destroyed = false;
        this.overlayIDs = [];
        this._pinning = { columns: ColumnPinningPosition.Start };
        this._advancedFilteringPositionSettings = {
            verticalDirection: VerticalAlignment.Middle,
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle
        };
        this._advancedFilteringOverlaySettings = {
            closeOnOutsideClick: false,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(this._advancedFilteringPositionSettings),
        };
        /**
         * Gets/Sets the display time for the row adding snackbar notification.
         * @remarks
         * By default it is 6000ms.
         */
        this.snackbarDisplayTime = 6000;
        /**
         * Gets/Sets whether to autogenerate the columns.
         * @remarks
         * The default value is false. When set to true, it will override all columns declared through code or in markup.
         * @example
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.autoGenerate = false;
        /**
         * @hidden @internal
         */
        this.cancelAddMode = false;
        /**
         * Emitted after filtering is performed.
         * @remarks
         * Returns the filtering expressions tree of the column for which filtering was performed.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
         *              (filteringExpressionsTreeChange)="filteringExprTreeChange($event)"></igx-grid>
         * ```
         */
        this.filteringExpressionsTreeChange = new EventEmitter();
        /**
         * Emitted after advanced filtering is performed.
         * @remarks
         * Returns the advanced filtering expressions tree.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
         *           (advancedFilteringExpressionsTreeChange)="advancedFilteringExprTreeChange($event)"></igx-grid>
         * ```
         */
        this.advancedFilteringExpressionsTreeChange = new EventEmitter();
        /**
         * Emitted when grid is scrolled horizontally/vertically.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
         *              (onScroll)="onScroll($event)"></igx-grid>
         * ```
         */
        this.onScroll = new EventEmitter();
        /**
         * Emitted after the current page is changed.
         * @example
         * ```html
         * <igx-grid (pageChange)="onPageChange($event)"></igx-grid>
         * ```
         * ```typescript
         * public onPageChange(page: number) {
         *   this.currentPage = page;
         * }
         * ```
         */
        this.pageChange = new EventEmitter();
        /**
         * Emitted when `perPage` property value of the grid is changed.
         * @example
         * ```html
         * <igx-grid #grid (perPageChange)="onPerPageChange($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * public onPerPageChange(perPage: number) {
         *   this.perPage = perPage;
         * }
         * ```
         */
        this.perPageChange = new EventEmitter();
        /**
         * @hidden
         * @internal
         */
        this.rowDragging = false;
        /**
         * Gets the row ID that is being dragged.
         * @remarks
         * The row ID is either the primaryKey value or the data record instance.
         */
        this.dragRowID = null;
        /**
         * @hidden @interal
         */
        this.addRowParent = null;
        /**
         * @hidden
         * @internal
         */
        this.class = '';
        /**
         * Gets/Sets the styling classes applied to all even `IgxGridRowComponent`s in the grid.
         * @example
         * ```html
         * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-even-class'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.evenRowCSS = 'igx-grid__tr--even';
        /**
         * Gets/Sets the styling classes applied to all odd `IgxGridRowComponent`s in the grid.
         * @example
         * ```html
         * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-odd-class'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.oddRowCSS = 'igx-grid__tr--odd';
        /**
         * Gets/Sets the title to be displayed in the built-in column hiding UI.
         * @example
         * ```html
         * <igx-grid [showToolbar]="true" [columnHiding]="true" columnHidingTitle="Column Hiding"></igx-grid>
         * ```
         */
        this.columnHidingTitle = '';
        /**
         * Gets/Sets the title to be displayed in the UI of the column pinning.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [columnPinning]="'true" [columnPinningTitle]="'Column Hiding'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.columnPinningTitle = '';
        /**
         * Emitted when `IgxGridCellComponent` is clicked.
         * @remarks
         * Returns the `IgxGridCellComponent`.
         * @example
         * ```html
         * <igx-grid #grid (onCellClick)="onCellClick($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onCellClick = new EventEmitter();
        /**
         * Emitted when `IgxGridCellComponent` is selected.
         * @remarks
         *  Returns the `IgxGridCellComponent`.
         * @example
         * ```html
         * <igx-grid #grid (onSelection)="onCellSelect($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         *  Emitted when `IgxGridRowComponent` is selected.
         * @example
         * ```html
         * <igx-grid #grid (onRowSelectionChange)="onCellClickChange($event)" [data]="localData" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowSelectionChange = new EventEmitter();
        /**
         *  Emitted when `IgxColumnComponent` is selected.
         * @example
         * ```html
         * <igx-grid #grid (onColumnSelectionChange)="onColumnSelectionChange($event)" [data]="localData" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onColumnSelectionChange = new EventEmitter();
        /**
         * Emitted when `IgxColumnComponent` is pinned.
         * @remarks
         * The index that the column is inserted at may be changed through the `insertAtIndex` property.
         * @example
         * ```typescript
         * public columnPinning(event) {
         *     if (event.column.field === "Name") {
         *       event.insertAtIndex = 0;
         *     }
         * }
         * ```
         */
        this.onColumnPinning = new EventEmitter();
        /**
         * Emitted when cell enters edit mode.
         * @remarks
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (cellEditEnter)="editStart($event)" [data]="data" [primaryKey]="'ProductID'">
         * </igx-grid>
         * ```
         */
        this.cellEditEnter = new EventEmitter();
        /**
         * Emitted when cell exits edit mode.
         * @example
         * ```html
         * <igx-grid #grid3 (cellEditExit)="editExit($event)" [data]="data" [primaryKey]="'ProductID'">
         * </igx-grid>
         * ```
         */
        this.cellEditExit = new EventEmitter();
        /**
         * Emitted when cell has been edited.
         * @remarks
         * Event is fired after editing is completed, when the cell is exiting edit mode.
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (cellEdit)="editDone($event)" [data]="data" [primaryKey]="'ProductID'">
         * </igx-grid>
         * ```
         */
        this.cellEdit = new EventEmitter();
        /**
         * Emitted after cell has been edited and editing has been committed.
         * @example
         * ```html
         * <igx-grid #grid3 (cellEditDone)="editDone($event)" [data]="data" [primaryKey]="'ProductID'">
         * </igx-grid>
         * ```
         */
        this.cellEditDone = new EventEmitter();
        /**
         * Emitted when a row enters edit mode.
         * @remarks
         * Emitted when [rowEditable]="true".
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (rowEditEnter)="editStart($event)" [primaryKey]="'ProductID'" [rowEditable]="true">
         * </igx-grid>
         * ```
         */
        this.rowEditEnter = new EventEmitter();
        /**
         * Emitted when exiting edit mode for a row.
         * @remarks
         * Emitted when [rowEditable]="true" & `endEdit(true)` is called.
         * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,
         * performing paging operation, column resizing, pinning, moving or hitting `Done`
         * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (rowEdit)="editDone($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
         * </igx-grid>
         * ```
         */
        this.rowEdit = new EventEmitter();
        /**
         * Emitted after exiting edit mode for a row and editing has been committed.
         * @remarks
         * Emitted when [rowEditable]="true" & `endEdit(true)` is called.
         * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,
         * performing paging operation, column resizing, pinning, moving or hitting `Done`
         * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.
         * @example
         * ```html
         * <igx-grid #grid3 (rowEditDone)="editDone($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
         * </igx-grid>
         * ```
         */
        this.rowEditDone = new EventEmitter();
        /**
         * Emitted when row editing is canceled.
         * @remarks
         * Emits when [rowEditable]="true" & `endEdit(false)` is called.
         * Emitted when changing hitting `Esc` key during cell editing and when click on the `Cancel` button
         * in the row editing overlay.
         * @example
         * ```html
         * <igx-grid #grid3 (rowEditExit)="editExit($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
         * </igx-grid>
         * ```
         */
        this.rowEditExit = new EventEmitter();
        /**
         * Emitted when a column is initialized.
         * @remarks
         * Returns the column object.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [onColumnInit]="initColumns($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onColumnInit = new EventEmitter();
        /**
         * Emitted when sorting is performed through the UI.
         * @remarks
         * Returns the sorting expression.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [autoGenerate]="true" (onSortingDone)="sortingDone($event)"></igx-grid>
         * ```
         */
        this.onSortingDone = new EventEmitter();
        /**
         * Emitted when filtering is performed through the UI.
         * @remarks
         * Returns the filtering expressions tree of the column for which filtering was performed.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onFilteringDone)="filteringDone($event)"></igx-grid>
         * ```
         */
        this.onFilteringDone = new EventEmitter();
        /**
         * Emitted when paging is performed.
         * @remarks
         * Returns an object consisting of the previous and next pages.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onPagingDone)="pagingDone($event)"></igx-grid>
         * ```
         */
        this.onPagingDone = new EventEmitter();
        /**
         * Emitted when a row added through the API.
         * @remarks
         * Returns the data for the new `IgxGridRowComponent` object.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onRowAdded)="rowAdded($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowAdded = new EventEmitter();
        /**
         * Emitted when a row is deleted through API.
         * @remarks
         * Returns an `IRowDataEventArgs` object.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onRowDeleted)="rowDeleted($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowDeleted = new EventEmitter();
        /**
         * Emitted when column is resized.
         * @remarks
         * Returns the `IgxColumnComponent` object's old and new width.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onColumnResized)="resizing($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onColumnResized = new EventEmitter();
        /**
         * Emitted when a cell is right clicked.
         * @remarks
         * Returns the `IgxGridCellComponent` object.
         * ```html
         * <igx-grid #grid [data]="localData" (onContextMenu)="contextMenu($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onContextMenu = new EventEmitter();
        /**
         * Emitted when a cell is double clicked.
         * @remarks
         * Returns the `IgxGridCellComponent` object.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onDoubleClick)="dblClick($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onDoubleClick = new EventEmitter();
        /**
         * Emitted when column visibility is changed.
         * @remarks
         * Args: { column: any, newValue: boolean }
         * @example
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnVisibilityChanged)="visibilityChanged($event)"></igx-grid>
         * ```
         */
        this.onColumnVisibilityChanged = new EventEmitter();
        /**
         * Emitted when column moving starts.
         * @remarks
         * Returns the moved `IgxColumnComponent` object.
         * @example
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingStart)="movingStart($event)"></igx-grid>
         * ```
         */
        this.onColumnMovingStart = new EventEmitter();
        /**
         * Emitted during the column moving operation.
         * @remarks
         * Returns the source and target `IgxColumnComponent` objects. This event is cancelable.
         * @example
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMoving)="moving($event)"></igx-grid>
         * ```
         */
        this.onColumnMoving = new EventEmitter();
        /**
         * Emitted when column moving ends.
         * @remarks
         * Returns the source and target `IgxColumnComponent` objects.
         * @example
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingEnd)="movingEnds($event)"></igx-grid>
         * ```
         */
        this.onColumnMovingEnd = new EventEmitter();
        /**
         * Emitted when keydown is triggered over element inside grid's body.
         * @remarks
         * This event is fired only if the key combination is supported in the grid.
         * Return the target type, target object and the original event. This event is cancelable.
         * @example
         * ```html
         *  <igx-grid (onGridKeydown)="customKeydown($event)"></igx-grid>
         * ```
         */
        this.onGridKeydown = new EventEmitter();
        /**
         * Emitted when start dragging a row.
         * @remarks
         * Return the dragged row.
         */
        this.onRowDragStart = new EventEmitter();
        /**
         * Emitted when dropping a row.
         * @remarks
         * Return the dropped row.
         */
        this.onRowDragEnd = new EventEmitter();
        /**
         * Emitted when a copy operation is executed.
         * @remarks
         * Fired only if copy behavior is enabled through the [`clipboardOptions`]{@link IgxGridBaseDirective#clipboardOptions}.
         */
        this.onGridCopy = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.expansionStatesChange = new EventEmitter();
        /**
         * Emitted when the expanded state of a row gets changed.
         * @example
         * ```html
         * <igx-grid [data]="employeeData" (onRowToggle)="rowToggle($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowToggle = new EventEmitter();
        /**
         * Emitted when the pinned state of a row is changed.
         * @example
         * ```html
         * <igx-grid [data]="employeeData" (onRowPinning)="rowPin($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowPinning = new EventEmitter();
        /**
         * Emmited when the active node is changed.
         *
         * @example
         * ```
         * <igx-grid [data]="data" [autoGenerate]="true" (activeNodeChange)="activeNodeChange($event)"></igx-grid>
         * ```
         */
        this.activeNodeChange = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.columnList = new QueryList();
        /**
         * @hidden @internal
         */
        this.tmpOutlets = new QueryList();
        /**
         * The custom template, if any, that should be used when rendering a row expand indicator.
         */
        this.rowExpandedIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a row collapse indicator.
         */
        this.rowCollapsedIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a header expand indicator.
         */
        this.headerExpandIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a header collapse indicator.
         */
        this.headerCollapseIndicatorTemplate = null;
        /**
         * @hidden @internal
         */
        this.tabindex = 0;
        /**
         * @hidden @internal
         */
        this.hostRole = 'grid';
        /**
         * Emitted before sorting is performed.
         * @remarks
         * Returns the sorting expressions.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [autoGenerate]="true" (sortingExpressionsChange)="sortingExprChange($event)"></igx-grid>
         * ```
         */
        this.sortingExpressionsChange = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.columnsWithNoSetWidths = null;
        /* Toolbar related definitions */
        this._showToolbar = false;
        this._exportExcel = false;
        this._exportCsv = false;
        this._toolbarTitle = null;
        this._exportText = null;
        this._exportExcelText = null;
        this._exportCsvText = null;
        this._rowEditable = false;
        this._filteredSortedData = null;
        /**
         * Provides access to the `IgxToolbarComponent`.
         * @example
         * ```typescript
         * const gridToolbar = this.grid.toolbar;
         * ```
         */
        this.toolbar = null;
        this.toolbarHtml = null;
        /**
         * Controls the copy behavior of the grid.
         */
        this.clipboardOptions = {
            /**
             * Enables/disables the copy behavior
             */
            enabled: true,
            /**
             * Include the columns headers in the clipboard output.
             */
            copyHeaders: true,
            /**
             * Apply the columns formatters (if any) on the data in the clipboard output.
             */
            copyFormatters: true,
            /**
             * The separator used for formatting the copy output. Defaults to `\t`.
             */
            separator: '\t'
        };
        /**
         * @hidden @internal
         */
        this.snackbarActionText = this.resourceStrings.igx_grid_snackbar_addrow_actiontext;
        /**
         * @hidden @internal
         */
        this.snackbarLabel = this.resourceStrings.igx_grid_snackbar_addrow_label;
        /**
         * Emitted when an export process is initiated by the user.
         * @example
         * ```typescript
         * toolbarExporting(event: IGridToolbarExportEventArgs){
         *     const toolbarExporting = event;
         * }
         * ```
         */
        this.onToolbarExporting = new EventEmitter();
        /* End of toolbar related definitions */
        /**
         * Emitted when making a range selection.
         * @remarks
         * Range selection can be made either through drag selection or through keyboard selection.
         */
        this.onRangeSelection = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.calcHeight = 0;
        /**
         * @hidden @internal
         */
        this.chipsGoupingExpressions = [];
        /**
         * @hidden @internal
         */
        this.disableTransitions = false;
        /**
         * @hidden @internal
         */
        this.lastSearchInfo = {
            searchText: '',
            caseSensitive: false,
            exactMatch: false,
            activeMatchIndex: 0,
            matchInfoCache: []
        };
        /**
         * @hidden @internal
         */
        this.columnWidthSetByUser = false;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        /**
         * @hidden
         */
        this._perPage = 15;
        /**
         * @hidden
         */
        this._page = 0;
        /**
         * @hidden
         */
        this._paging = false;
        /**
         * @hidden
         */
        this._pagingMode = GridPagingMode.local;
        /**
         * @hidden @internal
         */
        this._totalRecords = -1;
        /**
         * @hidden
         */
        this._hideRowSelectors = false;
        /**
         * @hidden
         */
        this._rowDrag = false;
        /**
         * @hidden
         */
        this._pipeTrigger = 0;
        /**
         * @hidden
         */
        this._filteringPipeTrigger = 0;
        /**
         * @hidden
         */
        this._summaryPipeTrigger = 0;
        /**
         * @hidden
         */
        this._columns = [];
        /**
         * @hidden
         */
        this._pinnedColumns = [];
        /**
         * @hidden
         */
        this._unpinnedColumns = [];
        /**
         * @hidden
         */
        this._filteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
        /**
         * @hidden
         */
        this._sortingExpressions = [];
        /**
         * @hidden
         */
        this._maxLevelHeaderDepth = null;
        /**
         * @hidden
         */
        this._columnHiding = false;
        /**
         * @hidden
         */
        this._columnPinning = false;
        this._pinnedRecordIDs = [];
        this._allowFiltering = false;
        this._allowAdvancedFiltering = false;
        this._filterMode = FilterMode.quickFilter;
        this.observer = new ResizeObserver(() => { });
        this.resizeNotify = new Subject();
        this._hiddenColumnsText = '';
        this._pinnedColumnsText = '';
        this._height = '100%';
        this._width = '100%';
        this._horizontalForOfs = [];
        this._multiRowLayoutRowSize = 1;
        this._expansionStates = new Map();
        this._defaultExpandState = false;
        // Caches
        this._totalWidth = NaN;
        this._pinnedVisible = [];
        this._unpinnedVisible = [];
        this._pinnedWidth = NaN;
        this._unpinnedWidth = NaN;
        this._visibleColumns = [];
        this._columnGroups = false;
        this._autoGeneratedCols = [];
        this._headerFeaturesWidth = NaN;
        this._defaultTargetRecordNumber = 10;
        this._summaryPosition = GridSummaryPosition.bottom;
        this._summaryCalculationMode = GridSummaryCalculationMode.rootAndChildLevels;
        this._showSummaryOnCollapse = false;
        this._cellSelectionMode = GridSelectionMode.multiple;
        this._rowSelectionMode = GridSelectionMode.none;
        this._columnSelectionMode = GridSelectionMode.none;
        this.rowEditPositioningStrategy = new RowEditPositionStrategy({
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom,
            closeAnimation: null
        });
        this.rowEditSettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: false,
            outlet: this.rowOutletDirective,
            positionStrategy: this.rowEditPositioningStrategy
        };
        /**
         * @hidden @internal
         */
        this.paginatorSettings = null;
        this.verticalScrollHandler = (event) => {
            var _a;
            this.verticalScrollContainer.onScroll(event);
            this.disableTransitions = true;
            this.zone.run(() => {
                this.zone.onStable.pipe(first$1()).subscribe(() => {
                    this.verticalScrollContainer.onChunkLoad.emit(this.verticalScrollContainer.state);
                    if (this.rowEditable) {
                        this.changeRowEditingOverlayStateOnScroll(this.rowInEditMode);
                    }
                });
            });
            this.disableTransitions = false;
            this.hideOverlays();
            (_a = this.actionStrip) === null || _a === void 0 ? void 0 : _a.hide();
            const args = {
                direction: 'vertical',
                event: event,
                scrollPosition: this.verticalScrollContainer.scrollPosition
            };
            this.onScroll.emit(args);
        };
        this.horizontalScrollHandler = (event) => {
            const scrollLeft = event.target.scrollLeft;
            this.headerContainer.onHScroll(scrollLeft);
            this._horizontalForOfs.forEach(vfor => vfor.onHScroll(scrollLeft));
            this.cdr.markForCheck();
            this.zone.run(() => {
                this.zone.onStable.pipe(first$1()).subscribe(() => {
                    this.parentVirtDir.onChunkLoad.emit(this.headerContainer.state);
                });
            });
            this.hideOverlays();
            const args = { direction: 'horizontal', event: event, scrollPosition: this.headerContainer.scrollPosition };
            this.onScroll.emit(args);
        };
        /**
         * @hidden @internal
         */
        this.preventContainerScroll = (evt) => {
            if (evt.target.scrollTop !== 0) {
                this.verticalScrollContainer.addScrollTop(evt.target.scrollTop);
                evt.target.scrollTop = 0;
            }
            if (evt.target.scrollLeft !== 0) {
                this.headerContainer.scrollPosition += evt.target.scrollLeft;
                evt.target.scrollLeft = 0;
            }
        };
        /**
         * @hidden
         */
        this.rowEditingWheelHandler = (event) => {
            if (event.deltaY > 0) {
                this.verticalScrollContainer.scrollNext();
            }
            else {
                this.verticalScrollContainer.scrollPrev();
            }
        };
        this.locale = this.locale || this.localeId;
        this.datePipe = new DatePipe(this.locale);
        this.decimalPipe = new DecimalPipe(this.locale);
        this.cdr.detach();
    }
    /**
     * @hidden @internal
     */
    get scrollSize() {
        return this.verticalScrollContainer.getScrollNativeSize();
    }
    /**
     * Gets/Sets the resource strings.
     * @remarks
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    get resourceStrings() {
        return this._resourceStrings;
    }
    /**
     * Gets/Sets the filtering logic of the `IgxGridComponent`.
     * @remarks
     * The default is AND.
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true" [filteringLogic]="filtering"></igx-grid>
     * ```
     */
    get filteringLogic() {
        return this._filteringExpressionsTree.operator;
    }
    set filteringLogic(value) {
        this._filteringExpressionsTree.operator = value;
    }
    /**
     * Gets/Sets the filtering state.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(filteringExpressionsTree)]="model.filteringExpressions"></igx-grid>
     * ```
     * @remarks
     * Supports two-way binding.
     */
    get filteringExpressionsTree() {
        return this._filteringExpressionsTree;
    }
    set filteringExpressionsTree(value) {
        if (value && value instanceof FilteringExpressionsTree) {
            const val = value;
            for (let index = 0; index < val.filteringOperands.length; index++) {
                if (!(val.filteringOperands[index] instanceof FilteringExpressionsTree)) {
                    const newExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, val.filteringOperands[index].fieldName);
                    newExpressionsTree.filteringOperands.push(val.filteringOperands[index]);
                    val.filteringOperands[index] = newExpressionsTree;
                }
            }
            value.type = FilteringExpressionsTreeType.Regular;
            this._filteringExpressionsTree = value;
            this._filteringPipeTrigger++;
            this.filteringExpressionsTreeChange.emit(this._filteringExpressionsTree);
            if (this.filteringService.isFilteringExpressionsTreeEmpty(this._filteringExpressionsTree) &&
                !this.advancedFilteringExpressionsTree) {
                this.filteredData = null;
            }
            this.filteringService.refreshExpressions();
            this.selectionService.clearHeaderCBState();
            this.summaryService.clearSummaryCache();
            this.notifyChanges();
        }
    }
    /**
     * Gets/Sets the advanced filtering state.
     * @example
     * ```typescript
     * let advancedFilteringExpressionsTree = this.grid.advancedFilteringExpressionsTree;
     * this.grid.advancedFilteringExpressionsTree = logic;
     * ```
     */
    get advancedFilteringExpressionsTree() {
        return this._advancedFilteringExpressionsTree;
    }
    set advancedFilteringExpressionsTree(value) {
        if (value && value instanceof FilteringExpressionsTree) {
            value.type = FilteringExpressionsTreeType.Advanced;
            this._advancedFilteringExpressionsTree = value;
            this._filteringPipeTrigger++;
        }
        else {
            this._advancedFilteringExpressionsTree = null;
        }
        this.advancedFilteringExpressionsTreeChange.emit(this._advancedFilteringExpressionsTree);
        if (this.filteringService.isFilteringExpressionsTreeEmpty(this._advancedFilteringExpressionsTree) &&
            !this.advancedFilteringExpressionsTree) {
            this.filteredData = null;
        }
        this.selectionService.clearHeaderCBState();
        this.summaryService.clearSummaryCache();
        this.notifyChanges();
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.onFilteringDone.emit(this._advancedFilteringExpressionsTree));
    }
    /**
     * Gets/Sets the locale.
     * @remarks
     * If not set, returns browser's language.
     */
    get locale() {
        return this._locale;
    }
    set locale(value) {
        if (value !== this._locale) {
            this._locale = value;
            this.summaryService.clearSummaryCache();
            this._pipeTrigger++;
            this.notifyChanges();
        }
    }
    get pagingMode() {
        return this._pagingMode;
    }
    set pagingMode(val) {
        this._pagingMode = val;
        this._pipeTrigger++;
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets whether the paging feature is enabled.
     * @remarks
     * The default state is disabled (false).
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [paging]="true"></igx-grid>
     * ```
     */
    get paging() {
        return this._paging;
    }
    set paging(value) {
        this._paging = value;
        this._pipeTrigger++;
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets the current page index.
     * @example
     * ```html
     *  <igx-grid #grid [data]="Data" [paging]="true" [(page)]="model.page" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * Supports two-way binding.
     */
    get page() {
        return this._page;
    }
    set page(val) {
        if (val === this._page || val < 0 || val > this.totalPages - 1) {
            return;
        }
        this.selectionService.clear(true);
        this.onPagingDone.emit({ previous: this._page, current: val });
        this._page = val;
        this.pageChange.emit(this._page);
        this.navigateTo(0);
        this.notifyChanges();
    }
    /**
     * Gets/Sets the number of visible items per page.
     * @remarks
     * The default is 15.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [paging]="true" [(perPage)]="model.perPage" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get perPage() {
        return this._perPage;
    }
    set perPage(val) {
        if (val < 0) {
            return;
        }
        this.selectionService.clear(true);
        this._perPage = val;
        this.perPageChange.emit(this._perPage);
        this.page = 0;
        this.endEdit(true);
        this.notifyChanges();
    }
    /**
     * Gets/Sets whether the column hiding UI is enabled.
     * @remarks
     * By default it is disabled (false). In order for the UI to work, you need to enable the toolbar as shown in the example below.
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true" [showToolbar]="true" [columnHiding]="true"></igx-grid>
     * ```
     */
    get columnHiding() {
        return this._columnHiding;
    }
    set columnHiding(value) {
        if (this._columnHiding !== value) {
            this._columnHiding = value;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets if the row selectors are hidden.
     * @remarks
     *  By default row selectors are shown
     */
    get hideRowSelectors() {
        return this._hideRowSelectors;
    }
    set hideRowSelectors(value) {
        this._hideRowSelectors = value;
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets whether rows can be moved.
     * @example
     * ```html
     * <igx-grid #grid [rowDraggable]="true"></igx-grid>
     * ```
     */
    get rowDraggable() {
        return this._rowDrag && this.hasVisibleColumns;
    }
    set rowDraggable(val) {
        this._rowDrag = val;
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets whether the rows are editable.
     * @remarks
     * By default it is set to false.
     * @example
     * ```html
     * <igx-grid #grid [showToolbar]="true" [rowEditable]="true" [primaryKey]="'ProductID'" [columnHiding]="true"></igx-grid>
     * ```
     */
    get rowEditable() {
        return this._rowEditable;
    }
    set rowEditable(val) {
        if (!this._init) {
            this.refreshGridState();
        }
        this._rowEditable = val;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the height.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get height() {
        return this._height;
    }
    set height(value) {
        if (this._height !== value) {
            this._height = value;
            this.nativeElement.style.height = value;
            this.notifyChanges(true);
        }
    }
    /**
     * @hidden @internal
     */
    get hostWidth() {
        return this._width || this._hostWidth;
    }
    /**
     * Gets/Sets the width of the grid.
     * @example
     * ```typescript
     * let gridWidth = this.grid.width;
     * ```
     */
    get width() {
        return this._width;
    }
    set width(value) {
        if (this._width !== value) {
            this._width = value;
            this.nativeElement.style.width = value;
            this.notifyChanges(true);
        }
    }
    /**
     * Gets the width of the header.
     * @example
     * ```html
     * let gridHeaderWidth = this.grid.headerWidth;
     * ```
     */
    get headerWidth() {
        return parseInt(this.width, 10) - 17;
    }
    /**
     * Gets/Sets the row height.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [showToolbar]="true" [rowHeight]="100" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get rowHeight() {
        return this._rowHeight ? this._rowHeight : this.defaultRowHeight;
    }
    set rowHeight(value) {
        this._rowHeight = parseInt(value, 10);
    }
    /**
     * Gets/Sets the default width of the columns.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [showToolbar]="true" [columnWidth]="100" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get columnWidth() {
        return this._columnWidth;
    }
    set columnWidth(value) {
        this._columnWidth = value;
        this.columnWidthSetByUser = true;
        this.notifyChanges(true);
    }
    /**
     * Get/Sets the message displayed when there are no records.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    set emptyGridMessage(value) {
        this._emptyGridMessage = value;
    }
    get emptyGridMessage() {
        return this._emptyGridMessage || this.resourceStrings.igx_grid_emptyGrid_message;
    }
    /**
     * Gets/Sets whether the grid is going to show a loading indicator.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [isLoading]="true" [autoGenerate]="true"></igx-grid>
     * ```
     */
    set isLoading(value) {
        if (this._isLoading !== value) {
            this._isLoading = value;
            this.evaluateLoadingState();
        }
        Promise.resolve().then(() => {
            // wait for the current detection cycle to end before triggering a new one.
            this.notifyChanges();
        });
    }
    get isLoading() {
        return this._isLoading;
    }
    /**
     * Gets/Sets the message displayed when there are no records and the grid is filtered.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    set emptyFilteredGridMessage(value) {
        this._emptyFilteredGridMessage = value;
    }
    get emptyFilteredGridMessage() {
        return this._emptyFilteredGridMessage || this.resourceStrings.igx_grid_emptyFilteredGrid_message;
    }
    /**
     * Gets/Sets the initial pinning configuration.
     * @remarks
     * Allows to apply pinning the columns to the start or the end.
     * Note that pinning to both sides at a time is not allowed.
     * @example
     * ```html
     * <igx-grid [pinning]="pinningConfig"></igx-grid>
     * ```
     */
    get pinning() {
        return this._pinning;
    }
    set pinning(value) {
        if (value !== this._pinning) {
            this.resetCaches();
        }
        this._pinning = value;
    }
    /**
     * Gets/Sets if the built-in column pinning UI should be shown in the toolbar.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [columnPinning]="'true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get columnPinning() {
        return this._columnPinning;
    }
    set columnPinning(value) {
        if (this._columnPinning !== value) {
            this._columnPinning = value;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets if the filtering is enabled.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [allowFiltering]="true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get allowFiltering() {
        return this._allowFiltering;
    }
    set allowFiltering(value) {
        if (this._allowFiltering !== value) {
            this._allowFiltering = value;
            this.filteringService.registerSVGIcons();
            if (!this._init) {
                this.calcGridHeadRow();
            }
            this.filteringService.isFilterRowVisible = false;
            this.filteringService.filteredColumn = null;
            this.notifyChanges(true);
        }
    }
    /**
     * Gets/Sets a value indicating whether the advanced filtering is enabled.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [allowAdvancedFiltering]="true" [showToolbar]="true" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get allowAdvancedFiltering() {
        return this._allowAdvancedFiltering;
    }
    set allowAdvancedFiltering(value) {
        if (this._allowAdvancedFiltering !== value) {
            this._allowAdvancedFiltering = value;
            this.filteringService.registerSVGIcons();
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets the filter mode.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [filterMode]="'quickFilter'" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default it's set to FilterMode.quickFilter.
     */
    get filterMode() {
        return this._filterMode;
    }
    set filterMode(value) {
        this._filterMode = value;
        if (this.filteringService.isFilterRowVisible) {
            this.filteringRow.close();
        }
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets the summary position.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" summaryPosition="top" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default it is bottom.
     */
    get summaryPosition() {
        return this._summaryPosition;
    }
    set summaryPosition(value) {
        this._summaryPosition = value;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the summary calculation mode.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" summaryCalculationMode="rootLevelOnly" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default it is rootAndChildLevels which means the summaries are calculated for the root level and each child level.
     */
    get summaryCalculationMode() {
        return this._summaryCalculationMode;
    }
    set summaryCalculationMode(value) {
        this._summaryCalculationMode = value;
        if (!this._init) {
            this.endEdit(true);
            this.summaryService.resetSummaryHeight();
            this.notifyChanges(true);
        }
    }
    /**
     * Controls whether the summary row is visible when groupBy/parent row is collapsed.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [showSummaryOnCollapse]="true" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default showSummaryOnCollapse is set to 'false' which means that the summary row is not visible
     * when the groupBy/parent row is collapsed.
     */
    get showSummaryOnCollapse() {
        return this._showSummaryOnCollapse;
    }
    set showSummaryOnCollapse(value) {
        this._showSummaryOnCollapse = value;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the filtering strategy of the grid.
     * @example
     * ```html
     *  <igx-grid #grid [data]="localData" [filterStrategy]="filterStrategy"></igx-grid>
     * ```
     */
    get filterStrategy() {
        return this._filteringStrategy;
    }
    set filterStrategy(classRef) {
        this._filteringStrategy = classRef;
    }
    /**
     * Gets/Sets the sorting strategy of the grid.
     * @example
     * ```html
     *  <igx-grid #grid [data]="localData" [sortStrategy]="sortStrategy"></igx-grid>
     * ```
     */
    get sortStrategy() {
        return this._sortingStrategy;
    }
    set sortStrategy(value) {
        this._sortingStrategy = value;
    }
    /**
     * Gets/Sets the current selection state.
     * @remarks
     * Represents the selected rows' IDs (primary key or rowData)
     * @example
     * ```html
     * <igx-grid [data]="localData" primaryKey="ID" rowSelection="multiple" [selectedRows]="[0, 1, 2]"><igx-grid>
     * ```
     */
    set selectedRows(rowIDs) {
        rowIDs.length > 0
            ? this.selectRows(rowIDs, true)
            : this.deselectAllRows();
    }
    get selectedRows() {
        return this.selectionService.getSelectedRows();
    }
    /**
     * @hidden @internal
     */
    get excelStyleFilteringComponent() {
        return this.excelStyleFilteringComponents.first;
    }
    /**
     * A list of all `IgxGridHeaderGroupComponent`.
     * @example
     * ```typescript
     * const headerGroupsList = this.grid.headerGroupsList;
     * ```
     */
    get headerGroupsList() {
        return this.headerGroups ? flatten(this.headerGroups.toArray()) : [];
    }
    /**
     * A list of all `IgxGridHeaderComponent`.
     * @example
     * ```typescript
     * const headers = this.grid.headerCellList;
     * ```
     */
    get headerCellList() {
        return this.headerGroupsList.map((headerGroup) => headerGroup.headerCell).filter((headerCell) => headerCell);
    }
    /**
     * A list of all `IgxGridFilteringCellComponent`.
     * @example
     * ```typescript
     * const filterCells = this.grid.filterCellList;
     * ```
     */
    get filterCellList() {
        return this.headerGroupsList.map((headerGroup) => headerGroup.filterCell).filter((filterCell) => filterCell);
    }
    /**
     * @hidden @internal
     */
    get summariesRowList() {
        const res = new QueryList();
        if (!this._summaryRowList) {
            return res;
        }
        const sumList = this._summaryRowList.filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        });
        res.reset(sumList);
        return res;
    }
    /**
     * A list of `IgxGridRowComponent`.
     * @example
     * ```typescript
     * const rowList = this.grid.rowList;
     * ```
     */
    get rowList() {
        const res = new QueryList();
        if (!this._rowList) {
            return res;
        }
        const rList = this._rowList
            .filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        })
            .sort((a, b) => {
            return a.index - b.index;
        });
        res.reset(rList);
        return res;
    }
    /**
     * A list of currently rendered `IgxGridRowComponent`'s.
     * @example
     * ```typescript
     * const dataList = this.grid.dataRowList;
     * ```
     */
    get dataRowList() {
        const res = new QueryList();
        if (!this._dataRowList) {
            return res;
        }
        const rList = this._dataRowList.filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        }).sort((a, b) => {
            return a.index - b.index;
        });
        res.reset(rList);
        return res;
    }
    /**
     * Returns the template which will be used by the toolbar to show custom content.
     * @example
     * ```typescript
     * let customContentTemplate = this.grid.toolbarCustomContentTemplate;
     * ```
     */
    get toolbarCustomContentTemplate() {
        return this.toolbarCustomContentTemplates.first;
    }
    /**
     * @hidden
     * @internal
     */
    get headSelectorTemplate() {
        if (this.headSelectorsTemplates && this.headSelectorsTemplates.first) {
            return this.headSelectorsTemplates.first.templateRef;
        }
        return null;
    }
    /**
     * @hidden
     * @internal
     */
    get isPinningToStart() {
        return this.pinning.columns !== ColumnPinningPosition.End;
    }
    /**
     * @hidden
     * @internal
     */
    get isRowPinningToTop() {
        return this.pinning.rows !== RowPinningPosition.Bottom;
    }
    /**
     * @hidden
     * @internal
     */
    get rowSelectorTemplate() {
        if (this.rowSelectorsTemplates && this.rowSelectorsTemplates.first) {
            return this.rowSelectorsTemplates.first.templateRef;
        }
        return null;
    }
    /**
     * @hidden @internal
     */
    get rowOutletDirective() {
        return this.rowEditingOutletDirective;
    }
    /**
     * @hidden @internal
     */
    get parentRowOutletDirective() {
        return this.outlet;
    }
    /**
     * @hidden @internal
     */
    get rowEditContainer() {
        return this.rowEditCustom ? this.rowEditCustom : this.defaultRowEditTemplate;
    }
    /**
     * The custom template, if any, that should be used when rendering the row drag indicator icon
     */
    get dragIndicatorIconTemplate() {
        return this._customDragIndicatorIconTemplate || this.dragIndicatorIconTemplates.first;
    }
    set dragIndicatorIconTemplate(val) {
        this._customDragIndicatorIconTemplate = val;
    }
    /**
     * @hidden @internal
     */
    get rowInEditMode() {
        const editRowState = this.crudService.row;
        return editRowState !== null ? this.rowList.find(e => e.rowID === editRowState.id) : null;
    }
    /**
     * @hidden @internal
     */
    get firstEditableColumnIndex() {
        const index = this.visibleColumns.filter(col => col.editable)
            .map(c => c.visibleIndex).sort((a, b) => a - b);
        return index.length ? index[0] : null;
    }
    /**
     * @hidden @internal
     */
    get lastEditableColumnIndex() {
        const index = this.visibleColumns.filter(col => col.editable)
            .map(c => c.visibleIndex).sort((a, b) => a > b ? -1 : 1);
        return index.length ? index[0] : null;
    }
    /**
     * @hidden @internal
     * TODO: Nav service logic doesn't handle 0 results from this querylist
     */
    get rowEditTabs() {
        return this.rowEditTabsCUSTOM.length ? this.rowEditTabsCUSTOM : this.rowEditTabsDEFAULT;
    }
    get activeDescendant() {
        const activeElem = this.navigation.activeNode;
        if (activeElem) {
            return !this.navigation.isDataRow(activeElem.row, true) ? this.id + '_' + activeElem.row :
                this.id + '_' + activeElem.row + '_' + activeElem.column;
        }
        return null;
    }
    /**
     * @hidden @internal
     */
    get hostClass() {
        const classes = [this.getComponentDensityClass('igx-grid')];
        // The custom classes should be at the end.
        classes.push(this.class);
        return classes.join(' ');
    }
    get bannerClass() {
        const position = this.rowEditPositioningStrategy.isTop ? 'igx-banner__border-top' : 'igx-banner__border-bottom';
        return `${this.getComponentDensityClass('igx-banner')} ${position}`;
    }
    /**
     * @hidden @internal
     */
    get pipeTrigger() {
        return this._pipeTrigger;
    }
    /**
     * @hidden @internal
     */
    get filteringPipeTrigger() {
        return this._filteringPipeTrigger;
    }
    /**
     * @hidden @internal
     */
    get summaryPipeTrigger() {
        return this._summaryPipeTrigger;
    }
    /**
     * Gets/Sets the sorting state.
     * @remarks
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(sortingExpressions)]="model.sortingExpressions"></igx-grid>
     * ```
     */
    get sortingExpressions() {
        return this._sortingExpressions;
    }
    set sortingExpressions(value) {
        this._sortingExpressions = cloneArray(value);
        this.sortingExpressionsChange.emit(this._sortingExpressions);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    get maxLevelHeaderDepth() {
        if (this._maxLevelHeaderDepth === null) {
            this._maxLevelHeaderDepth = this.hasColumnLayouts ?
                this.columnList.reduce((acc, col) => Math.max(acc, col.rowStart), 0) :
                this.columnList.reduce((acc, col) => Math.max(acc, col.level), 0);
        }
        return this._maxLevelHeaderDepth;
    }
    /**
     * Gets the number of hidden columns.
     * @example
     * ```typescript
     * const hiddenCol = this.grid.hiddenColumnsCount;
     * ``
     */
    get hiddenColumnsCount() {
        return this.columnList.filter((col) => col.columnGroup === false && col.hidden === true).length;
    }
    /**
     * Gets/Sets the text to be displayed inside the toggle button.
     * @remarks
     * Used for the built-in column hiding UI of the`IgxColumnComponent`.
     * @example
     * ```html
     * <igx-grid [columnHiding]="true" [showToolbar]="true" [hiddenColumnsText]="'Hidden Columns'"></igx-grid>
     * ```
     */
    get hiddenColumnsText() {
        return this._hiddenColumnsText;
    }
    set hiddenColumnsText(value) {
        this._hiddenColumnsText = value;
    }
    /**
     * Gets/Sets the text to be displayed inside the toggle button.
     * @remarks
     * Used for the built-in column pinning UI of the`IgxColumnComponent`.
     * @example
     * ```html
     * <igx-grid [pinnedColumnsText]="'PinnedCols Text" [data]="data" [width]="'100%'" [height]="'500px'"></igx-grid>
     * ```
     */
    get pinnedColumnsText() {
        return this._pinnedColumnsText;
    }
    set pinnedColumnsText(value) {
        this._pinnedColumnsText = value;
    }
    /**
     * Get transactions service for the grid.
     */
    get transactions() {
        return this._transactions;
    }
    /**
     * @hidden @internal
     */
    get currentRowState() {
        return this._currentRowState;
    }
    /**
     * Gets/Sets whether the toolbar is shown.
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" ></igx-grid>
     * ```
     */
    get showToolbar() {
        return this._showToolbar;
    }
    set showToolbar(newValue) {
        if (this._showToolbar !== newValue) {
            this._showToolbar = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets the toolbar's title.
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [toolbarTitle]="'My Grid'"></igx-grid>
     * ```
     */
    get toolbarTitle() {
        return this._toolbarTitle;
    }
    set toolbarTitle(newValue) {
        if (this._toolbarTitle !== newValue) {
            this._toolbarTitle = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets whether exporting to MS Excel is enabled or disabled.
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportExcel]="true"></igx-grid>
     * ```
     */
    get exportExcel() {
        return this.getExportExcel();
    }
    set exportExcel(newValue) {
        if (this._exportExcel !== newValue) {
            this._exportExcel = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets whether the option for exporting to CSV is enabled or disabled.
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportCsv]="true"></igx-grid>
     * ```
     */
    get exportCsv() {
        return this.getExportCsv();
    }
    set exportCsv(newValue) {
        if (this._exportCsv !== newValue) {
            this._exportCsv = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets the textual content for the main export button.
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
     * ```
     */
    get exportText() {
        return this._exportText;
    }
    set exportText(newValue) {
        if (this._exportText !== newValue) {
            this._exportText = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets the textual content for the MS Excel export button.
     * ```html
     * <igx-grid [exportExcelText]="'My Excel Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
     * ```
     */
    get exportExcelText() {
        return this._exportExcelText;
    }
    set exportExcelText(newValue) {
        if (this._exportExcelText !== newValue) {
            this._exportExcelText = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets the textual content for the CSV export button.
     * @example
     * ```html
     * <igx-grid [exportCsvText]="'My Csv Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportExcel]="true"></igx-grid>
     * ```
     */
    get exportCsvText() {
        return this._exportCsvText;
    }
    set exportCsvText(newValue) {
        if (this._exportCsvText !== newValue) {
            this._exportCsvText = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets cell selection mode.
     * @remarks
     * By default the cell selection mode is multiple
     * @param selectionMode: GridSelectionMode
     */
    get cellSelection() {
        return this._cellSelectionMode;
    }
    set cellSelection(selectionMode) {
        this._cellSelectionMode = selectionMode;
        if (this.gridAPI.grid) {
            this.selectionService.clear(true);
            this.notifyChanges();
        }
    }
    /**
     * Gets/Sets row selection mode
     * @remarks
     * By default the row selection mode is none
     * @param selectionMode: GridSelectionMode
     */
    get rowSelection() {
        return this._rowSelectionMode;
    }
    set rowSelection(selectionMode) {
        this._rowSelectionMode = selectionMode;
        if (this.gridAPI.grid && this.columnList) {
            this.selectionService.clearAllSelectedRows();
            this.notifyChanges(true);
        }
    }
    /**
     * Gets/Sets column selection mode
     * @remarks
     * By default the row selection mode is none
     * @param selectionMode: GridSelectionMode
     */
    get columnSelection() {
        return this._columnSelectionMode;
    }
    set columnSelection(selectionMode) {
        this._columnSelectionMode = selectionMode;
        if (this.gridAPI.grid) {
            this.selectionService.clearAllSelectedColumns();
            this.notifyChanges(true);
        }
    }
    /**
     * @hidden
     * @internal
     */
    get headerFeaturesWidth() {
        return this._headerFeaturesWidth;
    }
    /**
     * @hidden
     * @internal
     */
    isDetailRecord(rec) {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    isGroupByRecord(rec) {
        return false;
    }
    /**
     * @hidden @internal
     */
    isGhostRecord(record) {
        return record.ghostRecord !== undefined;
    }
    /**
     * @hidden @internal
     */
    isAddRowRecord(record) {
        return record.addRow !== undefined;
    }
    /**
     * @hidden
     * Returns the row index of a row that takes into account the full view data like pinning.
     */
    getDataViewIndex(rowIndex, pinned) {
        if (pinned && !this.isRowPinningToTop) {
            rowIndex = rowIndex + this.unpinnedDataView.length;
        }
        else if (!pinned && this.isRowPinningToTop) {
            rowIndex = rowIndex + this.pinnedDataView.length;
        }
        return rowIndex;
    }
    /**
     * @hidden
     * @internal
     */
    get hasDetails() {
        return false;
    }
    /**
     * Returns the state of the grid virtualization.
     * @remarks
     * Includes the start index and how many records are rendered.
     * @example
     * ```typescript
     * const gridVirtState = this.grid1.virtualizationState;
     * ```
     */
    get virtualizationState() {
        return this.verticalScrollContainer.state;
    }
    /**
     * @hidden
     */
    set virtualizationState(state) {
        this.verticalScrollContainer.state = state;
    }
    /**
     * @hidden
     * @internal
     */
    hideOverlays() {
        this.overlayIDs.forEach(overlayID => {
            this.overlayService.hide(overlayID);
            this.overlayService.onClosed.pipe(filter(o => o.id === overlayID), takeUntil(this.destroy$)).subscribe(() => {
                this.nativeElement.focus();
            });
        });
    }
    /**
     * Returns whether the record is pinned or not.
     *
     * @param rowIndex Index of the record in the `dataView` collection.
     *
     * @hidden
     * @internal
     */
    isRecordPinnedByViewIndex(rowIndex) {
        return this.hasPinnedRecords && (this.isRowPinningToTop && rowIndex < this.pinnedDataView.length) ||
            (!this.isRowPinningToTop && rowIndex >= this.unpinnedDataView.length);
    }
    /**
     * Returns whether the record is pinned or not.
     *
     * @param rowIndex Index of the record in the `filteredSortedData` collection.
     */
    isRecordPinnedByIndex(rowIndex) {
        return this.hasPinnedRecords && (this.isRowPinningToTop && rowIndex < this._filteredSortedPinnedData.length) ||
            (!this.isRowPinningToTop && rowIndex >= this._filteredSortedUnpinnedData.length);
    }
    /**
     * @hidden
     * @internal
     */
    isRecordPinned(rec) {
        return this.getInitialPinnedIndex(rec) !== -1;
    }
    /**
     * @hidden
     * @internal
     * Returns the record index in order of pinning by the user. Does not consider sorting/filtering.
     */
    getInitialPinnedIndex(rec) {
        const id = this.gridAPI.get_row_id(rec);
        return this._pinnedRecordIDs.indexOf(id);
    }
    /**
     * @hidden
     * @internal
     */
    get hasPinnedRecords() {
        return this._pinnedRecordIDs.length > 0;
    }
    /**
     * @hidden
     * @internal
     */
    get pinnedRecordsCount() {
        return this._pinnedRecordIDs.length;
    }
    _setupServices() {
        this.gridAPI.grid = this;
        this.crudService.grid = this;
        this.selectionService.grid = this;
        this.navigation.grid = this;
        this.filteringService.grid = this;
        this.summaryService.grid = this;
    }
    _setupListeners() {
        const destructor = takeUntil(this.destroy$);
        fromEvent(this.nativeElement, 'focusout').pipe(filter(() => !!this.navigation.activeNode), destructor).subscribe((event) => {
            if (this.selectionService.dragMode && isIE()) {
                return;
            }
            if (!this.crudService.cell &&
                !!this.navigation.activeNode &&
                ((event.target === this.tbody.nativeElement && this.navigation.activeNode.row >= 0 &&
                    this.navigation.activeNode.row < this.dataView.length)
                    || (event.target === this.theadRow.nativeElement && this.navigation.activeNode.row === -1)
                    || (event.target === this.tfoot.nativeElement && this.navigation.activeNode.row === this.dataView.length)) &&
                !(this.rowEditable && this.crudService.rowEditingBlocked && this.rowInEditMode)) {
                this.navigation.activeNode = {};
                this.notifyChanges();
            }
        });
        this.onRowAdded.pipe(destructor).subscribe(args => this.refreshGridState(args));
        this.onRowDeleted.pipe(destructor).subscribe(args => {
            this.summaryService.deleteOperation = true;
            this.summaryService.clearSummaryCache(args);
        });
        this.transactions.onStateUpdate.pipe(destructor).subscribe((event) => {
            let actions = [];
            if (event.origin === TransactionEventOrigin.REDO) {
                actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.DELETE) : [];
            }
            else if (event.origin === TransactionEventOrigin.UNDO) {
                actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.ADD) : [];
            }
            if (actions.length > 0) {
                for (const action of actions) {
                    if (this.selectionService.isRowSelected(action.transaction.id)) {
                        this.selectionService.deselectRow(action.transaction.id);
                    }
                }
            }
            this.selectionService.clearHeaderCBState();
            this.summaryService.clearSummaryCache();
            this._pipeTrigger++;
            this.notifyChanges();
        });
        this.resizeNotify.pipe(destructor, filter(() => !this._init), throttleTime(100, undefined, { leading: true, trailing: true }))
            .subscribe(() => {
            this.zone.run(() => {
                this.notifyChanges(true);
            });
        });
        this.onPagingDone.pipe(destructor).subscribe(() => {
            this.endEdit(true);
            this.selectionService.clear(true);
        });
        this.onColumnMoving.pipe(destructor).subscribe(() => this.endEdit(true));
        this.onColumnResized.pipe(destructor).subscribe(() => this.endEdit(true));
        this.overlayService.onOpening.pipe(destructor).subscribe((event) => {
            if (this._advancedFilteringOverlayId === event.id) {
                const instance = event.componentRef.instance;
                if (instance) {
                    instance.initialize(this, this.overlayService, event.id);
                }
            }
        });
        this.overlayService.onOpened.pipe(destructor).subscribe((event) => {
            var _a, _b;
            const overlaySettings = (_a = this.overlayService.getOverlayById(event.id)) === null || _a === void 0 ? void 0 : _a.settings;
            // do not hide the advanced filtering overlay on scroll
            if (this._advancedFilteringOverlayId === event.id) {
                const instance = event.componentRef.instance;
                if (instance) {
                    instance.lastActiveNode = this.navigation.activeNode;
                    instance.setAddButtonFocus();
                }
                return;
            }
            // do not hide the overlay if it's attached to a row
            if (((_b = this.rowEditingOverlay) === null || _b === void 0 ? void 0 : _b.overlayId) === event.id) {
                return;
            }
            if ((overlaySettings === null || overlaySettings === void 0 ? void 0 : overlaySettings.outlet) === this.outlet && this.overlayIDs.indexOf(event.id) === -1) {
                this.overlayIDs.push(event.id);
            }
        });
        this.overlayService.onClosed.pipe(destructor, filter(() => !this._init)).subscribe((event) => {
            if (this._advancedFilteringOverlayId === event.id) {
                this._advancedFilteringOverlayId = null;
                return;
            }
            const ind = this.overlayIDs.indexOf(event.id);
            if (ind !== -1) {
                this.overlayIDs.splice(ind, 1);
            }
        });
        this.verticalScrollContainer.onDataChanging.pipe(destructor, filter(() => !this._init)).subscribe(($event) => {
            const shouldRecalcSize = this.isPercentHeight &&
                (!this.calcHeight || this.calcHeight === this.getDataBasedBodyHeight() ||
                    this.calcHeight === this.renderedRowHeight * this._defaultTargetRecordNumber);
            if (shouldRecalcSize) {
                this.calculateGridHeight();
                $event.containerSize = this.calcHeight;
            }
            this.evaluateLoadingState();
        });
        this.verticalScrollContainer.onScrollbarVisibilityChanged.pipe(destructor, filter(() => !this._init)).subscribe(() => {
            // called to recalc all widths that may have changes as a result of
            // the vert. scrollbar showing/hiding
            this.notifyChanges(true);
        });
        this.verticalScrollContainer.onContentSizeChange.pipe(destructor, filter(() => !this._init)).subscribe(($event) => {
            this.calculateGridSizes(false);
        });
        this.onDensityChanged.pipe(destructor).subscribe(() => {
            this.endEdit(true);
            this.summaryService.summaryHeight = 0;
            this.notifyChanges(true);
        });
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this._setupServices();
        this._setupListeners();
        this.rowListDiffer = this.differs.find([]).create(null);
        this.columnListDiffer = this.differs.find([]).create(null);
        this.calcWidth = this.width && this.width.indexOf('%') === -1 ? parseInt(this.width, 10) : 0;
        this.shouldGenerate = this.autoGenerate;
    }
    setupColumns() {
        if (this.autoGenerate) {
            this.autogenerateColumns();
        }
        this.initColumns(this.columnList, (col) => this.onColumnInit.emit(col));
        this.columnListDiffer.diff(this.columnList);
        this.columnList.changes
            .pipe(takeUntil(this.destroy$))
            .subscribe((change) => {
            this.onColumnsChanged(change);
        });
    }
    /**
     * @hidden
     * @internal
     */
    resetColumnsCaches() {
        this.columnList.forEach(column => column.resetCaches());
    }
    /**
     * @hidden @internal
     */
    generateRowID() {
        const primaryColumn = this.columnList.find(col => col.field === this.primaryKey);
        const idType = this.data.length ? typeof (this.data[0][this.primaryKey]) : primaryColumn ? primaryColumn.dataType : 'string';
        return idType === 'string' ? v4() : FAKE_ROW_ID--;
    }
    /**
     * @hidden
     * @internal
     */
    resetForOfCache() {
        const firstVirtRow = this.dataRowList.first;
        if (firstVirtRow) {
            if (this._cdrRequests) {
                firstVirtRow.virtDirRow.cdr.detectChanges();
            }
            firstVirtRow.virtDirRow.assumeMaster();
        }
    }
    /**
     * @hidden
     * @internal
     */
    setFilteredData(data, pinned) {
        if (this.hasPinnedRecords && pinned) {
            this._filteredPinnedData = data || [];
            const filteredUnpinned = this._filteredUnpinnedData || [];
            const filteredData = [...this._filteredPinnedData, ...filteredUnpinned];
            this.filteredData = filteredData.length > 0 ? filteredData : this._filteredUnpinnedData;
        }
        else if (this.hasPinnedRecords && !pinned) {
            this._filteredUnpinnedData = data;
        }
        else {
            this.filteredData = data;
        }
    }
    /**
     * @hidden
     * @internal
     */
    resetColumnCollections() {
        this._visibleColumns.length = 0;
        this._pinnedVisible.length = 0;
        this._unpinnedVisible.length = 0;
    }
    /**
     * @hidden
     * @internal
     */
    resetCachedWidths() {
        this._unpinnedWidth = NaN;
        this._pinnedWidth = NaN;
        this._totalWidth = NaN;
    }
    /**
     * @hidden
     * @internal
     */
    resetCaches(recalcFeatureWidth = true) {
        if (recalcFeatureWidth) {
            this._headerFeaturesWidth = NaN;
        }
        this.resetForOfCache();
        this.resetColumnsCaches();
        this.resetColumnCollections();
        this.resetCachedWidths();
        this.hasVisibleColumns = undefined;
        this._columnGroups = this.columnList.some(col => col.columnGroup);
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.setupColumns();
        if (this.actionStrip) {
            this.actionStrip.menuOverlaySettings.outlet = this.outlet;
        }
    }
    /**
     * @hidden
     * @internal
     */
    setFilteredSortedData(data, pinned) {
        data = data || [];
        if (this.pinnedRecordsCount > 0 && pinned) {
            this._filteredSortedPinnedData = data;
            this.pinnedRecords = data;
            this._filteredSortedData = this.isRowPinningToTop ? [...this._filteredSortedPinnedData, ...this._filteredSortedUnpinnedData] :
                [...this._filteredSortedUnpinnedData, ...this._filteredSortedPinnedData];
            this.refreshSearch(true, false);
        }
        else if (this.pinnedRecordsCount > 0 && !pinned) {
            this._filteredSortedUnpinnedData = data;
        }
        else {
            this._filteredSortedData = data;
            this.refreshSearch(true, false);
        }
    }
    /**
     * @hidden @internal
     */
    _setupRowObservers() {
        const elementFilter = (item) => this.isDefined(item.nativeElement.parentElement);
        const extractForOfs = pipe(map((collection) => collection.filter(elementFilter).map(item => item.virtDirRow)));
        const rowListObserver = extractForOfs(this._dataRowList.changes);
        const summaryRowObserver = extractForOfs(this._summaryRowList.changes);
        const resetHorizontalForOfs = () => {
            this._horizontalForOfs = [
                ...this._dataRowList.filter(elementFilter).map(item => item.virtDirRow),
                ...this._summaryRowList.filter(elementFilter).map(item => item.virtDirRow)
            ];
        };
        rowListObserver.pipe(takeUntil(this.destroy$)).subscribe(resetHorizontalForOfs);
        summaryRowObserver.pipe(takeUntil(this.destroy$)).subscribe(resetHorizontalForOfs);
        resetHorizontalForOfs();
    }
    /**
     * @hidden @internal
     */
    _zoneBegoneListeners() {
        this.zone.runOutsideAngular(() => {
            this.verticalScrollContainer.getScroll().addEventListener('scroll', this.verticalScrollHandler);
            this.headerContainer.getScroll().addEventListener('scroll', this.horizontalScrollHandler);
            this.observer = new ResizeObserver(() => this.resizeNotify.next());
            this.observer.observe(this.nativeElement);
        });
    }
    /**
     * @hidden
     * @internal
     */
    hideActionStrip(event) {
        var _a;
        (_a = this.actionStrip) === null || _a === void 0 ? void 0 : _a.hide();
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        var _a;
        this.initPinning();
        this.calculateGridSizes();
        this._init = false;
        this.cdr.reattach();
        this._setupRowObservers();
        this._zoneBegoneListeners();
        this.paginatorSettings = { outlet: this.outlet };
        const vertScrDC = this.verticalScrollContainer.displayContainer;
        vertScrDC.addEventListener('scroll', this.preventContainerScroll);
        this._pinnedRowList.changes
            .pipe(takeUntil(this.destroy$))
            .subscribe((change) => {
            this.onPinnedRowsChanged(change);
        });
        (_a = this.addRowSnackbar) === null || _a === void 0 ? void 0 : _a.onAction.subscribe(() => {
            const rec = this.filteredSortedData[this.lastAddedRowIndex];
            this.scrollTo(rec, 0);
            this.addRowSnackbar.hide();
        });
    }
    /**
     * @hidden @internal
     */
    notifyChanges(repaint = false) {
        this._cdrRequests = true;
        this._cdrRequestRepaint = repaint;
        this.cdr.markForCheck();
    }
    resetNotifyChanges() {
        this._cdrRequestRepaint = false;
        this._cdrRequests = false;
    }
    /**
     * @hidden @internal
     */
    ngDoCheck() {
        super.ngDoCheck();
        if (this._init) {
            return;
        }
        if (this._cdrRequestRepaint) {
            this.resetNotifyChanges();
            this.calculateGridSizes();
            this.refreshSearch(true);
            return;
        }
        if (this._cdrRequests) {
            this.resetNotifyChanges();
            this.cdr.detectChanges();
        }
    }
    /**
     * @hidden
     * @internal
     */
    getDragGhostCustomTemplate() {
        if (this.dragGhostCustomTemplates && this.dragGhostCustomTemplates.first) {
            return this.dragGhostCustomTemplates.first;
        }
        return null;
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.tmpOutlets.forEach((tmplOutlet) => {
            tmplOutlet.cleanCache();
        });
        this.destroy$.next(true);
        this.destroy$.complete();
        this._destroyed = true;
        if (this._advancedFilteringOverlayId) {
            this.overlayService.hide(this._advancedFilteringOverlayId);
        }
        this.zone.runOutsideAngular(() => {
            var _a, _b, _c, _d, _e;
            this.observer.disconnect();
            (_b = (_a = this.verticalScrollContainer) === null || _a === void 0 ? void 0 : _a.getScroll()) === null || _b === void 0 ? void 0 : _b.removeEventListener('scroll', this.verticalScrollHandler);
            (_d = (_c = this.headerContainer) === null || _c === void 0 ? void 0 : _c.getScroll()) === null || _d === void 0 ? void 0 : _d.removeEventListener('scroll', this.horizontalScrollHandler);
            const vertScrDC = (_e = this.verticalScrollContainer) === null || _e === void 0 ? void 0 : _e.displayContainer;
            vertScrDC === null || vertScrDC === void 0 ? void 0 : vertScrDC.removeEventListener('scroll', this.preventContainerScroll);
        });
    }
    /**
     * Toggles the specified column's visibility.
     * @example
     * ```typescript
     * this.grid1.toggleColumnVisibility({
     *       column: this.grid1.columns[0],
     *       newValue: true
     * });
     * ```
     */
    toggleColumnVisibility(args) {
        const col = args.column ? this.columnList.find((c) => c === args.column) : undefined;
        if (!col) {
            return;
        }
        col.hidden = args.newValue;
        this.onColumnVisibilityChanged.emit(args);
    }
    /**
     * Gets/Sets a list of key-value pairs [row ID, expansion state].
     * @remarks
     * Includes only states that differ from the default one.
     * Supports two-way binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="data" [(expansionStates)]="model.expansionStates">
     * </igx-grid>
     * ```
     */
    get expansionStates() {
        return this._expansionStates;
    }
    set expansionStates(value) {
        this._expansionStates = new Map(value);
        this.expansionStatesChange.emit(this._expansionStates);
        this.notifyChanges(true);
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
    }
    /**
     * Expands all rows.
     * @example
     * ```typescript
     * this.grid.expandAll();
     * ```
     */
    expandAll() {
        this._defaultExpandState = true;
        this.expansionStates = new Map();
    }
    /**
     * Collapses all rows.
     * @example
     * ```typescript
     * this.grid.collapseAll();
     * ```
     */
    collapseAll() {
        this._defaultExpandState = false;
        this.expansionStates = new Map();
    }
    /**
     * Expands the row by its id.
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.expandRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     */
    expandRow(rowID) {
        this.gridAPI.set_row_expansion_state(rowID, true);
    }
    /**
     * Collapses the row by its id.
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.collapseRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     */
    collapseRow(rowID) {
        this.gridAPI.set_row_expansion_state(rowID, false);
    }
    /**
     * Toggles the row by its id.
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.toggleRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     */
    toggleRow(rowID) {
        const rec = this.gridAPI.get_rec_by_id(rowID);
        const state = this.gridAPI.get_row_expansion_state(rec);
        this.gridAPI.set_row_expansion_state(rowID, !state);
    }
    /**
     * @hidden
     * @internal
     */
    getDefaultExpandState(rec) {
        return this._defaultExpandState;
    }
    /**
     * Gets the native element.
     * @example
     * ```typescript
     * const nativeEl = this.grid.nativeElement.
     * ```
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * Gets/Sets the outlet used to attach the grid's overlays to.
     * @remark
     * If set, returns the outlet defined outside the grid. Otherwise returns the grid's internal outlet directive.
     */
    get outlet() {
        return this.resolveOutlet();
    }
    set outlet(val) {
        this._userOutletDirective = val;
    }
    resolveOutlet() {
        return this._userOutletDirective ? this._userOutletDirective : this._outletDirective;
    }
    /**
     * Gets the default row height.
     * @example
     * ```typescript
     * const rowHeigh = this.grid.defaultRowHeight;
     * ```
     */
    get defaultRowHeight() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 40;
            case DisplayDensity.compact:
                return 32;
            default:
                return 50;
        }
    }
    /**
     * @hidden @internal
     */
    get defaultSummaryHeight() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 30;
            case DisplayDensity.compact:
                return 24;
            default:
                return 36;
        }
    }
    /**
     * Returns the `IgxGridHeaderGroupComponent`'s minimum allowed width.
     * @remarks
     * Used internally for restricting header group component width.
     * The values below depend on the header cell default right/left padding values.
     */
    get defaultHeaderGroupMinWidth() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 32;
            case DisplayDensity.compact:
                return 24;
            default:
                return 48;
        }
    }
    /**
     * @hidden @internal
     */
    paginatorClassName() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 'igx-paginator--cosy';
            case DisplayDensity.compact:
                return 'igx-paginator--compact';
            default:
                return 'igx-paginator';
        }
    }
    /**
     * Gets the current width of the container for the pinned `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth;
     * ```
     */
    get pinnedWidth() {
        if (!isNaN(this._pinnedWidth)) {
            return this._pinnedWidth;
        }
        this._pinnedWidth = this.getPinnedWidth();
        return this._pinnedWidth;
    }
    /**
     * Gets the current width of the container for the unpinned `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const unpinnedWidth = this.grid.getUnpinnedWidth;
     * ```
     */
    get unpinnedWidth() {
        if (!isNaN(this._unpinnedWidth)) {
            return this._unpinnedWidth;
        }
        this._unpinnedWidth = this.getUnpinnedWidth();
        return this._unpinnedWidth;
    }
    /**
     * @hidden @internal
     */
    get isHorizontalScrollHidden() {
        const diff = this.unpinnedWidth - this.totalWidth;
        return this.width === null || diff >= 0;
    }
    /**
     * @hidden @internal
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     */
    featureColumnsWidth(expander) {
        if (Number.isNaN(this._headerFeaturesWidth)) {
            const rowSelectArea = this.headerSelectorContainer ?
                this.headerSelectorContainer.nativeElement.getBoundingClientRect().width : 0;
            const rowDragArea = this.rowDraggable && this.headerDragContainer ?
                this.headerDragContainer.nativeElement.getBoundingClientRect().width : 0;
            const groupableArea = this.headerGroupContainer ?
                this.headerGroupContainer.nativeElement.getBoundingClientRect().width : 0;
            const expanderWidth = expander ? expander.nativeElement.getBoundingClientRect().width : 0;
            this._headerFeaturesWidth = rowSelectArea + rowDragArea + groupableArea + expanderWidth;
        }
        return this._headerFeaturesWidth;
    }
    /**
     * @hidden @internal
     */
    get summariesMargin() {
        return this.featureColumnsWidth();
    }
    /**
     * Gets an array of `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const colums = this.grid.columns.
     * ```
     */
    get columns() {
        return this._columns;
    }
    /**
     * Gets an array of the pinned `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const pinnedColumns = this.grid.pinnedColumns.
     * ```
     */
    get pinnedColumns() {
        if (this._pinnedVisible.length) {
            return this._pinnedVisible;
        }
        this._pinnedVisible = this._pinnedColumns.filter(col => !col.hidden);
        return this._pinnedVisible;
    }
    /**
     * Gets an array of the pinned `IgxRowComponent`s.
     * @example
     * ```typescript
     * const pinnedRow = this.grid.pinnedRows;
     * ```
     */
    get pinnedRows() {
        return this._pinnedRowList.toArray().sort((a, b) => {
            return a.index - b.index;
        });
    }
    /**
     * Gets an array of unpinned `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const unpinnedColumns = this.grid.unpinnedColumns.
     * ```
     */
    get unpinnedColumns() {
        if (this._unpinnedVisible.length) {
            return this._unpinnedVisible;
        }
        this._unpinnedVisible = this._unpinnedColumns.filter((col) => !col.hidden);
        return this._unpinnedVisible;
    }
    /**
     * Gets the `width` to be set on `IgxGridHeaderGroupComponent`.
     */
    getHeaderGroupWidth(column) {
        if (this.hasColumnLayouts) {
            return '';
        }
        const colWidth = parseFloat(column.calcWidth);
        const minWidth = this.defaultHeaderGroupMinWidth;
        if (colWidth < minWidth) {
            return minWidth + 'px';
        }
        return colWidth + 'px';
    }
    /**
     * Returns the `IgxColumnComponent` by field name.
     * @example
     * ```typescript
     * const myCol = this.grid1.getColumnByName("ID");
     * ```
     * @param name
     */
    getColumnByName(name) {
        return this.columnList.find((col) => col.field === name);
    }
    getColumnByVisibleIndex(index) {
        return this.visibleColumns.find((col) => !col.columnGroup && !col.columnLayout &&
            col.visibleIndex === index);
    }
    /**
     * Returns the `IgxRowDirective` by index.
     * @example
     * ```typescript
     * const myRow = this.grid1.getRowByIndex(1);
     * ```
     * @param index
     */
    getRowByIndex(index) {
        return this.gridAPI.get_row_by_index(index);
    }
    /**
     * Returns `IgxGridRowComponent` object by the specified primary key .
     * @remarks
     * Requires that the `primaryKey` property is set.
     * @example
     * ```typescript
     * const myRow = this.grid1.getRowByKey("cell5");
     * ```
     * @param keyValue
     */
    getRowByKey(keyValue) {
        return this.gridAPI.get_row_by_key(keyValue);
    }
    /**
     * Returns an array of visible `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const visibleColumns = this.grid.visibleColumns.
     * ```
     */
    get visibleColumns() {
        if (this._visibleColumns.length) {
            return this._visibleColumns;
        }
        this._visibleColumns = this.columnList.filter(c => !c.hidden);
        return this._visibleColumns;
    }
    /**
     * Returns the `IgxGridCellComponent` that matches the conditions.
     * @example
     * ```typescript
     * const myCell = this.grid1.getCellByColumn(2,"UnitPrice");
     * ```
     * @param rowIndex
     * @param columnField
     */
    getCellByColumn(rowIndex, columnField) {
        const columnId = this.columnList.map((column) => column.field).indexOf(columnField);
        if (columnId !== -1) {
            return this.gridAPI.get_cell_by_index(rowIndex, columnId);
        }
    }
    getCellByColumnVisibleIndex(rowIndex, index) {
        return this.gridAPI.get_cell_by_visible_index(rowIndex, index);
    }
    /**
     * Returns an `IgxGridCellComponent` object by the specified primary key and column field.
     * @remarks
     * Requires that the primaryKey property is set.
     * @example
     * ```typescript
     * grid.getCellByKey(1, 'index');
     * ```
     * @param rowSelector match any rowID
     * @param columnField
     */
    getCellByKey(rowSelector, columnField) {
        return this.gridAPI.get_cell_by_key(rowSelector, columnField);
    }
    /**
     * Gets the total number of pages.
     * @example
     * ```typescript
     * const totalPages = this.grid.totalPages;
     * ```
     */
    get totalPages() {
        if (this.pagingState) {
            return this.pagingState.metadata.countPages;
        }
        return this._totalRecords >= 0 ? Math.ceil(this._totalRecords / this.perPage) : -1;
    }
    /**
     * Gets if the current page is the first page.
     * @example
     * ```typescript
     * const firstPage = this.grid.isFirstPage;
     * ```
     */
    get isFirstPage() {
        return this.page === 0;
    }
    /**
     * Goes to the next page, if the grid is not already at the last page.
     * @example
     * ```typescript
     * this.grid1.nextPage();
     * ```
     */
    nextPage() {
        if (!this.isLastPage) {
            this.page += 1;
        }
    }
    /**
     * Goes to the previous page, if the grid is not already at the first page.
     * @example
     * ```typescript
     * this.grid1.previousPage();
     * ```
     */
    previousPage() {
        if (!this.isFirstPage) {
            this.page -= 1;
        }
    }
    /**
     * Returns the total number of records.
     * @remarks
     * Only functions when paging is enabled.
     * @example
     * ```typescript
     * const totalRecords = this.grid.totalRecords;
     * ```
     */
    get totalRecords() {
        var _a;
        return this._totalRecords >= 0 ? this._totalRecords : (_a = this.pagingState) === null || _a === void 0 ? void 0 : _a.metadata.countRecords;
    }
    set totalRecords(total) {
        if (total >= 0) {
            this._totalRecords = total;
            this._pipeTrigger++;
            this.notifyChanges();
        }
    }
    /**
     * Returns if the current page is the last page.
     * @example
     * ```typescript
     * const lastPage = this.grid.isLastPage;
     * ```
     */
    get isLastPage() {
        return this.page + 1 >= this.totalPages;
    }
    /**
     * Returns the total width of the `IgxGridComponent`.
     * @example
     * ```typescript
     * const gridWidth = this.grid.totalWidth;
     * ```
     */
    get totalWidth() {
        if (!isNaN(this._totalWidth)) {
            return this._totalWidth;
        }
        // Take only top level columns
        const cols = this.visibleColumns.filter(col => col.level === 0 && !col.pinned);
        let totalWidth = 0;
        let i = 0;
        for (i; i < cols.length; i++) {
            totalWidth += parseInt(cols[i].calcWidth, 10) || 0;
        }
        this._totalWidth = totalWidth;
        return totalWidth;
    }
    /**
     * @hidden
     * @internal
     */
    get showRowSelectors() {
        return this.isRowSelectable && this.hasVisibleColumns && !this.hideRowSelectors;
    }
    /**
     * @hidden
     * @internal
     */
    get showAddButton() {
        return this.rowEditable && this.dataView.length === 0 && this.columns.length > 0;
    }
    /**
     * @hidden
     * @internal
     */
    get showDragIcons() {
        return this.rowDraggable && this.columns.length > this.hiddenColumnsCount;
    }
    /**
     * Reorder columns in the main columnList and _columns collections.
     * @hidden
     */
    _moveColumns(from, to, pos) {
        const list = this.columnList.toArray();
        this._reorderColumns(from, to, pos, list);
        const newList = this._resetColumnList(list);
        this.columnList.reset(newList);
        this.columnList.notifyOnChanges();
        this._columns = this.columnList.toArray();
    }
    /**
     * @hidden
     */
    _resetColumnList(list) {
        if (!list) {
            list = this.columnList.toArray();
        }
        let newList = [];
        list.filter(c => c.level === 0).forEach(p => {
            newList.push(p);
            if (p.columnGroup) {
                newList = newList.concat(p.allChildren);
            }
        });
        return newList;
    }
    /**
     * Reorders columns inside the passed column collection.
     * When reordering column group collection, the collection is not flattened.
     * In all other cases, the columns collection is flattened, this is why adittional calculations on the dropIndex are done.
     * @hidden
     */
    _reorderColumns(from, to, position, columnCollection, inGroup = false) {
        const fromIndex = columnCollection.indexOf(from);
        const childColumnsCount = inGroup ? 1 : from.allChildren.length + 1;
        columnCollection.splice(fromIndex, childColumnsCount);
        let dropIndex = columnCollection.indexOf(to);
        if (position === DropPosition.AfterDropTarget) {
            dropIndex++;
            if (!inGroup && to.columnGroup) {
                dropIndex += to.allChildren.length;
            }
        }
        columnCollection.splice(dropIndex, 0, from);
    }
    /**
     * Reorder column group collection.
     * @hidden
     */
    _moveChildColumns(parent, from, to, pos) {
        const buffer = parent.children.toArray();
        this._reorderColumns(from, to, pos, buffer, true);
        parent.children.reset(buffer);
    }
    /**
     * Places a column before or after the specified target column.
     * @example
     * ```typescript
     * grid.moveColumn(column, target);
     * ```
     */
    moveColumn(column, target, pos = DropPosition.AfterDropTarget) {
        if (column === target || (column.level !== target.level) ||
            (column.topLevelParent !== target.topLevelParent)) {
            return;
        }
        this.endEdit(true);
        if (column.level) {
            this._moveChildColumns(column.parent, column, target, pos);
        }
        if (target.pinned && !column.pinned) {
            column.pin();
        }
        if (!target.pinned && column.pinned) {
            column.unpin();
        }
        if (target.pinned && column.pinned) {
            this._reorderColumns(column, target, pos, this._pinnedColumns);
        }
        if (!target.pinned && !column.pinned) {
            this._reorderColumns(column, target, pos, this._unpinnedColumns);
        }
        this._moveColumns(column, target, pos);
        this._columnsReordered(column, target);
    }
    /**
     * Notiy changes, reset cache and populateVisibleIndexes.
     * @hidden
     */
    _columnsReordered(column, target) {
        this.notifyChanges();
        if (this.hasColumnLayouts) {
            this.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        // after reordering is done reset cached column collections.
        this.resetColumnCollections();
        column.resetCaches();
        const args = {
            source: column,
            target: target
        };
        this.onColumnMovingEnd.emit(args);
    }
    /**
     * Goes to the desired page index.
     * @example
     * ```typescript
     * this.grid1.paginate(1);
     * ```
     * @param val
     */
    paginate(val) {
        if (val < 0 || val > this.totalPages - 1) {
            return;
        }
        this.page = val;
    }
    /**
     * Manually marks the `IgxGridComponent` for change detection.
     * @example
     * ```typescript
     * this.grid1.markForCheck();
     * ```
     */
    markForCheck() {
        this.cdr.detectChanges();
    }
    /**
     * @hidden @internal
     */
    beginAddRowByIndex(rowID, index, asChild) {
        if (!this.rowEditable) {
            console.warn('The grid must use row edit mode to perform row adding! Please set rowEditable to true.');
            return;
        }
        this.endEdit(true);
        this.cancelAddMode = false;
        const isInPinnedArea = this.isRecordPinnedByViewIndex(index);
        const pinIndex = this.pinnedRecords.findIndex(x => x[this.primaryKey] === rowID);
        const unpinIndex = this.getUnpinnedIndexById(rowID);
        if (this.expansionStates.get(rowID)) {
            this.collapseRow(rowID);
        }
        this.addRowParent = {
            rowID: rowID,
            index: isInPinnedArea ? pinIndex : unpinIndex,
            asChild: asChild,
            isPinned: isInPinnedArea
        };
        this._pipeTrigger++;
        this.cdr.detectChanges();
        if (isInPinnedArea) {
            this.calculateGridHeight();
        }
        const newRowIndex = this.addRowParent.index + 1;
        // ensure adding row is in view.
        const shouldScroll = this.navigation.shouldPerformVerticalScroll(newRowIndex, -1);
        if (shouldScroll) {
            this.navigateTo(newRowIndex, -1);
        }
        const row = this.getRowByIndex(index + 1);
        row.animateAdd = true;
        row.onAnimationEnd.pipe(first$1()).subscribe(() => {
            row.animateAdd = false;
            const cell = row.cells.find(c => c.editable);
            if (cell) {
                cell.setEditMode(true);
                cell.activate();
            }
        });
    }
    /**
     * Creates a new `IgxGridRowComponent` and adds the data record to the end of the data source.
     * @example
     * ```typescript
     * this.grid1.addRow(record);
     * ```
     * @param data
     */
    addRow(data) {
        // commit pending states prior to adding a row
        this.endEdit(true);
        this.gridAPI.addRowToData(data);
        this.onRowAdded.emit({ data });
        this._pipeTrigger++;
        this.notifyChanges();
    }
    /**
     * Removes the `IgxGridRowComponent` and the corresponding data record by primary key.
     * @remarks
     * Requires that the `primaryKey` property is set.
     * The method accept rowSelector as a parameter, which is the rowID.
     * @example
     * ```typescript
     * this.grid1.deleteRow(0);
     * ```
     * @param rowSelector
     */
    deleteRow(rowSelector) {
        if (this.primaryKey !== undefined && this.primaryKey !== null) {
            this.deleteRowById(rowSelector);
        }
    }
    /** @hidden */
    deleteRowById(rowId) {
        this.gridAPI.deleteRowById(rowId);
    }
    /**
     * @hidden
     */
    deleteRowFromData(rowID, index) {
        //  if there is a row (index !== 0) delete it
        //  if there is a row in ADD or UPDATE state change it's state to DELETE
        if (index !== -1) {
            if (this.transactions.enabled) {
                const transaction = { id: rowID, type: TransactionType.DELETE, newValue: null };
                this.transactions.add(transaction, this.data[index]);
            }
            else {
                this.data.splice(index, 1);
            }
        }
        else {
            const state = this.transactions.getState(rowID);
            this.transactions.add({ id: rowID, type: TransactionType.DELETE, newValue: null }, state && state.recordRef);
        }
    }
    /**
     * Updates the `IgxGridRowComponent` and the corresponding data record by primary key.
     * @remarks
     * Requires that the `primaryKey` property is set.
     * @example
     * ```typescript
     * this.gridWithPK.updateCell('Updated', 1, 'ProductName');
     * ```
     * @param value the new value which is to be set.
     * @param rowSelector corresponds to rowID.
     * @param column corresponds to column field.
     */
    updateCell(value, rowSelector, column) {
        if (this.isDefined(this.primaryKey)) {
            const col = this.columnList.toArray().find(c => c.field === column);
            if (col) {
                // Simplify
                const rowData = this.gridAPI.getRowData(rowSelector);
                const index = this.gridAPI.get_row_index_in_data(rowSelector);
                // If row passed is invalid
                if (index < 0) {
                    return;
                }
                const id = {
                    rowID: rowSelector,
                    columnID: col.index,
                    rowIndex: index
                };
                const cell = new IgxCell(id, index, col, rowData[col.field], rowData[col.field], rowData, this);
                const args = this.gridAPI.update_cell(cell, value);
                if (this.crudService.cell && this.crudService.sameCell(cell)) {
                    if (args.cancel) {
                        return;
                    }
                    this.crudService.exitCellEdit();
                }
                this.cdr.detectChanges();
            }
        }
    }
    /**
     * Updates the `IgxGridRowComponent`
     * @remarks
     * The row is specified by
     * rowSelector parameter and the data source record with the passed value.
     * This method will apply requested update only if primary key is specified in the grid.
     * @example
     * ```typescript
     * grid.updateRow({
     *       ProductID: 1, ProductName: 'Spearmint', InStock: true, UnitsInStock: 1, OrderDate: new Date('2005-03-21')
     *   }, 1);
     * ```
     * @param value
     * @param rowSelector correspond to rowID
     */
    updateRow(value, rowSelector) {
        if (this.isDefined(this.primaryKey)) {
            const editableCell = this.crudService.cell;
            if (editableCell && editableCell.id.rowID === rowSelector) {
                this.crudService.exitCellEdit();
            }
            const row = new IgxRow(rowSelector, -1, this.gridAPI.getRowData(rowSelector), this);
            this.gridAPI.update_row(row, value);
            // TODO: fix for #5934 and probably break for #5763
            // consider adding of third optional boolean parameter in updateRow.
            // If developer set this parameter to true we should call notifyChanges(true), and
            // vise-versa if developer set it to false we should call notifyChanges(false).
            // The parameter should default to false
            this.notifyChanges();
        }
    }
    /**
     * Returns the data that is contained in the row component.
     * @remarks
     * If the primary key is not specified the row selector match the row data.
     * @example
     * ```typescript
     * const data = grid.getRowData(94741);
     * ```
     * @param rowSelector correspond to rowID
     */
    getRowData(rowSelector) {
        if (!this.primaryKey) {
            return rowSelector;
        }
        const data = this.gridAPI.get_all_data(this.transactions.enabled);
        const index = this.gridAPI.get_row_index_in_data(rowSelector);
        return index < 0 ? {} : data[index];
    }
    /**
     * Sort a single `IgxColumnComponent`.
     * @remarks
     * Sort the `IgxGridComponent`'s `IgxColumnComponent` based on the provided array of sorting expressions.
     * @example
     * ```typescript
     * this.grid.sort({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * ```
     */
    sort(expression) {
        this.endEdit(false);
        if (expression instanceof Array) {
            this.gridAPI.sort_multiple(expression);
        }
        else {
            this.gridAPI.sort(expression);
        }
        requestAnimationFrame(() => this.onSortingDone.emit(expression));
    }
    /**
     * Filters a single `IgxColumnComponent`.
     * @example
     * ```typescript
     * public filter(term) {
     *      this.grid.filter("ProductName", term, IgxStringFilteringOperand.instance().condition("contains"));
     * }
     * ```
     * @param name
     * @param value
     * @param conditionOrExpressionTree
     * @param ignoreCase
     */
    filter(name, value, conditionOrExpressionTree, ignoreCase) {
        this.filteringService.filter(name, value, conditionOrExpressionTree, ignoreCase);
    }
    /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     * @example
     * ```typescript
     * grid.filterGlobal('some', IgxStringFilteringOperand.instance().condition('contains'));
     * ```
     * @param value
     * @param condition
     * @param ignoreCase
     */
    filterGlobal(value, condition, ignoreCase) {
        this.filteringService.filterGlobal(value, condition, ignoreCase);
    }
    /**
     * Enables summaries for the specified column and applies your customSummary.
     * @remarks
     * If you do not provide the customSummary, then the default summary for the column data type will be applied.
     * @example
     * ```typescript
     * grid.enableSummaries([{ fieldName: 'ProductName' }, { fieldName: 'ID' }]);
     * ```
     * Enable summaries for the listed columns.
     * @example
     * ```typescript
     * grid.enableSummaries('ProductName');
     * ```
     * @param rest
     */
    enableSummaries(...rest) {
        if (rest.length === 1 && Array.isArray(rest[0])) {
            this._multipleSummaries(rest[0], true);
        }
        else {
            this._summaries(rest[0], true, rest[1]);
        }
    }
    /**
     * Disable summaries for the specified column.
     * @example
     * ```typescript
     * grid.disableSummaries('ProductName');
     * ```
     * @remarks
     * Disable summaries for the listed columns.
     * @example
     * ```typescript
     * grid.disableSummaries([{ fieldName: 'ProductName' }]);
     * ```
     */
    disableSummaries(...rest) {
        if (rest.length === 1 && Array.isArray(rest[0])) {
            this._disableMultipleSummaries(rest[0]);
        }
        else {
            this._summaries(rest[0], false);
        }
    }
    /**
     * If name is provided, clears the filtering state of the corresponding `IgxColumnComponent`.
     * @remarks
     * Otherwise clears the filtering state of all `IgxColumnComponent`s.
     * @example
     * ```typescript
     * this.grid.clearFilter();
     * ```
     * @param name
     */
    clearFilter(name) {
        this.filteringService.clearFilter(name);
    }
    /**
     * If name is provided, clears the sorting state of the corresponding `IgxColumnComponent`.
     * @remarks
     * otherwise clears the sorting state of all `IgxColumnComponent`.
     * @example
     * ```typescript
     * this.grid.clearSort();
     * ```
     * @param name
     */
    clearSort(name) {
        if (!name) {
            this.sortingExpressions = [];
            return;
        }
        if (!this.gridAPI.get_column_by_name(name)) {
            return;
        }
        this.gridAPI.clear_sort(name);
    }
    /**
     * @hidden @internal
     */
    refreshGridState(args) {
        this.endEdit(true);
        this.selectionService.clearHeaderCBState();
        this.summaryService.clearSummaryCache();
        this.cdr.detectChanges();
    }
    // TODO: We have return values here. Move them to event args ??
    /**
     * Pins a column by field name.
     * @remarks
     * Returns whether the operation is successful.
     * @example
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * @param columnName
     * @param index
     */
    pinColumn(columnName, index) {
        const col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
        return col.pin(index);
    }
    /**
     * Unpins a column by field name. Returns whether the operation is successful.
     * @example
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * @param columnName
     * @param index
     */
    unpinColumn(columnName, index) {
        const col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
        return col.unpin(index);
    }
    /**
     * Pin the row by its id.
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.pinRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     * @param index The index at which to insert the row in the pinned collection.
     */
    pinRow(rowID, index) {
        if (this._pinnedRecordIDs.indexOf(rowID) !== -1) {
            return false;
        }
        const row = this.gridAPI.get_row_by_key(rowID);
        const eventArgs = {
            insertAtIndex: index,
            isPinned: true,
            rowID: rowID,
            row: row
        };
        this.onRowPinning.emit(eventArgs);
        this.endEdit(true);
        const insertIndex = typeof eventArgs.insertAtIndex === 'number' ? eventArgs.insertAtIndex : this._pinnedRecordIDs.length;
        this._pinnedRecordIDs.splice(insertIndex, 0, rowID);
        this._pipeTrigger++;
        if (this.gridAPI.grid) {
            this.notifyChanges();
        }
    }
    /**
     * Unpin the row by its id.
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.unpinRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     */
    unpinRow(rowID) {
        const index = this._pinnedRecordIDs.indexOf(rowID);
        if (index === -1) {
            return false;
        }
        const row = this.gridAPI.get_row_by_key(rowID);
        const eventArgs = {
            isPinned: false,
            rowID: rowID,
            row: row
        };
        this.onRowPinning.emit(eventArgs);
        this.endEdit(true);
        this._pinnedRecordIDs.splice(index, 1);
        this._pipeTrigger++;
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
        return true;
    }
    get pinnedRowHeight() {
        const containerHeight = this.pinContainer ? this.pinContainer.nativeElement.offsetHeight : 0;
        return this.hasPinnedRecords ? containerHeight : 0;
    }
    get totalHeight() {
        return this.calcHeight ? this.calcHeight + this.pinnedRowHeight : this.calcHeight;
    }
    /**
     * Recalculates grid width/height dimensions.
     * @remarks
     * Should be run when changing DOM elements dimentions manually that affect the grid's size.
     * @example
     * ```typescript
     * this.grid.reflow();
     * ```
     */
    reflow() {
        this.calculateGridSizes();
    }
    /**
     * Finds the next occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * @remarks
     * Returns how many times the grid contains the string.
     * @example
     * ```typescript
     * this.grid.findNext("financial");
     * ```
     * @param text the string to search.
     * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param exactMatch optionally, if the text should match the entire value  (defaults to false).
     */
    findNext(text, caseSensitive, exactMatch) {
        return this.find(text, 1, caseSensitive, exactMatch);
    }
    /**
     * Finds the previous occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * @remarks
     * Returns how many times the grid contains the string.
     * @example
     * ```typescript
     * this.grid.findPrev("financial");
     * ```
     * @param text the string to search.
     * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param exactMatch optionally, if the text should match the entire value (defaults to false).
     */
    findPrev(text, caseSensitive, exactMatch) {
        return this.find(text, -1, caseSensitive, exactMatch);
    }
    /**
     * Reapplies the existing search.
     * @remarks
     * Returns how many times the grid contains the last search.
     * @example
     * ```typescript
     * this.grid.refreshSearch();
     * ```
     * @param updateActiveInfo
     */
    refreshSearch(updateActiveInfo, endEdit = true) {
        if (this.lastSearchInfo.searchText) {
            this.rebuildMatchCache();
            if (updateActiveInfo) {
                const activeInfo = IgxTextHighlightDirective.highlightGroupsMap.get(this.id);
                this.lastSearchInfo.matchInfoCache.forEach((match, i) => {
                    if (match.column === activeInfo.column &&
                        match.row === activeInfo.row &&
                        match.index === activeInfo.index &&
                        compareMaps(match.metadata, activeInfo.metadata)) {
                        this.lastSearchInfo.activeMatchIndex = i;
                    }
                });
            }
            return this.find(this.lastSearchInfo.searchText, 0, this.lastSearchInfo.caseSensitive, this.lastSearchInfo.exactMatch, false, endEdit);
        }
        else {
            return 0;
        }
    }
    /**
     * Removes all the highlights in the cell.
     * @example
     * ```typescript
     * this.grid.clearSearch();
     * ```
     */
    clearSearch() {
        this.lastSearchInfo = {
            searchText: '',
            caseSensitive: false,
            exactMatch: false,
            activeMatchIndex: 0,
            matchInfoCache: []
        };
        this.rowList.forEach((row) => {
            if (row.cells) {
                row.cells.forEach((c) => {
                    c.clearHighlight();
                });
            }
        });
    }
    /**
     * Returns if the `IgxGridComponent` has sortable columns.
     * @example
     * ```typescript
     * const sortableGrid = this.grid.hasSortableColumns;
     * ```
     */
    get hasSortableColumns() {
        return this.columnList.some((col) => col.sortable);
    }
    /**
     * Returns if the `IgxGridComponent` has editable columns.
     * @example
     * ```typescript
     * const editableGrid = this.grid.hasEditableColumns;
     * ```
     */
    get hasEditableColumns() {
        return this.columnList.some((col) => col.editable);
    }
    /**
     * Returns if the `IgxGridComponent` has fiterable columns.
     * @example
     * ```typescript
     * const filterableGrid = this.grid.hasFilterableColumns;
     * ```
     */
    get hasFilterableColumns() {
        return this.columnList.some((col) => col.filterable);
    }
    /**
     * Returns if the `IgxGridComponent` has summarized columns.
     * @example
     * ```typescript
     * const summarizedGrid = this.grid.hasSummarizedColumns;
     * ```
     */
    get hasSummarizedColumns() {
        return this.summaryService.hasSummarizedColumns;
    }
    /**
     * @hidden @internal
     */
    get rootSummariesEnabled() {
        return this.summaryCalculationMode !== GridSummaryCalculationMode.childLevelsOnly;
    }
    /**
     * @hidden @internal
     */
    get hasVisibleColumns() {
        if (this._hasVisibleColumns === undefined) {
            return this.columnList ? this.columnList.some(c => !c.hidden) : false;
        }
        return this._hasVisibleColumns;
    }
    set hasVisibleColumns(value) {
        this._hasVisibleColumns = value;
    }
    /**
     * Returns if the `IgxGridComponent` has moveable columns.
     * @example
     * ```typescript
     * const movableGrid = this.grid.hasMovableColumns;
     * ```
     */
    get hasMovableColumns() {
        return this.columnList && this.columnList.some((col) => col.movable);
    }
    /**
     * Returns if the `IgxGridComponent` has column groups.
     * @example
     * ```typescript
     * const groupGrid = this.grid.hasColumnGroups;
     * ```
     */
    get hasColumnGroups() {
        return this._columnGroups;
    }
    /**
     * Returns if the `IgxGridComponent` has column layouts for multi-row layout definition.
     * @example
     * ```typescript
     * const layoutGrid = this.grid.hasColumnLayouts;
     * ```
     */
    get hasColumnLayouts() {
        return !!this.columnList.some(col => col.columnLayout);
    }
    /**
     * Returns an array of the selected `IgxGridCellComponent`s.
     * @example
     * ```typescript
     * const selectedCells = this.grid.selectedCells;
     * ```
     */
    get selectedCells() {
        if (this.dataRowList) {
            return this.dataRowList.map((row) => row.cells.filter((cell) => cell.selected))
                .reduce((a, b) => a.concat(b), []);
        }
        return [];
    }
    /**
     * @hidden @internal
     */
    get multiRowLayoutRowSize() {
        return this._multiRowLayoutRowSize;
    }
    /**
     * @hidden
     */
    get rowBasedHeight() {
        return this.dataLength * this.rowHeight;
    }
    /**
     * @hidden
     */
    get isPercentWidth() {
        return this.width && this.width.indexOf('%') !== -1;
    }
    /**
     * @hidden @internal
     */
    get isPercentHeight() {
        return this._height && this._height.indexOf('%') !== -1;
    }
    /**
     * @hidden
     * Sets columns defaultWidth property
     */
    _derivePossibleWidth() {
        if (!this.columnWidthSetByUser) {
            this._columnWidth = this.width !== null ? this.getPossibleColumnWidth() : MINIMUM_COLUMN_WIDTH + 'px';
        }
        this.columnList.forEach((column) => {
            if (this.hasColumnLayouts && parseInt(this._columnWidth, 10)) {
                const columnWidthCombined = parseInt(this._columnWidth, 10) * (column.colEnd ? column.colEnd - column.colStart : 1);
                column.defaultWidth = columnWidthCombined + 'px';
            }
            else {
                column.defaultWidth = this._columnWidth;
                column.resetCaches();
            }
        });
        this.resetCachedWidths();
    }
    /**
     * @hidden
     */
    get defaultTargetBodyHeight() {
        const allItems = this.dataLength;
        return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
    }
    /**
     * @hidden @internal
     * The rowHeight input is bound to min-height css prop of rows that adds a 1px border in all cases
     */
    get renderedRowHeight() {
        return this.rowHeight + 1;
    }
    /**
     * @hidden
     * @internal
     */
    calcGridHeadRow() {
        if (this.maxLevelHeaderDepth) {
            this._baseFontSize = parseFloat(getComputedStyle(this.document.documentElement).getPropertyValue('font-size'));
            let minSize = (this.maxLevelHeaderDepth + 1) * this.defaultRowHeight / this._baseFontSize;
            if (this._allowFiltering && this._filterMode === FilterMode.quickFilter) {
                minSize += (FILTER_ROW_HEIGHT + 1) / this._baseFontSize;
            }
            this.theadRow.nativeElement.style.minHeight = `${minSize}rem`;
        }
    }
    /**
     * @hidden
     * Sets TBODY height i.e. this.calcHeight
     */
    calculateGridHeight() {
        this.calcGridHeadRow();
        this.summariesHeight = 0;
        if (this.hasSummarizedColumns && this.rootSummariesEnabled) {
            this.summariesHeight = this.summaryService.calcMaxSummaryHeight();
        }
        this.calcHeight = this._calculateGridBodyHeight();
        if (this.pinnedRowHeight && this.calcHeight) {
            this.calcHeight -= this.pinnedRowHeight;
        }
    }
    /**
     * @hidden
     */
    getGroupAreaHeight() {
        return 0;
    }
    /**
     * @hidden
     */
    getComputedHeight(elem) {
        return elem.offsetHeight ? parseFloat(this.document.defaultView.getComputedStyle(elem).getPropertyValue('height')) : 0;
    }
    /**
     * @hidden
     */
    getFooterHeight() {
        return this.summariesHeight || this.getComputedHeight(this.tfoot.nativeElement);
    }
    /**
     * @hidden
     */
    getTheadRowHeight() {
        const height = this.getComputedHeight(this.theadRow.nativeElement);
        return (!this.allowFiltering || (this.allowFiltering && this.filterMode !== FilterMode.quickFilter)) ?
            height - this.getFilterCellHeight() :
            height;
    }
    /**
     * @hidden
     */
    getToolbarHeight() {
        let toolbarHeight = 0;
        if (this.showToolbar && this.toolbarHtml != null) {
            const height = this.getComputedHeight(this.toolbarHtml.nativeElement);
            toolbarHeight = this.toolbarHtml.nativeElement.firstElementChild ?
                height : 0;
        }
        return toolbarHeight;
    }
    /**
     * @hidden
     */
    getPagingFooterHeight() {
        let pagingHeight = 0;
        if (this.footer) {
            const height = this.getComputedHeight(this.footer.nativeElement);
            pagingHeight = this.footer.nativeElement.firstElementChild ?
                height : 0;
        }
        return pagingHeight;
    }
    /**
     * @hidden
     */
    getFilterCellHeight() {
        const headerGroupNativeEl = (this.headerGroupsList.length !== 0) ?
            this.headerGroupsList[0].element.nativeElement : null;
        const filterCellNativeEl = (headerGroupNativeEl) ?
            headerGroupNativeEl.querySelector('igx-grid-filtering-cell') : null;
        return (filterCellNativeEl) ? filterCellNativeEl.offsetHeight : 0;
    }
    /**
     * @hidden
     */
    _calculateGridBodyHeight() {
        if (!this._height) {
            return null;
        }
        const actualTheadRow = this.getTheadRowHeight();
        const footerHeight = this.getFooterHeight();
        const toolbarHeight = this.getToolbarHeight();
        const pagingHeight = this.getPagingFooterHeight();
        const groupAreaHeight = this.getGroupAreaHeight();
        const scrHeight = this.getComputedHeight(this.scr.nativeElement);
        const renderedHeight = toolbarHeight + actualTheadRow +
            footerHeight + pagingHeight + groupAreaHeight +
            scrHeight;
        let gridHeight = 0;
        if (this.isPercentHeight) {
            const computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('height');
            const autoSize = this._shouldAutoSize(renderedHeight);
            if (autoSize || computed.indexOf('%') !== -1) {
                const bodyHeight = this.getDataBasedBodyHeight();
                return bodyHeight > 0 ? bodyHeight : null;
            }
            gridHeight = parseFloat(computed);
        }
        else {
            gridHeight = parseInt(this._height, 10);
        }
        const height = Math.abs(gridHeight - renderedHeight);
        if (Math.round(height) === 0 || isNaN(gridHeight)) {
            const bodyHeight = this.defaultTargetBodyHeight;
            return bodyHeight > 0 ? bodyHeight : null;
        }
        return height;
    }
    checkContainerSizeChange() {
        const origHeight = this.nativeElement.parentElement.offsetHeight;
        this.nativeElement.style.display = 'none';
        const height = this.nativeElement.parentElement.offsetHeight;
        this.nativeElement.style.display = '';
        return origHeight !== height;
    }
    _shouldAutoSize(renderedHeight) {
        this.tbody.nativeElement.style.display = 'none';
        let res = !this.nativeElement.parentElement ||
            this.nativeElement.parentElement.clientHeight === 0 ||
            this.nativeElement.parentElement.clientHeight === renderedHeight;
        if (!isChromium()) {
            // If grid causes the parent container to extend (for example when container is flex)
            // we should always auto-size since the actual size of the container will continuously change as the grid renders elements.
            res = this.checkContainerSizeChange();
        }
        this.tbody.nativeElement.style.display = '';
        return res;
    }
    /**
     * @hidden @internal
     */
    get outerWidth() {
        return this.hasVerticalScroll() ? this.calcWidth + this.scrollSize : this.calcWidth;
    }
    /**
     * @hidden @internal
     * Gets the visible content height that includes header + tbody + footer.
     */
    getVisibleContentHeight() {
        let height = this.theadRow.nativeElement.clientHeight + this.tbody.nativeElement.clientHeight;
        if (this.hasSummarizedColumns) {
            height += this.tfoot.nativeElement.clientHeight;
        }
        return height;
    }
    /**
     * @hidden @internal
     */
    getPossibleColumnWidth(baseWidth = null) {
        let computedWidth;
        if (baseWidth !== null) {
            computedWidth = baseWidth;
        }
        else {
            computedWidth = this.calcWidth ||
                parseInt(this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width'), 10);
        }
        computedWidth -= this.featureColumnsWidth();
        const visibleChildColumns = this.visibleColumns.filter(c => !c.columnGroup);
        // Column layouts related
        let visibleCols = [];
        const columnBlocks = this.visibleColumns.filter(c => c.columnGroup);
        const colsPerBlock = columnBlocks.map(block => block.getInitialChildColumnSizes(block.children));
        const combinedBlocksSize = colsPerBlock.reduce((acc, item) => acc + item.length, 0);
        colsPerBlock.forEach(blockCols => visibleCols = visibleCols.concat(blockCols));
        //
        const columnsWithSetWidths = this.hasColumnLayouts ?
            visibleCols.filter(c => c.widthSetByUser) :
            visibleChildColumns.filter(c => c.widthSetByUser);
        const columnsToSize = this.hasColumnLayouts ?
            combinedBlocksSize - columnsWithSetWidths.length :
            visibleChildColumns.length - columnsWithSetWidths.length;
        const sumExistingWidths = columnsWithSetWidths
            .reduce((prev, curr) => {
            const colWidth = curr.width;
            const widthValue = parseInt(colWidth, 10);
            const currWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1 ?
                widthValue / 100 * computedWidth :
                widthValue;
            return prev + currWidth;
        }, 0);
        // When all columns are hidden, return 0px width
        if (!sumExistingWidths && !columnsToSize) {
            return '0px';
        }
        const columnWidth = Math.floor(!Number.isFinite(sumExistingWidths) ?
            Math.max(computedWidth / columnsToSize, MINIMUM_COLUMN_WIDTH) :
            Math.max((computedWidth - sumExistingWidths) / columnsToSize, MINIMUM_COLUMN_WIDTH));
        return columnWidth + 'px';
    }
    /**
     * @hidden
     * Sets grid width i.e. this.calcWidth
     */
    calculateGridWidth() {
        let width;
        if (this.isPercentWidth) {
            /* width in %*/
            const computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width');
            width = computed.indexOf('%') === -1 ? parseInt(computed, 10) : null;
        }
        else {
            width = parseInt(this.width, 10);
        }
        if (!width && this.nativeElement) {
            width = this.nativeElement.offsetWidth;
        }
        if (this.width === null || !width) {
            width = this.getColumnWidthSum();
        }
        if (this.hasVerticalScroll() && this.width !== null) {
            width -= this.scrollSize;
        }
        if ((Number.isFinite(width) || width === null) && width !== this.calcWidth) {
            this.calcWidth = width;
        }
        this._derivePossibleWidth();
    }
    getColumnWidthSum() {
        let colSum = 0;
        const cols = this.hasColumnLayouts ?
            this.visibleColumns.filter(x => x.columnLayout) : this.visibleColumns.filter(x => !x.columnGroup);
        cols.forEach((item) => {
            const isWidthInPercent = item.width && typeof item.width === 'string' && item.width.indexOf('%') !== -1;
            if (isWidthInPercent) {
                item.width = item.calcWidth || MINIMUM_COLUMN_WIDTH + 'px';
            }
            colSum += parseInt((item.width || item.defaultWidth), 10) || MINIMUM_COLUMN_WIDTH;
        });
        if (!colSum) {
            return null;
        }
        this.cdr.detectChanges();
        colSum += this.featureColumnsWidth();
        return colSum;
    }
    /**
     * @hidden @internal
     */
    hasVerticalScroll() {
        if (this._init) {
            return false;
        }
        const isScrollable = this.verticalScrollContainer ? this.verticalScrollContainer.isScrollable() : false;
        return !!(this.calcWidth && this.dataView &&
            this.dataView.length > 0 &&
            isScrollable);
    }
    /**
     * @hidden @internal
     */
    getDataBasedBodyHeight() {
        return !this.data || (this.data.length < this._defaultTargetRecordNumber) ?
            0 : this.defaultTargetBodyHeight;
    }
    /**
     * @hidden @internal
     */
    onPinnedRowsChanged(change) {
        const diff = this.rowListDiffer.diff(change);
        if (diff) {
            this.notifyChanges(true);
        }
    }
    /**
     * @hidden
     */
    onColumnsChanged(change) {
        const diff = this.columnListDiffer.diff(change);
        if (this.autoGenerate && this.columnList.length === 0 && this._autoGeneratedCols.length > 0) {
            // In Ivy if there are nested conditional templates the content children are re-evaluated
            // hence autogenerated columns are cleared and need to be reset.
            this.columnList.reset(this._autoGeneratedCols);
            return;
        }
        if (diff) {
            let added = false;
            let removed = false;
            diff.forEachAddedItem((record) => {
                this.onColumnInit.emit(record.item);
                added = true;
                record.item.pinned ? this._pinnedColumns.push(record.item) : this._unpinnedColumns.push(record.item);
            });
            this.initColumns(this.columnList);
            diff.forEachRemovedItem((record) => {
                const isColumnGroup = record.item instanceof IgxColumnGroupComponent;
                if (!isColumnGroup) {
                    // Clear Grouping
                    this.gridAPI.clear_groupby(record.item.field);
                    // Clear Filtering
                    this.gridAPI.clear_filter(record.item.field);
                    // Close filter row
                    if (this.filteringService.isFilterRowVisible
                        && this.filteringService.filteredColumn
                        && this.filteringService.filteredColumn.field === record.item.field) {
                        this.filteringRow.close();
                    }
                    // Clear Sorting
                    this.gridAPI.clear_sort(record.item.field);
                    // Remove column selection
                    this.selectionService.deselectColumnsWithNoEvent([record.item.field]);
                }
                removed = true;
            });
            this.resetCaches();
            if (added || removed) {
                this.summaryService.clearSummaryCache();
                Promise.resolve().then(() => {
                    // `onColumnsChanged` can be executed midway a current detectChange cycle and markForCheck will be ignored then.
                    // This ensures that we will wait for the current cycle to end so we can trigger a new one and ngDoCheck to fire.
                    this.notifyChanges(true);
                });
            }
        }
    }
    /**
     * @hidden
     */
    calculateGridSizes(recalcFeatureWidth = true) {
        /*
            TODO: (R.K.) This layered lasagne should be refactored
            ASAP. The reason I have to reset the caches so many times is because
            after teach `detectChanges` call they are filled with invalid
            state. Of course all of this happens midway through the grid
            sizing process which of course, uses values from the caches, thus resulting
            in a broken layout.
        */
        this.resetCaches(recalcFeatureWidth);
        this.cdr.detectChanges();
        const hasScroll = this.hasVerticalScroll();
        this.calculateGridWidth();
        this.resetCaches(recalcFeatureWidth);
        this.cdr.detectChanges();
        this.calculateGridHeight();
        if (this.rowEditable) {
            this.repositionRowEditingOverlay(this.rowInEditMode);
        }
        if (this.filteringService.isFilterRowVisible) {
            this.filteringRow.resetChipsArea();
        }
        this.cdr.detectChanges();
        // in case scrollbar has appeared recalc to size correctly.
        if (hasScroll !== this.hasVerticalScroll()) {
            this.calculateGridWidth();
            this.cdr.detectChanges();
        }
        if (this.zone.isStable) {
            this.zone.run(() => {
                this._applyWidthHostBinding();
                this.cdr.detectChanges();
            });
        }
        else {
            this.zone.onStable.pipe(first$1()).subscribe(() => {
                this.zone.run(() => {
                    this._applyWidthHostBinding();
                });
            });
        }
        this.resetCaches(recalcFeatureWidth);
    }
    _applyWidthHostBinding() {
        let width = this._width;
        if (width === null) {
            let currentWidth = this.calcWidth;
            if (this.hasVerticalScroll()) {
                currentWidth += this.scrollSize;
            }
            width = currentWidth + 'px';
            this.resetCaches();
        }
        this._hostWidth = width;
        this.cdr.markForCheck();
    }
    /**
     * Gets calculated width of the pinned area.
     * @example
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth();
     * ```
     * @param takeHidden If we should take into account the hidden columns in the pinned area.
     */
    getPinnedWidth(takeHidden = false) {
        const fc = takeHidden ? this._pinnedColumns : this.pinnedColumns;
        let sum = 0;
        for (const col of fc) {
            if (col.level === 0) {
                sum += parseInt(col.calcWidth, 10);
            }
        }
        if (this.pinning.columns === ColumnPinningPosition.Start) {
            sum += this.featureColumnsWidth();
        }
        return sum;
    }
    /**
     * @hidden
     * Gets calculated width of the unpinned area
     * @param takeHidden If we should take into account the hidden columns in the pinned area.
     */
    getUnpinnedWidth(takeHidden = false) {
        let width = this.isPercentWidth ?
            this.calcWidth :
            parseInt(this.width, 10) || parseInt(this.hostWidth, 10) || this.calcWidth;
        if (this.hasVerticalScroll() && !this.isPercentWidth) {
            width -= this.scrollSize;
        }
        if (this.pinning.columns === ColumnPinningPosition.End) {
            width -= this.featureColumnsWidth();
        }
        return width - this.getPinnedWidth(takeHidden);
    }
    /**
     * @hidden
     */
    _summaries(fieldName, hasSummary, summaryOperand) {
        const column = this.gridAPI.get_column_by_name(fieldName);
        if (column) {
            column.hasSummary = hasSummary;
            if (summaryOperand) {
                if (this.rootSummariesEnabled) {
                    this.summaryService.retriggerRootPipe++;
                }
                column.summaries = summaryOperand;
            }
        }
    }
    /**
     * @hidden
     */
    _multipleSummaries(expressions, hasSummary) {
        expressions.forEach((element) => {
            this._summaries(element.fieldName, hasSummary, element.customSummary);
        });
    }
    /**
     * @hidden
     */
    _disableMultipleSummaries(expressions) {
        expressions.forEach((column) => {
            const columnName = column && column.fieldName ? column.fieldName : column;
            this._summaries(columnName, false);
        });
    }
    /**
     * @hidden
     */
    resolveDataTypes(rec) {
        if (typeof rec === 'number') {
            return DataType.Number;
        }
        else if (typeof rec === 'boolean') {
            return DataType.Boolean;
        }
        else if (typeof rec === 'object' && rec instanceof Date) {
            return DataType.Date;
        }
        return DataType.String;
    }
    /**
     * @hidden
     */
    autogenerateColumns() {
        const data = this.gridAPI.get_data();
        const factory = this.resolver.resolveComponentFactory(IgxColumnComponent);
        const fields = this.generateDataFields(data);
        const columns = [];
        fields.forEach((field) => {
            const ref = factory.create(this.viewRef.injector);
            ref.instance.field = field;
            ref.instance.dataType = this.resolveDataTypes(data[0][field]);
            ref.changeDetectorRef.detectChanges();
            columns.push(ref.instance);
        });
        this._autoGeneratedCols = columns;
        this.columnList.reset(columns);
        if (data && data.length > 0) {
            this.shouldGenerate = false;
        }
    }
    generateDataFields(data) {
        return Object.keys(data && data.length !== 0 ? data[0] : []);
    }
    /**
     * @hidden
     */
    onlyTopLevel(arr) {
        return arr.filter(c => c.level === 0);
    }
    /**
     * @hidden
     */
    initColumns(collection, cb = null) {
        this._columnGroups = this.columnList.some(col => col.columnGroup);
        if (this.hasColumnLayouts) {
            // Set overall row layout size
            this.columnList.forEach((col) => {
                if (col.columnLayout) {
                    const layoutSize = col.children ?
                        col.children.reduce((acc, val) => Math.max(val.rowStart + val.gridRowSpan - 1, acc), 1) :
                        1;
                    this._multiRowLayoutRowSize = Math.max(layoutSize, this._multiRowLayoutRowSize);
                }
            });
        }
        if (this.hasColumnLayouts && this.hasColumnGroups) {
            // invalid configuration - multi-row and column groups
            // remove column groups
            const columnLayoutColumns = this.columnList.filter((col) => col.columnLayout || col.columnLayoutChild);
            this.columnList.reset(columnLayoutColumns);
        }
        this._maxLevelHeaderDepth = null;
        this._columns = this.columnList.toArray();
        collection.forEach((column) => {
            column.defaultWidth = this.columnWidthSetByUser ? this._columnWidth : column.defaultWidth ? column.defaultWidth : '';
            if (cb) {
                cb(column);
            }
        });
        this.reinitPinStates();
        if (this.hasColumnLayouts) {
            collection.forEach((column) => {
                column.populateVisibleIndexes();
            });
        }
    }
    /**
     * @hidden
     */
    reinitPinStates() {
        this._pinnedColumns = this.columnList
            .filter((c) => c.pinned).sort((a, b) => this._pinnedColumns.indexOf(a) - this._pinnedColumns.indexOf(b));
        this._unpinnedColumns = this.hasColumnGroups ? this.columnList.filter((c) => !c.pinned) :
            this.columnList.filter((c) => !c.pinned)
                .sort((a, b) => this._unpinnedColumns.indexOf(a) - this._unpinnedColumns.indexOf(b));
    }
    /**
     * @hidden @internal
     */
    isColumnGrouped(fieldName) {
        return false;
    }
    /**
     * @hidden @internal
     */
    onHeaderSelectorClick(event) {
        if (!this.isMultiRowSelectionEnabled) {
            return;
        }
        this.selectionService.areAllRowSelected() ?
            this.selectionService.clearRowSelection(event) : this.selectionService.selectAllRows(event);
    }
    /**
     * @hidden @internal
     */
    get headSelectorBaseAriaLabel() {
        if (this._filteringExpressionsTree.filteringOperands.length > 0) {
            return this.selectionService.areAllRowSelected() ? 'Deselect all filtered' : 'Select all filtered';
        }
        return this.selectionService.areAllRowSelected() ? 'Deselect all' : 'Select all';
    }
    /**
     * @hidden
     * @internal
     */
    get totalRowsCountAfterFilter() {
        if (this.data) {
            return this.selectionService.allData.length;
        }
        return 0;
    }
    /**
     * Returns the currently transformed paged/filtered/sorted/grouped pinned row data, displayed in the grid.
     * @example
     * ```typescript
     *      const pinnedDataView = this.grid.pinnedDataView;
     * ```
     */
    get pinnedDataView() {
        return this.pinnedRecords ? this.pinnedRecords : [];
    }
    /**
     * Returns currently transformed paged/filtered/sorted/grouped unpinned row data, displayed in the grid.
     * @example
     * ```typescript
     *      const pinnedDataView = this.grid.pinnedDataView;
     * ```
     */
    get unpinnedDataView() {
        return this.unpinnedRecords ? this.unpinnedRecords : this.verticalScrollContainer.igxForOf || [];
    }
    /**
     * Returns the currently transformed paged/filtered/sorted/grouped/pinned/unpinned row data, displayed in the grid.
     * @example
     * ```typescript
     *      const dataView = this.grid.dataView;
     * ```
     */
    get dataView() {
        return this.isRowPinningToTop ?
            [...this.pinnedDataView, ...this.unpinnedDataView] :
            [...this.unpinnedDataView, ...this.pinnedDataView];
    }
    /**
     * Select specified rows by ID.
     * @example
     * ```typescript
     * this.grid.selectRows([1,2,5], true);
     * ```
     * @param rowIDs
     * @param clearCurrentSelection if true clears the current selection
     */
    selectRows(rowIDs, clearCurrentSelection) {
        this.selectionService.selectRowsWithNoEvent(rowIDs, clearCurrentSelection);
        this.notifyChanges();
    }
    /**
     * Deselect specified rows by ID.
     * @example
     * ```typescript
     * this.grid.deselectRows([1,2,5]);
     * ```
     * @param rowIDs
     */
    deselectRows(rowIDs) {
        this.selectionService.deselectRowsWithNoEvent(rowIDs);
        this.notifyChanges();
    }
    /**
     * Selects all rows
     * @remarks
     * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * If you set the parameter onlyFilterData to false that will select all rows in the grid exept deleted rows.
     * @example
     * ```typescript
     * this.grid.selectAllRows();
     * this.grid.selectAllRows(false);
     * ```
     * @param onlyFilterData
     */
    selectAllRows(onlyFilterData = true) {
        const data = onlyFilterData && this.filteredData ? this.filteredData : this.gridAPI.get_all_data(true);
        const rowIDs = this.selectionService.getRowIDs(data).filter(rID => !this.gridAPI.row_deleted_transaction(rID));
        this.selectRows(rowIDs);
    }
    /**
     * Deselects all rows
     * @remarks
     * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * If you set the parameter onlyFilterData to false that will deselect all rows in the grid exept deleted rows.
     * @example
     * ```typescript
     * this.grid.deselectAllRows();
     * ```
     * @param onlyFilterData
     */
    deselectAllRows(onlyFilterData = true) {
        if (onlyFilterData && this.filteredData && this.filteredData.length > 0) {
            this.deselectRows(this.selectionService.getRowIDs(this.filteredData));
        }
        else {
            this.selectionService.clearAllSelectedRows();
            this.notifyChanges();
        }
    }
    /**
     * @hidden @internal
     */
    clearCellSelection() {
        this.selectionService.clear(true);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    dragScroll(dir) {
        const scrollDelta = 48;
        const horizontal = this.headerContainer.getScroll();
        const vertical = this.verticalScrollContainer.getScroll();
        switch (dir) {
            case DragScrollDirection.LEFT:
                horizontal.scrollLeft -= scrollDelta;
                break;
            case DragScrollDirection.RIGHT:
                horizontal.scrollLeft += scrollDelta;
                break;
            case DragScrollDirection.TOP:
                vertical.scrollTop -= scrollDelta;
                break;
            case DragScrollDirection.BOTTOM:
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.BOTTOMLEFT:
                horizontal.scrollLeft -= scrollDelta;
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.BOTTOMRIGHT:
                horizontal.scrollLeft += scrollDelta;
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.TOPLEFT:
                horizontal.scrollLeft -= scrollDelta;
                vertical.scrollTop -= scrollDelta;
                break;
            case DragScrollDirection.TOPRIGHT:
                horizontal.scrollLeft += scrollDelta;
                vertical.scrollTop -= scrollDelta;
                break;
            default:
                return;
        }
    }
    /**
     * @hidden @internal
     */
    isDefined(arg) {
        return arg !== undefined && arg !== null;
    }
    /**
     * @hidden @internal
     */
    selectRange(arg) {
        if (!this.isDefined(arg)) {
            this.clearCellSelection();
            return;
        }
        if (arg instanceof Array) {
            arg.forEach(range => this.setSelection(range));
        }
        else {
            this.setSelection(arg);
        }
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    columnToVisibleIndex(field) {
        const visibleColumns = this.visibleColumns;
        if (typeof field === 'number') {
            return field;
        }
        return visibleColumns.find(column => column.field === field).visibleIndex;
    }
    /**
     * @hidden @internal
     */
    setSelection(range) {
        const startNode = { row: range.rowStart, column: this.columnToVisibleIndex(range.columnStart) };
        const endNode = { row: range.rowEnd, column: this.columnToVisibleIndex(range.columnEnd) };
        this.selectionService.pointerState.node = startNode;
        this.selectionService.selectRange(endNode, this.selectionService.pointerState);
        this.selectionService.addRangeMeta(endNode, this.selectionService.pointerState);
        this.selectionService.initPointerState();
    }
    /**
     * @hidden @internal
     */
    getSelectedRanges() {
        return this.selectionService.ranges;
    }
    extractDataFromSelection(source, formatters = false, headers = false) {
        var _a;
        let columnsArray;
        let record = {};
        const selectedData = [];
        const activeEl = this.selectionService.activeElement;
        const totalItems = (_a = this.totalItemCount) !== null && _a !== void 0 ? _a : 0;
        const isRemote = totalItems && totalItems > this.dataView.length;
        const selectionMap = isRemote ? Array.from(this.selectionService.selection) :
            Array.from(this.selectionService.selection).filter((tuple) => tuple[0] < source.length);
        if (this.cellSelection === GridSelectionMode.single && activeEl) {
            selectionMap.push([activeEl.row, new Set().add(activeEl.column)]);
        }
        for (let [row, set] of selectionMap) {
            row = this.paging ? row + (this.perPage * this.page) : row;
            row = isRemote ? row - this.virtualizationState.startIndex : row;
            if (!source[row] || source[row].detailsData !== undefined) {
                continue;
            }
            const temp = Array.from(set);
            for (const each of temp) {
                columnsArray = this.getSelectableColumnsAt(each);
                columnsArray.forEach((col) => {
                    if (col) {
                        const key = headers ? col.header || col.field : col.field;
                        const value = source[row].ghostRecord ?
                            resolveNestedPath(source[row].recordRef, col.field) : resolveNestedPath(source[row], col.field);
                        record[key] = formatters && col.formatter ? col.formatter(value) : value;
                    }
                });
            }
            if (Object.keys(record).length) {
                selectedData.push(record);
            }
            record = {};
        }
        return selectedData;
    }
    getSelectableColumnsAt(index) {
        if (this.hasColumnLayouts) {
            const visibleLayoutColumns = this.visibleColumns
                .filter(col => col.columnLayout)
                .sort((a, b) => a.visibleIndex - b.visibleIndex);
            const colLayout = visibleLayoutColumns[index];
            return colLayout ? colLayout.children.toArray() : [];
        }
        else {
            const visibleColumns = this.visibleColumns
                .filter(col => !col.columnGroup)
                .sort((a, b) => a.visibleIndex - b.visibleIndex);
            return [visibleColumns[index]];
        }
    }
    /**
     *
     * Returns an array of the current cell selection in the form of `[{ column.field: cell.value }, ...]`.
     * @remarks
     * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
     * If `headers` is enabled, it will use the column header (if any) instead of the column field.
     */
    getSelectedData(formatters = false, headers = false) {
        const source = this.filteredSortedData;
        return this.extractDataFromSelection(source, formatters, headers);
    }
    /**
     * Get current selected columns.
     * @example
     * Returns an array with selected columns
     * ```typescript
     * const selectedColumns = this.grid.selectedColumns();
     * ```
     */
    selectedColumns() {
        const fields = this.selectionService.getSelectedColumns();
        return fields.map(field => this.getColumnByName(field)).filter(field => field);
    }
    /**
     * Select specified columns.
     * @example
     * ```typescript
     * this.grid.selectColumns(['ID','Name'], true);
     * ```
     * @param columns
     * @param clearCurrentSelection if true clears the current selection
     */
    selectColumns(columns, clearCurrentSelection) {
        let fieldToSelect = [];
        if (columns.length === 0 || typeof columns[0] === 'string') {
            fieldToSelect = columns;
        }
        else {
            columns.forEach(col => {
                if (col.columnGroup) {
                    const children = col.allChildren.filter(c => !c.columnGroup).map(c => c.field);
                    fieldToSelect = [...fieldToSelect, ...children];
                }
                else {
                    fieldToSelect.push(col.field);
                }
            });
        }
        this.selectionService.selectColumnsWithNoEvent(fieldToSelect, clearCurrentSelection);
        this.notifyChanges();
    }
    /**
     * Deselect specified columns by filed.
     * @example
     * ```typescript
     * this.grid.deselectColumns(['ID','Name']);
     * ```
     * @param columns
     */
    deselectColumns(columns) {
        let fieldToDeselect = [];
        if (columns.length === 0 || typeof columns[0] === 'string') {
            fieldToDeselect = columns;
        }
        else {
            columns.forEach(col => {
                if (col.columnGroup) {
                    const children = col.allChildren.filter(c => !c.columnGroup).map(c => c.field);
                    fieldToDeselect = [...fieldToDeselect, ...children];
                }
                else {
                    fieldToDeselect.push(col.field);
                }
            });
        }
        this.selectionService.deselectColumnsWithNoEvent(fieldToDeselect);
        this.notifyChanges();
    }
    /**
     * Deselects all columns
     * @example
     * ```typescript
     * this.grid.deselectAllColumns();
     * ```
     */
    deselectAllColumns() {
        this.selectionService.clearAllSelectedColumns();
        this.notifyChanges();
    }
    /**
     * Selects all columns
     * @example
     * ```typescript
     * this.grid.deselectAllColumns();
     * ```
     */
    selectAllColumns() {
        this.selectColumns(this.columnList.filter(c => !c.columnGroup));
    }
    extractDataFromColumnsSelection(source, formatters = false, headers = false) {
        let record = {};
        const selectedData = [];
        const selectedColumns = this.selectedColumns();
        if (selectedColumns.length === 0) {
            return [];
        }
        for (let rowIndex = 0; rowIndex < source.length; rowIndex++) {
            selectedColumns.forEach((col) => {
                const key = headers ? col.header || col.field : col.field;
                record[key] = formatters && col.formatter ? col.formatter(source[rowIndex][col.field])
                    : source[rowIndex][col.field];
            });
            if (Object.keys(record).length) {
                selectedData.push(record);
            }
            record = {};
        }
        return selectedData;
    }
    /**
     *
     * Returns an array of the current columns selection in the form of `[{ column.field: cell.value }, ...]`.
     * @remarks
     * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
     * If `headers` is enabled, it will use the column header (if any) instead of the column field.
     */
    getSelectedColumnsData(formatters = false, headers = false) {
        const source = this.filteredSortedData ? this.filteredSortedData : this.data;
        return this.extractDataFromColumnsSelection(source, formatters, headers);
    }
    /**
     * @hidden
     * @internal
     */
    copyHandler(event) {
        if (!this.clipboardOptions.enabled || this.crudService.cellInEditMode || (!isIE() && event.type === 'keydown')) {
            return;
        }
        const data = this.getSelectedData(this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);
        const ev = { data, cancel: false };
        this.onGridCopy.emit(ev);
        if (ev.cancel) {
            return;
        }
        const transformer = new CharSeparatedValueData(ev.data, this.clipboardOptions.separator);
        let result = transformer.prepareData();
        if (!this.clipboardOptions.copyHeaders) {
            result = result.substring(result.indexOf('\n') + 1);
        }
        if (isIE()) {
            window.clipboardData.setData('Text', result);
            return;
        }
        event.preventDefault();
        /* Necessary for the hiearachical case but will probably have to
           change how getSelectedData is propagated in the hiearachical grid
        */
        event.stopPropagation();
        event.clipboardData.setData('text/plain', result);
    }
    /**
     * @hidden @internal
     */
    showSnackbarFor(index) {
        this.addRowSnackbar.actionText = index === -1 ? '' : this.snackbarActionText;
        this.lastAddedRowIndex = index;
        this.addRowSnackbar.show();
    }
    /**
     * Navigates to a position in the grid based on provided `rowindex` and `visibleColumnIndex`.
     * @remarks
     * Also can execute a custom logic over the target element,
     * through a callback function that accepts { targetType: GridKeydownTargetType, target: Object }
     * @example
     * ```typescript
     *  this.grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); });
     * ```
     */
    navigateTo(rowIndex, visibleColIndex = -1, cb = null) {
        var _a;
        const totalItems = (_a = this.totalItemCount) !== null && _a !== void 0 ? _a : this.dataView.length - 1;
        if (rowIndex < 0 || rowIndex > totalItems || (visibleColIndex !== -1
            && this.columnList.map(col => col.visibleIndex).indexOf(visibleColIndex) === -1)) {
            return;
        }
        if (this.dataView.slice(rowIndex, rowIndex + 1).find(rec => rec.expression || rec.childGridsData)) {
            visibleColIndex = -1;
        }
        // If the target row is pinned no need to scroll as well.
        const shouldScrollVertically = this.navigation.shouldPerformVerticalScroll(rowIndex, visibleColIndex);
        const shouldScrollHorizontally = this.navigation.shouldPerformHorizontalScroll(visibleColIndex, rowIndex);
        if (shouldScrollVertically) {
            this.navigation.performVerticalScrollToCell(rowIndex, visibleColIndex, () => {
                if (shouldScrollHorizontally) {
                    this.navigation.performHorizontalScrollToCell(visibleColIndex, () => this.executeCallback(rowIndex, visibleColIndex, cb));
                }
                else {
                    this.executeCallback(rowIndex, visibleColIndex, cb);
                }
            });
        }
        else if (shouldScrollHorizontally) {
            this.navigation.performHorizontalScrollToCell(visibleColIndex, () => {
                if (shouldScrollVertically) {
                    this.navigation.performVerticalScrollToCell(rowIndex, visibleColIndex, () => this.executeCallback(rowIndex, visibleColIndex, cb));
                }
                else {
                    this.executeCallback(rowIndex, visibleColIndex, cb);
                }
            });
        }
        else {
            this.executeCallback(rowIndex, visibleColIndex, cb);
        }
    }
    /**
     * Returns `ICellPosition` which defines the next cell,
     * according to the current position, that match specific criteria.
     * @remarks
     * You can pass callback function as a third parameter of `getPreviousCell` method.
     * The callback function accepts IgxColumnComponent as a param
     * @example
     * ```typescript
     *  const nextEditableCellPosition = this.grid.getNextCell(0, 3, (column) => column.editable);
     * ```
     */
    getNextCell(currRowIndex, curVisibleColIndex, callback = null) {
        const columns = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0);
        if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
            return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
        }
        const colIndexes = callback ? columns.filter((col) => callback(col)).map(editCol => editCol.visibleIndex).sort((a, b) => a - b) :
            columns.map(editCol => editCol.visibleIndex).sort((a, b) => a - b);
        const nextCellIndex = colIndexes.find(index => index > curVisibleColIndex);
        if (this.dataView.slice(currRowIndex, currRowIndex + 1)
            .find(rec => !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData) && nextCellIndex !== undefined) {
            return { rowIndex: currRowIndex, visibleColumnIndex: nextCellIndex };
        }
        else {
            if (colIndexes.length === 0 || this.getNextDataRowIndex(currRowIndex) === currRowIndex) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            else {
                return { rowIndex: this.getNextDataRowIndex(currRowIndex), visibleColumnIndex: colIndexes[0] };
            }
        }
    }
    /**
     * Returns `ICellPosition` which defines the previous cell,
     * according to the current position, that match specific criteria.
     * @remarks
     * You can pass callback function as a third parameter of `getPreviousCell` method.
     * The callback function accepts IgxColumnComponent as a param
     * @example
     * ```typescript
     *  const previousEditableCellPosition = this.grid.getPreviousCell(0, 3, (column) => column.editable);
     * ```
     */
    getPreviousCell(currRowIndex, curVisibleColIndex, callback = null) {
        const columns = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0);
        if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
            return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
        }
        const colIndexes = callback ? columns.filter((col) => callback(col)).map(editCol => editCol.visibleIndex).sort((a, b) => b - a) :
            columns.map(editCol => editCol.visibleIndex).sort((a, b) => b - a);
        const prevCellIndex = colIndexes.find(index => index < curVisibleColIndex);
        if (this.dataView.slice(currRowIndex, currRowIndex + 1)
            .find(rec => !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData) && prevCellIndex !== undefined) {
            return { rowIndex: currRowIndex, visibleColumnIndex: prevCellIndex };
        }
        else {
            if (colIndexes.length === 0 || this.getNextDataRowIndex(currRowIndex, true) === currRowIndex) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            else {
                return { rowIndex: this.getNextDataRowIndex(currRowIndex, true), visibleColumnIndex: colIndexes[0] };
            }
        }
    }
    executeCallback(rowIndex, visibleColIndex = -1, cb = null) {
        if (!cb) {
            return;
        }
        let row = this.summariesRowList.filter(s => s.index !== 0).concat(this.rowList.toArray()).find(r => r.index === rowIndex);
        if (!row) {
            if (this.totalItemCount) {
                this.verticalScrollContainer.onDataChanged.pipe(first$1()).subscribe(() => {
                    this.cdr.detectChanges();
                    row = this.summariesRowList.filter(s => s.index !== 0).concat(this.rowList.toArray()).find(r => r.index === rowIndex);
                    const cbArgs = this.getNavigationArguments(row, visibleColIndex);
                    cb(cbArgs);
                });
            }
            if (this.dataView[rowIndex].detailsData) {
                this.navigation.setActiveNode({ row: rowIndex });
                this.cdr.detectChanges();
            }
            return;
        }
        const args = this.getNavigationArguments(row, visibleColIndex);
        cb(args);
    }
    getNavigationArguments(row, visibleColIndex) {
        let targetType, target;
        switch (row.nativeElement.tagName.toLowerCase()) {
            case 'igx-grid-groupby-row':
                targetType = 'groupRow';
                target = row;
                break;
            case 'igx-grid-summary-row':
                targetType = 'summaryCell';
                target = visibleColIndex !== -1 ?
                    row.summaryCells.find(c => c.visibleColumnIndex === visibleColIndex) : row.summaryCells.first;
                break;
            case 'igx-child-grid-row':
                targetType = 'hierarchicalRow';
                target = row;
                break;
            default:
                targetType = 'dataCell';
                target = visibleColIndex !== -1 ? row.cells.find(c => c.visibleColumnIndex === visibleColIndex) : row.cells.first;
                break;
        }
        return { targetType: targetType, target: target };
    }
    getNextDataRowIndex(currentRowIndex, previous = false) {
        if (currentRowIndex < 0 || (currentRowIndex === 0 && previous) || (currentRowIndex >= this.dataView.length - 1 && !previous)) {
            return currentRowIndex;
        }
        // find next/prev record that is editable.
        const nextRowIndex = previous ? this.findPrevEditableDataRowIndex(currentRowIndex) :
            this.dataView.findIndex((rec, index) => index > currentRowIndex && this.isEditableDataRecordAtIndex(index));
        return nextRowIndex !== -1 ? nextRowIndex : currentRowIndex;
    }
    /**
     * Returns the previous editable row index or -1 if no such row is found.
     * @param currentIndex The index of the current editable record.
     */
    findPrevEditableDataRowIndex(currentIndex) {
        let i = this.dataView.length;
        while (i--) {
            if (i < currentIndex && this.isEditableDataRecordAtIndex(i)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Returns if the record at the specified data view index is a an editable data record.
     * If record is group rec, summary rec, child rec, ghost rec. etc. it is not editable.
     * @param dataViewIndex The index of that record in the data view.
     */
    isEditableDataRecordAtIndex(dataViewIndex) {
        const rec = this.dataView[dataViewIndex];
        return !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData &&
            !this.isGhostRecordAtIndex(dataViewIndex);
    }
    /**
     * Returns if the record at the specified data view index is a ghost.
     * If record is pinned but is not in pinned area then it is a ghost record.
     * @param dataViewIndex The index of that record in the data view.
     */
    isGhostRecordAtIndex(dataViewIndex) {
        const isPinned = this.isRecordPinned(this.dataView[dataViewIndex]);
        const isInPinnedArea = this.isRecordPinnedByViewIndex(dataViewIndex);
        return isPinned && !isInPinnedArea;
    }
    isValidPosition(rowIndex, colIndex) {
        const rows = this.summariesRowList.filter(s => s.index !== 0).concat(this.rowList.toArray()).length;
        const cols = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0 && !col.hidden).length;
        if (rows < 1 || cols < 1) {
            return false;
        }
        if (rowIndex > -1 && rowIndex < this.dataView.length &&
            colIndex > -1 && colIndex <= Math.max(...this.visibleColumns.map(c => c.visibleIndex))) {
            return true;
        }
        return false;
    }
    /**
     * @hidden @internal
     */
    trackColumnChanges(index, col) {
        return col.field + col._calcWidth;
    }
    find(text, increment, caseSensitive, exactMatch, scroll, endEdit = true) {
        if (!this.rowList) {
            return 0;
        }
        if (endEdit) {
            this.endEdit(false);
        }
        if (!text) {
            this.clearSearch();
            return 0;
        }
        const caseSensitiveResolved = caseSensitive ? true : false;
        const exactMatchResolved = exactMatch ? true : false;
        let rebuildCache = false;
        if (this.lastSearchInfo.searchText !== text ||
            this.lastSearchInfo.caseSensitive !== caseSensitiveResolved ||
            this.lastSearchInfo.exactMatch !== exactMatchResolved) {
            this.lastSearchInfo = {
                searchText: text,
                activeMatchIndex: 0,
                caseSensitive: caseSensitiveResolved,
                exactMatch: exactMatchResolved,
                matchInfoCache: []
            };
            rebuildCache = true;
        }
        else {
            this.lastSearchInfo.activeMatchIndex += increment;
        }
        if (rebuildCache) {
            this.rowList.forEach((row) => {
                if (row.cells) {
                    row.cells.forEach((c) => {
                        c.highlightText(text, caseSensitiveResolved, exactMatchResolved);
                    });
                }
            });
            this.rebuildMatchCache();
        }
        if (this.lastSearchInfo.activeMatchIndex >= this.lastSearchInfo.matchInfoCache.length) {
            this.lastSearchInfo.activeMatchIndex = 0;
        }
        else if (this.lastSearchInfo.activeMatchIndex < 0) {
            this.lastSearchInfo.activeMatchIndex = this.lastSearchInfo.matchInfoCache.length - 1;
        }
        if (this.lastSearchInfo.matchInfoCache.length) {
            const matchInfo = this.lastSearchInfo.matchInfoCache[this.lastSearchInfo.activeMatchIndex];
            this.lastSearchInfo = Object.assign({}, this.lastSearchInfo);
            if (scroll !== false) {
                this.scrollTo(matchInfo.row, matchInfo.column);
            }
            IgxTextHighlightDirective.setActiveHighlight(this.id, {
                column: matchInfo.column,
                row: matchInfo.row,
                index: matchInfo.index,
                metadata: matchInfo.metadata,
            });
        }
        else {
            IgxTextHighlightDirective.clearActiveHighlight(this.id);
        }
        return this.lastSearchInfo.matchInfoCache.length;
    }
    /**
     * Returns an array containing the filtered sorted data.
     * @example
     * ```typescript
     * const filteredSortedData = this.grid1.filteredSortedData;
     * ```
     */
    get filteredSortedData() {
        return this._filteredSortedData;
    }
    /**
     * @hidden
     */
    initPinning() {
        let currentPinnedWidth = 0;
        const pinnedColumns = [];
        const unpinnedColumns = [];
        this.calculateGridWidth();
        this.resetCaches();
        // When a column is a group or is inside a group, pin all related.
        this._pinnedColumns.forEach(col => {
            if (col.parent) {
                col.parent.pinned = true;
            }
            if (col.columnGroup) {
                col.children.forEach(child => child.pinned = true);
            }
        });
        // Make sure we don't exceed unpinned area min width and get pinned and unpinned col collections.
        // We take into account top level columns (top level groups and non groups).
        // If top level is unpinned the pinning handles all children to be unpinned as well.
        for (let i = 0; i < this._columns.length; i++) {
            if (this._columns[i].pinned && !this._columns[i].parent) {
                // Pinned column. Check if with it the unpinned min width is exceeded.
                const colWidth = parseInt(this._columns[i].width, 10);
                currentPinnedWidth += colWidth;
                pinnedColumns.push(this._columns[i]);
            }
            else if (this._columns[i].pinned && this._columns[i].parent) {
                if (this._columns[i].topLevelParent.pinned) {
                    pinnedColumns.push(this._columns[i]);
                }
                else {
                    this._columns[i].pinned = false;
                    unpinnedColumns.push(this._columns[i]);
                }
            }
            else {
                unpinnedColumns.push(this._columns[i]);
            }
        }
        // Assign the applicaple collections.
        this._pinnedColumns = pinnedColumns;
        this._unpinnedColumns = unpinnedColumns;
        this.notifyChanges();
    }
    /**
     * @hidden
     */
    scrollTo(row, column, inCollection = this._filteredSortedUnpinnedData) {
        let delayScrolling = false;
        if (this.paging && typeof (row) !== 'number') {
            const rowIndex = inCollection.indexOf(row);
            const page = Math.floor(rowIndex / this.perPage);
            if (this.page !== page) {
                delayScrolling = true;
                this.page = page;
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(first$1()).subscribe(() => {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(row));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(row));
        }
        this.scrollToHorizontally(column);
    }
    /**
     * @hidden
     */
    scrollToHorizontally(column) {
        let columnIndex = typeof column === 'number' ? column : this.getColumnByName(column).visibleIndex;
        const scrollRow = this.rowList.find(r => r.virtDirRow);
        const virtDir = scrollRow ? scrollRow.virtDirRow : null;
        if (this.isPinningToStart && this.pinnedColumns.length) {
            if (columnIndex >= this.pinnedColumns.length) {
                columnIndex -= this.pinnedColumns.length;
                this.scrollDirective(virtDir, columnIndex);
            }
        }
        else {
            this.scrollDirective(virtDir, columnIndex);
        }
    }
    /**
     * @hidden
     */
    scrollDirective(directive, goal) {
        if (!directive) {
            return;
        }
        directive.scrollTo(goal);
    }
    rebuildMatchCache() {
        this.lastSearchInfo.matchInfoCache = [];
        const caseSensitive = this.lastSearchInfo.caseSensitive;
        const exactMatch = this.lastSearchInfo.exactMatch;
        const searchText = caseSensitive ? this.lastSearchInfo.searchText : this.lastSearchInfo.searchText.toLowerCase();
        const data = this.filteredSortedData;
        const columnItems = this.visibleColumns.filter((c) => !c.columnGroup).sort((c1, c2) => c1.visibleIndex - c2.visibleIndex);
        data.forEach((dataRow, rowIndex) => {
            columnItems.forEach((c) => {
                const pipeArgs = this.getColumnByName(c.field).pipeArgs;
                const value = c.formatter ? c.formatter(resolveNestedPath(dataRow, c.field)) :
                    c.dataType === 'number' ? this.decimalPipe.transform(resolveNestedPath(dataRow, c.field), pipeArgs.digitsInfo, this.locale) :
                        c.dataType === 'date' ? this.datePipe.transform(resolveNestedPath(dataRow, c.field), pipeArgs.format, pipeArgs.timezone, this.locale)
                            : resolveNestedPath(dataRow, c.field);
                if (value !== undefined && value !== null && c.searchable) {
                    let searchValue = caseSensitive ? String(value) : String(value).toLowerCase();
                    if (exactMatch) {
                        if (searchValue === searchText) {
                            const metadata = new Map();
                            metadata.set('pinned', this.isRecordPinnedByIndex(rowIndex));
                            this.lastSearchInfo.matchInfoCache.push({
                                row: dataRow,
                                column: c.field,
                                index: 0,
                                metadata: metadata,
                            });
                        }
                    }
                    else {
                        let occurenceIndex = 0;
                        let searchIndex = searchValue.indexOf(searchText);
                        while (searchIndex !== -1) {
                            const metadata = new Map();
                            metadata.set('pinned', this.isRecordPinnedByIndex(rowIndex));
                            this.lastSearchInfo.matchInfoCache.push({
                                row: dataRow,
                                column: c.field,
                                index: occurenceIndex++,
                                metadata: metadata,
                            });
                            searchValue = searchValue.substring(searchIndex + searchText.length);
                            searchIndex = searchValue.indexOf(searchText);
                        }
                    }
                }
            });
        });
    }
    /**
     * @hidden
     */
    isExpandedGroup(_group) {
        return undefined;
    }
    changeRowEditingOverlayStateOnScroll(row) {
        if (!this.rowEditable || !this.rowEditingOverlay || this.rowEditingOverlay.collapsed) {
            return;
        }
        if (!row) {
            this.toggleRowEditingOverlay(false);
        }
        else {
            this.repositionRowEditingOverlay(row);
        }
    }
    /**
     * Should be called when data and/or isLoading input changes so that the overlay can be
     * hidden/shown based on the current value of shouldOverlayLoading
     */
    evaluateLoadingState() {
        if (this.shouldOverlayLoading) {
            // a new overlay should be shown
            const overlaySettings = {
                outlet: this.loadingOutlet,
                closeOnOutsideClick: false,
                positionStrategy: new ContainerPositionStrategy()
            };
            if (!this._loadingId) {
                this._loadingId = this.overlayService.attach(this.loadingOverlay, overlaySettings);
                this.overlayService.show(this._loadingId, overlaySettings);
            }
        }
        else {
            if (this._loadingId) {
                this.overlayService.hide(this._loadingId);
                this._loadingId = null;
            }
        }
    }
    /**
     * @hidden @internal
     */
    openRowOverlay(id) {
        this.configureRowEditingOverlay(id, this.rowList.length <= MIN_ROW_EDITING_COUNT_THRESHOLD);
        this.rowEditingOverlay.open(this.rowEditSettings);
        this.rowEditingOverlay.element.addEventListener('wheel', this.rowEditingWheelHandler);
    }
    /**
     * @hidden @internal
     */
    closeRowEditingOverlay() {
        this.rowEditingOverlay.element.removeEventListener('wheel', this.rowEditingWheelHandler);
        this.rowEditPositioningStrategy.isTopInitialPosition = null;
        this.rowEditingOverlay.close();
        this.rowEditingOverlay.element.parentElement.style.display = '';
    }
    /**
     * @hidden @internal
     */
    toggleRowEditingOverlay(show) {
        const rowStyle = this.rowEditingOverlay.element.style;
        if (show) {
            rowStyle.display = 'block';
        }
        else {
            rowStyle.display = 'none';
        }
    }
    /**
     * @hidden @internal
     */
    repositionRowEditingOverlay(row) {
        if (row && !this.rowEditingOverlay.collapsed) {
            const rowStyle = this.rowEditingOverlay.element.parentElement.style;
            if (row) {
                rowStyle.display = '';
                this.configureRowEditingOverlay(row.rowID);
                this.rowEditingOverlay.reposition();
            }
            else {
                rowStyle.display = 'none';
            }
        }
    }
    configureRowEditingOverlay(rowID, useOuter = false) {
        let settings = this.rowEditSettings;
        const overlay = this.overlayService.getOverlayById(this.rowEditingOverlay.overlayId);
        if (overlay) {
            settings = overlay.settings;
        }
        settings.outlet = useOuter ? this.parentRowOutletDirective : this.rowOutletDirective;
        this.rowEditPositioningStrategy.settings.container = this.tbody.nativeElement;
        const pinned = this._pinnedRecordIDs.indexOf(rowID) !== -1;
        const targetRow = !pinned ? this.gridAPI.get_row_by_key(rowID) : this.pinnedRows.find(x => x.rowID === rowID);
        if (!targetRow) {
            return;
        }
        settings.target = targetRow.element.nativeElement;
        this.toggleRowEditingOverlay(true);
    }
    /**
     * @hidden @internal
     */
    get rowChangesCount() {
        if (!this.crudService.row) {
            return 0;
        }
        const f = (obj) => {
            let changes = 0;
            Object.keys(obj).forEach(key => isObject(obj[key]) ? changes += f(obj[key]) : changes++);
            return changes;
        };
        const rowChanges = this.transactions.getAggregatedValue(this.crudService.row.id, false);
        return rowChanges ? f(rowChanges) : 0;
    }
    writeToData(rowIndex, value) {
        mergeObjects(this.gridAPI.get_all_data()[rowIndex], value);
    }
    /**
     * @hidden @internal
     */
    endRowTransaction(commit, row) {
        row.newData = this.transactions.getAggregatedValue(row.id, true);
        let rowEditArgs = row.createEditEventArgs();
        if (!commit) {
            this.transactions.endPending(false);
        }
        else {
            rowEditArgs = this.gridAPI.update_row(row, row.newData);
            if (rowEditArgs === null || rowEditArgs === void 0 ? void 0 : rowEditArgs.cancel) {
                return true;
            }
        }
        this.crudService.endRowEdit();
        const nonCancelableArgs = row.createDoneEditEventArgs(rowEditArgs.oldValue);
        this.rowEditExit.emit(nonCancelableArgs);
        this.closeRowEditingOverlay();
    }
    /**
     * @hidden @internal
     */
    gridOutletKeyboardHandler(event) {
        // TODO: This should be removed after grid keyboard refactoring
        // call stopPropagation for keydown event for the outlet not to propagate event to the grid
        event.stopPropagation();
    }
    // TODO: Refactor
    /**
     * Finishes the row transactions on the current row.
     * @remarks
     * If `commit === true`, passes them from the pending state to the data (or transaction service)
     * @example
     * ```html
     * <button igxButton (click)="grid.endEdit(true)">Commit Row</button>
     * ```
     * @param commit
     */
    endEdit(commit = true, event) {
        const row = this.crudService.row;
        const cell = this.crudService.cell;
        let canceled = false;
        // TODO: Merge the crudService with with BaseAPI service
        if (!row && !cell) {
            return;
        }
        if (row === null || row === void 0 ? void 0 : row.isAddRow) {
            canceled = this.endAdd(commit, event);
            return canceled;
        }
        if (commit) {
            canceled = this.gridAPI.submit_value();
            if (canceled) {
                return true;
            }
        }
        else {
            this.crudService.exitCellEdit();
        }
        canceled = this.crudService.exitRowEdit(commit);
        this.crudService.rowEditingBlocked = canceled;
        if (canceled) {
            return true;
        }
        const activeCell = this.selectionService.activeElement;
        if (event && activeCell) {
            const rowIndex = activeCell.row;
            const visibleColIndex = activeCell.layout ? activeCell.layout.columnVisibleIndex : activeCell.column;
            this.navigateTo(rowIndex, visibleColIndex, (c) => {
                if (c.targetType === 'dataCell' && c.target) {
                    c.target.activate(event);
                }
            });
        }
        return false;
    }
    endAdd(commit = true, event) {
        const row = this.crudService.row;
        const cell = this.crudService.cell;
        const cachedRowData = Object.assign({}, row.data);
        let cancelable = false;
        if (!row && !cell) {
            return;
        }
        if (commit) {
            this.onRowAdded.pipe(first$1()).subscribe((args) => {
                const rowData = args.data;
                const pinnedIndex = this.pinnedRecords.findIndex(x => x[this.primaryKey] === rowData[this.primaryKey]);
                // A check whether the row is in the current view
                const viewIndex = pinnedIndex !== -1 ? pinnedIndex : this.findRecordIndexInView(rowData);
                const dataIndex = this.filteredSortedData.findIndex(data => data[this.primaryKey] === rowData[this.primaryKey]);
                const isInView = viewIndex !== -1 && !this.navigation.shouldPerformVerticalScroll(viewIndex, 0);
                const showIndex = isInView ? -1 : dataIndex;
                this.showSnackbarFor(showIndex);
            });
            cancelable = this.gridAPI.submit_add_value();
            if (!cancelable) {
                const args = row.createEditEventArgs();
                this.rowEdit.emit(args);
                if (args.cancel) {
                    return args.cancel;
                }
                const parentId = this._getParentRecordId();
                this.gridAPI.addRowToData(row.data, parentId);
                const doneArgs = row.createDoneEditEventArgs(cachedRowData);
                this.rowEditDone.emit(doneArgs);
                this.crudService.endRowEdit();
                if (this.addRowParent.isPinned) {
                    this.pinRow(row.id);
                }
            }
            this.addRowParent = null;
            this.cancelAddMode = cancelable;
        }
        else {
            this.crudService.exitCellEdit();
            this.cancelAddMode = true;
        }
        this.crudService.endRowEdit();
        this.closeRowEditingOverlay();
        this._pipeTrigger++;
        if (!this.cancelAddMode) {
            this.cdr.detectChanges();
            this.onRowAdded.emit({ data: row.data });
        }
        const nonCancelableArgs = row.createDoneEditEventArgs(cachedRowData);
        this.rowEditExit.emit(nonCancelableArgs);
        return this.cancelAddMode;
    }
    /**
     * @hidden
     * @internal
     */
    _getParentRecordId() {
        return this.addRowParent.asChild ? this.addRowParent.rowID : undefined;
    }
    /**
     * @hidden
     * @internal
     */
    endRowEdit(commit = true, event) {
        const canceled = this.endEdit(commit, event);
        if (canceled) {
            return true;
        }
        const activeCell = this.navigation.activeNode;
        if (activeCell && activeCell.row !== -1) {
            this.tbody.nativeElement.focus();
        }
    }
    /**
     * @hidden @internal
     */
    triggerPipes() {
        this._pipeTrigger++;
        this.cdr.detectChanges();
    }
    /**
     * @hidden @internal
     */
    endAddRow() {
        this.cancelAddMode = true;
        this.triggerPipes();
    }
    findRecordIndexInView(rec) {
        return this.dataView.findIndex(data => data[this.primaryKey] === rec[this.primaryKey]);
    }
    getUnpinnedIndexById(id) {
        return this.unpinnedRecords.findIndex(x => x[this.primaryKey] === id);
    }
    /**
     * @hidden @internal
     */
    get dataWithAddedInTransactionRows() {
        const result = cloneArray(this.gridAPI.get_all_data());
        if (this.transactions.enabled) {
            result.push(...this.transactions.getAggregatedChanges(true)
                .filter(t => t.type === TransactionType.ADD)
                .map(t => t.newValue));
        }
        return result;
    }
    /**
     * @hidden @internal
     */
    get dataLength() {
        return this.transactions.enabled ? this.dataWithAddedInTransactionRows.length : this.gridAPI.get_all_data().length;
    }
    /**
     * @hidden @internal
     */
    get template() {
        if (this.isLoading && (this.hasZeroResultFilter || this.hasNoData)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
        }
        if (this.hasZeroResultFilter) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
        }
        if (this.hasNoData) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    get hasZeroResultFilter() {
        return this.filteredData && this.filteredData.length === 0;
    }
    /**
     * @hidden @internal
     */
    get hasNoData() {
        return !this.data || this.dataLength === 0;
    }
    /**
     * @hidden @internal
     */
    hasHorizontalScroll() {
        return this.totalWidth - this.unpinnedWidth > 0;
    }
    _restoreVirtState(row) {
        // check virtualization state of data record added from cache
        // in case state is no longer valid - update it.
        const rowForOf = row.virtDirRow;
        const gridScrLeft = rowForOf.getScroll().scrollLeft;
        const left = -parseInt(rowForOf.dc.instance._viewContainer.element.nativeElement.style.left, 10);
        const actualScrollLeft = left + rowForOf.getColumnScrollLeft(rowForOf.state.startIndex);
        if (gridScrLeft !== actualScrollLeft) {
            rowForOf.onHScroll(gridScrLeft);
            rowForOf.cdr.detectChanges();
        }
    }
    /**
     * @hidden
     */
    getExportExcel() {
        return this._exportExcel;
    }
    /**
     * @hidden
     */
    getExportCsv() {
        return this._exportCsv;
    }
    /**
     * @hidden @internal
     */
    get shouldOverlayLoading() {
        return this.isLoading && !this.hasNoData && !this.hasZeroResultFilter;
    }
    /**
     * @hidden @internal
     */
    isSummaryRow(rowData) {
        return rowData.summaries && (rowData.summaries instanceof Map);
    }
    /**
     * @hidden @internal
     */
    get isMultiRowSelectionEnabled() {
        return this.rowSelection === GridSelectionMode.multiple;
    }
    /**
     * @hidden @internal
     */
    get isRowSelectable() {
        return this.rowSelection !== GridSelectionMode.none;
    }
    /**
     * @hidden @internal
     */
    get isCellSelectable() {
        return this.cellSelection !== GridSelectionMode.none;
    }
    /**
     * @hidden @internal
     */
    cachedViewLoaded(args) {
        if (this.hasHorizontalScroll()) {
            const tmplId = args.context.templateID;
            const index = args.context.index;
            args.view.detectChanges();
            this.zone.onStable.pipe(first$1()).subscribe(() => {
                const row = tmplId === 'dataRow' ? this.getRowByIndex(index) : null;
                const summaryRow = tmplId === 'summaryRow' ? this.summariesRowList.find((sr) => sr.dataRowIndex === index) : null;
                if (row && row instanceof IgxRowDirective) {
                    this._restoreVirtState(row);
                }
                else if (summaryRow) {
                    this._restoreVirtState(summaryRow);
                }
            });
        }
    }
    /**
     * Opens the advanced filtering dialog.
     */
    openAdvancedFilteringDialog() {
        if (!this._advancedFilteringOverlayId) {
            this._advancedFilteringOverlaySettings.target =
                this.rootGrid ? this.rootGrid.nativeElement : this.nativeElement;
            this._advancedFilteringOverlaySettings.outlet = this.outlet;
            this._advancedFilteringOverlayId = this.overlayService.attach(IgxAdvancedFilteringDialogComponent, this._advancedFilteringOverlaySettings, {
                injector: this.viewRef.injector,
                componentFactoryResolver: this.resolver
            });
            this.overlayService.show(this._advancedFilteringOverlayId, this._advancedFilteringOverlaySettings);
        }
    }
    /**
     * Closes the advanced filtering dialog.
     * @param applyChanges indicates whether the changes should be applied
     */
    closeAdvancedFilteringDialog(applyChanges) {
        if (this._advancedFilteringOverlayId) {
            const advancedFilteringOverlay = this.overlayService.getOverlayById(this._advancedFilteringOverlayId);
            const advancedFilteringDialog = advancedFilteringOverlay.componentRef.instance;
            if (applyChanges) {
                advancedFilteringDialog.applyChanges();
            }
            advancedFilteringDialog.closeDialog();
        }
    }
    getEmptyRecordObjectFor(rec) {
        const row = Object.assign({}, rec);
        Object.keys(row).forEach(key => row[key] = undefined);
        row[this.primaryKey] = this.generateRowID();
        return row;
    }
}
IgxGridBaseDirective.ɵfac = function IgxGridBaseDirective_Factory(t) { return new (t || IgxGridBaseDirective)(ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(IgxGridTransaction), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(IgxGridNavigationService), ɵngcc0.ɵɵdirectiveInject(IgxFilteringService), ɵngcc0.ɵɵdirectiveInject(IgxOverlayService), ɵngcc0.ɵɵdirectiveInject(IgxGridSummaryService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID)); };
IgxGridBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridBaseDirective, contentQueries: function IgxGridBaseDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowExpandedIndicatorDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowCollapsedIndicatorDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxHeaderExpandIndicatorDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxHeaderCollapseIndicatorDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxActionStripComponent, true);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, IgxExcelStyleLoadingValuesTemplateDirective, true, IgxExcelStyleLoadingValuesTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowEditTemplateDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowEditTextDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowEditActionsDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxColumnComponent, true, IgxColumnComponent);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxGridExcelStyleFilteringComponent, false, IgxGridExcelStyleFilteringComponent);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxGridToolbarCustomContentDirective, false, IgxGridToolbarCustomContentDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxHeadSelectorDirective, false, IgxHeadSelectorDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowSelectorDirective, false, IgxRowSelectorDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowDragGhostDirective, false, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDragIndicatorIconDirective, false, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowEditTabStopDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowExpandedIndicatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowCollapsedIndicatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerExpandIndicatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerCollapseIndicatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.actionStrip = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.excelStyleLoadingValuesTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditCustom = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditText = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditActions = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnList = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.excelStyleFilteringComponents = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toolbarCustomContentTemplates = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headSelectorsTemplates = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowSelectorsTemplates = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragGhostCustomTemplates = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragIndicatorIconTemplates = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditTabsCUSTOM = _t);
    } }, viewQuery: function IgxGridBaseDirective_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c134, true, IgxGridToolbarComponent);
        ɵngcc0.ɵɵviewQuery(_c134, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c135, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c136, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(IgxSnackbarComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxGridColumnResizerComponent, true);
        ɵngcc0.ɵɵstaticViewQuery(_c137, true);
        ɵngcc0.ɵɵstaticViewQuery(_c138, true, IgxOverlayOutletDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c139, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c140, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c141, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c6, true, IgxGridForOfDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c142, true, IgxGridForOfDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c143, true, IgxGridForOfDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c144, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c145, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c146, true, IgxGridForOfDirective);
        ɵngcc0.ɵɵviewQuery(_c147, true);
        ɵngcc0.ɵɵviewQuery(_c148, true);
        ɵngcc0.ɵɵviewQuery(_c149, true);
        ɵngcc0.ɵɵviewQuery(_c150, true, IgxGridFilteringRowComponent);
        ɵngcc0.ɵɵstaticViewQuery(_c151, true);
        ɵngcc0.ɵɵstaticViewQuery(_c152, true);
        ɵngcc0.ɵɵviewQuery(_c153, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c154, true);
        ɵngcc0.ɵɵstaticViewQuery(_c155, true, IgxOverlayOutletDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c156, true, IgxOverlayOutletDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c157, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c158, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(IgxToggleDirective, true);
        ɵngcc0.ɵɵviewQuery(IgxTemplateOutletDirective, true, IgxTemplateOutletDirective);
        ɵngcc0.ɵɵviewQuery(IgxGridHeaderGroupComponent, true, IgxGridHeaderGroupComponent);
        ɵngcc0.ɵɵviewQuery(_c159, true);
        ɵngcc0.ɵɵviewQuery(_c160, true);
        ɵngcc0.ɵɵviewQuery(_c161, true, IgxSummaryRowComponent);
        ɵngcc0.ɵɵviewQuery(IgxRowDirective, true, IgxRowDirective);
        ɵngcc0.ɵɵviewQuery(IgxRowEditTabStopDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toolbar = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toolbarHtml = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExpandedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultCollapsedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.addRowSnackbar = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resizeLine = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.loadingOverlay = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.loadingOutlet = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.emptyFilteredGridTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.emptyGridDefaultTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.loadingGridDefaultTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.parentVirtDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.verticalScrollContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.verticalScroll = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.scr = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerSelectorContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerDragContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerGroupContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filteringRow = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.theadRow = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tbody = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pinContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tfoot = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._outletDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditingOutletDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragIndicatorIconBase = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultRowEditTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditingOverlay = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tmpOutlets = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerGroups = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._rowList = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._pinnedRowList = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._summaryRowList = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._dataRowList = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditTabsDEFAULT = _t);
    } }, hostVars: 7, hostBindings: function IgxGridBaseDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function IgxGridBaseDirective_mouseleave_HostBindingHandler($event) { return ctx.hideActionStrip($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("role", ctx.hostRole)("class", ctx.hostClass);
        ɵngcc0.ɵɵstyleProp("height", ctx.height)("width", ctx.hostWidth);
    } }, inputs: { snackbarDisplayTime: "snackbarDisplayTime", autoGenerate: "autoGenerate", class: "class", evenRowCSS: "evenRowCSS", oddRowCSS: "oddRowCSS", columnHidingTitle: "columnHidingTitle", columnPinningTitle: "columnPinningTitle", clipboardOptions: "clipboardOptions", locale: "locale", resourceStrings: "resourceStrings", filteringLogic: "filteringLogic", filteringExpressionsTree: "filteringExpressionsTree", advancedFilteringExpressionsTree: "advancedFilteringExpressionsTree", pagingMode: "pagingMode", paging: "paging", page: "page", perPage: "perPage", columnHiding: "columnHiding", hideRowSelectors: "hideRowSelectors", rowDraggable: "rowDraggable", rowEditable: "rowEditable", height: "height", width: "width", rowHeight: "rowHeight", columnWidth: "columnWidth", emptyGridMessage: "emptyGridMessage", isLoading: "isLoading", emptyFilteredGridMessage: "emptyFilteredGridMessage", pinning: "pinning", columnPinning: "columnPinning", allowFiltering: "allowFiltering", allowAdvancedFiltering: "allowAdvancedFiltering", filterMode: "filterMode", summaryPosition: "summaryPosition", summaryCalculationMode: "summaryCalculationMode", showSummaryOnCollapse: "showSummaryOnCollapse", filterStrategy: "filterStrategy", sortStrategy: "sortStrategy", selectedRows: "selectedRows", sortingExpressions: "sortingExpressions", hiddenColumnsText: "hiddenColumnsText", pinnedColumnsText: "pinnedColumnsText", showToolbar: "showToolbar", toolbarTitle: "toolbarTitle", exportExcel: "exportExcel", exportCsv: "exportCsv", exportText: "exportText", exportExcelText: "exportExcelText", exportCsvText: "exportCsvText", cellSelection: "cellSelection", rowSelection: "rowSelection", columnSelection: "columnSelection", expansionStates: "expansionStates", outlet: "outlet", totalRecords: "totalRecords", emptyGridTemplate: "emptyGridTemplate", addRowEmptyTemplate: "addRowEmptyTemplate", loadingGridTemplate: "loadingGridTemplate", paginationTemplate: "paginationTemplate", primaryKey: "primaryKey", uniqueColumnValuesStrategy: "uniqueColumnValuesStrategy" }, outputs: { filteringExpressionsTreeChange: "filteringExpressionsTreeChange", advancedFilteringExpressionsTreeChange: "advancedFilteringExpressionsTreeChange", onScroll: "onScroll", pageChange: "pageChange", perPageChange: "perPageChange", onCellClick: "onCellClick", onSelection: "onSelection", onRowSelectionChange: "onRowSelectionChange", onColumnSelectionChange: "onColumnSelectionChange", onColumnPinning: "onColumnPinning", cellEditEnter: "cellEditEnter", cellEditExit: "cellEditExit", cellEdit: "cellEdit", cellEditDone: "cellEditDone", rowEditEnter: "rowEditEnter", rowEdit: "rowEdit", rowEditDone: "rowEditDone", rowEditExit: "rowEditExit", onColumnInit: "onColumnInit", onSortingDone: "onSortingDone", onFilteringDone: "onFilteringDone", onPagingDone: "onPagingDone", onRowAdded: "onRowAdded", onRowDeleted: "onRowDeleted", onColumnResized: "onColumnResized", onContextMenu: "onContextMenu", onDoubleClick: "onDoubleClick", onColumnVisibilityChanged: "onColumnVisibilityChanged", onColumnMovingStart: "onColumnMovingStart", onColumnMoving: "onColumnMoving", onColumnMovingEnd: "onColumnMovingEnd", onGridKeydown: "onGridKeydown", onRowDragStart: "onRowDragStart", onRowDragEnd: "onRowDragEnd", onGridCopy: "onGridCopy", expansionStatesChange: "expansionStatesChange", onRowToggle: "onRowToggle", onRowPinning: "onRowPinning", activeNodeChange: "activeNodeChange", sortingExpressionsChange: "sortingExpressionsChange", onToolbarExporting: "onToolbarExporting", onRangeSelection: "onRangeSelection" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxGridBaseDirective.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: IgxColumnResizingService },
    { type: GridBaseAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
    { type: ElementRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: IterableDiffers },
    { type: ViewContainerRef },
    { type: IgxGridNavigationService },
    { type: IgxFilteringService },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxGridSummaryService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
IgxGridBaseDirective.propDecorators = {
    defaultExpandedTemplate: [{ type: ViewChild, args: ['defaultExpandedTemplate', { read: TemplateRef, static: true },] }],
    defaultCollapsedTemplate: [{ type: ViewChild, args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true },] }],
    resourceStrings: [{ type: Input }],
    snackbarDisplayTime: [{ type: Input }],
    autoGenerate: [{ type: Input }],
    emptyGridTemplate: [{ type: Input }],
    addRowEmptyTemplate: [{ type: Input }],
    loadingGridTemplate: [{ type: Input }],
    filteringLogic: [{ type: Input }],
    filteringExpressionsTree: [{ type: Input }],
    filteringExpressionsTreeChange: [{ type: Output }],
    advancedFilteringExpressionsTreeChange: [{ type: Output }],
    onScroll: [{ type: Output }],
    advancedFilteringExpressionsTree: [{ type: Input }],
    locale: [{ type: Input }],
    pagingMode: [{ type: Input }],
    paging: [{ type: Input }],
    page: [{ type: Input }],
    pageChange: [{ type: Output }],
    perPage: [{ type: Input }],
    perPageChange: [{ type: Output }],
    paginationTemplate: [{ type: Input }],
    columnHiding: [{ type: Input }],
    hideRowSelectors: [{ type: Input }],
    rowDraggable: [{ type: Input }],
    rowEditable: [{ type: Input }],
    class: [{ type: Input }],
    height: [{ type: HostBinding, args: ['style.height',] }, { type: Input }],
    hostWidth: [{ type: HostBinding, args: ['style.width',] }],
    width: [{ type: Input }],
    evenRowCSS: [{ type: Input }],
    oddRowCSS: [{ type: Input }],
    rowHeight: [{ type: Input }],
    columnWidth: [{ type: Input }],
    primaryKey: [{ type: Input }],
    emptyGridMessage: [{ type: Input }],
    isLoading: [{ type: Input }],
    emptyFilteredGridMessage: [{ type: Input }],
    columnHidingTitle: [{ type: Input }],
    pinning: [{ type: Input }],
    columnPinning: [{ type: Input }],
    columnPinningTitle: [{ type: Input }],
    allowFiltering: [{ type: Input }],
    allowAdvancedFiltering: [{ type: Input }],
    filterMode: [{ type: Input }],
    summaryPosition: [{ type: Input }],
    summaryCalculationMode: [{ type: Input }],
    showSummaryOnCollapse: [{ type: Input }],
    filterStrategy: [{ type: Input }],
    sortStrategy: [{ type: Input }],
    uniqueColumnValuesStrategy: [{ type: Input }],
    selectedRows: [{ type: Input }],
    onCellClick: [{ type: Output }],
    onSelection: [{ type: Output }],
    onRowSelectionChange: [{ type: Output }],
    onColumnSelectionChange: [{ type: Output }],
    onColumnPinning: [{ type: Output }],
    cellEditEnter: [{ type: Output }],
    cellEditExit: [{ type: Output }],
    cellEdit: [{ type: Output }],
    cellEditDone: [{ type: Output }],
    rowEditEnter: [{ type: Output }],
    rowEdit: [{ type: Output }],
    rowEditDone: [{ type: Output }],
    rowEditExit: [{ type: Output }],
    onColumnInit: [{ type: Output }],
    onSortingDone: [{ type: Output }],
    onFilteringDone: [{ type: Output }],
    onPagingDone: [{ type: Output }],
    onRowAdded: [{ type: Output }],
    onRowDeleted: [{ type: Output }],
    onColumnResized: [{ type: Output }],
    onContextMenu: [{ type: Output }],
    onDoubleClick: [{ type: Output }],
    onColumnVisibilityChanged: [{ type: Output }],
    onColumnMovingStart: [{ type: Output }],
    onColumnMoving: [{ type: Output }],
    onColumnMovingEnd: [{ type: Output }],
    onGridKeydown: [{ type: Output }],
    onRowDragStart: [{ type: Output }],
    onRowDragEnd: [{ type: Output }],
    onGridCopy: [{ type: Output }],
    expansionStatesChange: [{ type: Output }],
    onRowToggle: [{ type: Output }],
    onRowPinning: [{ type: Output }],
    activeNodeChange: [{ type: Output }],
    addRowSnackbar: [{ type: ViewChild, args: [IgxSnackbarComponent,] }],
    resizeLine: [{ type: ViewChild, args: [IgxGridColumnResizerComponent,] }],
    loadingOverlay: [{ type: ViewChild, args: ['loadingOverlay', { static: true },] }],
    loadingOutlet: [{ type: ViewChild, args: ['igxLoadingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    columnList: [{ type: ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: true },] }],
    actionStrip: [{ type: ContentChild, args: [IgxActionStripComponent,] }],
    excelStyleLoadingValuesTemplateDirective: [{ type: ContentChild, args: [IgxExcelStyleLoadingValuesTemplateDirective, { read: IgxExcelStyleLoadingValuesTemplateDirective, static: true },] }],
    excelStyleFilteringComponents: [{ type: ContentChildren, args: [IgxGridExcelStyleFilteringComponent, { read: IgxGridExcelStyleFilteringComponent, descendants: false },] }],
    headerGroups: [{ type: ViewChildren, args: [IgxGridHeaderGroupComponent, { read: IgxGridHeaderGroupComponent },] }],
    _rowList: [{ type: ViewChildren, args: ['row',] }],
    _pinnedRowList: [{ type: ViewChildren, args: ['pinnedRow',] }],
    _summaryRowList: [{ type: ViewChildren, args: ['summaryRow', { read: IgxSummaryRowComponent },] }],
    _dataRowList: [{ type: ViewChildren, args: [IgxRowDirective, { read: IgxRowDirective },] }],
    emptyFilteredGridTemplate: [{ type: ViewChild, args: ['emptyFilteredGrid', { read: TemplateRef, static: true },] }],
    emptyGridDefaultTemplate: [{ type: ViewChild, args: ['defaultEmptyGrid', { read: TemplateRef, static: true },] }],
    loadingGridDefaultTemplate: [{ type: ViewChild, args: ['defaultLoadingGrid', { read: TemplateRef, static: true },] }],
    parentVirtDir: [{ type: ViewChild, args: ['scrollContainer', { read: IgxGridForOfDirective, static: true },] }],
    toolbarCustomContentTemplates: [{ type: ContentChildren, args: [IgxGridToolbarCustomContentDirective, { read: IgxGridToolbarCustomContentDirective, descendants: false },] }],
    headSelectorsTemplates: [{ type: ContentChildren, args: [IgxHeadSelectorDirective, { read: IgxHeadSelectorDirective, descendants: false },] }],
    rowSelectorsTemplates: [{ type: ContentChildren, args: [IgxRowSelectorDirective, { read: IgxRowSelectorDirective, descendants: false },] }],
    dragGhostCustomTemplates: [{ type: ContentChildren, args: [IgxRowDragGhostDirective, { read: TemplateRef, descendants: false },] }],
    verticalScrollContainer: [{ type: ViewChild, args: ['verticalScrollContainer', { read: IgxGridForOfDirective, static: true },] }],
    verticalScroll: [{ type: ViewChild, args: ['verticalScrollHolder', { read: IgxGridForOfDirective, static: true },] }],
    scr: [{ type: ViewChild, args: ['scr', { read: ElementRef, static: true },] }],
    footer: [{ type: ViewChild, args: ['footer', { read: ElementRef },] }],
    headerContainer: [{ type: ViewChild, args: ['hContainer', { read: IgxGridForOfDirective, static: true },] }],
    headerSelectorContainer: [{ type: ViewChild, args: ['headerSelectorContainer',] }],
    headerDragContainer: [{ type: ViewChild, args: ['headerDragContainer',] }],
    headerGroupContainer: [{ type: ViewChild, args: ['headerGroupContainer',] }],
    filteringRow: [{ type: ViewChild, args: ['filteringRow', { read: IgxGridFilteringRowComponent },] }],
    theadRow: [{ type: ViewChild, args: ['theadRow', { static: true },] }],
    tbody: [{ type: ViewChild, args: ['tbody', { static: true },] }],
    pinContainer: [{ type: ViewChild, args: ['pinContainer', { read: ElementRef },] }],
    tfoot: [{ type: ViewChild, args: ['tfoot', { static: true },] }],
    _outletDirective: [{ type: ViewChild, args: ['igxFilteringOverlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    rowEditingOutletDirective: [{ type: ViewChild, args: ['igxRowEditingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    tmpOutlets: [{ type: ViewChildren, args: [IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective },] }],
    dragIndicatorIconBase: [{ type: ViewChild, args: ['dragIndicatorIconBase', { read: TemplateRef, static: true },] }],
    defaultRowEditTemplate: [{ type: ViewChild, args: ['defaultRowEditTemplate', { read: TemplateRef, static: true },] }],
    rowEditCustom: [{ type: ContentChild, args: [IgxRowEditTemplateDirective, { read: TemplateRef },] }],
    rowEditText: [{ type: ContentChild, args: [IgxRowEditTextDirective, { read: TemplateRef },] }],
    rowEditActions: [{ type: ContentChild, args: [IgxRowEditActionsDirective, { read: TemplateRef },] }],
    rowExpandedIndicatorTemplate: [{ type: ContentChild, args: [IgxRowExpandedIndicatorDirective, { read: TemplateRef },] }],
    rowCollapsedIndicatorTemplate: [{ type: ContentChild, args: [IgxRowCollapsedIndicatorDirective, { read: TemplateRef },] }],
    headerExpandIndicatorTemplate: [{ type: ContentChild, args: [IgxHeaderExpandIndicatorDirective, { read: TemplateRef },] }],
    headerCollapseIndicatorTemplate: [{ type: ContentChild, args: [IgxHeaderCollapseIndicatorDirective, { read: TemplateRef },] }],
    dragIndicatorIconTemplates: [{ type: ContentChildren, args: [IgxDragIndicatorIconDirective, { read: TemplateRef, descendants: false },] }],
    rowEditTabsDEFAULT: [{ type: ViewChildren, args: [IgxRowEditTabStopDirective,] }],
    rowEditTabsCUSTOM: [{ type: ContentChildren, args: [IgxRowEditTabStopDirective, { descendants: true },] }],
    rowEditingOverlay: [{ type: ViewChild, args: [IgxToggleDirective,] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    hostClass: [{ type: HostBinding, args: ['attr.class',] }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }],
    sortingExpressions: [{ type: Input }],
    sortingExpressionsChange: [{ type: Output }],
    hiddenColumnsText: [{ type: Input }],
    pinnedColumnsText: [{ type: Input }],
    toolbar: [{ type: ViewChild, args: ['toolbar', { read: IgxGridToolbarComponent },] }],
    toolbarHtml: [{ type: ViewChild, args: ['toolbar', { read: ElementRef },] }],
    showToolbar: [{ type: Input }],
    toolbarTitle: [{ type: Input }],
    exportExcel: [{ type: Input }],
    exportCsv: [{ type: Input }],
    exportText: [{ type: Input }],
    exportExcelText: [{ type: Input }],
    exportCsvText: [{ type: Input }],
    clipboardOptions: [{ type: Input }],
    cellSelection: [{ type: Input }],
    rowSelection: [{ type: Input }],
    columnSelection: [{ type: Input }],
    onToolbarExporting: [{ type: Output }],
    onRangeSelection: [{ type: Output }],
    hideActionStrip: [{ type: HostListener, args: ['mouseleave', ['$event'],] }],
    expansionStates: [{ type: Input }],
    outlet: [{ type: Input }],
    totalRecords: [{ type: Input }]
};
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "filteringLogic", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "filteringExpressionsTree", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "advancedFilteringExpressionsTree", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "hideRowSelectors", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "rowEditable", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "height", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "width", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "rowHeight", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "columnWidth", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "primaryKey", void 0);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "isLoading", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "columnPinning", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "sortingExpressions", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "hiddenColumnsText", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "pinnedColumnsText", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "showToolbar", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "toolbarTitle", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "exportExcel", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "exportCsv", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "exportText", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "exportExcelText", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "exportCsvText", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "cellSelection", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "rowSelection", null);
__decorate([
    WatchChanges()
], IgxGridBaseDirective.prototype, "columnSelection", null);

class IgxGridAPIService extends GridBaseAPIService {
    groupBy(expression) {
        const groupingState = cloneArray(this.grid.groupingExpressions);
        const sortingState = cloneArray(this.grid.sortingExpressions);
        this.prepare_sorting_expression([sortingState, groupingState], expression);
        this.grid.groupingExpressions = groupingState;
        this.arrange_sorting_expressions();
    }
    groupBy_multiple(expressions) {
        const groupingState = cloneArray(this.grid.groupingExpressions);
        const sortingState = cloneArray(this.grid.sortingExpressions);
        for (const each of expressions) {
            this.prepare_sorting_expression([sortingState, groupingState], each);
        }
        this.grid.groupingExpressions = groupingState;
        this.arrange_sorting_expressions();
    }
    clear_groupby(name) {
        const groupingState = cloneArray(this.grid.groupingExpressions);
        const sortingState = cloneArray(this.grid.sortingExpressions);
        if (name) {
            const names = typeof name === 'string' ? [name] : name;
            const groupedCols = groupingState.filter((state) => names.indexOf(state.fieldName) < 0);
            const newSortingExpr = sortingState.filter((state) => names.indexOf(state.fieldName) < 0);
            this.grid.groupingExpressions = groupedCols;
            this.grid.sortingExpressions = newSortingExpr;
            names.forEach((colName) => {
                const grExprIndex = groupingState.findIndex((exp) => exp.fieldName === colName);
                const grpExpandState = this.grid.groupingExpansionState;
                /* remove expansion states related to the cleared group
                   and all with deeper hierarchy than the cleared group */
                const newExpandState = grpExpandState.filter((val) => {
                    return val.hierarchy && val.hierarchy.length <= grExprIndex;
                });
                /* Do not set the new instance produced by filter
                    when there are no differences between expansion states */
                if (newExpandState.length !== grpExpandState.length) {
                    this.grid.groupingExpansionState = newExpandState;
                }
            });
        }
        else {
            // clear all
            this.grid.groupingExpressions = [];
            this.grid.groupingExpansionState = [];
            for (const grExpr of groupingState) {
                const sortExprIndex = sortingState.findIndex((exp) => exp.fieldName === grExpr.fieldName);
                if (sortExprIndex > -1) {
                    sortingState.splice(sortExprIndex, 1);
                }
            }
            this.grid.sortingExpressions = sortingState;
        }
    }
    groupBy_get_expanded_for_group(groupRow) {
        const grState = this.grid.groupingExpansionState;
        const hierarchy = DataUtil.getHierarchy(groupRow);
        return grState.find((state) => DataUtil.isHierarchyMatch(state.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy));
    }
    groupBy_is_row_in_group(groupRow, rowID) {
        const grid = this.grid;
        let rowInGroup = false;
        groupRow.records.forEach(row => {
            if (grid.primaryKey ? row[grid.primaryKey] === rowID : row === rowID) {
                rowInGroup = true;
            }
        });
        return rowInGroup;
    }
    groupBy_toggle_group(groupRow) {
        const grid = this.grid;
        if (grid.crudService.cellInEditMode) {
            grid.endEdit(true);
        }
        const expansionState = grid.groupingExpansionState;
        const state = this.groupBy_get_expanded_for_group(groupRow);
        if (state) {
            state.expanded = !state.expanded;
        }
        else {
            expansionState.push({
                expanded: !grid.groupsExpanded,
                hierarchy: DataUtil.getHierarchy(groupRow)
            });
        }
        this.grid.groupingExpansionState = [...expansionState];
        if (grid.rowEditable) {
            grid.repositionRowEditingOverlay(grid.rowInEditMode);
        }
    }
    groupBy_fully_expand_group(groupRow) {
        const state = this.groupBy_get_expanded_for_group(groupRow);
        const expanded = state ? state.expanded : this.grid.groupsExpanded;
        if (!expanded) {
            this.groupBy_toggle_group(groupRow);
        }
        if (groupRow.groupParent) {
            this.groupBy_fully_expand_group(groupRow.groupParent);
        }
    }
    remove_grouping_expression(fieldName) {
        const groupingExpressions = this.grid.groupingExpressions;
        const index = groupingExpressions.findIndex((expr) => expr.fieldName === fieldName);
        if (index !== -1) {
            groupingExpressions.splice(index, 1);
        }
    }
    arrange_sorting_expressions() {
        const groupingState = this.grid.groupingExpressions;
        this.grid.sortingExpressions.sort((a, b) => {
            const groupExprA = groupingState.find((expr) => expr.fieldName === a.fieldName);
            const groupExprB = groupingState.find((expr) => expr.fieldName === b.fieldName);
            if (groupExprA && groupExprB) {
                return groupingState.indexOf(groupExprA) > groupingState.indexOf(groupExprB) ? 1 : -1;
            }
            else if (groupExprA) {
                return -1;
            }
            else if (groupExprB) {
                return 1;
            }
            else {
                return 0;
            }
        });
    }
    get_groupBy_record_id(gRow) {
        let recordId = '{ ';
        const hierrarchy = DataUtil.getHierarchy(gRow);
        for (let i = 0; i < hierrarchy.length; i++) {
            const groupByKey = hierrarchy[i];
            recordId += `'${groupByKey.fieldName}': '${groupByKey.value}'`;
            if (i < hierrarchy.length - 1) {
                recordId += ', ';
            }
        }
        recordId += ' }';
        return recordId;
    }
}
IgxGridAPIService.ɵfac = function IgxGridAPIService_Factory(t) { return ɵIgxGridAPIService_BaseFactory(t || IgxGridAPIService); };
IgxGridAPIService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxGridAPIService, factory: IgxGridAPIService.ɵfac });

class IgxGridGroupByRowComponent {
    constructor(gridAPI, gridSelection, element, cdr) {
        this.gridAPI = gridAPI;
        this.gridSelection = gridSelection;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */
        this.defaultCssClass = 'igx-grid__group-row';
        /**
         * @hidden
         */
        this.paddingIndentationCssClass = 'igx-grid__group-row--padding-level';
        /**
         * @hidden
         */
        this.isFocused = false;
    }
    /**
     * Returns whether the row is focused.
     * ```
     * let gridRowFocused = this.grid1.rowList.first.focused;
     * ```
     */
    get focused() {
        return this.isActive();
    }
    /**
     * Returns whether the group row is expanded.
     * ```typescript
     * const groupRowExpanded = this.grid1.rowList.first.expanded;
     * ```
     */
    get expanded() {
        return this.grid.isExpandedGroup(this.groupRow);
    }
    /**
     * @hidden
     */
    get describedBy() {
        const grRowExpr = this.groupRow.expression !== undefined ? this.groupRow.expression.fieldName : '';
        return this.gridID + '_' + grRowExpr;
    }
    get dataRowIndex() {
        return this.index;
    }
    /**
     * Returns a reference to the underlying HTML element.
     * ```typescript
     * const groupRowElement = this.nativeElement;
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    get attrCellID() {
        return `${this.gridID}_${this.index}`;
    }
    /**
     * Returns the style classes applied to the group rows.
     * ```typescript
     * const groupCssStyles = this.grid1.rowList.first.styleClasses;
     * ```
     */
    get styleClasses() {
        return `${this.defaultCssClass} ` + `${this.paddingIndentationCssClass}-` + this.groupRow.level +
            (this.isActive() ? ` ${this.defaultCssClass}--active` : '');
    }
    isActive() {
        return this.grid.navigation.activeNode ? this.grid.navigation.activeNode.row === this.index : false;
    }
    activate() {
        this.grid.navigation.setActiveNode({ row: this.index }, 'groupRow');
    }
    /**
     * Toggles the group row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     */
    toggle() {
        this.grid.toggleGroup(this.groupRow);
    }
    get iconTemplate() {
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultGroupByExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultGroupByCollapsedTemplate;
        }
    }
    get selectionNode() {
        return {
            row: this.index,
            column: this.gridSelection.activeElement ? this.gridSelection.activeElement.column : 0
        };
    }
    /**
     * Returns a reference to the `IgxGridComponent` the `IgxGridGroupByRowComponent` belongs to.
     * ```typescript
     * this.grid1.rowList.first.grid;
     * ```
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * @hidden
     */
    get dataType() {
        const column = this.groupRow.column;
        return (column && column.dataType) || DataType.String;
    }
}
IgxGridGroupByRowComponent.ɵfac = function IgxGridGroupByRowComponent_Factory(t) { return new (t || IgxGridGroupByRowComponent)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxGridGroupByRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridGroupByRowComponent, selectors: [["igx-grid-groupby-row"]], viewQuery: function IgxGridGroupByRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c162, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c163, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c164, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultGroupByExpandedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultGroupByCollapsedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupContent = _t.first);
    } }, hostVars: 6, hostBindings: function IgxGridGroupByRowComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("pointerdown", function IgxGridGroupByRowComponent_pointerdown_HostBindingHandler() { return ctx.activate(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.expanded)("aria-describedby", ctx.describedBy)("data-rowIndex", ctx.dataRowIndex)("id", ctx.attrCellID);
        ɵngcc0.ɵɵclassMap(ctx.styleClasses);
    } }, inputs: { isFocused: "isFocused", index: "index", gridID: "gridID", groupRow: "groupRow" }, decls: 13, vars: 8, consts: [["defaultGroupRow", ""], [1, "igx-grid__grouping-indicator", 3, "click"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-grid__group-content"], ["groupContent", ""], ["defaultGroupByExpandedTemplate", ""], ["defaultGroupByCollapsedTemplate", ""], ["defaultGroupByTemplate", ""], ["fontSet", "material"], [1, "igx-group-label"], ["fontSet", "material", 1, "igx-group-label__icon"], [1, "igx-group-label__column-name"], [4, "ngIf", "ngIfElse"], ["default", ""], [1, "igx-group-label__count-badge", 3, "value"], [1, "igx-group-label__text"], [4, "ngIf"]], template: function IgxGridGroupByRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, null, 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵlistener("click", function IgxGridGroupByRowComponent_Template_div_click_2_listener() { return ctx.toggle(); });
        ɵngcc0.ɵɵtemplate(3, IgxGridGroupByRowComponent_ng_container_3_Template, 1, 0, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 3, 4);
        ɵngcc0.ɵɵtemplate(6, IgxGridGroupByRowComponent_ng_container_6_Template, 1, 0, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, IgxGridGroupByRowComponent_ng_template_7_Template, 2, 0, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(9, IgxGridGroupByRowComponent_ng_template_9_Template, 2, 0, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(11, IgxGridGroupByRowComponent_ng_template_11_Template, 9, 4, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        const _r8 = ɵngcc0.ɵɵreference(12);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.iconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(4, _c17, ctx));
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.grid.groupRowTemplate ? ctx.grid.groupRowTemplate : _r8)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(6, _c17, ctx.groupRow));
    } }, directives: [ɵngcc2.NgTemplateOutlet, IgxIconComponent, ɵngcc2.NgIf, IgxBadgeComponent], pipes: [ɵngcc2.DecimalPipe, ɵngcc2.DatePipe], encapsulation: 2, changeDetection: 0 });
IgxGridGroupByRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxGridSelectionService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxGridGroupByRowComponent.propDecorators = {
    defaultGroupByExpandedTemplate: [{ type: ViewChild, args: ['defaultGroupByExpandedTemplate', { read: TemplateRef, static: true },] }],
    defaultGroupByCollapsedTemplate: [{ type: ViewChild, args: ['defaultGroupByCollapsedTemplate', { read: TemplateRef, static: true },] }],
    isFocused: [{ type: Input }],
    index: [{ type: Input }],
    gridID: [{ type: Input }],
    groupRow: [{ type: Input }],
    groupContent: [{ type: ViewChild, args: ['groupContent', { static: true },] }],
    expanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
    describedBy: [{ type: HostBinding, args: ['attr.aria-describedby',] }],
    dataRowIndex: [{ type: HostBinding, args: ['attr.data-rowIndex',] }],
    attrCellID: [{ type: HostBinding, args: ['attr.id',] }],
    styleClasses: [{ type: HostBinding, args: ['class',] }],
    activate: [{ type: HostListener, args: ['pointerdown',] }]
};

/** @hidden */
class IgxGridMRLNavigationService extends IgxGridNavigationService {
    getNextPosition(rowIndex, colIndex, key, shift, ctrl, event) {
        if (!this.activeNode.layout) {
            this.activeNode.layout = this.layout(this.activeNode.column || 0);
        }
        switch (key) {
            case 'tab':
            case ' ':
            case 'spacebar':
            case 'space':
            case 'escape':
            case 'esc':
            case 'enter':
            case 'f2':
                super.getNextPosition(rowIndex, colIndex, key, shift, ctrl, event);
                break;
            case 'end':
                rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row;
                colIndex = ctrl ? this.lastColIndexPerMRLBlock(this.lastIndexPerRow) : this.lastIndexPerRow;
                break;
            case 'home':
                rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row;
                colIndex = ctrl ? 0 : this.firstIndexPerRow;
                break;
            case 'arrowleft':
            case 'left':
                colIndex = ctrl ? this.firstIndexPerRow : this.getNextHorizontalCellPosition(true).column;
                break;
            case 'arrowright':
            case 'right':
                colIndex = ctrl ? this.lastIndexPerRow : this.getNextHorizontalCellPosition().column;
                break;
            case 'arrowup':
            case 'up':
                const prevPos = this.getNextVerticalPosition(true);
                colIndex = ctrl ? this.activeNode.column : prevPos.column;
                rowIndex = ctrl ? this.findFirstDataRowIndex() : prevPos.row;
                break;
            case 'arrowdown':
            case 'down':
                const nextPos = this.getNextVerticalPosition();
                colIndex = ctrl ? this.activeNode.column : nextPos.column;
                rowIndex = ctrl ? this.findLastDataRowIndex() : nextPos.row;
                break;
            default:
                return;
        }
        const nextLayout = this.layout(colIndex);
        const newLayout = key.includes('up') || key.includes('down') ? { rowStart: nextLayout.rowStart } : { colStart: nextLayout.colStart };
        Object.assign(this.activeNode.layout, newLayout, { rowEnd: nextLayout.rowEnd });
        if (ctrl && (key === 'home' || key === 'end')) {
            this.activeNode.layout = nextLayout;
        }
        return { rowIndex, colIndex };
    }
    isValidPosition(rowIndex, colIndex) {
        if (rowIndex < 0 || colIndex < 0 || this.grid.dataView.length - 1 < rowIndex ||
            Math.max(...this.grid.visibleColumns.map(col => col.visibleIndex)) < colIndex ||
            (this.activeNode.column !== colIndex && !this.isDataRow(rowIndex, true))) {
            return false;
        }
        return true;
    }
    shouldPerformVerticalScroll(targetRowIndex, visibleColIndex) {
        if (!super.shouldPerformVerticalScroll(targetRowIndex, visibleColIndex)) {
            return false;
        }
        if (!this.isDataRow(targetRowIndex) || visibleColIndex < 0) {
            return super.shouldPerformVerticalScroll(targetRowIndex, visibleColIndex);
        }
        const targetRow = super.getRowElementByIndex(targetRowIndex);
        const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        const scrollPos = this.getVerticalScrollPositions(targetRowIndex, visibleColIndex);
        return (!targetRow || targetRow.offsetTop + scrollPos.topOffset < Math.abs(this.containerTopOffset)
            || containerHeight && containerHeight < scrollPos.rowBottom - Math.ceil(this.scrollTop));
    }
    isColumnFullyVisible(visibleColIndex) {
        const targetCol = this.grid.getColumnByVisibleIndex(visibleColIndex);
        if (this.isParentColumnFullyVisible(targetCol === null || targetCol === void 0 ? void 0 : targetCol.parent) || super.isColumnPinned(visibleColIndex, this.forOfDir())) {
            return true;
        }
        const scrollPos = this.getChildColumnScrollPositions(visibleColIndex);
        const colWidth = scrollPos.rightScroll - scrollPos.leftScroll;
        if (this.displayContainerWidth < colWidth && this.displayContainerScrollLeft === scrollPos.leftScroll) {
            return true;
        }
        return this.displayContainerWidth >= scrollPos.rightScroll - this.displayContainerScrollLeft &&
            this.displayContainerScrollLeft <= scrollPos.leftScroll;
    }
    isParentColumnFullyVisible(parent) {
        if (!this.forOfDir().getScroll().clientWidth || (parent === null || parent === void 0 ? void 0 : parent.pinned)) {
            return true;
        }
        const index = this.forOfDir().igxForOf.indexOf(parent);
        return this.displayContainerWidth >= this.forOfDir().getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft &&
            this.displayContainerScrollLeft <= this.forOfDir().getColumnScrollLeft(index);
    }
    getChildColumnScrollPositions(visibleColIndex) {
        const targetCol = this.grid.getColumnByVisibleIndex(visibleColIndex);
        const parentVIndex = this.forOfDir().igxForOf.indexOf(targetCol.parent);
        let leftScroll = this.forOfDir().getColumnScrollLeft(parentVIndex);
        let rightScroll = this.forOfDir().getColumnScrollLeft(parentVIndex + 1);
        targetCol.parent.children.forEach((c) => {
            if (c.rowStart >= targetCol.rowStart && c.visibleIndex < targetCol.visibleIndex) {
                leftScroll += parseInt(c.width, 10);
            }
            if (c.rowStart <= targetCol.rowStart && c.visibleIndex > targetCol.visibleIndex) {
                rightScroll -= parseInt(c.width, 10);
            }
        });
        return { leftScroll, rightScroll: rightScroll };
    }
    getVerticalScrollPositions(rowIndex, visibleIndex) {
        const targetCol = this.grid.getColumnByVisibleIndex(visibleIndex);
        const rowSpan = targetCol.rowEnd && targetCol.rowEnd - targetCol.rowStart ? targetCol.rowEnd - targetCol.rowStart : 1;
        const topOffset = this.grid.defaultRowHeight * (targetCol.rowStart - 1);
        const rowTop = this.grid.verticalScrollContainer.sizesCache[rowIndex] + topOffset;
        return { topOffset, rowTop, rowBottom: rowTop + (this.grid.defaultRowHeight * rowSpan) };
    }
    performHorizontalScrollToCell(visibleColumnIndex, cb) {
        if (!this.shouldPerformHorizontalScroll(visibleColumnIndex)) {
            return;
        }
        const scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);
        const startScroll = scrollPos.rightScroll - this.displayContainerScrollLeft;
        const nextScroll = !(this.displayContainerScrollLeft <= scrollPos.leftScroll) && this.displayContainerWidth >= startScroll ?
            scrollPos.leftScroll : scrollPos.rightScroll - this.displayContainerWidth;
        this.forOfDir().getScroll().scrollLeft = nextScroll;
        this.grid.parentVirtDir.onChunkLoad
            .pipe(first$1())
            .subscribe(() => {
            if (cb) {
                cb();
            }
        });
    }
    performVerticalScrollToCell(rowIndex, visibleColIndex, cb) {
        var _a;
        const children = (_a = this.parentByChildIndex(visibleColIndex || 0)) === null || _a === void 0 ? void 0 : _a.children;
        if (!super.isDataRow(rowIndex) || (children && children.length < 2) || visibleColIndex < 0) {
            return super.performVerticalScrollToCell(rowIndex, visibleColIndex, cb);
        }
        const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        const pos = this.getVerticalScrollPositions(rowIndex, visibleColIndex);
        const row = super.getRowElementByIndex(rowIndex);
        if ((this.scrollTop > pos.rowTop) && (!row || row.offsetTop + pos.topOffset < Math.abs(this.containerTopOffset))) {
            pos.topOffset === 0 ? this.grid.verticalScrollContainer.scrollTo(rowIndex) :
                this.grid.verticalScrollContainer.scrollPosition = pos.rowTop;
        }
        else {
            this.grid.verticalScrollContainer.addScrollTop(Math.abs(pos.rowBottom - this.scrollTop - containerHeight));
        }
        this.grid.verticalScrollContainer.onChunkLoad
            .pipe(first$1()).subscribe(() => {
            if (cb) {
                cb();
            }
        });
    }
    getNextHorizontalCellPosition(previous = false) {
        const parent = this.parentByChildIndex(this.activeNode.column);
        if (!this.hasNextHorizontalPosition(previous, parent)) {
            return { row: this.activeNode.row, column: this.activeNode.column };
        }
        const columns = previous ? parent.children.filter(c => c.rowStart <= this.activeNode.layout.rowStart)
            .sort((a, b) => b.visibleIndex - a.visibleIndex) : parent.children.filter(c => c.rowStart <= this.activeNode.layout.rowStart);
        let column = columns.find((col) => previous ?
            col.visibleIndex < this.activeNode.column && this.rowEnd(col) > this.activeNode.layout.rowStart :
            col.visibleIndex > this.activeNode.column && col.colStart > this.activeNode.layout.colStart);
        if (!column || (previous && this.activeNode.layout.colStart === 1)) {
            const index = previous ? parent.visibleIndex - 1 : parent.visibleIndex + 1;
            const children = this.grid.columnList.find(cols => cols.columnLayout && cols.visibleIndex === index).children;
            column = previous ? children.toArray().reverse().find(child => child.rowStart <= this.activeNode.layout.rowStart) :
                children.find(child => this.rowEnd(child) > this.activeNode.layout.rowStart && child.colStart === 1);
        }
        return { row: this.activeNode.row, column: column.visibleIndex };
    }
    getNextVerticalPosition(previous = false) {
        this.activeNode.column = this.activeNode.column || 0;
        if (!this.hasNextVerticalPosition(previous)) {
            return { row: this.activeNode.row, column: this.activeNode.column };
        }
        const currentRowStart = this.grid.getColumnByVisibleIndex(this.activeNode.column).rowStart;
        const nextBlock = !this.isDataRow(this.activeNode.row) ||
            (previous ? currentRowStart === 1 : currentRowStart === this.lastRowStartPerBlock());
        const nextRI = previous ? this.activeNode.row - 1 : this.activeNode.row + 1;
        if (nextBlock && !this.isDataRow(nextRI)) {
            return { row: nextRI, column: this.activeNode.column };
        }
        const children = this.parentByChildIndex(this.activeNode.column).children;
        const col = previous ? this.getPreviousRowIndex(children, nextBlock) : this.getNextRowIndex(children, nextBlock);
        return { row: nextBlock ? nextRI : this.activeNode.row, column: col.visibleIndex };
    }
    getNextRowIndex(children, next) {
        const rowStart = next ? 1 : this.rowEnd(this.grid.getColumnByVisibleIndex(this.activeNode.column));
        const col = children.filter(c => c.rowStart === rowStart);
        return col.find(co => co.colStart === this.activeNode.layout.colStart) ||
            col.sort((a, b) => b.visibleIndex - a.visibleIndex).find(co => co.colStart <= this.activeNode.layout.colStart);
    }
    getPreviousRowIndex(children, prev) {
        const end = prev ? Math.max(...children.map(c => this.rowEnd(c))) :
            this.grid.getColumnByVisibleIndex(this.activeNode.column).rowStart;
        const col = children.filter(c => this.rowEnd(c) === end);
        return col.find(co => co.colStart === this.activeNode.layout.colStart) ||
            col.sort((a, b) => b.visibleIndex - a.visibleIndex).find(co => co.colStart <= this.activeNode.layout.colStart);
    }
    headerNavigation(event) {
        const key = event.key.toLowerCase();
        if (!HEADER_KEYS.has(key)) {
            return;
        }
        event.preventDefault();
        if (!this.activeNode.layout) {
            this.activeNode.layout = this.layout(this.activeNode.column || 0);
        }
        const alt = event.altKey;
        const ctrl = event.ctrlKey;
        this.performHeaderKeyCombination(this.grid.getColumnByVisibleIndex(this.activeNode.column), key, event.shiftKey, ctrl, alt, event);
        if (!ctrl && !alt && (key.includes('down') || key.includes('up'))) {
            const children = this.parentByChildIndex(this.activeNode.column).children;
            const col = key.includes('down') ? this.getNextRowIndex(children, false) : this.getPreviousRowIndex(children, false);
            if (!col) {
                return;
            }
            this.activeNode.column = col.visibleIndex;
            const layout = this.layout(this.activeNode.column);
            const nextLayout = Object.assign(Object.assign({}, this.activeNode.layout), { rowStart: layout.rowStart, rowEnd: layout.rowEnd });
            this.setActiveNode({ row: this.activeNode.row, layout: nextLayout });
            return;
        }
        this.horizontalNav(event, key, -1, 'headerCell');
    }
    horizontalNav(event, key, rowIndex, tag) {
        const ctrl = event.ctrlKey;
        if (!HORIZONTAL_NAV_KEYS.has(key) || event.altKey) {
            return;
        }
        this.activeNode.row = rowIndex;
        const newActiveNode = {
            column: this.activeNode.column,
            mchCache: {
                level: this.activeNode.level,
                visibleIndex: this.activeNode.column
            }
        };
        if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {
            newActiveNode.column = ctrl || key === 'home' ? this.firstIndexPerRow : this.getNextHorizontalCellPosition(true).column;
        }
        if ((key.includes('right') || key === 'end') && this.activeNode.column !== this.lastIndexPerRow) {
            newActiveNode.column = ctrl || key === 'end' ? this.lastIndexPerRow : this.getNextHorizontalCellPosition().column;
        }
        if (tag === 'headerCell') {
            const column = this.grid.getColumnByVisibleIndex(newActiveNode.column);
            newActiveNode.mchCache.level = column.level;
            newActiveNode.mchCache.visibleIndex = column.visibleIndex;
        }
        const layout = this.layout(newActiveNode.column);
        const newLayout = Object.assign(Object.assign({}, this.activeNode.layout), { colStart: layout.colStart, rowEnd: layout.rowEnd });
        this.setActiveNode({ row: this.activeNode.row, column: newActiveNode.column,
            layout: newLayout, mchCache: newActiveNode.mchCache });
        this.performHorizontalScrollToCell(newActiveNode.column);
    }
    get lastIndexPerRow() {
        const children = this.grid.visibleColumns.find(c => c.visibleIndex === this.lastLayoutIndex && c.columnLayout)
            .children.toArray().reverse();
        const column = children.find(co => co.rowStart === this.activeNode.layout.rowStart) ||
            children.find(co => co.rowStart <= this.activeNode.layout.rowStart);
        return column.visibleIndex;
    }
    get firstIndexPerRow() {
        const children = this.grid.visibleColumns.find(c => c.visibleIndex === 0 && c.columnLayout).children;
        const column = children.find(co => co.rowStart === this.activeNode.layout.rowStart) ||
            children.find(co => co.rowStart <= this.activeNode.layout.rowStart);
        return column.visibleIndex;
    }
    get lastLayoutIndex() {
        return Math.max(...this.grid.visibleColumns.filter(c => c.columnLayout).map(col => col.visibleIndex));
    }
    get scrollTop() {
        return Math.abs(this.grid.verticalScrollContainer.getScroll().scrollTop);
    }
    lastColIndexPerMRLBlock(visibleIndex = this.activeNode.column) {
        return this.parentByChildIndex(visibleIndex).children.last.visibleIndex;
    }
    lastRowStartPerBlock(visibleIndex = this.activeNode.column) {
        return Math.max(...this.parentByChildIndex(visibleIndex).children.map(c => c.rowStart));
    }
    rowEnd(column) {
        return column.rowEnd && column.rowEnd - column.rowStart ? column.rowStart + column.rowEnd - column.rowStart : column.rowStart + 1;
    }
    /**
     * @hidden
     * @internal
     */
    layout(visibleIndex) {
        const column = this.grid.getColumnByVisibleIndex(visibleIndex);
        return { colStart: column.colStart, rowStart: column.rowStart,
            colEnd: column.colEnd, rowEnd: column.rowEnd, columnVisibleIndex: column.visibleIndex };
    }
    parentByChildIndex(visibleIndex) {
        var _a;
        return (_a = this.grid.getColumnByVisibleIndex(visibleIndex)) === null || _a === void 0 ? void 0 : _a.parent;
    }
    hasNextHorizontalPosition(previous = false, parent) {
        if (previous && parent.visibleIndex === 0 && this.activeNode.layout.colStart === 1 ||
            !previous && parent.visibleIndex === this.lastLayoutIndex && this.activeNode.column === this.lastIndexPerRow) {
            return false;
        }
        return true;
    }
    hasNextVerticalPosition(prev = false) {
        if ((prev && this.activeNode.row === 0 && (!this.isDataRow(this.activeNode.row) || this.activeNode.layout.rowStart === 1)) ||
            (!prev && this.activeNode.row >= this.grid.dataView.length - 1 && this.activeNode.column === this.lastColIndexPerMRLBlock())) {
            return false;
        }
        return true;
    }
}
IgxGridMRLNavigationService.ɵfac = function IgxGridMRLNavigationService_Factory(t) { return ɵIgxGridMRLNavigationService_BaseFactory(t || IgxGridMRLNavigationService); };
IgxGridMRLNavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxGridMRLNavigationService, factory: IgxGridMRLNavigationService.ɵfac });

let NEXT_ID$o = 0;
/**
 * Grid provides a way to present and manipulate tabular data.
 * @igxModule IgxGridModule
 * @igxGroup Grids & Lists
 * @igxKeywords grid, table
 * @igxTheme igx-grid-theme
 * @remarks
 * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
 * has been bound, it can be manipulated through filtering, sorting & editing operations.
 * @example
 * ```html
 * <igx-grid [data]="employeeData" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-grid>
 * ```
 */
class IgxGridComponent extends IgxGridBaseDirective {
    constructor() {
        super(...arguments);
        this._id = `igx-grid-${NEXT_ID$o++}`;
        /**
         * @hidden
         */
        this._groupingExpressions = [];
        /**
         * @hidden
         */
        this._groupingExpandState = [];
        this._hideGroupedColumns = false;
        this._dropAreaMessage = null;
        this._showGroupArea = true;
        /**
         * Emitted when a new chunk of data is loaded from virtualization.
         * @example
         * ```typescript
         *  <igx-grid #grid [data]="localData" [autoGenerate]="true" (onDataPreLoad)='handleDataPreloadEvent()'></igx-grid>
         * ```
         */
        this.onDataPreLoad = new EventEmitter();
        this._filteredData = null;
        this.childDetailTemplates = new Map();
        /**
         * @hidden
         */
        this.groupingExpressionsChange = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.groupingExpansionStateChange = new EventEmitter();
        /**
         * Gets/Sets whether created groups are rendered expanded or collapsed.
         * @remarks
         * The default rendered state is expanded.
         * @example
         * ```html
         * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.groupsExpanded = true;
        /**
         * Gets the hierarchical representation of the group by records.
         * @example
         * ```typescript
         * let groupRecords = this.grid.groupsRecords;
         * ```
         */
        this.groupsRecords = [];
        /**
         * Emitted when columns are grouped/ungrouped.
         * @remarks
         * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
         * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
         * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
         * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
         * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
         * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
         * columns.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onGroupingDone = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.detailTemplate = null;
    }
    /**
     * Gets/Sets the value of the `id` attribute.
     * @remarks
     * If not provided it will be automatically generated.
     * @example
     * ```html
     * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    /**
     * Gets/Sets the array of data that populates the `IgxGridComponent`.
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get data() {
        return this._data;
    }
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
        }
        this.cdr.markForCheck();
    }
    /**
     * Gets/Sets an array of objects containing the filtered data.
     * @example
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * this.grid.filteredData = [...];
     * ```
     */
    get filteredData() {
        return this._filteredData;
    }
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Gets/Sets the total number of records in the data source.
     * @remarks
     * This property is required for remote grid virtualization to function when it is bound to remote data.
     * @example
     * ```typescript
     * const itemCount = this.grid1.totalItemCount;
     * this.grid1.totalItemCount = 55;
     * ```
     */
    set totalItemCount(count) {
        this.verticalScrollContainer.totalItemCount = count;
        this.cdr.detectChanges();
    }
    get totalItemCount() {
        return this.verticalScrollContainer.totalItemCount;
    }
    get _gridAPI() {
        return this.gridAPI;
    }
    /**
     * Gets/Sets the group by state.
     * @example
     * ```typescript
     * let groupByState = this.grid.groupingExpressions;
     * this.grid.groupingExpressions = [...];
     * ```
     * @remarks
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpressions)]="model.groupingExpressions"></igx-grid>
     * ```
     */
    get groupingExpressions() {
        return this._groupingExpressions;
    }
    set groupingExpressions(value) {
        if (value && value.length > 10) {
            throw Error('Maximum amount of grouped columns is 10.');
        }
        const oldExpressions = this.groupingExpressions;
        const newExpressions = value;
        this._groupingExpressions = cloneArray(value);
        this.groupingExpressionsChange.emit(this._groupingExpressions);
        this.chipsGoupingExpressions = cloneArray(value);
        if (this._gridAPI.grid) {
            /* grouping should work in conjunction with sorting
            and without overriding separate sorting expressions */
            this._applyGrouping();
            this._gridAPI.arrange_sorting_expressions();
            this.notifyChanges();
        }
        else {
            // setter called before grid is registered in grid API service
            this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);
        }
        if (!this._init && JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {
            const groupedCols = [];
            const ungroupedCols = [];
            const groupedColsArr = newExpressions.filter((obj) => {
                return !oldExpressions.some((obj2) => {
                    return obj.fieldName === obj2.fieldName;
                });
            });
            groupedColsArr.forEach((elem) => {
                groupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            const ungroupedColsArr = oldExpressions.filter((obj) => {
                return !newExpressions.some((obj2) => {
                    return obj.fieldName === obj2.fieldName;
                });
            });
            ungroupedColsArr.forEach((elem) => {
                ungroupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            this.notifyChanges();
            const groupingDoneArgs = {
                expressions: newExpressions,
                groupedColumns: groupedCols,
                ungroupedColumns: ungroupedCols
            };
            this.onGroupingDone.emit(groupingDoneArgs);
        }
    }
    /**
     * Gets/Sets a list of expansion states for group rows.
     * @remarks
     * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
     * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpansionState)]="model.groupingExpansionState"></igx-grid>
     * ```
     */
    get groupingExpansionState() {
        return this._groupingExpandState;
    }
    set groupingExpansionState(value) {
        if (value !== this._groupingExpandState) {
            this.groupingExpansionStateChange.emit(value);
        }
        this._groupingExpandState = value;
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
    }
    /**
     * Gets/Sets whether the grouped columns should be hidden.
     * @remarks
     * The default value is "false"
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get hideGroupedColumns() {
        return this._hideGroupedColumns;
    }
    set hideGroupedColumns(value) {
        if (value) {
            this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
        }
        else {
            this.groupingDiffer = null;
        }
        if (this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(value);
        }
        this._hideGroupedColumns = value;
    }
    /**
     * Gets/Sets the message displayed inside the GroupBy drop area where columns can be dragged on.
     * @remarks
     * The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
     * @example
     * ```html
     * <igx-grid dropAreaMessage="Drop here to group!">
     *      <igx-column [groupable]="true" field="ID"></igx-column>
     * </igx-grid>
     * ```
     */
    set dropAreaMessage(value) {
        this._dropAreaMessage = value;
        this.notifyChanges();
    }
    get dropAreaMessage() {
        return this._dropAreaMessage || this.resourceStrings.igx_grid_groupByArea_message;
    }
    /**
     * Gets the list of group rows.
     * @example
     * ```typescript
     * const groupList = this.grid.groupsRowList;
     * ```
     */
    get groupsRowList() {
        const res = new QueryList();
        if (!this._groupsRowList) {
            return res;
        }
        const rList = this._groupsRowList.filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        }).sort((item1, item2) => item1.index - item2.index);
        res.reset(rList);
        return res;
    }
    /**
     * @hidden @internal
     */
    getDetailsContext(rowData, index) {
        return {
            $implicit: rowData,
            index: index
        };
    }
    /**
     * @hidden @internal
     */
    trackChanges(index, rec) {
        if (rec.detailsData !== undefined) {
            return rec.detailsData;
        }
        return rec;
    }
    /**
     * @hidden @internal
     */
    detailsViewFocused(container, rowIndex) {
        this.navigation.setActiveNode({ row: rowIndex });
    }
    /**
     * @hidden @internal
     */
    get hasDetails() {
        return !!this.gridDetailsTemplate;
    }
    /**
     * @hidden @internal
     */
    getRowTemplate(rowData) {
        if (this.isGroupByRecord(rowData)) {
            return this.defaultGroupTemplate;
        }
        else if (this.isSummaryRow(rowData)) {
            return this.summaryTemplate;
        }
        else if (this.hasDetails && this.isDetailRecord(rowData)) {
            return this.detailTemplateContainer;
        }
        else {
            return this.recordTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    isDetailRecord(record) {
        return record.detailsData !== undefined;
    }
    /**
     * @hidden @internal
     */
    isDetailActive(rowIndex) {
        return this.navigation.activeNode ? this.navigation.activeNode.row === rowIndex : false;
    }
    /**
     * @hidden @internal
     */
    get groupAreaHostClass() {
        return this.getComponentDensityClass('igx-drop-area');
    }
    /**
     * Gets/Sets the template reference for the group row.
     * @example
     * ```
     * const groupRowTemplate = this.grid.groupRowTemplate;
     * this.grid.groupRowTemplate = myRowTemplate;
     * ```
     */
    get groupRowTemplate() {
        return this._groupRowTemplate;
    }
    set groupRowTemplate(template) {
        this._groupRowTemplate = template;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the template reference of the `IgxGridComponent`'s group area.
     * @example
     * ```typescript
     * const groupAreaTemplate = this.grid.groupAreaTemplate;
     * this.grid.groupAreaTemplate = myAreaTemplate.
     * ```
     */
    get groupAreaTemplate() {
        return this._groupAreaTemplate;
    }
    set groupAreaTemplate(template) {
        this._groupAreaTemplate = template;
        this.notifyChanges();
    }
    /**
     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
     * @remarks
     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
     * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
     * @example
     * ```typescript
     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * this.grid.groupBy([
     *     { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
     *     { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
     *     { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
     * ]);
     * ```
     */
    groupBy(expression) {
        if (this.checkIfNoColumnField(expression)) {
            return;
        }
        this.endEdit(true);
        if (expression instanceof Array) {
            this._gridAPI.groupBy_multiple(expression);
        }
        else {
            this._gridAPI.groupBy(expression);
        }
        this.notifyChanges(true);
    }
    /**
     * Clears grouping for particular column, array of columns or all columns.
     * @remarks
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * @example
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     * @param name Name of column or array of column names to be ungrouped.
     */
    clearGrouping(name) {
        this._gridAPI.clear_groupby(name);
        this.notifyChanges(true);
    }
    preventHeaderScroll(args) {
        if (args.target.scrollLeft !== 0) {
            this.navigation.forOfDir().getScroll().scrollLeft = args.target.scrollLeft;
            args.target.scrollLeft = 0;
        }
    }
    /**
     * Returns if a group is expanded or not.
     * @param group The group record.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     */
    isExpandedGroup(group) {
        const state = this._getStateForGroupRow(group);
        return state ? state.expanded : this.groupsExpanded;
    }
    /**
     * Toggles the expansion state of a group.
     * @param groupRow The group record to toggle.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     */
    toggleGroup(groupRow) {
        this._toggleGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * Expands the specified group and all of its parent groups.
     * @param groupRow The group record to fully expand.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * this.grid.fullyExpandGroup(this.groupRow);
     * ```
     */
    fullyExpandGroup(groupRow) {
        this._fullyExpandGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    isGroupByRecord(record) {
        // return record.records instance of GroupedRecords fails under Webpack
        return record.records && record.records.length;
    }
    /**
     * Toggles the expansion state of all group rows recursively.
     * @example
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     */
    toggleAllGroupRows() {
        this.groupingExpansionState = [];
        this.groupsExpanded = !this.groupsExpanded;
        this.notifyChanges();
    }
    /**
     * Returns if the `IgxGridComponent` has groupable columns.
     * @example
     * ```typescript
     * const groupableGrid = this.grid.hasGroupableColumns;
     * ```
     */
    get hasGroupableColumns() {
        return this.columnList.some((col) => col.groupable && !col.columnGroup);
    }
    get showGroupArea() {
        return this._showGroupArea;
    }
    set showGroupArea(value) {
        this._showGroupArea = value;
    }
    _setGroupColsVisibility(value) {
        if (this.columnList.length > 0 && !this.hasColumnLayouts) {
            this.groupingExpressions.forEach((expr) => {
                const col = this.getColumnByName(expr.fieldName);
                col.hidden = value;
            });
        }
    }
    /**
     * Gets if the grid's group by drop area is visible.
     * @example
     * ```typescript
     * const dropVisible = this.grid.dropAreaVisible;
     * ```
     */
    get dropAreaVisible() {
        return (this.draggedColumn && this.draggedColumn.groupable) ||
            !this.chipsGoupingExpressions.length;
    }
    /**
     * @hidden @internal
     */
    _getStateForGroupRow(groupRow) {
        return this._gridAPI.groupBy_get_expanded_for_group(groupRow);
    }
    /**
     * @hidden
     */
    _toggleGroup(groupRow) {
        this._gridAPI.groupBy_toggle_group(groupRow);
    }
    /**
     * @hidden @internal
     */
    _fullyExpandGroup(groupRow) {
        this._gridAPI.groupBy_fully_expand_group(groupRow);
    }
    /**
     * @hidden @internal
     */
    _applyGrouping() {
        this._gridAPI.sort_multiple(this._groupingExpressions);
    }
    /**
     * @hidden @internal
     */
    isColumnGrouped(fieldName) {
        return this.groupingExpressions.find(exp => exp.fieldName === fieldName) ? true : false;
    }
    /**
     * @hidden @internal
     */
    getContext(rowData, rowIndex, pinned) {
        if (this.isDetailRecord(rowData)) {
            const cachedData = this.childDetailTemplates.get(rowData.detailsData);
            const rowID = this.primaryKey ? rowData.detailsData[this.primaryKey] : this.data.indexOf(rowData.detailsData);
            if (cachedData) {
                const view = cachedData.view;
                const tmlpOutlet = cachedData.owner;
                return {
                    $implicit: rowData.detailsData,
                    moveView: view,
                    owner: tmlpOutlet,
                    index: this.dataView.indexOf(rowData),
                    templateID: 'detailRow-' + rowID
                };
            }
            else {
                // child rows contain unique grids, hence should have unique templates
                return {
                    $implicit: rowData.detailsData,
                    templateID: 'detailRow-' + rowID,
                    index: this.dataView.indexOf(rowData)
                };
            }
        }
        return {
            $implicit: this.isGhostRecord(rowData) || this.isAddRowRecord(rowData) ? rowData.recordRef : rowData,
            index: this.getDataViewIndex(rowIndex, pinned),
            templateID: this.isGroupByRecord(rowData) ? 'groupRow' : this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',
            disabled: this.isGhostRecord(rowData),
            addRow: this.isAddRowRecord(rowData) ? rowData.addRow : false
        };
    }
    /**
     * @hidden @internal
     */
    viewCreatedHandler(args) {
        if (args.context.templateID.indexOf('detailRow') !== -1) {
            this.childDetailTemplates.set(args.context.$implicit, args);
        }
    }
    /**
     * @hidden @internal
     */
    viewMovedHandler(args) {
        if (args.context.templateID.indexOf('detailRow') !== -1) {
            // view was moved, update owner in cache
            const key = args.context.$implicit;
            const cachedData = this.childDetailTemplates.get(key);
            cachedData.owner = args.owner;
        }
    }
    /**
     * @hidden @internal
     */
    onChipRemoved(event) {
        this.clearGrouping(event.owner.id);
    }
    /**
     * @hidden @internal
     */
    chipsOrderChanged(event) {
        const newGrouping = [];
        for (let i = 0; i < event.chipsArray.length; i++) {
            const expr = this.groupingExpressions.filter((item) => {
                return item.fieldName === event.chipsArray[i].id;
            })[0];
            if (!this.getColumnByName(expr.fieldName).groupable) {
                // disallow changing order if there are columns with groupable: false
                return;
            }
            newGrouping.push(expr);
        }
        this.groupingExpansionState = [];
        this.chipsGoupingExpressions = newGrouping;
        if (event.originalEvent instanceof KeyboardEvent) {
            // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
            this.groupingExpressions = this.chipsGoupingExpressions;
        }
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    chipsMovingEnded() {
        this.groupingExpressions = this.chipsGoupingExpressions;
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    onChipClicked(event) {
        const sortingExpr = this.sortingExpressions;
        const columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
        columnExpr.dir = 3 - columnExpr.dir;
        this.sort(columnExpr);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    onChipKeyDown(event) {
        if (event.originalEvent.key === ' ' || event.originalEvent.key === 'Spacebar' || event.originalEvent.key === 'Enter') {
            const sortingExpr = this.sortingExpressions;
            const columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
            columnExpr.dir = 3 - columnExpr.dir;
            this.sort(columnExpr);
            this.notifyChanges();
        }
    }
    /**
     * @hidden @internal
     */
    get defaultTargetBodyHeight() {
        const allItems = this.totalItemCount || this.dataLength;
        return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
    }
    /**
     * @hidden @internal
     */
    getGroupAreaHeight() {
        return this.groupArea ? this.getComputedHeight(this.groupArea.nativeElement) : 0;
    }
    /**
     * @hidden @internal
     */
    scrollTo(row, column) {
        if (this.groupingExpressions && this.groupingExpressions.length
            && typeof (row) !== 'number') {
            const rowIndex = this.groupingResult.indexOf(row);
            const groupByRecord = this.groupingMetadata[rowIndex];
            if (groupByRecord) {
                this._fullyExpandGroup(groupByRecord);
            }
        }
        super.scrollTo(row, column, this.groupingFlatResult);
    }
    /**
     * @hidden @internal
     */
    get dropAreaTemplateResolved() {
        if (this.dropAreaTemplate) {
            return this.dropAreaTemplate;
        }
        else {
            return this.defaultDropAreaTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    getGroupByChipTitle(expression) {
        const column = this.getColumnByName(expression.fieldName);
        return (column && column.header) || expression.fieldName;
    }
    /**
     * @hidden @internal
     */
    get iconTemplate() {
        if (this.groupsExpanded) {
            return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    getColumnGroupable(fieldName) {
        const column = this.getColumnByName(fieldName);
        return column && column.groupable;
    }
    /**
     * @hidden @internal
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (this.allowFiltering && this.hasColumnLayouts) {
            this.filterMode = FilterMode.excelStyleFilter;
        }
        if (this.groupTemplate) {
            this._groupRowTemplate = this.groupTemplate.template;
        }
        if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(this.hideGroupedColumns);
        }
        this._setupNavigationService();
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.verticalScrollContainer.onBeforeViewDestroyed.pipe(takeUntil(this.destroy$)).subscribe((view) => {
            const rowData = view.context.$implicit;
            if (this.isDetailRecord(rowData)) {
                const cachedData = this.childDetailTemplates.get(rowData.detailsData);
                if (cachedData) {
                    const tmlpOutlet = cachedData.owner;
                    tmlpOutlet._viewContainerRef.detach(0);
                }
            }
        });
    }
    /**
     * @hidden @internal
     */
    ngOnInit() {
        super.ngOnInit();
        this.onGroupingDone.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.endEdit(true);
            this.summaryService.updateSummaryCache(args);
            this._headerFeaturesWidth = NaN;
        });
    }
    /**
     * @hidden @internal
     */
    ngDoCheck() {
        if (this.groupingDiffer && this.columnList && !this.hasColumnLayouts) {
            const changes = this.groupingDiffer.diff(this.groupingExpressions);
            if (changes && this.columnList.length > 0) {
                changes.forEachAddedItem((rec) => {
                    const col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = true;
                });
                changes.forEachRemovedItem((rec) => {
                    const col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
        super.ngDoCheck();
    }
    /**
     * @hidden @internal
     */
    dataLoading(event) {
        this.onDataPreLoad.emit(event);
    }
    /**
     * @inheritdoc
     */
    getSelectedData(formatters = false, headers = false) {
        if (this.groupingExpressions.length || this.hasDetails) {
            const source = [];
            const process = (record) => {
                if (record.expression || record.summaries || this.isDetailRecord(record)) {
                    source.push(null);
                    return;
                }
                source.push(record);
            };
            this.dataView.forEach(process);
            return this.extractDataFromSelection(source, formatters, headers);
        }
        else {
            return super.getSelectedData(formatters, headers);
        }
    }
    _setupNavigationService() {
        if (this.hasColumnLayouts) {
            this.navigation = new IgxGridMRLNavigationService();
            this.navigation.grid = this;
        }
    }
    checkIfNoColumnField(expression) {
        if (expression instanceof Array) {
            for (const singleExpression of expression) {
                if (!singleExpression.fieldName) {
                    return true;
                }
            }
            return false;
        }
        return !expression.fieldName;
    }
}
IgxGridComponent.ɵfac = function IgxGridComponent_Factory(t) { return ɵIgxGridComponent_BaseFactory(t || IgxGridComponent); };
IgxGridComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridComponent, selectors: [["igx-grid"]], contentQueries: function IgxGridComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxGridDetailTemplateDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxGroupByRowTemplateDirective, true, IgxGroupByRowTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxGridDetailTemplateDirective, true, IgxGridDetailTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.detailTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.gridDetailsTemplate = _t.first);
    } }, viewQuery: function IgxGridComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c165, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(_c166, true);
        ɵngcc0.ɵɵstaticViewQuery(_c167, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c168, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c169, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c170, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(IgxGridGroupByRowComponent, true, IgxGridGroupByRowComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultDropAreaTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupArea = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.recordTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.detailTemplateContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultGroupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.summaryTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._groupsRowList = _t);
    } }, hostVars: 1, hostBindings: function IgxGridComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { groupsExpanded: "groupsExpanded", id: "id", data: "data", groupingExpressions: "groupingExpressions", groupingExpansionState: "groupingExpansionState", hideGroupedColumns: "hideGroupedColumns", dropAreaMessage: "dropAreaMessage", showGroupArea: "showGroupArea", dropAreaTemplate: "dropAreaTemplate" }, outputs: { onDataPreLoad: "onDataPreLoad", groupingExpressionsChange: "groupingExpressionsChange", groupingExpansionStateChange: "groupingExpansionStateChange", onGroupingDone: "onGroupingDone" }, features: [ɵngcc0.ɵɵProvidersFeature([
            IgxGridNavigationService,
            IgxGridSummaryService,
            IgxGridSelectionService,
            IgxGridCRUDService,
            { provide: GridBaseAPIService, useClass: IgxGridAPIService },
            { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxGridComponent) },
            IgxFilteringService,
            IgxColumnResizingService,
            IgxForOfSyncService,
            IgxForOfScrollSyncService
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c186, decls: 115, vars: 187, consts: [["role", "toolbar", 3, "max-width", "flex-basis", "gridID", "displayDensity", 4, "ngIf"], ["class", "igx-grid__grouparea", 3, "flex-basis", 4, "ngIf"], [1, "igx-grid__thead"], ["role", "rowgroup", "tabindex", "0", 1, "igx-grid__thead-wrapper", 3, "focus", "keydown", "scroll"], ["theadRow", ""], ["role", "row", 1, "igx-grid__tr"], ["id", "left", "class", "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop", "left", 4, "ngIf"], ["id", "left", "class", "igx-grid__scroll-on-drag-pinned", 3, "igxColumnMovingDrop", "left", 4, "ngIf"], [4, "ngIf"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollOrientation", "igxForScrollContainer", "igxForContainerSize", "igxForTrackBy", "igxForSizePropName"], ["hContainer", ""], [3, "width", "column", 4, "ngIf"], ["id", "right", "class", "igx-grid__scroll-on-drag-right", 3, "igxColumnMovingDrop", 4, "ngIf"], [1, "igx-grid__thead-thumb", 3, "hidden"], ["igxGridBody", "", 1, "igx-grid__tbody", 3, "keydown.control.c", "copy"], ["tabindex", "0", "role", "rowgroup", 1, "igx-grid__tbody-content", 3, "igxGridDragSelect", "keydown", "focus", "onDragStop", "scroll", "onDragScroll"], ["tbody", ""], ["id", "left", "class", "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop", 4, "ngIf"], [4, "ngTemplateOutlet"], ["pinnedRecordsTemplate", ""], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollOrientation", "igxForScrollContainer", "igxForContainerSize", "igxForItemSize", "igxForTrackBy", "onChunkPreload"], ["verticalScrollContainer", ""], ["record_template", ""], ["pinned_record_template", ""], ["group_template", ""], ["summary_template", ""], ["detail_template_container", ""], ["igxOverlayOutlet", "", 1, "igx-grid__row-editing-outlet"], ["igxRowEditingOverlayOutlet", ""], ["loadingOverlay", ""], [3, "indeterminate", 4, "ngIf"], [1, "igx-grid__tbody-scrollbar", 3, "hidden", "pointerdown"], [1, "igx-grid__tbody-scrollbar-start"], [1, "igx-grid__tbody-scrollbar-main"], ["igxGridFor", "", 3, "igxGridForOf"], ["verticalScrollHolder", ""], [1, "igx-grid__tbody-scrollbar-end"], [1, "igx-grid__addrow-snackbar"], [3, "actionText", "displayTime"], ["addRowSnackbar", ""], ["role", "rowgroup", "tabindex", "0", 1, "igx-grid__tfoot", 3, "focus", "keydown"], ["tfoot", ""], ["role", "row", "class", "igx-grid__summaries", 3, "width", "height", "gridID", "summaries", "index", 4, "ngIf"], [1, "igx-grid__tfoot-thumb", 3, "hidden"], [1, "igx-grid__scroll", 3, "hidden", "pointerdown"], ["scr", ""], [1, "igx-grid__scroll-start"], [1, "igx-grid__scroll-main"], ["scrollContainer", ""], [1, "igx-grid__scroll-end", 3, "hidden"], [1, "igx-grid__footer"], ["footer", ""], ["defaultPaginator", ""], ["emptyFilteredGrid", ""], ["defaultEmptyGrid", ""], ["defaultAddRowEmptyTemplate", ""], ["defaultLoadingGrid", ""], ["defaultDropArea", ""], ["defaultExpandedTemplate", ""], ["defaultCollapsedTemplate", ""], ["igxToggle", "", 4, "ngIf"], ["defaultRowEditText", ""], ["defaultRowEditActions", ""], ["defaultRowEditTemplate", ""], ["dragIndicatorIconBase", ""], ["igxHeadSelector", ""], ["headSelectorBaseTemplate", ""], ["igxOverlayOutlet", "", 1, "igx-grid__loading-outlet"], ["igxLoadingOverlayOutlet", ""], ["igxOverlayOutlet", "", 1, "igx-grid__outlet", 3, "keydown"], ["igxFilteringOverlayOutlet", ""], ["role", "toolbar", 3, "gridID", "displayDensity"], ["toolbar", ""], [1, "igx-grid__grouparea"], ["groupArea", ""], [3, "onReorder", "onMoveEnd"], [4, "ngFor", "ngForOf"], ["igxGroupAreaDrop", ""], [3, "id", "title", "removable", "draggable", "displayDensity", "disabled", "onKeyDown", "onRemove", "onClick"], ["igxSuffix", ""], [1, "igx-grid__grouparea-connector"], ["id", "left", 1, "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop"], ["id", "left", 1, "igx-grid__scroll-on-drag-pinned", 3, "igxColumnMovingDrop"], [3, "ngClass", "click", "pointerdown"], ["headerGroupContainer", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-grid__drag-indicator", 3, "ngClass", "pointerdown"], ["headerDragContainer", ""], [2, "visibility", "hidden"], [1, "igx-grid__cbx-selection", 3, "ngClass", "click", "pointerdown"], ["headerSelectorContainer", ""], ["headSelector", ""], ["ngFor", "", 3, "ngForOf"], [3, "column", "gridID"], [3, "column"], ["filteringRow", ""], ["id", "right", 1, "igx-grid__scroll-on-drag-right", 3, "igxColumnMovingDrop"], ["class", "igx-grid__tr--pinned", 3, "ngClass", "width", 4, "ngIf"], [1, "igx-grid__tr--pinned", 3, "ngClass"], ["pinContainer", ""], [3, "igxTemplateOutlet", "igxTemplateOutletContext", "onCachedViewLoaded", "onViewCreated", "onViewMoved"], [3, "gridID", "index", "rowData", "disabled", "addRow"], ["row", ""], [3, "gridID", "index", "rowData", "addRow"], ["row", "", "pinnedRow", ""], [3, "gridID", "index", "groupRow"], [1, "igx-grid__summaries--body", 3, "gridID", "summaries", "index"], ["summaryRow", ""], ["detail", "true", 2, "overflow", "auto", "width", "100%", 3, "id", "ngClass", "pointerdown"], ["detailsContainer", ""], [1, "igx-grid__hierarchical-indent", 2, "display", "flex"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "indeterminate"], ["role", "row", 1, "igx-grid__summaries", 3, "gridID", "summaries", "index"], [3, "overlaySettings", "displayDensity", "page", "totalRecords", "perPage", "pageChange", "perPageChange"], [1, "igx-grid__tbody-message"], ["igxButton", "raised", "igxRipple", "", 3, "click"], [1, "igx-grid__loading"], ["fontSet", "material", 1, "igx-drop-area__icon"], [1, "igx-drop-area__text"], ["role", "button", 1, "igx-grid__group-expand-btn", 3, "ngClass"], ["igxToggle", ""], [3, "className"], ["igxButton", "", "igxRowEditTabStop", "", 3, "click"], ["class", "igx-banner__message", 4, "ngIf"], [1, "igx-banner__actions"], [1, "igx-banner__row"], [1, "igx-banner__message"], [1, "igx-banner__text"], ["fontSet", "material"], [1, "igx-grid__cbx-padding"], ["disableRipple", "true", 3, "tabindex", "readonly", "checked", "ngStyle", "indeterminate", "aria-label"], ["headerCheckbox", ""]], template: function IgxGridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c182);
        ɵngcc0.ɵɵtemplate(0, IgxGridComponent_igx_grid_toolbar_0_Template, 2, 6, "igx-grid-toolbar", 0);
        ɵngcc0.ɵɵtemplate(1, IgxGridComponent_div_1_Template, 6, 9, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3, 4);
        ɵngcc0.ɵɵlistener("focus", function IgxGridComponent_Template_div_focus_3_listener() { return ctx.navigation.focusFirstCell(); })("keydown", function IgxGridComponent_Template_div_keydown_3_listener($event) { return ctx.navigation.headerNavigation($event); })("scroll", function IgxGridComponent_Template_div_scroll_3_listener($event) { return ctx.preventHeaderScroll($event); });
        ɵngcc0.ɵɵelementStart(5, "div", 5);
        ɵngcc0.ɵɵtemplate(6, IgxGridComponent_span_6_Template, 1, 4, "span", 6);
        ɵngcc0.ɵɵtemplate(7, IgxGridComponent_span_7_Template, 1, 4, "span", 7);
        ɵngcc0.ɵɵtemplate(8, IgxGridComponent_ng_container_8_Template, 4, 10, "ng-container", 8);
        ɵngcc0.ɵɵtemplate(9, IgxGridComponent_ng_container_9_Template, 5, 4, "ng-container", 8);
        ɵngcc0.ɵɵtemplate(10, IgxGridComponent_ng_container_10_Template, 4, 10, "ng-container", 8);
        ɵngcc0.ɵɵtemplate(11, IgxGridComponent_ng_container_11_Template, 3, 3, "ng-container", 8);
        ɵngcc0.ɵɵtemplate(12, IgxGridComponent_ng_template_12_Template, 1, 6, "ng-template", 9, 10, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(14, "igxTopLevel");
        ɵngcc0.ɵɵtemplate(15, IgxGridComponent_ng_container_15_Template, 3, 3, "ng-container", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(16, IgxGridComponent_igx_grid_filtering_row_16_Template, 2, 3, "igx-grid-filtering-row", 11);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(17, IgxGridComponent_span_17_Template, 1, 2, "span", 12);
        ɵngcc0.ɵɵelement(18, "div", 13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(19, "div", 14);
        ɵngcc0.ɵɵlistener("keydown.control.c", function IgxGridComponent_Template_div_keydown_control_c_19_listener($event) { return ctx.copyHandler($event); })("copy", function IgxGridComponent_Template_div_copy_19_listener($event) { return ctx.copyHandler($event); });
        ɵngcc0.ɵɵelementStart(20, "div", 15, 16);
        ɵngcc0.ɵɵlistener("keydown", function IgxGridComponent_Template_div_keydown_20_listener($event) { return ctx.navigation.handleNavigation($event); })("focus", function IgxGridComponent_Template_div_focus_20_listener($event) { return ctx.navigation.focusTbody($event); })("onDragStop", function IgxGridComponent_Template_div_onDragStop_20_listener($event) { return ctx.selectionService.dragMode = $event; })("scroll", function IgxGridComponent_Template_div_scroll_20_listener($event) { return ctx.preventContainerScroll($event); })("onDragScroll", function IgxGridComponent_Template_div_onDragScroll_20_listener($event) { return ctx.dragScroll($event); });
        ɵngcc0.ɵɵtemplate(22, IgxGridComponent_span_22_Template, 1, 2, "span", 17);
        ɵngcc0.ɵɵtemplate(23, IgxGridComponent_span_23_Template, 1, 4, "span", 7);
        ɵngcc0.ɵɵtemplate(24, IgxGridComponent_ng_container_24_Template, 1, 0, "ng-container", 18);
        ɵngcc0.ɵɵtemplate(25, IgxGridComponent_ng_template_25_Template, 7, 47, "ng-template", null, 19, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(27, IgxGridComponent_ng_template_27_Template, 1, 2, "ng-template", 20, 21, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(29, "gridAddRow");
        ɵngcc0.ɵɵpipe(30, "gridRowPinning");
        ɵngcc0.ɵɵpipe(31, "gridDetails");
        ɵngcc0.ɵɵpipe(32, "gridSummary");
        ɵngcc0.ɵɵpipe(33, "gridPaging");
        ɵngcc0.ɵɵpipe(34, "gridGroupBy");
        ɵngcc0.ɵɵpipe(35, "gridSort");
        ɵngcc0.ɵɵpipe(36, "gridFiltering");
        ɵngcc0.ɵɵpipe(37, "visibleColumns");
        ɵngcc0.ɵɵpipe(38, "gridTransaction");
        ɵngcc0.ɵɵlistener("onChunkPreload", function IgxGridComponent_Template_ng_template_onChunkPreload_27_listener($event) { return ctx.dataLoading($event); });
        ɵngcc0.ɵɵtemplate(39, IgxGridComponent_ng_container_39_Template, 1, 0, "ng-container", 18);
        ɵngcc0.ɵɵtemplate(40, IgxGridComponent_ng_template_40_Template, 2, 5, "ng-template", null, 22, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(42, IgxGridComponent_ng_template_42_Template, 3, 4, "ng-template", null, 23, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(44, IgxGridComponent_ng_template_44_Template, 2, 3, "ng-template", null, 24, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(46, IgxGridComponent_ng_template_46_Template, 2, 3, "ng-template", null, 25, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(48, IgxGridComponent_ng_template_48_Template, 5, 9, "ng-template", null, 26, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(50, IgxGridComponent_ng_container_50_Template, 1, 0, "ng-container", 18);
        ɵngcc0.ɵɵelement(51, "div", 27, 28);
        ɵngcc0.ɵɵelement(53, "igc-trial-watermark");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(54, "div", null, 29);
        ɵngcc0.ɵɵtemplate(56, IgxGridComponent_igx_circular_bar_56_Template, 1, 1, "igx-circular-bar", 30);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(57, IgxGridComponent_span_57_Template, 1, 2, "span", 12);
        ɵngcc0.ɵɵelementStart(58, "div", 31);
        ɵngcc0.ɵɵlistener("pointerdown", function IgxGridComponent_Template_div_pointerdown_58_listener($event) { return $event.preventDefault(); });
        ɵngcc0.ɵɵelement(59, "div", 32);
        ɵngcc0.ɵɵelementStart(60, "div", 33);
        ɵngcc0.ɵɵtemplate(61, IgxGridComponent_ng_template_61_Template, 0, 0, "ng-template", 34, 35, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(63, "div", 36);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(64, "div", 37);
        ɵngcc0.ɵɵelementStart(65, "igx-snackbar", 38, 39);
        ɵngcc0.ɵɵtext(67);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(68, "div", 40, 41);
        ɵngcc0.ɵɵlistener("focus", function IgxGridComponent_Template_div_focus_68_listener() { return ctx.navigation.focusFirstCell(false); })("keydown", function IgxGridComponent_Template_div_keydown_68_listener($event) { return ctx.navigation.summaryNav($event); });
        ɵngcc0.ɵɵtemplate(70, IgxGridComponent_igx_grid_summary_row_70_Template, 3, 10, "igx-grid-summary-row", 42);
        ɵngcc0.ɵɵelement(71, "div", 43);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(72, "div", 44, 45);
        ɵngcc0.ɵɵlistener("pointerdown", function IgxGridComponent_Template_div_pointerdown_72_listener($event) { return $event.preventDefault(); });
        ɵngcc0.ɵɵelement(74, "div", 46);
        ɵngcc0.ɵɵelementStart(75, "div", 47);
        ɵngcc0.ɵɵtemplate(76, IgxGridComponent_ng_template_76_Template, 0, 0, "ng-template", 34, 48, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(78, "div", 49);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(79, "div", 50, 51);
        ɵngcc0.ɵɵprojection(81);
        ɵngcc0.ɵɵtemplate(82, IgxGridComponent_ng_container_82_Template, 2, 4, "ng-container", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(83, IgxGridComponent_ng_template_83_Template, 1, 5, "ng-template", null, 52, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(85, IgxGridComponent_ng_template_85_Template, 4, 2, "ng-template", null, 53, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(87, IgxGridComponent_ng_template_87_Template, 4, 2, "ng-template", null, 54, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(89, IgxGridComponent_ng_template_89_Template, 2, 1, "ng-template", null, 55, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(91, IgxGridComponent_ng_template_91_Template, 2, 1, "ng-template", null, 56, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(93, IgxGridComponent_ng_template_93_Template, 4, 1, "ng-template", null, 57, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(95, IgxGridComponent_ng_template_95_Template, 2, 3, "ng-template", null, 58, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(97, IgxGridComponent_ng_template_97_Template, 2, 3, "ng-template", null, 59, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(99, IgxGridComponent_div_99_Template, 3, 6, "div", 60);
        ɵngcc0.ɵɵtemplate(100, IgxGridComponent_ng_template_100_Template, 1, 1, "ng-template", null, 61, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(102, IgxGridComponent_ng_template_102_Template, 4, 0, "ng-template", null, 62, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(104, IgxGridComponent_ng_template_104_Template, 4, 5, "ng-template", null, 63, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(106, IgxGridComponent_ng_template_106_Template, 2, 0, "ng-template", null, 64, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(108, IgxGridComponent_ng_template_108_Template, 3, 8, "ng-template", 65, 66, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(110, IgxGridComponent_igx_grid_column_resizer_110_Template, 1, 0, "igx-grid-column-resizer", 8);
        ɵngcc0.ɵɵelement(111, "div", 67, 68);
        ɵngcc0.ɵɵelementStart(113, "div", 69, 70);
        ɵngcc0.ɵɵlistener("keydown", function IgxGridComponent_Template_div_keydown_113_listener($event) { return ctx.gridOutletKeyboardHandler($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r18 = ɵngcc0.ɵɵreference(26);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToolbar);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showGroupArea && (ctx.groupingExpressions.length > 0 || ctx.hasGroupableColumns));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵclassProp("igx-grid__tr--mrl", ctx.hasColumnLayouts);
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length <= 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.groupingExpressions.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowDraggable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showRowSelectors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(14, 88, ctx.unpinnedColumns))("igxForScrollOrientation", "horizontal")("igxForScrollContainer", ctx.parentVirtDir)("igxForContainerSize", ctx.unpinnedWidth)("igxForTrackBy", ctx.trackColumnChanges)("igxForSizePropName", "calcPixelWidth");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && !ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.filteringService.isFilterRowVisible);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollSize, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", ctx.totalHeight, "px")("width", ctx.calcWidth || null, "px");
        ɵngcc0.ɵɵproperty("igxGridDragSelect", ctx.selectionService.dragMode);
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length <= 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasPinnedRecords && ctx.isRowPinningToTop ? _r18 : null);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind3(29, 90, ɵngcc0.ɵɵpipeBind4(30, 94, ɵngcc0.ɵɵpipeBind4(31, 99, ɵngcc0.ɵɵpipeBindV(32, 104, ɵngcc0.ɵɵpureFunction8(176, _c184, ɵngcc0.ɵɵpipeBindV(33, 113, ɵngcc0.ɵɵpureFunction5(170, _c66, ɵngcc0.ɵɵpipeBindV(34, 119, ɵngcc0.ɵɵpureFunction7(162, _c183, ɵngcc0.ɵɵpipeBindV(35, 127, ɵngcc0.ɵɵpureFunction5(156, _c66, ɵngcc0.ɵɵpipeBindV(36, 133, ɵngcc0.ɵɵpureFunction7(148, _c183, ɵngcc0.ɵɵpipeBind2(37, 141, ɵngcc0.ɵɵpipeBind3(38, 144, ctx.data, ctx.id, ctx.pipeTrigger), ctx.hasVisibleColumns), ctx.filteringExpressionsTree, ctx.filterStrategy, ctx.advancedFilteringExpressionsTree, ctx.id, ctx.pipeTrigger, ctx.filteringPipeTrigger)), ctx.sortingExpressions, ctx.sortStrategy, ctx.id, ctx.pipeTrigger)), ctx.groupingExpressions, ctx.groupingExpansionState, ctx.groupsExpanded, ctx.id, ctx.groupsRecords, ctx.pipeTrigger)), ctx.page, ctx.perPage, ctx.id, ctx.pipeTrigger)), ctx.hasSummarizedColumns, ctx.summaryCalculationMode, ctx.summaryPosition, ctx.id, ctx.showSummaryOnCollapse, ctx.pipeTrigger, ctx.summaryPipeTrigger)), ctx.hasDetails, ctx.expansionStates, ctx.pipeTrigger), ctx.id, false, ctx.pipeTrigger), false, ctx.pipeTrigger))("igxForScrollOrientation", "vertical")("igxForScrollContainer", ctx.verticalScroll)("igxForContainerSize", ctx.calcHeight)("igxForItemSize", ctx.hasColumnLayouts ? ctx.rowHeight * ctx.multiRowLayoutRowSize + 1 : ctx.renderedRowHeight)("igxForTrackBy", ctx.trackChanges);
        ɵngcc0.ɵɵadvance(12);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasPinnedRecords && !ctx.isRowPinningToTop ? _r18 : null);
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template);
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldOverlayLoading);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollSize, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.calcHeight, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpureFunction0(185, _c185));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", !ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, "px");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("actionText", ctx.snackbarActionText)("displayTime", ctx.snackbarDisplayTime);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.snackbarLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.summariesHeight, "px");
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasSummarizedColumns && ctx.rootSummariesEnabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.summariesHeight, "px")("width", ctx.scrollSize, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.scrollSize, "px");
        ɵngcc0.ɵɵproperty("hidden", ctx.isHorizontalScrollHidden);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, "px")("min-width", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.unpinnedWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpureFunction0(186, _c185));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("float", "right")("width", ctx.pinnedWidth, "px")("min-width", ctx.pinnedWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", ctx.pinnedWidth === 0 || ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.paging && ctx.totalRecords);
        ɵngcc0.ɵɵadvance(17);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowEditable);
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngIf", ctx.colResizingService.showResizer);
    } }, directives: function () { return [ɵngcc2.NgIf, IgxGridForOfDirective, IgxGridBodyDirective, IgxGridDragSelectDirective, ɵngcc2.NgTemplateOutlet, IgxOverlayOutletDirective, IgxSnackbarComponent, IgxHeadSelectorDirective, IgxGridToolbarComponent, IgxChipsAreaComponent, ɵngcc2.NgForOf, IgxGroupAreaDropDirective, IgxChipComponent, IgxIconComponent, IgxSuffixDirective, IgxColumnMovingDropDirective, ɵngcc2.NgClass, IgxGridHeaderGroupComponent, IgxGridFilteringRowComponent, IgxTemplateOutletDirective, IgxGridRowComponent, IgxGridGroupByRowComponent, IgxSummaryRowComponent, IgxCircularProgressBarComponent, IgxPaginatorComponent, IgxButtonDirective, IgxRippleDirective, IgxToggleDirective, IgxRowEditTabStopDirective, IgxCheckboxComponent, ɵngcc2.NgStyle, IgxGridColumnResizerComponent]; }, pipes: function () { return [IgxGridTopLevelColumns, IgxGridAddRowPipe, IgxGridRowPinningPipe, IgxGridDetailsPipe, IgxGridSummaryPipe, IgxGridPagingPipe, IgxGridGroupingPipe, IgxGridSortingPipe, IgxGridFilteringPipe, IgxHasVisibleColumnsPipe, IgxGridTransactionPipe, IgxSummaryDataPipe]; }, encapsulation: 2, changeDetection: 0 });
IgxGridComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    data: [{ type: Input }],
    onDataPreLoad: [{ type: Output }],
    groupingExpressions: [{ type: Input }],
    groupingExpressionsChange: [{ type: Output }],
    groupingExpansionState: [{ type: Input }],
    groupingExpansionStateChange: [{ type: Output }],
    groupsExpanded: [{ type: Input }],
    hideGroupedColumns: [{ type: Input }],
    dropAreaMessage: [{ type: Input }],
    dropAreaTemplate: [{ type: Input }],
    onGroupingDone: [{ type: Output }],
    groupTemplate: [{ type: ContentChild, args: [IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective },] }],
    gridDetailsTemplate: [{ type: ContentChild, args: [IgxGridDetailTemplateDirective, { read: IgxGridDetailTemplateDirective, static: false },] }],
    _groupsRowList: [{ type: ViewChildren, args: [IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent },] }],
    defaultDropAreaTemplate: [{ type: ViewChild, args: ['defaultDropArea', { read: TemplateRef, static: true },] }],
    groupArea: [{ type: ViewChild, args: ['groupArea',] }],
    recordTemplate: [{ type: ViewChild, args: ['record_template', { read: TemplateRef, static: true },] }],
    detailTemplateContainer: [{ type: ViewChild, args: ['detail_template_container', { read: TemplateRef, static: true },] }],
    detailTemplate: [{ type: ContentChild, args: [IgxGridDetailTemplateDirective, { read: TemplateRef, static: false },] }],
    defaultGroupTemplate: [{ type: ViewChild, args: ['group_template', { read: TemplateRef, static: true },] }],
    summaryTemplate: [{ type: ViewChild, args: ['summary_template', { read: TemplateRef, static: true },] }],
    showGroupArea: [{ type: Input }]
};

class IgxGridStateDirective {
    /**
     * @hidden
     */
    constructor(grid, resolver, viewRef) {
        this.grid = grid;
        this.resolver = resolver;
        this.viewRef = viewRef;
        this.featureKeys = [];
        this._options = {
            columns: true,
            filtering: true,
            advancedFiltering: true,
            sorting: true,
            groupBy: true,
            paging: true,
            cellSelection: true,
            rowSelection: true,
            columnSelection: true,
            rowPinning: true,
            expansion: true,
            rowIslands: true
        };
        this.FEATURES = {
            sorting: {
                getFeatureState(context) {
                    const sortingState = context.currGrid.sortingExpressions;
                    sortingState.forEach(s => {
                        delete s.strategy;
                        delete s.owner;
                    });
                    return { sorting: sortingState };
                },
                restoreFeatureState(context, state) {
                    context.currGrid.sortingExpressions = state;
                }
            },
            filtering: {
                getFeatureState(context) {
                    const filteringState = context.currGrid.filteringExpressionsTree;
                    if (filteringState) {
                        delete filteringState.owner;
                        for (const item of filteringState.filteringOperands) {
                            delete item.owner;
                        }
                    }
                    return { filtering: filteringState };
                },
                restoreFeatureState(context, state) {
                    const filterTree = context.createExpressionsTreeFromObject(state);
                    context.currGrid.filteringExpressionsTree = filterTree;
                }
            },
            advancedFiltering: {
                getFeatureState(context) {
                    const filteringState = context.currGrid.advancedFilteringExpressionsTree;
                    let advancedFiltering;
                    if (filteringState) {
                        delete filteringState.owner;
                        for (const item of filteringState.filteringOperands) {
                            delete item.owner;
                        }
                        advancedFiltering = filteringState;
                    }
                    else {
                        advancedFiltering = {};
                    }
                    return { advancedFiltering: advancedFiltering };
                },
                restoreFeatureState(context, state) {
                    const filterTree = context.createExpressionsTreeFromObject(state);
                    context.currGrid.advancedFilteringExpressionsTree = filterTree;
                }
            },
            columns: {
                getFeatureState(context) {
                    const gridColumns = context.currGrid.columns.map((c) => {
                        return {
                            pinned: c.pinned,
                            sortable: c.sortable,
                            filterable: c.filterable,
                            editable: c.editable,
                            sortingIgnoreCase: c.sortingIgnoreCase,
                            filteringIgnoreCase: c.filteringIgnoreCase,
                            headerClasses: c.headerClasses,
                            headerGroupClasses: c.headerGroupClasses,
                            maxWidth: c.maxWidth,
                            groupable: c.groupable,
                            movable: c.movable,
                            hidden: c.hidden,
                            dataType: c.dataType,
                            hasSummary: c.hasSummary,
                            field: c.field,
                            width: c.width,
                            header: c.header,
                            resizable: c.resizable,
                            searchable: c.searchable,
                            selectable: c.selectable
                        };
                    });
                    return { columns: gridColumns };
                },
                restoreFeatureState(context, state) {
                    const newColumns = [];
                    const factory = context.resolver.resolveComponentFactory(IgxColumnComponent);
                    state.forEach((colState) => {
                        const ref = factory.create(context.viewRef.injector);
                        Object.assign(ref.instance, colState);
                        ref.changeDetectorRef.detectChanges();
                        newColumns.push(ref.instance);
                    });
                    context.currGrid.columnList.reset(newColumns);
                    context.currGrid.columnList.notifyOnChanges();
                }
            },
            groupBy: {
                getFeatureState(context) {
                    const grid = context.currGrid;
                    const groupingExpressions = grid.groupingExpressions;
                    groupingExpressions.forEach(expr => {
                        delete expr.strategy;
                    });
                    const expansionState = grid.groupingExpansionState;
                    const groupsExpanded = grid.groupsExpanded;
                    return { groupBy: { expressions: groupingExpressions, expansion: expansionState, defaultExpanded: groupsExpanded } };
                },
                restoreFeatureState(context, state) {
                    const grid = context.currGrid;
                    grid.groupingExpressions = state.expressions;
                    if (grid.groupsExpanded !== state.defaultExpanded) {
                        grid.toggleAllGroupRows();
                    }
                    else {
                        grid.groupingExpansionState = state.expansion;
                    }
                }
            },
            paging: {
                getFeatureState(context) {
                    const pagingState = context.currGrid.pagingState;
                    return { paging: pagingState };
                },
                restoreFeatureState(context, state) {
                    if (context.currGrid.perPage !== state.recordsPerPage) {
                        context.currGrid.perPage = state.recordsPerPage;
                        context.currGrid.cdr.detectChanges();
                    }
                    context.currGrid.page = state.index;
                }
            },
            rowSelection: {
                getFeatureState(context) {
                    const selection = context.currGrid.selectedRows;
                    return { rowSelection: selection };
                },
                restoreFeatureState(context, state) {
                    context.currGrid.selectRows(state);
                }
            },
            cellSelection: {
                getFeatureState(context) {
                    const selection = context.currGrid.getSelectedRanges().map(range => {
                        return { rowStart: range.rowStart, rowEnd: range.rowEnd, columnStart: range.columnStart, columnEnd: range.columnEnd };
                    });
                    return { cellSelection: selection };
                },
                restoreFeatureState(context, state) {
                    state.forEach(r => {
                        const range = { rowStart: r.rowStart, rowEnd: r.rowEnd, columnStart: r.columnStart, columnEnd: r.columnEnd };
                        context.currGrid.selectRange(range);
                    });
                }
            },
            columnSelection: {
                getFeatureState(context) {
                    const selection = context.currGrid.selectedColumns().map(c => c.field);
                    return { columnSelection: selection };
                },
                restoreFeatureState(context, state) {
                    context.currGrid.deselectAllColumns();
                    context.currGrid.selectColumns(state);
                }
            },
            rowPinning: {
                getFeatureState(context) {
                    const pinned = context.currGrid.pinnedRows.map(x => x.rowID);
                    return { rowPinning: pinned };
                },
                restoreFeatureState(context, state) {
                    // clear current state.
                    context.currGrid.pinnedRows.forEach(row => row.unpin());
                    state.forEach(rowID => context.currGrid.pinRow(rowID));
                }
            },
            pinningConfig: {
                getFeatureState(context) {
                    return { pinningConfig: context.currGrid.pinning };
                },
                restoreFeatureState(context, state) {
                    context.currGrid.pinning = state;
                }
            },
            expansion: {
                getFeatureState(context) {
                    const expansionStates = Array.from(context.currGrid.expansionStates);
                    return { expansion: expansionStates };
                },
                restoreFeatureState(context, state) {
                    const expansionStates = new Map(state);
                    context.currGrid.expansionStates = expansionStates;
                }
            },
            rowIslands: {
                getFeatureState(context) {
                    const childGridStates = [];
                    const rowIslands = context.currGrid.allLayoutList;
                    if (rowIslands) {
                        rowIslands.forEach(rowIsland => {
                            const childGrids = rowIsland.rowIslandAPI.getChildGrids();
                            childGrids.forEach(chGrid => {
                                const parentRowID = this.getParentRowID(chGrid);
                                context.currGrid = chGrid;
                                if (context.currGrid) {
                                    const childGridState = context.buildState(context.featureKeys);
                                    childGridStates.push({ id: `${rowIsland.id}`, parentRowID: parentRowID, state: childGridState });
                                }
                            });
                        });
                    }
                    context.currGrid = context.grid;
                    return { rowIslands: childGridStates };
                },
                restoreFeatureState(context, state) {
                    const rowIslands = context.currGrid.allLayoutList;
                    if (rowIslands) {
                        rowIslands.forEach(rowIsland => {
                            const childGrids = rowIsland.rowIslandAPI.getChildGrids();
                            childGrids.forEach(chGrid => {
                                const parentRowID = this.getParentRowID(chGrid);
                                context.currGrid = chGrid;
                                const childGridState = state.find(st => st.id === rowIsland.id && st.parentRowID === parentRowID);
                                if (childGridState && context.currGrid) {
                                    context.restoreGridState(childGridState.state, context.featureKeys);
                                }
                            });
                        });
                    }
                    context.currGrid = context.grid;
                },
                /**
                 * Traverses the hierarchy up to the root grid to return the ID of the expanded row.
                 */
                getParentRowID(grid) {
                    let childGrid, childRow;
                    while (grid.parent) {
                        childRow = grid.childRow;
                        childGrid = grid;
                        grid = grid.parent;
                    }
                    return grid.hgridAPI.getParentRowId(childGrid);
                }
            }
        };
    }
    /**
     *  An object with options determining if a certain feature state should be saved.
     * ```html
     * <igx-grid [igxGridState]="options"></igx-grid>
     * ```
     * ```typescript
     * public options = {selection: false, advancedFiltering: false};
     * ```
     */
    get options() {
        return this._options;
    }
    set options(value) {
        Object.assign(this._options, value);
        if (!(this.grid instanceof IgxGridComponent)) {
            delete this._options.groupBy;
        }
        else {
            delete this._options.rowIslands;
        }
    }
    /**
     * Gets the state of a feature or states of all grid features, unless a certain feature is disabled through the `options` property.
     * @param `serialize` determines whether the returned object will be serialized to JSON string. Default value is true.
     * @param `feature` string or array of strings determining the features to be added in the state. If skipped, all features are added.
     * @returns Returns the serialized to JSON string IGridState object, or the non-serialized IGridState object.
     * ```html
     * <igx-grid [igxGridState]="options"></igx-grid>
     * ```
     * ```typescript
     * @ViewChild(IgxGridStateDirective, { static: true }) public state;
     * let state = this.state.getState(); // returns string
     * let state = this.state(false) // returns `IGridState` object
     * ```
     */
    getState(serialize = true, features) {
        let state;
        this.currGrid = this.grid;
        this.state = state = this.buildState(features);
        if (serialize) {
            state = JSON.stringify(state, this.stringifyCallback);
        }
        return state;
    }
    /**
     * Restores grid features' state based on the IGridState object passed as an argument.
     * @param IGridState object to restore state from.
     * @returns
     * ```html
     * <igx-grid [igxGridState]="options"></igx-grid>
     * ```
     * ```typescript
     * @ViewChild(IgxGridStateDirective, { static: true }) public state;
     * this.state.setState(gridState);
     * ```
     */
    setState(state, features) {
        if (typeof state === 'string') {
            state = JSON.parse(state);
        }
        this.currGrid = this.grid;
        this.restoreGridState(state, features);
        this.grid.cdr.detectChanges(); // TODO
    }
    /**
     * Builds an IGridState object.
     */
    buildState(keys) {
        this.applyFeatures(keys);
        let gridState = {};
        this.featureKeys.forEach(f => {
            if (this.options[f]) {
                if (!(this.grid instanceof IgxGridComponent) && f === 'groupBy') {
                    return;
                }
                const feature = this.getFeature(f);
                const featureState = feature.getFeatureState(this);
                gridState = Object.assign(gridState, featureState);
            }
        });
        return gridState;
    }
    /**
     * The method that calls corresponding methods to restore features from the passed IGridState object.
     */
    restoreGridState(state, features) {
        this.applyFeatures(features);
        this.featureKeys.forEach(f => {
            if (this.options[f]) {
                const featureState = state[f];
                if (featureState) {
                    const feature = this.getFeature(f);
                    feature.restoreFeatureState(this, featureState);
                }
            }
        });
    }
    /**
     * Returns a collection of all grid features.
     */
    applyFeatures(keys) {
        this.featureKeys = [];
        if (!keys) {
            for (const key of Object.keys(this.options)) {
                this.featureKeys.push(key);
            }
        }
        else if (Array.isArray(keys)) {
            this.featureKeys = [...keys];
        }
        else {
            this.featureKeys.push(keys);
        }
    }
    /**
     * This method builds a FilteringExpressionsTree from a provided object.
     */
    createExpressionsTreeFromObject(exprTreeObject) {
        if (!exprTreeObject || !exprTreeObject.filteringOperands) {
            return null;
        }
        const expressionsTree = new FilteringExpressionsTree(exprTreeObject.operator, exprTreeObject.fieldName);
        for (const item of exprTreeObject.filteringOperands) {
            // Check if item is an expressions tree or a single expression.
            if (item.filteringOperands) {
                const subTree = this.createExpressionsTreeFromObject(item);
                expressionsTree.filteringOperands.push(subTree);
            }
            else {
                const expr = item;
                let dataType;
                if (this.currGrid.columnList.length > 0) {
                    dataType = this.currGrid.columnList.find(c => c.field === expr.fieldName).dataType;
                }
                else {
                    dataType = this.state.columns.find(c => c.field === expr.fieldName).dataType;
                }
                // when ESF, values are stored in Set.
                // First those values are converted to an array before returning string in the stringifyCallback
                // now we need to convert those back to Set
                if (Array.isArray(expr.searchVal)) {
                    expr.searchVal = new Set(expr.searchVal);
                }
                else {
                    expr.searchVal = (dataType === 'date') ? new Date(Date.parse(expr.searchVal)) : expr.searchVal;
                }
                expr.condition = this.generateFilteringCondition(dataType, expr.condition.name);
                expressionsTree.filteringOperands.push(expr);
            }
        }
        return expressionsTree;
    }
    /**
     * Returns the filtering logic function for a given dataType and condition (contains, greaterThan, etc.)
     */
    generateFilteringCondition(dataType, name) {
        let filters;
        switch (dataType) {
            case DataType.Boolean:
                filters = IgxBooleanFilteringOperand.instance();
                break;
            case DataType.Number:
                filters = IgxNumberFilteringOperand.instance();
                break;
            case DataType.Date:
                filters = IgxDateFilteringOperand.instance();
                break;
            case DataType.String:
            default:
                filters = IgxStringFilteringOperand.instance();
                break;
        }
        return filters.condition(name);
    }
    stringifyCallback(key, val) {
        if (key === 'searchVal' && val instanceof Set) {
            return Array.from(val);
        }
        return val;
    }
    getFeature(key) {
        const feature = this.FEATURES[key];
        return feature;
    }
}
IgxGridStateDirective.ɵfac = function IgxGridStateDirective_Factory(t) { return new (t || IgxGridStateDirective)(ɵngcc0.ɵɵdirectiveInject(IgxGridBaseDirective, 9), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
IgxGridStateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridStateDirective, selectors: [["", "igxGridState", ""]], inputs: { options: ["igxGridState", "options"] } });
IgxGridStateDirective.ctorParameters = () => [
    { type: IgxGridBaseDirective, decorators: [{ type: Host }, { type: Optional }] },
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef }
];
IgxGridStateDirective.propDecorators = {
    options: [{ type: Input, args: ['igxGridState',] }]
};
/**
 * @hidden
 */
class IgxGridStateModule {
}
IgxGridStateModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridStateModule });
IgxGridStateModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridStateModule_Factory(t) { return new (t || IgxGridStateModule)(); } });

class IgxGridSharedModules {
}
IgxGridSharedModules.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridSharedModules });
IgxGridSharedModules.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridSharedModules_Factory(t) { return new (t || IgxGridSharedModules)(); }, imports: [[
            CommonModule,
            FormsModule,
            IgxButtonModule,
            IgxDatePickerModule,
            IgxIconModule,
            IgxRippleModule,
            IgxInputGroupModule,
            IgxFocusModule,
            IgxToggleModule,
            IgxForOfModule,
            IgxTemplateOutletModule,
            IgxTextHighlightModule,
            IgxTextSelectionModule,
            IgxCheckboxModule,
            IgxBadgeModule,
            IgxChipsModule,
            IgxDragDropModule,
            IgxDropDownModule,
            IgxButtonGroupModule,
            IgxProgressBarModule,
            IgxSelectModule,
            IgxGridStateModule,
            IgxSnackbarModule
        ], CommonModule,
        FormsModule, IgxButtonModule, IgxDatePickerModule, IgxIconModule, IgxRippleModule, IgxInputGroupModule, IgxFocusModule, IgxToggleModule, IgxForOfModule, IgxTemplateOutletModule, IgxTextHighlightModule, IgxGridStateModule, IgxTextSelectionModule, IgxCheckboxModule, IgxBadgeModule, IgxChipsModule, IgxDragDropModule, IgxDropDownModule, IgxButtonGroupModule, IgxProgressBarModule, IgxSelectModule, IgxSnackbarModule] });

/**
 * @hidden
 */
class ItemPropertyValueChangedDirective {
    constructor(propName) {
        this.valueChanged = new EventEmitter();
        this._propName = propName;
    }
    get object() {
        return this._object;
    }
    set object(value) {
        if (value) {
            this._object = value;
        }
    }
    get value() {
        return (this.object) ? this.object[this._propName] : null;
    }
    set value(value) {
        this.onValueChanged(value);
    }
    onValueChanged(value) {
        const currentValue = this.value;
        if (value !== currentValue) {
            this.object[this._propName] = value;
            this.valueChanged.emit({ oldValue: currentValue, newValue: value });
        }
    }
}
ItemPropertyValueChangedDirective.ɵfac = function ItemPropertyValueChangedDirective_Factory(t) { return new (t || ItemPropertyValueChangedDirective)(ɵngcc0.ɵɵdirectiveInject(String)); };
ItemPropertyValueChangedDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ItemPropertyValueChangedDirective, inputs: { value: "value" }, outputs: { valueChanged: "valueChanged" } });
ItemPropertyValueChangedDirective.ctorParameters = () => [
    { type: String }
];
ItemPropertyValueChangedDirective.propDecorators = {
    value: [{ type: Input }],
    valueChanged: [{ type: Output }]
};
/** @hidden */
class ColumnChooserItemBaseDirective extends ItemPropertyValueChangedDirective {
    constructor(prop) {
        super(prop);
        this.prop = prop;
        this.indentation = 30;
    }
    get column() {
        return this.object;
    }
    set column(value) {
        if (value) {
            this.object = value;
        }
    }
    get name() {
        return (this.column) ? ((this.column.header) ? this.column.header : this.column.field) : '';
    }
    get level() {
        return this.column.level;
    }
    get calcIndent() {
        return this.indentation * this.level;
    }
}
ColumnChooserItemBaseDirective.ɵfac = function ColumnChooserItemBaseDirective_Factory(t) { return new (t || ColumnChooserItemBaseDirective)(ɵngcc0.ɵɵdirectiveInject(String)); };
ColumnChooserItemBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColumnChooserItemBaseDirective, inputs: { indentation: "indentation", column: "column", container: "container" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
ColumnChooserItemBaseDirective.ctorParameters = () => [
    { type: String }
];
ColumnChooserItemBaseDirective.propDecorators = {
    column: [{ type: Input }],
    indentation: [{ type: Input }],
    container: [{ type: Input }]
};

/** @hidden */
class IgxColumnHidingItemDirective extends ColumnChooserItemBaseDirective {
    constructor() {
        super('hidden');
    }
    get disabled() {
        return this.column.disableHiding;
    }
}
IgxColumnHidingItemDirective.ɵfac = function IgxColumnHidingItemDirective_Factory(t) { return new (t || IgxColumnHidingItemDirective)(); };
IgxColumnHidingItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxColumnHidingItemDirective, selectors: [["", "igxColumnHidingItem", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxColumnHidingItemDirective.ctorParameters = () => [];

class CustomFilteringStrategy extends FilteringStrategy {
    filter(data, expressionsTree) {
        const res = [];
        data.forEach((item) => {
            if (this.matchRecord(item, expressionsTree.filteringOperands[0])) {
                res.push(item);
            }
            else if (item.column.columnGroup) {
                if (item.column.allChildren.findIndex((child) => this.matchRecord(child, expressionsTree.filteringOperands[1]) ||
                    this.matchRecord(child, expressionsTree.filteringOperands[2])) > -1) {
                    res.push(item);
                }
            }
        });
        return res;
    }
}
/** @hidden */
class ColumnChooserBaseDirective {
    constructor(cdr) {
        this.cdr = cdr;
        /**
         * Hides/ shows the filtering columns input from the UI.
         */
        this.disableFilter = false;
        /**
         * Access to the columnHidingUI:
         * ```typescript
         * @ViewChild('column-hiding-component')
         *  public columnHidingUI: IgxColumnHidingComponent;
         * ```
         * Sets/gets the max height of the column area.
         * ```typescript
         * let columnsAreaMaxHeight =  this.columnHidingUI.columnsAreaMaxHeight;
         * ```
         *
         * ```html
         * <igx-column-hiding [columnsAreaMaxHeight]="200px"></igx-column-hiding>
         * ```
         */
        this.columnsAreaMaxHeight = '100%';
        /**
         * Sets/Gets the css class selector.
         * By default the value of the `class` attribute is `"igx-column-hiding"`.
         * ```typescript
         * let cssCLass =  this.columnHidingUI.cssClass;
         * ```
         * ```typescript
         * this.columnHidingUI.cssClass = 'column-chooser';
         * ```
         */
        this.cssClass = 'igx-column-hiding';
        /**
         * @hidden
         */
        this._currentColumns = [];
        /**
         * @hidden
         */
        this._gridColumns = [];
        /**
         * @hidden
         */
        this._rawColumns = [];
        /**
         * @hidden
         */
        this._columnDisplayOrder = ColumnDisplayOrder.DisplayOrder;
        /**
         * @hidden
         */
        this._filterCriteria = '';
        /**
         * @hidden
         */
        this._filterColumnsPrompt = '';
        /**
         * @hidden
         */
        this._title = '';
    }
    /**
     * Gets the grid columns that are going to be manipulated.
     * ```typescript
     * let gridColumns = this.columnHidingUI.columns;
     * ```
     */
    get columns() {
        return this._gridColumns;
    }
    /**
     * Sets the the grid columns that are going to be manipulated.
     * ```html
     * <igx-column-hiding [columns]="grid.columns"></igx-column-hiding>
     * ```
     */
    set columns(value) {
        if (value) {
            this._gridColumns = value;
            this.createColumnItems();
            if (this.filterCriteria) {
                this.filter();
            }
        }
    }
    /**
     * Sets/gets the title of the column chooser.
     * ```typescript
     * let title =  this.columnHidingUI.title;
     * ```
     */
    get title() {
        return this._title;
    }
    /**
     * ```html
     * <igx-column-hiding [title]="'IgxColumnHidingComponent Title'"></igx-column-hiding>
     * ```
     */
    set title(value) {
        this._title = (value) ? value : '';
    }
    /**
     * Gets the prompt that is displayed in the filter input.
     * ```typescript
     * let filterColumnsPrompt =  this.columnHidingUI.filterColumnsPrompt;
     * ```
     */
    get filterColumnsPrompt() {
        return this._filterColumnsPrompt;
    }
    /**
     * Sets the prompt that is going to be displayed in the filter input.
     * ```html
     * <igx-column-hiding [filterColumnsPrompt]="'Type here to search'"></igx-column-hiding>
     * ```
     */
    set filterColumnsPrompt(value) {
        this._filterColumnsPrompt = (value) ? value : '';
    }
    /**
     * Gets the items of the selected columns.
     * ```typescript
     * let columnItems =  this.columnHidingUI.columnItems;
     * ```
     */
    get columnItems() {
        return this._currentColumns;
    }
    /**
     * Gets the value which filters the columns list.
     * ```typescript
     * let filterCriteria =  this.columnHidingUI.filterCriteria;
     * ```
     */
    get filterCriteria() {
        return this._filterCriteria;
    }
    /**
     * Sets the value which filters the columns list.
     * ```html
     *  <igx-column-hiding [filterCriteria]="'ID'"></igx-column-hiding>
     * ```
     */
    set filterCriteria(value) {
        if (!value || value.length === 0) {
            this.clearFiltering();
            this._filterCriteria = '';
            this.cdr.detectChanges();
            return;
        }
        else if (this._filterCriteria && this._filterCriteria.length > value.length) {
            this.clearFiltering();
        }
        this._filterCriteria = value;
        this.filter();
        this.cdr.detectChanges();
    }
    /**
     * Gets the display order of the columns.
     * ```typescript
     * let columnDisplayOrder  =  this.columnHidingUI.columnDisplayOrder;
     * ```
     */
    get columnDisplayOrder() {
        return this._columnDisplayOrder;
    }
    /**
     * Sets the display order of the columns.
     * ```typescript
     * this.columnHidingUI.columnDisplayOrder = ColumnDisplayOrder.Alphabetical;
     * ```
     */
    set columnDisplayOrder(value) {
        if (value !== undefined) {
            this.orderColumns(value);
            if (this._filterCriteria.length > 0) {
                this.filter();
            }
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        for (const item of this._currentColumns) {
            item.valueChanged.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    createColumnItems() {
        if (this._gridColumns.length > 0) {
            this._rawColumns = [];
            this._gridColumns.forEach((column) => {
                const item = this.createColumnItem(this, column);
                if (item) {
                    this._rawColumns.push(item);
                }
            });
            this._currentColumns = this._rawColumns.slice(0);
            this.orderColumns(this._columnDisplayOrder);
        }
    }
    /**
     * @hidden
     */
    orderColumns(value) {
        this._columnDisplayOrder = value;
        if (value === ColumnDisplayOrder[ColumnDisplayOrder.Alphabetical] ||
            value === ColumnDisplayOrder.Alphabetical) {
            this._currentColumns = this._rawColumns.slice(0).sort((current, next) => {
                return current.name.toLowerCase().localeCompare(next.name.toLowerCase());
            });
        }
        else {
            this._currentColumns = this._rawColumns;
        }
    }
    /**
     * @hidden
     */
    filter() {
        const filteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.Or);
        filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('name'));
        filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('field'));
        filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('header'));
        const strategy = new CustomFilteringStrategy();
        this._currentColumns = strategy.filter(this._currentColumns, filteringExpressionsTree);
    }
    /**
     * @hidden
     */
    createFilteringExpression(fieldName) {
        return {
            condition: IgxStringFilteringOperand.instance().condition('contains'),
            fieldName: fieldName,
            ignoreCase: true,
            searchVal: this._filterCriteria
        };
    }
    /**
     * @hidden
     */
    clearFiltering() {
        this.createColumnItems();
    }
}
ColumnChooserBaseDirective.ɵfac = function ColumnChooserBaseDirective_Factory(t) { return new (t || ColumnChooserBaseDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ColumnChooserBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColumnChooserBaseDirective, hostVars: 1, hostBindings: function ColumnChooserBaseDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.cssClass);
    } }, inputs: { disableFilter: "disableFilter", columnsAreaMaxHeight: "columnsAreaMaxHeight", columns: "columns", title: "title", filterColumnsPrompt: "filterColumnsPrompt", columnItems: "columnItems", filterCriteria: "filterCriteria", columnDisplayOrder: "columnDisplayOrder" } });
ColumnChooserBaseDirective.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
ColumnChooserBaseDirective.propDecorators = {
    columns: [{ type: Input }],
    title: [{ type: Input }],
    filterColumnsPrompt: [{ type: Input }],
    disableFilter: [{ type: Input }],
    columnItems: [{ type: Input }],
    filterCriteria: [{ type: Input }],
    columnDisplayOrder: [{ type: Input }],
    columnsAreaMaxHeight: [{ type: Input }],
    cssClass: [{ type: HostBinding, args: ['attr.class',] }]
};

let IgxColumnHidingComponent = class IgxColumnHidingComponent extends ColumnChooserBaseDirective {
    constructor(cdr) {
        super(cdr);
        this.cdr = cdr;
        /**
         * Sets/gets the text of the button that shows all columns if they are hidden.
         * ```typescript
         * let showAllButtonText =  this.columnHiding.showAllText;
         * ```
         *
         * ```html
         * <igx-column-hiding [showAllText] = "'Show Columns'"></igx-column-hiding>
         * ```
         * @memberof IgxColumnHidingComponent
         */
        this.showAllText = 'Show All';
        /**
         * Sets/gets the text of the button that hides all columns if they are shown.
         * ```typescript
         * let hideAllButtonText =  this.columnHiding.hideAllText;
         * ```
         *
         * ```html
         * <igx-column-hiding [hideAllText] = "'Hide Columns'"></igx-column-hiding>
         * ```
         * @memberof IgxColumnHidingComponent
         */
        this.hideAllText = 'Hide All';
        /**
         * An event that is emitted after the columns visibility is changed.
         * Provides references to the `column` and the `newValue` properties as event arguments.
         * ```html
         *  <igx-column-hiding (onColumnVisibilityChanged) = "onColumnVisibilityChanged($event)"></igx-column-hiding>
         * ```
         * @memberof IgxColumnHidingComponent
         */
        this.onColumnVisibilityChanged = new EventEmitter();
        this.destroy$ = new Subject();
    }
    /**
     * Returns a boolean indicating whether the `HIDE ALL` button is disabled.
     * ```html
     * <igx-column-hiding #columnHidingUI
     *     [columns]="grid.columns" [title]="'Column Hiding'">
     * </igx-column-hiding>
     * ```
     * ```typescript
     * @ViewChild("'columnHidingUI'")
     * public columnHiding: IgxColumnHidingComponent;
     * let isHideAlldisabled =  this.columnHiding.disableHideAll;
     * ```
     * @memberof IgxColumnHidingComponent
     */
    get disableHideAll() {
        if (!this.columnItems || this.columnItems.length < 1 ||
            this.hiddenColumnsCount === this.columns.length) {
            return true;
        }
        else if (this.hidableColumns.length < 1 ||
            this.hidableColumns.length === this.hidableColumns.filter((col) => col.value).length) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Returns a boolean indicating whether the `SHOW ALL` button is disabled.
     * ```typescript
     * let isShowAlldisabled =  this.columnHiding.disableShowAll;
     * ```
     * @memberof IgxColumnHidingComponent
     */
    get disableShowAll() {
        if (!this.columnItems || this.columnItems.length < 1 ||
            this.hiddenColumnsCount < 1 || this.hidableColumns.length < 1) {
            return true;
        }
        else if (this.hidableColumns.length === this.hidableColumns.filter((col) => !col.value).length) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Gets the count of the hidden columns.
     * ```typescript
     * let hiddenColumnsCount =  this.columnHiding.hiddenColumnsCount;
     * ```
     * @memberof IgxColumnHidingComponent
     */
    get hiddenColumnsCount() {
        return (this.columns) ? this.columns.filter((col) => col.hidden).length : 0;
    }
    /**
     * @hidden
     */
    get hidableColumns() {
        return this.columnItems.filter((col) => !col.disabled);
    }
    /**
     * @hidden
     */
    createColumnItem(container, column) {
        if (column.grid.hasColumnLayouts && !column.columnLayout) {
            return null;
        }
        const item = new IgxColumnHidingItemDirective();
        item.container = container;
        item.column = column;
        item.valueChanged.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.onVisibilityChanged({ column: item.column, newValue: args.newValue });
        });
        return item;
    }
    /**
     * Shows all columns in the grid.
     * ```typescript
     * this.columnHiding.showAllColumns();
     * ```
     * @memberof IgxColumnHidingComponent
     */
    showAllColumns() {
        const collection = this.hidableColumns;
        for (const col of collection) {
            col.value = false;
        }
    }
    /**
     * Hides all columns in the grid.
     * ```typescript
     * this.columnHiding.hideAllColumns();
     * ```
     * @memberof IgxColumnHidingComponent
     */
    hideAllColumns() {
        const collection = this.hidableColumns;
        for (const col of collection) {
            col.value = true;
        }
    }
    /**
     * @hidden
     */
    onVisibilityChanged(args) {
        this.onColumnVisibilityChanged.emit(args);
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
};
IgxColumnHidingComponent.ɵfac = function IgxColumnHidingComponent_Factory(t) { return new (t || IgxColumnHidingComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxColumnHidingComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxColumnHidingComponent, selectors: [["igx-column-hiding"]], inputs: { showAllText: "showAllText", hideAllText: "hideAllText", disableHideAll: "disableHideAll", disableShowAll: "disableShowAll" }, outputs: { onColumnVisibilityChanged: "onColumnVisibilityChanged" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 9, consts: [[1, "igx-column-actions__header"], ["class", "igx-column-actions__header-title", 4, "ngIf"], ["class", "igx-column-actions__header-input", 4, "ngIf"], [1, "igx-column-actions__columns"], ["class", "igx-column-actions__columns-item", 3, "checked", "disabled", "margin-left", "onColumnVisibilityChanged", "change", 4, "ngFor", "ngForOf"], [1, "igx-column-actions__buttons"], ["igxButton", "", "igxRipple", "", 3, "disabled", "click"], [1, "igx-column-actions__header-title"], [1, "igx-column-actions__header-input"], ["igxInput", "", "type", "text", "autocomplete", "off", 3, "ngModel", "placeholder", "ngModelChange"], [1, "igx-column-actions__columns-item", 3, "checked", "disabled", "onColumnVisibilityChanged", "change"]], template: function IgxColumnHidingComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxColumnHidingComponent_h4_1_Template, 2, 1, "h4", 1);
        ɵngcc0.ɵɵtemplate(2, IgxColumnHidingComponent_igx_input_group_2_Template, 2, 2, "igx-input-group", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, IgxColumnHidingComponent_igx_checkbox_4_Template, 2, 5, "igx-checkbox", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 5);
        ɵngcc0.ɵɵelementStart(6, "button", 6);
        ɵngcc0.ɵɵlistener("click", function IgxColumnHidingComponent_Template_button_click_6_listener() { return ctx.showAllColumns(); });
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "button", 6);
        ɵngcc0.ɵɵlistener("click", function IgxColumnHidingComponent_Template_button_click_8_listener() { return ctx.hideAllColumns(); });
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.disableFilter);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("max-height", ctx.columnsAreaMaxHeight);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.hidableColumns);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("disabled", ctx.disableShowAll);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.showAllText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disableHideAll);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.hideAllText);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgForOf, IgxButtonDirective, IgxRippleDirective, IgxInputGroupComponent, ɵngcc3.DefaultValueAccessor, IgxInputDirective, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxCheckboxComponent], encapsulation: 2 });
IgxColumnHidingComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
IgxColumnHidingComponent.propDecorators = {
    disableHideAll: [{ type: Input }],
    disableShowAll: [{ type: Input }],
    showAllText: [{ type: Input }],
    hideAllText: [{ type: Input }],
    onColumnVisibilityChanged: [{ type: Output }]
};
IgxColumnHidingComponent = __decorate([
    DeprecateClass(`The 'IgxColumnHiding' component is deprecated.
Please use the 'IgxColumnActions' component with the 'IgxColumnHiding' directive instead.`)
], IgxColumnHidingComponent);

class IgxColumnHidingModule {
}
IgxColumnHidingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxColumnHidingModule });
IgxColumnHidingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxColumnHidingModule_Factory(t) { return new (t || IgxColumnHidingModule)(); }, imports: [[
            IgxGridSharedModules
        ]] });

/**
 * A component used for presenting Excel style clear filters UI.
 */
class IgxExcelStyleClearFiltersComponent {
    constructor(esf) {
        this.esf = esf;
    }
    /**
     * @hidden @internal
     */
    clearFilterClass() {
        if (this.esf.column.filteringExpressionsTree) {
            return 'igx-excel-filter__actions-clear';
        }
        return 'igx-excel-filter__actions-clear--disabled';
    }
    /**
     * @hidden @internal
     */
    clearFilter() {
        this.esf.grid.filteringService.clearFilter(this.esf.column.field);
        this.selectAllFilterItems();
    }
    /**
     * @hidden @internal
     */
    onClearFilterKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.clearFilter();
        }
    }
    selectAllFilterItems() {
        this.esf.listData.forEach(filterListItem => {
            filterListItem.isSelected = true;
            filterListItem.indeterminate = false;
        });
        this.esf.detectChanges();
    }
}
IgxExcelStyleClearFiltersComponent.ɵfac = function IgxExcelStyleClearFiltersComponent_Factory(t) { return new (t || IgxExcelStyleClearFiltersComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridExcelStyleFilteringComponent)); };
IgxExcelStyleClearFiltersComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleClearFiltersComponent, selectors: [["igx-excel-style-clear-filters"]], decls: 1, vars: 1, consts: [["tabindex", "0", 3, "ngClass", "keydown", "click", 4, "ngIf"], ["tabindex", "0", 3, "ngClass", "keydown", "click"]], template: function IgxExcelStyleClearFiltersComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxExcelStyleClearFiltersComponent_div_0_Template, 5, 2, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.esf.column);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgClass, IgxIconComponent], encapsulation: 2 });
IgxExcelStyleClearFiltersComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];

/**
 * @hidden
 */
class IgxExcelStyleDefaultExpressionComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.destroy$ = new Subject();
        this.dropDownOverlaySettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: true
        };
        this.onExpressionRemoved = new EventEmitter();
        this.onLogicOperatorChanged = new EventEmitter();
    }
    get isLast() {
        return this.expressionsList[this.expressionsList.length - 1] === this.expressionUI;
    }
    get isSingle() {
        return this.expressionsList.length === 1;
    }
    get conditionsPlaceholder() {
        return this.grid.resourceStrings['igx_grid_filter_condition_placeholder'];
    }
    get inputValuePlaceholder() {
        return this.grid.resourceStrings['igx_grid_filter_row_placeholder'];
    }
    get type() {
        switch (this.column.dataType) {
            case DataType.Number:
                return 'number';
            default:
                return 'text';
        }
    }
    get conditions() {
        return this.column.filters.conditionList();
    }
    get inputValuesElement() {
        return this.inputValuesDirective;
    }
    ngAfterViewInit() {
        this.dropDownOverlaySettings.outlet = this.overlayOutlet;
        this.dropDownOverlaySettings.target = this.dropdownConditions.inputGroup.element.nativeElement;
        this.dropDownOverlaySettings.excludeFromOutsideClick = [this.dropdownConditions.inputGroup.element.nativeElement];
        this.dropDownOverlaySettings.positionStrategy = new ConnectedPositioningStrategy();
    }
    focus() {
        // use requestAnimationFrame to focus the values input because when initializing the component
        // datepicker's input group is not yet fully initialized
        requestAnimationFrame(() => this.inputValuesElement.focus());
    }
    translateCondition(value) {
        return this.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;
    }
    getIconName() {
        if (this.column.dataType === DataType.Boolean && this.expressionUI.expression.condition === null) {
            return this.getCondition(this.conditions[0]).iconName;
        }
        else if (!this.expressionUI.expression.condition) {
            return 'filter_list';
        }
        else {
            return this.expressionUI.expression.condition.iconName;
        }
    }
    isConditionSelected(conditionName) {
        return this.expressionUI.expression.condition && this.expressionUI.expression.condition.name === conditionName;
    }
    onConditionsChanged(eventArgs) {
        const value = eventArgs.newSelection.value;
        this.expressionUI.expression.condition = this.getCondition(value);
        this.focus();
    }
    getCondition(value) {
        return this.column.filters.condition(value);
    }
    onValuesInput(eventArgs) {
        this.expressionUI.expression.searchVal = DataUtil.parseValue(this.column.dataType, eventArgs.target.value);
    }
    onLogicOperatorButtonClicked(eventArgs, buttonIndex) {
        if (this.logicOperatorButtonGroup.selectedButtons.length === 0) {
            eventArgs.stopPropagation();
            this.logicOperatorButtonGroup.selectButton(buttonIndex);
        }
        else {
            this.onLogicOperatorChanged.emit({
                target: this.expressionUI,
                newValue: buttonIndex
            });
        }
    }
    onLogicOperatorKeyDown(eventArgs, buttonIndex) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.logicOperatorButtonGroup.selectButton(buttonIndex);
            this.onLogicOperatorChanged.emit({
                target: this.expressionUI,
                newValue: buttonIndex
            });
        }
    }
    onRemoveButtonClick() {
        this.onExpressionRemoved.emit(this.expressionUI);
    }
    onOutletPointerDown(event) {
        event.preventDefault();
    }
}
IgxExcelStyleDefaultExpressionComponent.ɵfac = function IgxExcelStyleDefaultExpressionComponent_Factory(t) { return new (t || IgxExcelStyleDefaultExpressionComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxExcelStyleDefaultExpressionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleDefaultExpressionComponent, selectors: [["igx-excel-style-default-expression"]], viewQuery: function IgxExcelStyleDefaultExpressionComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c130, true, IgxOverlayOutletDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c187, true, IgxSelectComponent);
        ɵngcc0.ɵɵviewQuery(_c188, true, IgxButtonGroupComponent);
        ɵngcc0.ɵɵstaticViewQuery(_c189, true, IgxInputDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overlayOutlet = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdownConditions = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.logicOperatorButtonGroup = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputValuesDirective = _t.first);
    } }, inputs: { column: "column", expressionUI: "expressionUI", expressionsList: "expressionsList", grid: "grid", displayDensity: "displayDensity" }, outputs: { onExpressionRemoved: "onExpressionRemoved", onLogicOperatorChanged: "onLogicOperatorChanged" }, decls: 14, vars: 13, consts: [["type", "box", 3, "displayDensity", "placeholder", "overlaySettings", "onSelection"], ["dropdownConditions", ""], ["fontSet", "imx-icons", 3, "name", 4, "ngIf"], [4, "ngIf"], [3, "value", "selected", 4, "ngFor", "ngForOf"], ["type", "box", 3, "displayDensity"], ["inputGroupValues", ""], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "type", "placeholder", "disabled", "value", "input"], ["inputValues", ""], ["igxButton", "icon", 3, "displayDensity", "click", 4, "ngIf"], [3, "multiSelection", 4, "ngIf"], ["igxOverlayOutlet", "", 3, "pointerdown"], ["overlayOutlet", ""], ["fontSet", "imx-icons", 3, "name"], [3, "value", "selected"], [1, "igx-grid__filtering-dropdown-items"], [1, "igx-grid__filtering-dropdown-text"], ["igxButton", "icon", 3, "displayDensity", "click"], [3, "multiSelection"], ["logicOperatorButtonGroup", ""], ["igxButton", "", "tabindex", "0", "type", "button", 3, "displayDensity", "selected", "keydown", "click"], ["andButton", ""], ["orButton", ""]], template: function IgxExcelStyleDefaultExpressionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "igx-select", 0, 1);
        ɵngcc0.ɵɵlistener("onSelection", function IgxExcelStyleDefaultExpressionComponent_Template_igx_select_onSelection_0_listener($event) { return ctx.onConditionsChanged($event); });
        ɵngcc0.ɵɵelementStart(2, "igx-prefix");
        ɵngcc0.ɵɵtemplate(3, IgxExcelStyleDefaultExpressionComponent_igx_icon_3_Template, 1, 1, "igx-icon", 2);
        ɵngcc0.ɵɵtemplate(4, IgxExcelStyleDefaultExpressionComponent_igx_icon_4_Template, 2, 0, "igx-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, IgxExcelStyleDefaultExpressionComponent_igx_select_item_5_Template, 5, 4, "igx-select-item", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "igx-input-group", 5, 6);
        ɵngcc0.ɵɵelementStart(8, "input", 7, 8);
        ɵngcc0.ɵɵlistener("input", function IgxExcelStyleDefaultExpressionComponent_Template_input_input_8_listener($event) { return ctx.onValuesInput($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, IgxExcelStyleDefaultExpressionComponent_button_10_Template, 3, 1, "button", 9);
        ɵngcc0.ɵɵtemplate(11, IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_11_Template, 8, 7, "igx-buttongroup", 10);
        ɵngcc0.ɵɵelementStart(12, "div", 11, 12);
        ɵngcc0.ɵɵlistener("pointerdown", function IgxExcelStyleDefaultExpressionComponent_Template_div_pointerdown_12_listener($event) { return ctx.onOutletPointerDown($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity)("placeholder", ctx.conditionsPlaceholder)("overlaySettings", ctx.dropDownOverlaySettings);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.expressionUI.expression.condition);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.expressionUI.expression.condition);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.conditions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("type", ctx.type)("placeholder", ctx.inputValuePlaceholder)("disabled", ctx.expressionUI.expression.condition && ctx.expressionUI.expression.condition.isUnary)("value", ctx.expressionUI.expression.searchVal);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isSingle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isLast);
    } }, directives: [IgxSelectComponent, IgxPrefixDirective, ɵngcc2.NgIf, ɵngcc2.NgForOf, IgxInputGroupComponent, IgxInputDirective, IgxOverlayOutletDirective, IgxIconComponent, IgxSelectItemComponent, IgxButtonDirective, IgxButtonGroupComponent], encapsulation: 2 });
IgxExcelStyleDefaultExpressionComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
IgxExcelStyleDefaultExpressionComponent.propDecorators = {
    column: [{ type: Input }],
    expressionUI: [{ type: Input }],
    expressionsList: [{ type: Input }],
    grid: [{ type: Input }],
    displayDensity: [{ type: Input }],
    onExpressionRemoved: [{ type: Output }],
    onLogicOperatorChanged: [{ type: Output }],
    overlayOutlet: [{ type: ViewChild, args: ['overlayOutlet', { read: IgxOverlayOutletDirective, static: true },] }],
    dropdownConditions: [{ type: ViewChild, args: ['dropdownConditions', { read: IgxSelectComponent, static: true },] }],
    logicOperatorButtonGroup: [{ type: ViewChild, args: ['logicOperatorButtonGroup', { read: IgxButtonGroupComponent },] }],
    inputValuesDirective: [{ type: ViewChild, args: ['inputValues', { read: IgxInputDirective, static: true },] }]
};

/**
 * @hidden
 */
class IgxExcelStyleDateExpressionComponent extends IgxExcelStyleDefaultExpressionComponent {
    get inputValuesElement() {
        return this.datePicker.getEditElement();
    }
    get inputDatePlaceholder() {
        return this.grid.resourceStrings['igx_grid_filter_row_date_placeholder'];
    }
}
IgxExcelStyleDateExpressionComponent.ɵfac = function IgxExcelStyleDateExpressionComponent_Factory(t) { return ɵIgxExcelStyleDateExpressionComponent_BaseFactory(t || IgxExcelStyleDateExpressionComponent); };
IgxExcelStyleDateExpressionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleDateExpressionComponent, selectors: [["igx-excel-style-date-expression"]], viewQuery: function IgxExcelStyleDateExpressionComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c190, true, IgxDatePickerComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.datePicker = _t.first);
    } }, inputs: { displayDensity: "displayDensity" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 13, vars: 11, consts: [["type", "box", 3, "displayDensity", "placeholder", "overlaySettings", "onSelection"], ["dropdownConditions", ""], ["fontSet", "imx-icons", 3, "name", 4, "ngIf"], [4, "ngIf"], [3, "value", "selected", 4, "ngFor", "ngForOf"], ["mode", "dropdown", 3, "ngModel", "locale", "outlet", "ngModelChange"], ["datePicker", ""], ["igxDatePickerTemplate", ""], ["igxButton", "icon", 3, "displayDensity", "click", 4, "ngIf"], [3, "multiSelection", 4, "ngIf"], ["igxOverlayOutlet", "", 3, "pointerdown"], ["overlayOutlet", ""], ["fontSet", "imx-icons", 3, "name"], [3, "value", "selected"], ["type", "box", 3, "displayDensity"], ["dropDownTarget", ""], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "placeholder", "value", "readonly", "disabled", "click"], ["input", ""], ["igxButton", "icon", 3, "displayDensity", "click"], [3, "multiSelection"], ["logicOperatorButtonGroup", ""], ["igxButton", "", "tabindex", "0", "type", "button", 3, "displayDensity", "selected", "keydown", "click"], ["andButton", ""], ["orButton", ""]], template: function IgxExcelStyleDateExpressionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "igx-select", 0, 1);
        ɵngcc0.ɵɵlistener("onSelection", function IgxExcelStyleDateExpressionComponent_Template_igx_select_onSelection_0_listener($event) { return ctx.onConditionsChanged($event); });
        ɵngcc0.ɵɵelementStart(2, "igx-prefix");
        ɵngcc0.ɵɵtemplate(3, IgxExcelStyleDateExpressionComponent_igx_icon_3_Template, 1, 1, "igx-icon", 2);
        ɵngcc0.ɵɵtemplate(4, IgxExcelStyleDateExpressionComponent_igx_icon_4_Template, 2, 0, "igx-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, IgxExcelStyleDateExpressionComponent_igx_select_item_5_Template, 4, 4, "igx-select-item", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "igx-date-picker", 5, 6);
        ɵngcc0.ɵɵlistener("ngModelChange", function IgxExcelStyleDateExpressionComponent_Template_igx_date_picker_ngModelChange_6_listener($event) { return ctx.expressionUI.expression.searchVal = $event; });
        ɵngcc0.ɵɵtemplate(8, IgxExcelStyleDateExpressionComponent_ng_template_8_Template, 5, 10, "ng-template", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, IgxExcelStyleDateExpressionComponent_button_9_Template, 3, 1, "button", 8);
        ɵngcc0.ɵɵtemplate(10, IgxExcelStyleDateExpressionComponent_igx_buttongroup_10_Template, 8, 7, "igx-buttongroup", 9);
        ɵngcc0.ɵɵelementStart(11, "div", 10, 11);
        ɵngcc0.ɵɵlistener("pointerdown", function IgxExcelStyleDateExpressionComponent_Template_div_pointerdown_11_listener($event) { return ctx.onOutletPointerDown($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity)("placeholder", ctx.conditionsPlaceholder)("overlaySettings", ctx.dropDownOverlaySettings);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.expressionUI.expression.condition);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.expressionUI.expression.condition);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.conditions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngModel", ctx.expressionUI.expression.searchVal)("locale", ctx.grid.locale)("outlet", ctx.grid.outlet);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isSingle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isLast);
    } }, directives: [IgxSelectComponent, IgxPrefixDirective, ɵngcc2.NgIf, ɵngcc2.NgForOf, IgxDatePickerComponent, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxDatePickerTemplateDirective, IgxOverlayOutletDirective, IgxIconComponent, IgxSelectItemComponent, IgxInputGroupComponent, IgxInputDirective, IgxButtonDirective, IgxButtonGroupComponent], pipes: [ɵngcc2.DatePipe], encapsulation: 2 });
IgxExcelStyleDateExpressionComponent.propDecorators = {
    datePicker: [{ type: ViewChild, args: ['datePicker', { read: IgxDatePickerComponent, static: true },] }],
    displayDensity: [{ type: Input }]
};

/**
 * @hidden
 */
class IgxExcelStyleCustomDialogComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.destroy$ = new Subject();
        this.expressionsList = new Array();
        this._customDialogPositionSettings = {
            verticalDirection: VerticalAlignment.Middle,
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle
        };
        this._customDialogOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._customDialogPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
    }
    ngAfterViewInit() {
        this._customDialogOverlaySettings.outlet = this.grid.outlet;
    }
    get template() {
        if (this.column.dataType === DataType.Date) {
            return this.dateExpressionTemplate;
        }
        return this.defaultExpressionTemplate;
    }
    get grid() {
        return this.filteringService.grid;
    }
    onCustomDialogOpening() {
        if (this.selectedOperator) {
            this.createInitialExpressionUIElement();
        }
    }
    onCustomDialogOpened() {
        if (this.expressionComponents.first) {
            this.expressionComponents.first.focus();
        }
    }
    open(esf) {
        this._customDialogOverlaySettings.target =
            this.overlayComponentId ?
                this.grid.rootGrid ? this.grid.rootGrid.nativeElement : this.grid.nativeElement :
                esf;
        this.toggle.open(this._customDialogOverlaySettings);
    }
    onClearButtonClick() {
        this.filteringService.clearFilter(this.column.field);
        this.createInitialExpressionUIElement();
        this.cdr.detectChanges();
    }
    closeDialog() {
        if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
        }
        else {
            this.toggle.close();
        }
    }
    onApplyButtonClick() {
        this.expressionsList = this.expressionsList.filter(element => element.expression.condition &&
            (element.expression.searchVal || element.expression.searchVal === 0 || element.expression.condition.isUnary));
        if (this.expressionsList.length > 0) {
            this.expressionsList[0].beforeOperator = null;
            this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
        }
        this.filteringService.filterInternal(this.column.field, this.expressionsList);
        this.closeDialog();
    }
    onAddButtonClick() {
        const exprUI = new ExpressionUI();
        exprUI.expression = {
            condition: null,
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        this.expressionsList[this.expressionsList.length - 1].afterOperator = FilteringLogic.And;
        exprUI.beforeOperator = this.expressionsList[this.expressionsList.length - 1].afterOperator;
        this.expressionsList.push(exprUI);
        this.markChildrenForCheck();
        this.scrollToBottom();
    }
    onExpressionRemoved(event) {
        const indexToRemove = this.expressionsList.indexOf(event);
        if (indexToRemove === 0 && this.expressionsList.length > 1) {
            this.expressionsList[1].beforeOperator = null;
        }
        else if (indexToRemove === this.expressionsList.length - 1) {
            this.expressionsList[indexToRemove - 1].afterOperator = null;
        }
        else {
            this.expressionsList[indexToRemove - 1].afterOperator = this.expressionsList[indexToRemove + 1].beforeOperator;
            this.expressionsList[0].beforeOperator = null;
            this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
        }
        this.expressionsList.splice(indexToRemove, 1);
        this.cdr.detectChanges();
        this.markChildrenForCheck();
    }
    onLogicOperatorChanged(event) {
        const index = this.expressionsList.indexOf(event.target);
        event.target.afterOperator = event.newValue;
        if (index + 1 < this.expressionsList.length) {
            this.expressionsList[index + 1].beforeOperator = event.newValue;
        }
    }
    onKeyDown(eventArgs) {
        eventArgs.stopPropagation();
    }
    onApplyButtonKeyDown(eventArgs) {
        if (eventArgs.key === "Tab" /* TAB */ && !eventArgs.shiftKey) {
            eventArgs.stopPropagation();
            eventArgs.preventDefault();
        }
    }
    createCondition(conditionName) {
        switch (this.column.dataType) {
            case DataType.Boolean:
                return IgxBooleanFilteringOperand.instance().condition(conditionName);
            case DataType.Number:
                return IgxNumberFilteringOperand.instance().condition(conditionName);
            case DataType.Date:
                return IgxDateFilteringOperand.instance().condition(conditionName);
            default:
                return IgxStringFilteringOperand.instance().condition(conditionName);
        }
    }
    markChildrenForCheck() {
        this.expressionComponents.forEach(x => x.cdr.markForCheck());
        this.expressionDateComponents.forEach(x => x.cdr.markForCheck());
    }
    createInitialExpressionUIElement() {
        this.expressionsList = [];
        const firstExprUI = new ExpressionUI();
        firstExprUI.expression = {
            condition: this.createCondition(this.selectedOperator),
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        firstExprUI.afterOperator = FilteringLogic.And;
        this.expressionsList.push(firstExprUI);
        const secondExprUI = new ExpressionUI();
        secondExprUI.expression = {
            condition: null,
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        secondExprUI.beforeOperator = FilteringLogic.And;
        this.expressionsList.push(secondExprUI);
    }
    scrollToBottom() {
        requestAnimationFrame(() => {
            this.expressionsContainer.nativeElement.scrollTop = this.expressionsContainer.nativeElement.scrollHeight;
        });
    }
}
IgxExcelStyleCustomDialogComponent.ɵfac = function IgxExcelStyleCustomDialogComponent_Factory(t) { return new (t || IgxExcelStyleCustomDialogComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxExcelStyleCustomDialogComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleCustomDialogComponent, selectors: [["igx-excel-style-custom-dialog"]], viewQuery: function IgxExcelStyleCustomDialogComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c191, true, IgxToggleDirective);
        ɵngcc0.ɵɵviewQuery(_c192, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(_c193, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c129, true);
        ɵngcc0.ɵɵviewQuery(IgxExcelStyleDefaultExpressionComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxExcelStyleDateExpressionComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExpressionTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dateExpressionTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.expressionsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.expressionComponents = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.expressionDateComponents = _t);
    } }, inputs: { expressionsList: "expressionsList", column: "column", selectedOperator: "selectedOperator", filteringService: "filteringService", overlayComponentId: "overlayComponentId", overlayService: "overlayService", displayDensity: "displayDensity" }, decls: 22, vars: 16, consts: [["igxToggle", "", 1, "igx-excel-filter__secondary", 3, "ngClass", "keydown", "onOpening", "onOpened"], ["toggle", ""], [1, "igx-excel-filter__secondary-header"], [1, "igx-typography__h6"], [1, "igx-excel-filter__secondary-main"], ["expressionsContainer", ""], [4, "ngIf"], ["igxButton", "", 1, "igx-excel-filter__add-filter", 3, "displayDensity", "click"], [1, "igx-excel-filter__secondary-footer"], ["igxButton", "", 3, "displayDensity", "click"], ["igxButton", "raised", 3, "displayDensity", "click", "keydown"], ["class", "igx-excel-filter__condition", 3, "expressionUI", "column", "grid", "displayDensity", "expressionsList", "onExpressionRemoved", "onLogicOperatorChanged", 4, "ngFor", "ngForOf"], [1, "igx-excel-filter__condition", 3, "expressionUI", "column", "grid", "displayDensity", "expressionsList", "onExpressionRemoved", "onLogicOperatorChanged"]], template: function IgxExcelStyleCustomDialogComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "article", 0, 1);
        ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleCustomDialogComponent_Template_article_keydown_0_listener($event) { return ctx.onKeyDown($event); })("onOpening", function IgxExcelStyleCustomDialogComponent_Template_article_onOpening_0_listener() { return ctx.onCustomDialogOpening(); })("onOpened", function IgxExcelStyleCustomDialogComponent_Template_article_onOpened_0_listener() { return ctx.onCustomDialogOpened(); });
        ɵngcc0.ɵɵelementStart(2, "header", 2);
        ɵngcc0.ɵɵelementStart(3, "h4", 3);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "article", 4, 5);
        ɵngcc0.ɵɵtemplate(7, IgxExcelStyleCustomDialogComponent_ng_container_7_Template, 2, 1, "ng-container", 6);
        ɵngcc0.ɵɵtemplate(8, IgxExcelStyleCustomDialogComponent_ng_container_8_Template, 2, 1, "ng-container", 6);
        ɵngcc0.ɵɵelementStart(9, "button", 7);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleCustomDialogComponent_Template_button_click_9_listener() { return ctx.onAddButtonClick(); });
        ɵngcc0.ɵɵelementStart(10, "igx-icon");
        ɵngcc0.ɵɵtext(11, "add");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "span");
        ɵngcc0.ɵɵtext(13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(14, "footer", 8);
        ɵngcc0.ɵɵelementStart(15, "button", 9);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleCustomDialogComponent_Template_button_click_15_listener() { return ctx.onClearButtonClick(); });
        ɵngcc0.ɵɵtext(16);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(17, "div");
        ɵngcc0.ɵɵelementStart(18, "button", 9);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleCustomDialogComponent_Template_button_click_18_listener() { return ctx.closeDialog(); });
        ɵngcc0.ɵɵtext(19);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(20, "button", 10);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleCustomDialogComponent_Template_button_click_20_listener() { return ctx.onApplyButtonClick(); })("keydown", function IgxExcelStyleCustomDialogComponent_Template_button_keydown_20_listener($event) { return ctx.onApplyButtonKeyDown($event); });
        ɵngcc0.ɵɵtext(21);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(13, _c194, ctx.grid.displayDensity === "cosy", ctx.grid.displayDensity === "compact"));
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵtextInterpolate2(" ", ctx.grid.resourceStrings.igx_grid_excel_custom_dialog_header, "", ctx.column.header || ctx.column.field, " ");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.column.dataType === "date");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.column.dataType !== "date");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵtextInterpolate(ctx.grid.resourceStrings.igx_grid_excel_custom_dialog_add);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.grid.resourceStrings.igx_grid_excel_custom_dialog_clear);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.grid.resourceStrings.igx_grid_excel_cancel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.grid.resourceStrings.igx_grid_excel_apply, " ");
    } }, directives: [IgxToggleDirective, ɵngcc2.NgClass, ɵngcc2.NgIf, IgxButtonDirective, IgxIconComponent, ɵngcc2.NgForOf, IgxExcelStyleDateExpressionComponent, IgxExcelStyleDefaultExpressionComponent], encapsulation: 2 });
IgxExcelStyleCustomDialogComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
IgxExcelStyleCustomDialogComponent.propDecorators = {
    expressionsList: [{ type: Input }],
    column: [{ type: Input }],
    selectedOperator: [{ type: Input }],
    filteringService: [{ type: Input }],
    overlayComponentId: [{ type: Input }],
    overlayService: [{ type: Input }],
    displayDensity: [{ type: Input }],
    expressionComponents: [{ type: ViewChildren, args: [IgxExcelStyleDefaultExpressionComponent,] }],
    expressionDateComponents: [{ type: ViewChildren, args: [IgxExcelStyleDateExpressionComponent,] }],
    toggle: [{ type: ViewChild, args: ['toggle', { read: IgxToggleDirective, static: true },] }],
    defaultExpressionTemplate: [{ type: ViewChild, args: ['defaultExpressionTemplate', { read: TemplateRef },] }],
    dateExpressionTemplate: [{ type: ViewChild, args: ['dateExpressionTemplate', { read: TemplateRef },] }],
    expressionsContainer: [{ type: ViewChild, args: ['expressionsContainer', { static: true },] }]
};

/**
 * A component used for presenting Excel style conditional filter UI.
 */
class IgxExcelStyleConditionalFilterComponent {
    constructor(esf) {
        this.esf = esf;
        this.shouldOpenSubMenu = true;
        this.destroy$ = new Subject();
        this._subMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Top
        };
        this._subMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        this.esf.columnChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (this.esf.grid) {
                this._subMenuOverlaySettings.outlet = this.esf.grid.outlet;
            }
        });
        if (this.esf.grid) {
            this._subMenuOverlaySettings.outlet = this.esf.grid.outlet;
        }
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden @internal
     */
    onTextFilterKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.onTextFilterClick(eventArgs);
        }
    }
    /**
     * @hidden @internal
     */
    onTextFilterClick(eventArgs) {
        if (this.shouldOpenSubMenu) {
            this._subMenuOverlaySettings.target = eventArgs.currentTarget;
            const gridRect = this.esf.grid.nativeElement.getBoundingClientRect();
            const dropdownRect = this.esf.mainDropdown.nativeElement.getBoundingClientRect();
            let x = dropdownRect.left + dropdownRect.width;
            let x1 = gridRect.left + gridRect.width;
            x += window.pageXOffset;
            x1 += window.pageXOffset;
            if (Math.abs(x - x1) < 200) {
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Left;
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Left;
            }
            else {
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Right;
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Right;
            }
            this.subMenu.open(this._subMenuOverlaySettings);
            this.shouldOpenSubMenu = false;
        }
    }
    /**
     * @hidden @internal
     */
    getCondition(value) {
        return this.esf.column.filters.condition(value);
    }
    /**
     * @hidden @internal
     */
    translateCondition(value) {
        return this.esf.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;
    }
    /**
     * @hidden @internal
     */
    onSubMenuSelection(eventArgs) {
        if (this.esf.expressionsList && this.esf.expressionsList.length &&
            this.esf.expressionsList[0].expression.condition.name !== 'in') {
            this.customDialog.expressionsList = this.esf.expressionsList;
        }
        this.customDialog.selectedOperator = eventArgs.newSelection.value;
        eventArgs.cancel = true;
        if (this.esf.overlayComponentId) {
            this.esf.hide();
        }
        this.subMenu.close();
        this.customDialog.open(this.esf.mainDropdown.nativeElement);
    }
    /**
     * @hidden @internal
     */
    onSubMenuClosed() {
        requestAnimationFrame(() => {
            this.shouldOpenSubMenu = true;
        });
    }
    /**
     * @hidden @internal
     */
    showCustomFilterItem() {
        const exprTree = this.esf.column.filteringExpressionsTree;
        return exprTree && exprTree.filteringOperands && exprTree.filteringOperands.length &&
            !(exprTree.filteringOperands[0].condition &&
                exprTree.filteringOperands[0].condition.name === 'in');
    }
    /**
     * @hidden @internal
     */
    get subMenuText() {
        switch (this.esf.column.dataType) {
            case DataType.Boolean:
                return this.esf.grid.resourceStrings.igx_grid_excel_boolean_filter;
            case DataType.Number:
                return this.esf.grid.resourceStrings.igx_grid_excel_number_filter;
            case DataType.Date:
                return this.esf.grid.resourceStrings.igx_grid_excel_date_filter;
            default:
                return this.esf.grid.resourceStrings.igx_grid_excel_text_filter;
        }
    }
    /**
     * @hidden @internal
     */
    get conditions() {
        return this.esf.column.filters.conditionList();
    }
}
IgxExcelStyleConditionalFilterComponent.ɵfac = function IgxExcelStyleConditionalFilterComponent_Factory(t) { return new (t || IgxExcelStyleConditionalFilterComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridExcelStyleFilteringComponent)); };
IgxExcelStyleConditionalFilterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleConditionalFilterComponent, selectors: [["igx-excel-style-conditional-filter"]], viewQuery: function IgxExcelStyleConditionalFilterComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c195, true, IgxExcelStyleCustomDialogComponent);
        ɵngcc0.ɵɵviewQuery(_c196, true, IgxDropDownComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customDialog = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.subMenu = _t.first);
    } }, decls: 1, vars: 1, consts: [[4, "ngIf"], ["tabindex", "0", 1, "igx-excel-filter__actions-filter", 3, "igxDropDownItemNavigation", "keydown", "click"], [3, "maxHeight", "displayDensity", "onSelection", "onClosed"], ["subMenu", ""], [3, "value", 4, "ngFor", "ngForOf"], [3, "column", "filteringService", "overlayComponentId", "overlayService", "displayDensity"], ["customDialog", ""], [3, "value"], [1, "igx-grid__filtering-dropdown-items"], ["fontSet", "imx-icons", 3, "name"], [1, "igx-grid__filtering-dropdown-text"]], template: function IgxExcelStyleConditionalFilterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxExcelStyleConditionalFilterComponent_ng_container_0_Template, 13, 11, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.esf.column);
    } }, directives: [ɵngcc2.NgIf, IgxDropDownItemNavigationDirective, IgxIconComponent, IgxDropDownComponent, ɵngcc2.NgForOf, IgxExcelStyleCustomDialogComponent, IgxDropDownItemComponent], encapsulation: 2 });
IgxExcelStyleConditionalFilterComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];
IgxExcelStyleConditionalFilterComponent.propDecorators = {
    customDialog: [{ type: ViewChild, args: ['customDialog', { read: IgxExcelStyleCustomDialogComponent },] }],
    subMenu: [{ type: ViewChild, args: ['subMenu', { read: IgxDropDownComponent },] }]
};

/**
 * A component used for presenting Excel style header UI.
 */
class IgxExcelStyleHeaderComponent {
    constructor(esf) {
        this.esf = esf;
    }
}
IgxExcelStyleHeaderComponent.ɵfac = function IgxExcelStyleHeaderComponent_Factory(t) { return new (t || IgxExcelStyleHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridExcelStyleFilteringComponent)); };
IgxExcelStyleHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleHeaderComponent, selectors: [["igx-excel-style-header"]], inputs: { showPinning: "showPinning", showSelecting: "showSelecting", showHiding: "showHiding" }, decls: 1, vars: 1, consts: [["class", "igx-excel-filter__menu-header", 4, "ngIf"], [1, "igx-excel-filter__menu-header"], [1, "igx-excel-filter__menu-header-actions"], ["igxButton", "icon", 3, "ngClass", "click", 4, "ngIf"], ["igxButton", "icon", 3, "click", 4, "ngIf"], ["igxButton", "icon", 3, "ngClass", "click"], ["fontSet", "material"], ["igxButton", "icon", 3, "click"], ["fontSet", "imx-icons", 3, "name"]], template: function IgxExcelStyleHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxExcelStyleHeaderComponent_header_0_Template, 7, 4, "header", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.esf.column);
    } }, directives: [ɵngcc2.NgIf, IgxButtonDirective, ɵngcc2.NgClass, IgxIconComponent], encapsulation: 2 });
IgxExcelStyleHeaderComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];
IgxExcelStyleHeaderComponent.propDecorators = {
    showPinning: [{ type: Input }],
    showSelecting: [{ type: Input }],
    showHiding: [{ type: Input }]
};

/**
 * A component used for presenting Excel style column hiding UI.
 */
class IgxExcelStyleHidingComponent {
    constructor(esf) {
        this.esf = esf;
    }
}
IgxExcelStyleHidingComponent.ɵfac = function IgxExcelStyleHidingComponent_Factory(t) { return new (t || IgxExcelStyleHidingComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridExcelStyleFilteringComponent)); };
IgxExcelStyleHidingComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleHidingComponent, selectors: [["igx-excel-style-hiding"]], decls: 1, vars: 1, consts: [["class", "igx-excel-filter__actions-hide", "tabindex", "0", 3, "click", 4, "ngIf"], ["tabindex", "0", 1, "igx-excel-filter__actions-hide", 3, "click"]], template: function IgxExcelStyleHidingComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxExcelStyleHidingComponent_div_0_Template, 5, 2, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.esf.column);
    } }, directives: [ɵngcc2.NgIf, IgxIconComponent], encapsulation: 2 });
IgxExcelStyleHidingComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];

/**
 * A component used for presenting Excel style column moving UI.
 */
class IgxExcelStyleMovingComponent {
    constructor(esf) {
        this.esf = esf;
        /**
         * @hidden @internal
         */
        this.class = 'igx-excel-filter__move';
    }
    get visibleColumns() {
        return this.esf.grid.visibleColumns.filter(col => !(col instanceof IgxColumnGroupComponent));
    }
    /**
     * @hidden @internal
     */
    get canNotMoveLeft() {
        return this.esf.column.visibleIndex === 0 ||
            (this.esf.grid.unpinnedColumns.indexOf(this.esf.column) === 0 && this.esf.column.disablePinning) ||
            (this.esf.column.level !== 0 && !this.findColumn(0, this.visibleColumns));
    }
    /**
     * @hidden @internal
     */
    get canNotMoveRight() {
        return this.esf.column.visibleIndex === this.visibleColumns.length - 1 ||
            (this.esf.column.level !== 0 && !this.findColumn(1, this.visibleColumns));
    }
    /**
     * @hidden @internal
     */
    onMoveButtonClicked(moveDirection) {
        let targetColumn;
        if (this.esf.column.pinned) {
            if (this.esf.column.isLastPinned && moveDirection === 1 && this.esf.grid.isPinningToStart) {
                targetColumn = this.esf.grid.unpinnedColumns[0];
                moveDirection = 0;
            }
            else if (this.esf.column.isFirstPinned && moveDirection === 0 && !this.esf.grid.isPinningToStart) {
                targetColumn = this.esf.grid.unpinnedColumns[this.esf.grid.unpinnedColumns.length - 1];
                moveDirection = 1;
            }
            else {
                targetColumn = this.findColumn(moveDirection, this.esf.grid.pinnedColumns);
            }
        }
        else if (this.esf.grid.unpinnedColumns.indexOf(this.esf.column) === 0 && moveDirection === 0 &&
            this.esf.grid.isPinningToStart) {
            targetColumn = this.esf.grid.pinnedColumns[this.esf.grid.pinnedColumns.length - 1];
            if (targetColumn.parent) {
                targetColumn = targetColumn.topLevelParent;
            }
            moveDirection = 1;
        }
        else if (this.esf.grid.unpinnedColumns.indexOf(this.esf.column) === this.esf.grid.unpinnedColumns.length - 1 &&
            moveDirection === 1 && !this.esf.grid.isPinningToStart) {
            targetColumn = this.esf.grid.pinnedColumns[0];
            moveDirection = 0;
        }
        else {
            targetColumn = this.findColumn(moveDirection, this.esf.grid.unpinnedColumns);
        }
        this.esf.grid.moveColumn(this.esf.column, targetColumn, moveDirection);
    }
    findColumn(moveDirection, columns) {
        let index = columns.indexOf(this.esf.column);
        if (moveDirection === 0) {
            while (index > 0) {
                index--;
                if (columns[index].level === this.esf.column.level && columns[index].parent === this.esf.column.parent) {
                    return columns[index];
                }
            }
        }
        else {
            while (index < columns.length - 1) {
                index++;
                if (columns[index].level === this.esf.column.level && columns[index].parent === this.esf.column.parent) {
                    return columns[index];
                }
            }
        }
    }
}
IgxExcelStyleMovingComponent.ɵfac = function IgxExcelStyleMovingComponent_Factory(t) { return new (t || IgxExcelStyleMovingComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridExcelStyleFilteringComponent)); };
IgxExcelStyleMovingComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleMovingComponent, selectors: [["igx-excel-style-moving"]], hostVars: 2, hostBindings: function IgxExcelStyleMovingComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.class);
    } }, decls: 1, vars: 1, consts: [[4, "ngIf"], [1, "igx-excel-filter__move-buttons"], ["igxButton", "", 3, "displayDensity", "disabled", "click"]], template: function IgxExcelStyleMovingComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxExcelStyleMovingComponent_ng_container_0_Template, 14, 7, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.esf.column);
    } }, directives: [ɵngcc2.NgIf, IgxButtonDirective, IgxIconComponent], encapsulation: 2 });
IgxExcelStyleMovingComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];
IgxExcelStyleMovingComponent.propDecorators = {
    class: [{ type: HostBinding, args: ['class',] }]
};

/**
 * A component used for presenting Excel style column pinning UI.
 */
class IgxExcelStylePinningComponent {
    constructor(esf) {
        this.esf = esf;
    }
}
IgxExcelStylePinningComponent.ɵfac = function IgxExcelStylePinningComponent_Factory(t) { return new (t || IgxExcelStylePinningComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridExcelStyleFilteringComponent)); };
IgxExcelStylePinningComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStylePinningComponent, selectors: [["igx-excel-style-pinning"]], decls: 1, vars: 1, consts: [["tabindex", "0", 3, "ngClass", "click", 4, "ngIf"], ["tabindex", "0", 3, "ngClass", "click"], ["fontSet", "imx-icons", 3, "name"]], template: function IgxExcelStylePinningComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxExcelStylePinningComponent_div_0_Template, 4, 3, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.esf.column);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgClass, IgxIconComponent], encapsulation: 2 });
IgxExcelStylePinningComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];

/**
 * A component used for presenting Excel style conditional filter UI.
 */
class IgxExcelStyleSelectingComponent {
    constructor(esf) {
        this.esf = esf;
    }
}
IgxExcelStyleSelectingComponent.ɵfac = function IgxExcelStyleSelectingComponent_Factory(t) { return new (t || IgxExcelStyleSelectingComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridExcelStyleFilteringComponent)); };
IgxExcelStyleSelectingComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleSelectingComponent, selectors: [["igx-excel-style-selecting"]], decls: 1, vars: 1, consts: [["tabindex", "0", 3, "ngClass", "click", 4, "ngIf"], ["tabindex", "0", 3, "ngClass", "click"], ["fontSet", "material"]], template: function IgxExcelStyleSelectingComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxExcelStyleSelectingComponent_div_0_Template, 5, 2, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.esf.column);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgClass, IgxIconComponent], encapsulation: 2 });
IgxExcelStyleSelectingComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent }
];

/**
 * A component used for presenting Excel style column sorting UI.
 */
class IgxExcelStyleSortingComponent {
    constructor(esf, cdr) {
        this.esf = esf;
        this.cdr = cdr;
        this.destroy$ = new Subject();
        /**
         * @hidden @internal
         */
        this.class = 'igx-excel-filter__sort';
        this.esf.sortingChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.updateSelectedButtons(this.esf.column.field);
        });
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    updateSelectedButtons(fieldName) {
        const sortIndex = this.esf.grid.sortingExpressions.findIndex(s => s.fieldName === fieldName);
        this.cdr.detectChanges();
        this.sortButtonGroup.buttons.forEach((b, i) => {
            this.sortButtonGroup.deselectButton(i);
        });
        if (sortIndex !== -1) {
            const sortDirection = this.esf.grid.sortingExpressions[sortIndex].dir;
            this.sortButtonGroup.selectButton(sortDirection - 1);
        }
    }
    /**
     * @hidden @internal
     */
    onSortButtonClicked(sortDirection) {
        if (this.sortButtonGroup.selectedIndexes.length === 0) {
            if (this.esf.grid.isColumnGrouped(this.esf.column.field)) {
                this.sortButtonGroup.selectButton(sortDirection - 1);
            }
            else {
                this.esf.grid.clearSort(this.esf.column.field);
            }
        }
        else {
            this.esf.grid.sort({ fieldName: this.esf.column.field, dir: sortDirection, ignoreCase: true });
        }
    }
}
IgxExcelStyleSortingComponent.ɵfac = function IgxExcelStyleSortingComponent_Factory(t) { return new (t || IgxExcelStyleSortingComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridExcelStyleFilteringComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxExcelStyleSortingComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleSortingComponent, selectors: [["igx-excel-style-sorting"]], viewQuery: function IgxExcelStyleSortingComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c197, true, IgxButtonGroupComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sortButtonGroup = _t.first);
    } }, hostVars: 2, hostBindings: function IgxExcelStyleSortingComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.class);
    } }, decls: 1, vars: 1, consts: [[4, "ngIf"], [3, "multiSelection"], ["sortButtonGroup", ""], ["igxButton", "", 3, "displayDensity", "click"]], template: function IgxExcelStyleSortingComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxExcelStyleSortingComponent_ng_container_0_Template, 15, 8, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.esf.column);
    } }, directives: [ɵngcc2.NgIf, IgxButtonGroupComponent, IgxButtonDirective, IgxIconComponent], encapsulation: 2 });
IgxExcelStyleSortingComponent.ctorParameters = () => [
    { type: IgxGridExcelStyleFilteringComponent },
    { type: ChangeDetectorRef }
];
IgxExcelStyleSortingComponent.propDecorators = {
    class: [{ type: HostBinding, args: ['class',] }],
    sortButtonGroup: [{ type: ViewChild, args: ['sortButtonGroup', { read: IgxButtonGroupComponent },] }]
};

/**
 * Providing reference to `IgxGridCellComponent`:
 * ```typescript
 * @ViewChild('grid', { read: IgxGridComponent })
 *  public grid: IgxGridComponent;
 * ```
 * ```typescript
 *  let column = this.grid.columnList.first;
 * ```
 * ```typescript
 *  let cell = column.cells[0];
 * ```
 */
class IgxGridCellComponent {
    constructor(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil) {
        this.selectionService = selectionService;
        this.crudService = crudService;
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.element = element;
        this.zone = zone;
        this.touchManager = touchManager;
        this.platformUtil = platformUtil;
        this._vIndex = -1;
        /**
         * Sets/gets the highlight class of the cell.
         * Default value is `"igx-highlight"`.
         * ```typescript
         * let highlightClass = this.cell.highlightClass;
         * ```
         * ```typescript
         * this.cell.highlightClass = 'igx-cell-highlight';
         * ```
         * @memberof IgxGridCellComponent
         */
        this.highlightClass = 'igx-highlight';
        /**
         * Sets/gets the active highlight class class of the cell.
         * Default value is `"igx-highlight__active"`.
         * ```typescript
         * let activeHighlightClass = this.cell.activeHighlightClass;
         * ```
         * ```typescript
         * this.cell.activeHighlightClass = 'igx-cell-highlight_active';
         * ```
         * @memberof IgxGridCellComponent
         */
        this.activeHighlightClass = 'igx-highlight__active';
        /**
         * @hidden
         * @internal
         */
        this.lastPinned = false;
        /**
         * @hidden
         * @internal
         */
        this.firstPinned = false;
        /**
         * Returns whether the cell is in edit mode.
         */
        this.editMode = false;
        /**
         * Sets/get the `role` property of the cell.
         * Default value is `"gridcell"`.
         * ```typescript
         * this.cell.role = 'grid-cell';
         * ```
         * ```typescript
         * let cellRole = this.cell.role;
         * ```
         * @memberof IgxGridCellComponent
         */
        this.role = 'gridcell';
        /**
         * Gets the width of the cell.
         * ```typescript
         * let cellWidth = this.cell.width;
         * ```
         * @memberof IgxGridCellComponent
         */
        this.width = '';
        /**
         * @hidden
         */
        this.active = false;
        /**
         * @hidden
         */
        this.displayPinnedChip = false;
        /** @hidden @internal @deprecated */
        this.focused = this.active;
        this._cellSelection = GridSelectionMode.multiple;
        /**
         *
         * @hidden
         * @internal
         */
        this.pointerdown = (event) => {
            if (this.cellSelectionMode !== GridSelectionMode.multiple) {
                this.activate(event);
                return;
            }
            if (!isLeftClick(event)) {
                event.preventDefault();
                this.grid.navigation.setActiveNode({ rowIndex: this.rowIndex, colIndex: this.visibleColumnIndex });
                this.selectionService.addKeyboardRange();
                this.selectionService.initKeyboardState();
                this.selectionService.primaryButton = false;
                // Ensure RMB Click on edited cell does not end cell editing
                if (!this.selected) {
                    this.gridAPI.submit_value();
                }
                return;
            }
            this.selectionService.pointerDown(this.selectionNode, event.shiftKey, event.ctrlKey);
            this.activate(event);
        };
        /**
         *
         * @hidden
         * @internal
         */
        this.pointerenter = (event) => {
            const isHierarchicalGrid = this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
            if (isHierarchicalGrid && (!this.grid.navigation.activeNode.gridID || this.grid.navigation.activeNode.gridID !== this.gridID)) {
                return;
            }
            const dragMode = this.selectionService.pointerEnter(this.selectionNode, event);
            if (dragMode) {
                this.grid.cdr.detectChanges();
                if (isIE()) {
                    this.grid.tbody.nativeElement.focus({ preventScroll: true });
                }
            }
        };
        /**
         * @hidden
         * @internal
         */
        this.pointerup = (event) => {
            const isHierarchicalGrid = this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
            if (!isLeftClick(event) || (isHierarchicalGrid && (!this.grid.navigation.activeNode.gridID ||
                this.grid.navigation.activeNode.gridID !== this.gridID))) {
                return;
            }
            if (this.selectionService.pointerUp(this.selectionNode, this.grid.onRangeSelection)) {
                this.grid.cdr.detectChanges();
                if (isIE()) {
                    this.grid.tbody.nativeElement.focus({ preventScroll: true });
                }
            }
        };
        /**
         * @hidden
         * @internal
         */
        this.onDoubleClick = (event) => {
            if (event.type === 'doubletap') {
                // prevent double-tap to zoom on iOS
                event.preventDefault();
            }
            if (this.grid.rowEditable && this.row.addRow) {
                this.crudService.enterEditMode(this);
            }
            if (this.editable && !this.editMode && !this.row.deleted && !this.crudService.rowEditingBlocked) {
                this.crudService.enterEditMode(this);
            }
            this.grid.onDoubleClick.emit({
                cell: this,
                event
            });
        };
    }
    /**
     * @hidden
     * @internal
     */
    get isEmptyAddRowCell() {
        return this.row.addRow && (this.value === undefined || this.value === null);
    }
    /**
     * Gets the cell template context object.
     * ```typescript
     *  let context = this.cell.context();
     * ```
     * @memberof IgxGridCellComponent
     */
    get context() {
        return {
            $implicit: this.value,
            cell: this
        };
    }
    /**
     * Gets the cell template.
     * ```typescript
     * let template = this.cell.template;
     * ```
     * @memberof IgxGridCellComponent
     */
    get template() {
        if (this.editMode) {
            const inlineEditorTemplate = this.column.inlineEditorTemplate;
            return inlineEditorTemplate ? inlineEditorTemplate : this.inlineEditorTemplate;
        }
        if (this.cellTemplate) {
            return this.cellTemplate;
        }
        if (this.grid.rowEditable && this.row.addRow) {
            return this.addRowCellTemplate;
        }
        return this.defaultCellTemplate;
    }
    /**
     * Gets the cell template.
     * ```typescript
     * let template = this.cell.template;
     * ```
     * @memberof IgxGridCellComponent
     */
    get pinnedIndicatorTemplate() {
        if (this.pinnedIndicator) {
            return this.pinnedIndicator;
        }
        return this.defaultPinnedIndicator;
    }
    /**
     * Gets the `id` of the grid in which the cell is stored.
     * ```typescript
     * let gridId = this.cell.gridID;
     * ```
     * @memberof IgxGridCellComponent
     */
    get gridID() {
        return this.row.gridID;
    }
    /**
     * Gets the grid of the cell.
     * ```typescript
     * let grid = this.cell.grid;
     * ```
     * @memberof IgxGridCellComponent
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Gets the `index` of the row where the cell is stored.
     * ```typescript
     * let rowIndex = this.cell.rowIndex;
     * ```
     * @memberof IgxGridCellComponent
     */
    get rowIndex() {
        return this.row.index;
    }
    /**
     * Gets the `index` of the cell column.
     * ```typescript
     * let columnIndex = this.cell.columnIndex;
     * ```
     * @memberof IgxGridCellComponent
     */
    get columnIndex() {
        return this.column.index;
    }
    /**
     * Gets the visible `index` of the in which the cell is stored.
     * ```typescript
     * let visibleColumnIndex = this.cell.visibleColumnIndex;
     * ```
     * @memberof IgxGridCellComponent
     */
    get visibleColumnIndex() {
        return this.column.columnLayoutChild ? this.column.visibleIndex : this._vIndex;
    }
    set visibleColumnIndex(val) {
        this._vIndex = val;
    }
    /**
     * Gets the ID of the cell.
     * ```typescript
     * let cellID = this.cell.cellID;
     * ```
     * @memberof IgxGridCellComponent
     */
    get cellID() {
        const primaryKey = this.grid.primaryKey;
        const rowID = primaryKey ? this.rowData[primaryKey] : this.rowData;
        return { rowID, columnID: this.columnIndex, rowIndex: this.rowIndex };
    }
    get attrCellID() {
        return `${this.row.gridID}_${this.rowIndex}_${this.visibleColumnIndex}`;
    }
    get title() {
        return this.editMode || this.cellTemplate ? '' : this.value;
    }
    get booleanClass() {
        return this.column.dataType === 'boolean' && this.value;
    }
    /**
     * Returns a reference to the nativeElement of the cell.
     * ```typescript
     * let cellNativeElement = this.cell.nativeElement;
     * ```
     * @memberof IgxGridCellComponent
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @internal
     */
    get cellSelectionMode() {
        return this._cellSelection;
    }
    /**
     * @hidden
     * @internal
     */
    set lastSearchInfo(value) {
        this._lastSearchInfo = value;
        this.highlightText(this._lastSearchInfo.searchText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
    }
    set cellSelectionMode(value) {
        if (this._cellSelection === value) {
            return;
        }
        this.zone.runOutsideAngular(() => {
            value === GridSelectionMode.multiple ?
                this.addPointerListeners(value) : this.removePointerListeners(this._cellSelection);
        });
        this._cellSelection = value;
    }
    /**
     * Gets whether the cell is editable.
     * ```typescript
     * let isCellReadonly = this.cell.readonly;
     * ```
     * @memberof IgxGridCellComponent
     */
    get readonly() {
        return !this.editable;
    }
    get gridRowSpan() {
        return this.column.gridRowSpan;
    }
    get gridColumnSpan() {
        return this.column.gridColumnSpan;
    }
    get rowEnd() {
        return this.column.rowEnd;
    }
    get colEnd() {
        return this.column.colEnd;
    }
    get rowStart() {
        return this.column.rowStart;
    }
    get colStart() {
        return this.column.colStart;
    }
    get ariaSelected() {
        return this.selected || this.column.selected || this.row.selected;
    }
    /**
     * Gets whether the cell is selected.
     * ```typescript
     * let isSelected = this.cell.selected;
     * ```
     * @memberof IgxGridCellComponent
     */
    get selected() {
        return this.selectionService.selected(this.selectionNode);
    }
    /**
     * Selects/deselects the cell.
     * ```typescript
     * this.cell.selected = true.
     * ```
     * @memberof IgxGridCellComponent
     */
    set selected(val) {
        const node = this.selectionNode;
        val ? this.selectionService.add(node) : this.selectionService.remove(node);
        this.grid.notifyChanges();
    }
    /**
     * Gets whether the cell column is selected.
     * ```typescript
     * let isCellColumnSelected = this.cell.columnSelected;
     * ```
     * @memberof IgxGridCellComponent
     */
    get columnSelected() {
        return this.selectionService.isColumnSelected(this.column.field);
    }
    /**
     * Sets the current edit value while a cell is in edit mode.
     * Only for cell editing mode.
     * ```typescript
     * this.cell.editValue = value;
     * ```
     * @memberof IgxGridCellComponent
     */
    set editValue(value) {
        if (this.crudService.cellInEditMode) {
            this.crudService.cell.editValue = value;
        }
    }
    /**
     * Gets the current edit value while a cell is in edit mode.
     * Only for cell editing mode.
     * ```typescript
     * let editValue = this.cell.editValue;
     * ```
     * @memberof IgxGridCellComponent
     */
    get editValue() {
        if (this.crudService.cellInEditMode) {
            return this.crudService.cell.editValue;
        }
    }
    /**
     * Returns whether the cell is editable.
     */
    get editable() {
        return this.column.editable && !this.row.disabled;
    }
    set highlight(value) {
        this._highlight = value;
        if (this._highlight && this.grid.lastSearchInfo.searchText) {
            this._highlight.highlight(this.grid.lastSearchInfo.searchText, this.grid.lastSearchInfo.caseSensitive, this.grid.lastSearchInfo.exactMatch);
            this._highlight.activateIfNecessary();
        }
    }
    get highlight() {
        return this._highlight;
    }
    get selectionNode() {
        return {
            row: this.rowIndex,
            column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
            layout: this.column.columnLayoutChild ? {
                rowStart: this.column.rowStart,
                colStart: this.column.colStart,
                rowEnd: this.column.rowEnd,
                colEnd: this.column.colEnd,
                columnVisibleIndex: this.visibleColumnIndex
            } : null
        };
    }
    addPointerListeners(selection) {
        if (selection !== GridSelectionMode.multiple) {
            return;
        }
        this.nativeElement.addEventListener('pointerenter', this.pointerenter);
        this.nativeElement.addEventListener('pointerup', this.pointerup);
    }
    removePointerListeners(selection) {
        if (selection !== GridSelectionMode.multiple) {
            return;
        }
        this.nativeElement.removeEventListener('pointerenter', this.pointerenter);
        this.nativeElement.removeEventListener('pointerup', this.pointerup);
    }
    /**
     * @hidden
     * @internal
     */
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.addEventListener('pointerdown', this.pointerdown);
            this.addPointerListeners(this.cellSelectionMode);
            // IE 11 workarounds
            if (isIE()) {
                this.compositionStartHandler = () => this.crudService.isInCompositionMode = true;
                this.compositionEndHandler = () => this.crudService.isInCompositionMode = false;
                // Hitting Enter with IME submits and exits from edit mode instead of first closing the IME dialog
                this.nativeElement.addEventListener('compositionstart', this.compositionStartHandler);
                this.nativeElement.addEventListener('compositionend', this.compositionEndHandler);
            }
        });
        if (this.platformUtil.isIOS) {
            this.touchManager.addEventListener(this.nativeElement, 'doubletap', this.onDoubleClick, {
                cssProps: {} /* don't disable user-select, etc */
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.removeEventListener('pointerdown', this.pointerdown);
            this.removePointerListeners(this.cellSelectionMode);
            if (isIE()) {
                this.nativeElement.removeEventListener('compositionstart', this.compositionStartHandler);
                this.nativeElement.removeEventListener('compositionend', this.compositionEndHandler);
            }
        });
        this.touchManager.destroy();
    }
    /**
     * @hidden
     * @internal
     */
    _updateCRUDStatus() {
        if (this.editMode) {
            return;
        }
        const crud = this.crudService;
        const editableCell = this.crudService.cell;
        const editMode = !!(crud.row || crud.cell);
        if (this.editable && editMode && !this.row.deleted) {
            if (editableCell) {
                if (this.row.addRow) {
                    this.gridAPI.update_add_cell(editableCell, editableCell.editValue);
                    this.row.rowData = editableCell.rowData;
                }
                else {
                    this.gridAPI.update_cell(editableCell, editableCell.editValue);
                }
                /* This check is related with the following issue #6517:
                 * when edit cell that belongs to a column which is sorted and press tab,
                 * the next cell in edit mode is with wrong value /its context is not updated/;
                 * So we reapply sorting before the next cell enters edit mode.
                 * Also we need to keep the notifyChanges below, because of the current
                 * change detection cycle when we have editing with enabled transactions
                 */
                if (this.grid.sortingExpressions.length && this.grid.sortingExpressions.indexOf(editableCell.column.field)) {
                    this.grid.cdr.detectChanges();
                }
                if (this.crudService.cellEditingBlocked) {
                    return true;
                }
                crud.exitCellEdit();
            }
            this.grid.tbody.nativeElement.focus({ preventScroll: true });
            this.grid.notifyChanges();
            crud.enterEditMode(this);
            return false;
        }
        if (editableCell && crud.sameRow(this.cellID.rowID)) {
            if (this.row.addRow) {
                this.gridAPI.submit_add_value();
                this.row.rowData = editableCell.rowData;
            }
            else {
                this.gridAPI.submit_value();
            }
        }
        else if (editMode && !crud.sameRow(this.cellID.rowID)) {
            this.grid.endEdit(true);
        }
    }
    /**
     * @deprecated
     * Gets whether the cell is selected.
     * ```typescript
     * let isCellSelected = thid.cell.isCellSelected();
     * ```
     * @memberof IgxGridCellComponent
     */
    isCellSelected() {
        return this.selectionService.selected(this.selectionNode);
    }
    /**
     * @hidden
     * @internal
     */
    ngOnChanges(changes) {
        if (changes.value && !changes.value.firstChange) {
            if (this.highlight) {
                this.highlight.lastSearchInfo.searchedText = this.grid.lastSearchInfo.searchText;
                this.highlight.lastSearchInfo.caseSensitive = this.grid.lastSearchInfo.caseSensitive;
                this.highlight.lastSearchInfo.exactMatch = this.grid.lastSearchInfo.exactMatch;
            }
        }
    }
    /**
     * Starts/ends edit mode for the cell.
     *
     * ```typescript
     * cell.setEditMode(true);
     * ```
     */
    setEditMode(value) {
        if (this.row.deleted) {
            return;
        }
        if (this.editable && value) {
            this.gridAPI.submit_value();
            this.crudService.enterEditMode(this);
        }
        else {
            this.grid.crudService.exitCellEdit();
        }
        this.grid.notifyChanges();
    }
    /**
     * Sets new value to the cell.
     * ```typescript
     * this.cell.update('New Value');
     * ```
     * @memberof IgxGridCellComponent
     */
    // TODO: Refactor
    update(val) {
        if (this.row.deleted) {
            return;
        }
        const cell = this.crudService.createCell(this);
        const args = this.gridAPI.update_cell(cell, val);
        if (this.crudService.cell && this.crudService.sameCell(cell)) {
            if (args.cancel) {
                return;
            }
            this.grid.crudService.exitCellEdit();
        }
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     * @internal
     */
    onClick(event) {
        this.grid.onCellClick.emit({
            cell: this,
            event
        });
    }
    /**
     * @hidden
     * @internal
     */
    onContextMenu(event) {
        this.grid.onContextMenu.emit({
            cell: this,
            event
        });
    }
    /**
     * @hidden
     * @internal
     */
    activate(event) {
        const node = this.selectionNode;
        const shouldEmitSelection = !this.selectionService.isActiveNode(node);
        if (this.selectionService.primaryButton) {
            this._updateCRUDStatus();
            const activeElement = this.selectionService.activeElement;
            const row = activeElement ? this.gridAPI.get_row_by_index(activeElement.row) : null;
            if ((this.crudService.rowEditingBlocked && row && this.row.rowID !== row.rowID) ||
                (this.crudService.cell && this.crudService.cellEditingBlocked)) {
                return;
            }
            this.selectionService.activeElement = node;
        }
        else {
            this.selectionService.activeElement = null;
            if (this.crudService.cellInEditMode && !this.editMode) {
                this.gridAPI.submit_value();
            }
        }
        this.grid.navigation.setActiveNode({ row: this.rowIndex, column: this.visibleColumnIndex });
        this.selectionService.primaryButton = true;
        if (this.cellSelectionMode === GridSelectionMode.multiple && this.selectionService.activeElement) {
            this.selectionService.add(this.selectionService.activeElement, false); // pointer events handle range generation
            this.selectionService.keyboardStateOnFocus(node, this.grid.onRangeSelection, this.nativeElement);
        }
        if (this.grid.isCellSelectable && shouldEmitSelection) {
            this.grid.onSelection.emit({ cell: this, event });
        }
    }
    /**
     * If the provided string matches the text in the cell, the text gets highlighted.
     * ```typescript
     * this.cell.highlightText('Cell Value', true);
     * ```
     * @memberof IgxGridCellComponent
     */
    highlightText(text, caseSensitive, exactMatch) {
        return this.highlight && this.column.searchable ? this.highlight.highlight(text, caseSensitive, exactMatch) : 0;
    }
    /**
     * Clears the highlight of the text in the cell.
     * ```typescript
     * this.cell.clearHighLight();
     * ```
     * @memberof IgxGridCellComponent
     */
    clearHighlight() {
        if (this.highlight && this.column.searchable) {
            this.highlight.clearHighlight();
        }
    }
    /**
     * @hidden
     * @internal
     */
    calculateSizeToFit(range) {
        return Math.max(...Array.from(this.nativeElement.children)
            .map((child) => getNodeSizeViaRange(range, child)));
    }
    /**
     * @hidden
     * @internal
     */
    get searchMetadata() {
        const meta = new Map();
        meta.set('pinned', this.grid.isRecordPinnedByViewIndex(this.row.index));
        return meta;
    }
}
IgxGridCellComponent.ɵfac = function IgxGridCellComponent_Factory(t) { return new (t || IgxGridCellComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(HammerGesturesManager), ɵngcc0.ɵɵdirectiveInject(PlatformUtil)); };
IgxGridCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridCellComponent, selectors: [["igx-grid-cell"]], viewQuery: function IgxGridCellComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxTextHighlightDirective, true, IgxTextHighlightDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c198, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c199, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c200, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c201, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.highlight = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultPinnedIndicator = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inlineEditorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.addRowCellTemplate = _t.first);
    } }, hostVars: 25, hostBindings: function IgxGridCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("dblclick", function IgxGridCellComponent_dblclick_HostBindingHandler($event) { return ctx.onDoubleClick($event); })("click", function IgxGridCellComponent_click_HostBindingHandler($event) { return ctx.onClick($event); })("contextmenu", function IgxGridCellComponent_contextmenu_HostBindingHandler($event) { return ctx.onContextMenu($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("data-rowIndex", ctx.rowIndex)("data-visibleIndex", ctx.visibleColumnIndex)("id", ctx.attrCellID)("title", ctx.title)("aria-readonly", ctx.readonly)("aria-selected", ctx.ariaSelected);
        ɵngcc0.ɵɵclassProp("igx-grid__td--pinned-last", ctx.lastPinned)("igx-grid__td--pinned-first", ctx.firstPinned)("igx-grid__td--editing", ctx.editMode)("igx-grid__td--active", ctx.active)("igx-grid__td--row-pinned-first", ctx.displayPinnedChip)("igx-grid__td--new", ctx.isEmptyAddRowCell)("igx-grid__td--bool-true", ctx.booleanClass)("igx-grid__td--selected", ctx.selected)("igx-grid__td--column-selected", ctx.columnSelected);
    } }, inputs: { lastPinned: "lastPinned", firstPinned: "firstPinned", editMode: "editMode", width: "width", active: "active", displayPinnedChip: "displayPinnedChip", visibleColumnIndex: "visibleColumnIndex", cellSelectionMode: "cellSelectionMode", lastSearchInfo: "lastSearchInfo", column: "column", row: "row", rowData: "rowData", cellTemplate: "cellTemplate", pinnedIndicator: "pinnedIndicator", value: "value", formatter: "formatter" }, features: [ɵngcc0.ɵɵProvidersFeature([HammerGesturesManager]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 10, vars: 4, consts: [["defaultPinnedIndicator", ""], ["defaultCell", ""], ["addRowCell", ""], ["inlineEditor", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity", 4, "ngIf"], [1, "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity"], ["igxTextHighlight", "", "class", "igx-grid__td-text", "style", "pointer-events: none;", 3, "cssClass", "activeCssClass", "groupName", "value", "row", "column", "containerClass", "metadata", 4, "ngIf"], [3, "ngClass", 4, "ngIf"], ["igxTextHighlight", "", 1, "igx-grid__td-text", 2, "pointer-events", "none", 3, "cssClass", "activeCssClass", "groupName", "value", "row", "column", "containerClass", "metadata"], [3, "ngClass"], [4, "ngIf"], ["displayDensity", "compact"], ["igxInput", "", 3, "value", "igxFocus", "input"], ["igxInput", "", "type", "number", 3, "value", "igxFocus", "input"], [3, "value", "checked", "igxFocus", "disableRipple", "change"], ["mode", "dropdown", 3, "outlet", "locale", "value", "igxFocus", "labelVisibility", "valueChange"]], template: function IgxGridCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridCellComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxGridCellComponent_ng_template_2_Template, 2, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxGridCellComponent_ng_template_4_Template, 5, 21, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxGridCellComponent_ng_template_6_Template, 4, 4, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, IgxGridCellComponent_ng_container_8_Template, 1, 0, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(9, IgxGridCellComponent_ng_container_9_Template, 1, 0, "ng-container", 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(8);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.pinnedIndicatorTemplate)("ngTemplateOutletContext", ctx.context);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
    } }, directives: function () { return [ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxChipComponent, IgxTextHighlightDirective, IgxIconComponent, ɵngcc2.NgClass, IgxInputGroupComponent, IgxInputDirective, IgxFocusDirective, IgxCheckboxComponent, IgxDatePickerComponent]; }, pipes: function () { return [IgxColumnFormatterPipe, ɵngcc2.DecimalPipe, ɵngcc2.DatePipe]; }, encapsulation: 2, changeDetection: 0 });
IgxGridCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];
IgxGridCellComponent.propDecorators = {
    isEmptyAddRowCell: [{ type: HostBinding, args: ['class.igx-grid__td--new',] }],
    column: [{ type: Input }],
    row: [{ type: Input }],
    rowData: [{ type: Input }],
    cellTemplate: [{ type: Input }],
    pinnedIndicator: [{ type: Input }],
    value: [{ type: Input }],
    formatter: [{ type: Input }],
    rowIndex: [{ type: HostBinding, args: ['attr.data-rowIndex',] }],
    visibleColumnIndex: [{ type: HostBinding, args: ['attr.data-visibleIndex',] }, { type: Input }],
    attrCellID: [{ type: HostBinding, args: ['attr.id',] }],
    title: [{ type: HostBinding, args: ['attr.title',] }],
    booleanClass: [{ type: HostBinding, args: ['class.igx-grid__td--bool-true',] }],
    cellSelectionMode: [{ type: Input }],
    lastSearchInfo: [{ type: Input }],
    lastPinned: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid__td--pinned-last',] }],
    firstPinned: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid__td--pinned-first',] }],
    editMode: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid__td--editing',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    readonly: [{ type: HostBinding, args: ['attr.aria-readonly',] }],
    width: [{ type: Input }],
    active: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid__td--active',] }],
    ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
    selected: [{ type: HostBinding, args: ['class.igx-grid__td--selected',] }],
    columnSelected: [{ type: HostBinding, args: ['class.igx-grid__td--column-selected',] }],
    displayPinnedChip: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid__td--row-pinned-first',] }],
    defaultCellTemplate: [{ type: ViewChild, args: ['defaultCell', { read: TemplateRef, static: true },] }],
    defaultPinnedIndicator: [{ type: ViewChild, args: ['defaultPinnedIndicator', { read: TemplateRef, static: true },] }],
    inlineEditorTemplate: [{ type: ViewChild, args: ['inlineEditor', { read: TemplateRef, static: true },] }],
    addRowCellTemplate: [{ type: ViewChild, args: ['addRowCell', { read: TemplateRef, static: true },] }],
    highlight: [{ type: ViewChild, args: [IgxTextHighlightDirective, { read: IgxTextHighlightDirective },] }],
    onDoubleClick: [{ type: HostListener, args: ['dblclick', ['$event'],] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onContextMenu: [{ type: HostListener, args: ['contextmenu', ['$event'],] }]
};
__decorate([
    DeprecateMethod(`'isCellSelected' is deprecated. Use 'selected' property instead.`)
], IgxGridCellComponent.prototype, "isCellSelected", null);

class IgxGridFooterComponent {
}
IgxGridFooterComponent.ɵfac = function IgxGridFooterComponent_Factory(t) { return new (t || IgxGridFooterComponent)(); };
IgxGridFooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridFooterComponent, selectors: [["igx-grid-footer"]], ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxGridFooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });

class IgxPaginatorComponent extends DisplayDensityBase {
    constructor(_displayDensityOptions) {
        super(_displayDensityOptions);
        this._displayDensityOptions = _displayDensityOptions;
        this._resourceStrings = CurrentResourceStrings.PaginatorResStrings;
        this._overlaySettings = {};
        this._page = 0;
        this.defaultSelectValues = [5, 10, 15, 25, 50, 100, 500];
        this._perPage = 15;
        /**
         * An @Input property that sets if the pager in the paginator should be enabled.
         * ```html
         * <igx-paginator [pagerEnabled]="true"></igx-paginator>
         * ```
         * @memberof IgxPaginatorComponent
         */
        this.pagerEnabled = true;
        /**
         * An @Input property that sets if the pager in the paginator should be hidden.
         * ```html
         * <igx-paginator [pagerHidden]="true"></igx-paginator>
         * ```
         * @memberof IgxPaginatorComponent
         */
        this.pagerHidden = false;
        /**
         * An @Input property that sets if the dropdown in the paginator should be enabled.
         * ```html
         * <igx-paginator [dropdownEnabled]="true"></igx-paginator>
         * ```
         * @memberof IgxPaginatorComponent
         */
        this.dropdownEnabled = true;
        /**
         * An @Input property that sets if the dropdown in the paginator should be hidden.
         * ```html
         * <igx-paginator [dropdownHidden]="true"></igx-paginator>
         * ```
         * @memberof IgxPaginatorComponent
         */
        this.dropdownHidden = false;
        /**
         * @deprecated Use 'resourceStrings' instead.
         * An @Input property, sets number of label of the select.
         * The default is 'Items per page' localized string.
         * ```html
         * <igx-paginator label="My custom label"></igx-paginator>
         * ```
         * @memberof IgxPaginatorComponent
         */
        this.selectLabel = CurrentResourceStrings.PaginatorResStrings.igx_paginator_label;
        /**
         * @deprecated Use 'resourceStrings' instead.
         * An @Input property, sets a preposition between the current page and total pages.
         * The default is 'of' localized string.
         * @memberof IgxPaginatorComponent
         */
        this.prepositionPage = CurrentResourceStrings.PaginatorResStrings.igx_paginator_pager_text;
        /**
         * Emitted when `perPage` property value of the paginator is changed.
         * @example
         * ```html
         * <igx-paginator (perPageChange)="onPerPageChange($event)"></igx-paginator>
         * ```
         * ```typescript
         * public onPerPageChange(perPage: number) {
         *   this.perPage = perPage;
         * }
         * ```
         */
        this.perPageChange = new EventEmitter();
        /**
         * Emitted after the current page is changed.
         * @example
         * ```html
         * <igx-paginator (pageChange)="onPageChange($event)"></igx-paginator>
         * ```
         * ```typescript
         * public onPageChange(page: number) {
         *   this.currentPage = page;
         * }
         * ```
         */
        this.pageChange = new EventEmitter();
    }
    /**
     * Sets the class of the IgxPaginatorComponent based
     * on the provided displayDensity.
     */
    get classCosy() {
        return this.displayDensity === DisplayDensity.cosy;
    }
    get classCompact() {
        return this.displayDensity === DisplayDensity.compact;
    }
    get classComfortable() {
        return this.displayDensity === DisplayDensity.comfortable;
    }
    /**
     * An @Input property, sets current page of the `IgxPaginatorComponent`.
     * The default is 0.
     * ```typescript
     * let page = this.paginator.page;
     * ```
     * @memberof IgxPaginatorComponent
     */
    get page() {
        return this._page;
    }
    set page(value) {
        this._page = value;
        this.pageChange.emit(this._page);
    }
    /**
     * An @Input property, sets number of visible items per page in the `IgxPaginatorComponent`.
     * The default is 15.
     * ```typescript
     * let itemsPerPage = this.paginator.perPage;
     * ```
     * @memberof IgxPaginatorComponent
     */
    get perPage() {
        return this._perPage;
    }
    set perPage(value) {
        this._perPage = Number(value);
        this.perPageChange.emit(this._perPage);
        this._selectOptions = this.sortUniqueOptions(this.defaultSelectValues, this._perPage);
        this.totalPages = Math.ceil(this.totalRecords / this._perPage);
        if (this.totalPages !== 0 && this.page >= this.totalPages) {
            this.page = this.totalPages - 1;
        }
    }
    /**
     * An @Input property that sets the total records.
     * ```typescript
     * let totalRecords = this.paginator.totalRecords;
     * ```
     * @memberof IgxPaginatorComponent
     */
    get totalRecords() {
        return this._totalRecords;
    }
    set totalRecords(value) {
        this._totalRecords = value;
        this.totalPages = Math.ceil(this.totalRecords / this.perPage);
    }
    /**
     * An @Input property that sets custom options in the select of the paginator
     * ```typescript
     * let options = this.paginator.selectOptions;
     * ```
     * @memberof IgxPaginatorComponent
     */
    get selectOptions() {
        return this._selectOptions;
    }
    set selectOptions(value) {
        this._selectOptions = this.sortUniqueOptions(value, this._perPage);
        this.defaultSelectValues = [...value];
    }
    /**
     * An @Input property that sets custom OverlaySettings.
     * ```html
     * <igx-paginator [overlaySettings] = "customOverlaySettings"></igx-paginator>
     * ```
     */
    get overlaySettings() {
        return this._overlaySettings;
    }
    set overlaySettings(value) {
        this._overlaySettings = Object.assign({}, this._overlaySettings, value);
    }
    /**
     * An accessor that sets the resource strings.
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /**
     * Returns if the current page is the last page.
     * ```typescript
     * const lastPage = this.paginator.isLastPage;
     * ```
     */
    get isLastPage() {
        return this.page + 1 >= this.totalPages;
    }
    /**
     * Returns if the current page is the first page.
     * ```typescript
     * const lastPage = this.paginator.isFirstPage;
     * ```
     */
    get isFirstPage() {
        return this.page === 0;
    }
    /**
     * Returns if the first pager buttons should be disabled
     */
    get isFirstPageDisabled() {
        return this.isFirstPage || !this.pagerEnabled;
    }
    /**
     * Returns if the last pager buttons should be disabled
     */
    get isLastPageDisabled() {
        return this.isLastPage || !this.pagerEnabled;
    }
    sortUniqueOptions(values, newOption) {
        return Array.from(new Set([...values, newOption])).sort((a, b) => a - b);
    }
    /**
     * Sets DisplayDensity for the <select> inside the paginator
     * @hidden
     */
    paginatorSelectDisplayDensity() {
        if (this.displayDensity === DisplayDensity.comfortable) {
            return DisplayDensity.cosy;
        }
        return DisplayDensity.compact;
    }
    /**
     * Goes to the next page of the `IgxPaginatorComponent`, if the paginator is not already at the last page.
     * ```typescript
     * this.paginator.nextPage();
     * ```
     * @memberof IgxPaginatorComponent
     */
    nextPage() {
        if (!this.isLastPage) {
            this.page += 1;
        }
    }
    /**
     * Goes to the previous page of the `IgxPaginatorComponent`, if the paginator is not already at the first page.
     * ```typescript
     * this.paginator.previousPage();
     * ```
     * @memberof IgxPaginatorComponent
     */
    previousPage() {
        if (!this.isFirstPage) {
            this.page -= 1;
        }
    }
    /**
     * Goes to the desired page index.
     * ```typescript
     * this.paginator.paginate(1);
     * ```
     * @param val
     * @memberof IgxPaginatorComponent
     */
    paginate(val) {
        if (val < 0 || val > this.totalPages - 1) {
            return;
        }
        this.page = val;
    }
}
IgxPaginatorComponent.ɵfac = function IgxPaginatorComponent_Factory(t) { return new (t || IgxPaginatorComponent)(ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxPaginatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxPaginatorComponent, selectors: [["igx-paginator"]], hostVars: 6, hostBindings: function IgxPaginatorComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-paginator--cosy", ctx.classCosy)("igx-paginator--compact", ctx.classCompact)("igx-paginator", ctx.classComfortable);
    } }, inputs: { pagerEnabled: "pagerEnabled", pagerHidden: "pagerHidden", dropdownEnabled: "dropdownEnabled", dropdownHidden: "dropdownHidden", selectLabel: "selectLabel", prepositionPage: "prepositionPage", page: "page", perPage: "perPage", totalRecords: "totalRecords", selectOptions: "selectOptions", overlaySettings: "overlaySettings", resourceStrings: "resourceStrings" }, outputs: { perPageChange: "perPageChange", pageChange: "pageChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 28, vars: 25, consts: [[1, "igx-paginator__select", 3, "hidden"], [1, "igx-paginator__label"], [1, "igx-paginator__select-input"], ["type", "border", 3, "overlaySettings", "ngModel", "displayDensity", "disabled", "ngModelChange"], ["igxLabel", "", 3, "hidden"], [3, "value", 4, "ngFor", "ngForOf"], ["role", "navigation", 1, "igx-paginator__pager", 3, "hidden"], ["igxButton", "icon", "igxRipple", "", "igxRippleCentered", "true", 3, "title", "disabled", "click"], ["fontSet", "material"], ["aria-current", "page", 1, "igx-paginator__pager-text"], ["igxRipple", "", "igxRippleCentered", "true", "igxButton", "icon", 3, "title", "disabled", "click"], [3, "value"]], template: function IgxPaginatorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "label", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵelementStart(4, "igx-select", 3);
        ɵngcc0.ɵɵlistener("ngModelChange", function IgxPaginatorComponent_Template_igx_select_ngModelChange_4_listener($event) { return ctx.perPage = $event; });
        ɵngcc0.ɵɵelementStart(5, "label", 4);
        ɵngcc0.ɵɵtext(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, IgxPaginatorComponent_igx_select_item_7_Template, 2, 2, "igx-select-item", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div", 6);
        ɵngcc0.ɵɵelementStart(9, "button", 7);
        ɵngcc0.ɵɵlistener("click", function IgxPaginatorComponent_Template_button_click_9_listener() { return ctx.paginate(0); });
        ɵngcc0.ɵɵelementStart(10, "igx-icon", 8);
        ɵngcc0.ɵɵtext(11, "first_page");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "button", 7);
        ɵngcc0.ɵɵlistener("click", function IgxPaginatorComponent_Template_button_click_12_listener() { return ctx.previousPage(); });
        ɵngcc0.ɵɵelementStart(13, "igx-icon", 8);
        ɵngcc0.ɵɵtext(14, "chevron_left");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(15, "div", 9);
        ɵngcc0.ɵɵelementStart(16, "span");
        ɵngcc0.ɵɵtext(17);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(18, "span");
        ɵngcc0.ɵɵtext(19);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(20, "span");
        ɵngcc0.ɵɵtext(21);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(22, "button", 10);
        ɵngcc0.ɵɵlistener("click", function IgxPaginatorComponent_Template_button_click_22_listener() { return ctx.nextPage(); });
        ɵngcc0.ɵɵelementStart(23, "igx-icon", 8);
        ɵngcc0.ɵɵtext(24, "chevron_right");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(25, "button", 7);
        ɵngcc0.ɵɵlistener("click", function IgxPaginatorComponent_Template_button_click_25_listener() { return ctx.paginate(ctx.totalPages - 1); });
        ɵngcc0.ɵɵelementStart(26, "igx-icon", 8);
        ɵngcc0.ɵɵtext(27, "last_page");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("hidden", ctx.dropdownHidden);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.resourceStrings.igx_paginator_label);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("overlaySettings", ctx.overlaySettings)("ngModel", ctx.perPage)("displayDensity", ctx.paginatorSelectDisplayDensity())("disabled", !ctx.dropdownEnabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hidden", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.resourceStrings.igx_paginator_label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.selectOptions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hidden", ctx.pagerHidden);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("title", ctx.resourceStrings.igx_paginator_first_page_button_text)("disabled", ctx.isFirstPageDisabled);
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.isFirstPageDisabled);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("title", ctx.resourceStrings.igx_paginator_previous_page_button_text)("disabled", ctx.isFirstPageDisabled);
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.isFirstPageDisabled);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵtextInterpolate(ctx.page + 1);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1("\u00A0", ctx.resourceStrings.igx_paginator_pager_text, "\u00A0");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.totalPages);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("title", ctx.resourceStrings.igx_paginator_next_page_button_text)("disabled", ctx.isLastPageDisabled);
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.isLastPageDisabled);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("title", ctx.resourceStrings.igx_paginator_last_page_button_text)("disabled", ctx.isLastPageDisabled);
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.isLastPageDisabled);
    } }, directives: [IgxSelectComponent, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxLabelDirective, ɵngcc2.NgForOf, IgxButtonDirective, IgxRippleDirective, IgxIconComponent, IgxSelectItemComponent], encapsulation: 2 });
IgxPaginatorComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxPaginatorComponent.propDecorators = {
    classCosy: [{ type: HostBinding, args: ['class.igx-paginator--cosy',] }],
    classCompact: [{ type: HostBinding, args: ['class.igx-paginator--compact',] }],
    classComfortable: [{ type: HostBinding, args: ['class.igx-paginator',] }],
    page: [{ type: Input }],
    perPage: [{ type: Input }],
    totalRecords: [{ type: Input }],
    selectOptions: [{ type: Input }],
    pagerEnabled: [{ type: Input }],
    pagerHidden: [{ type: Input }],
    dropdownEnabled: [{ type: Input }],
    dropdownHidden: [{ type: Input }],
    overlaySettings: [{ type: Input }],
    resourceStrings: [{ type: Input }],
    selectLabel: [{ type: Input }],
    prepositionPage: [{ type: Input }],
    perPageChange: [{ type: Output }],
    pageChange: [{ type: Output }]
};
__decorate([
    DeprecateProperty(`'selectLabel' property is deprecated. Use 'resourceStrings' instead.`)
], IgxPaginatorComponent.prototype, "selectLabel", void 0);
__decorate([
    DeprecateProperty(`'prepositionPage' property is deprecated. Use 'resourceStrings' instead.`)
], IgxPaginatorComponent.prototype, "prepositionPage", void 0);
class IgxPaginatorModule {
}
IgxPaginatorModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxPaginatorModule });
IgxPaginatorModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxPaginatorModule_Factory(t) { return new (t || IgxPaginatorModule)(); }, imports: [[CommonModule, IgxSelectModule, FormsModule, IgxIconModule, IgxButtonModule, IgxRippleModule, IgxInputGroupModule]] });

/**
 * @hidden
 * @internal
 */
class IgxGridCellStyleClassesPipe {
    transform(cssClasses, _, data, field, index, __) {
        if (!cssClasses) {
            return '';
        }
        const result = [];
        for (const cssClass of Object.keys(cssClasses)) {
            const callbackOrValue = cssClasses[cssClass];
            const apply = typeof callbackOrValue === 'function' ?
                callbackOrValue(data, field, resolveNestedPath(data, field), index) : callbackOrValue;
            if (apply) {
                result.push(cssClass);
            }
        }
        return result.join(' ');
    }
}
IgxGridCellStyleClassesPipe.ɵfac = function IgxGridCellStyleClassesPipe_Factory(t) { return new (t || IgxGridCellStyleClassesPipe)(); };
IgxGridCellStyleClassesPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxCellStyleClasses", type: IgxGridCellStyleClassesPipe, pure: true });
/**
 * @hidden
 * @internal
 */
class IgxGridCellStylesPipe {
    transform(styles, _, data, field, index, __) {
        const css = {};
        if (!styles) {
            return css;
        }
        for (const prop of Object.keys(styles)) {
            const res = styles[prop];
            css[prop] = typeof res === 'function' ? res(data, field, resolveNestedPath(data, field), index) : res;
        }
        return css;
    }
}
IgxGridCellStylesPipe.ɵfac = function IgxGridCellStylesPipe_Factory(t) { return new (t || IgxGridCellStylesPipe)(); };
IgxGridCellStylesPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxCellStyles", type: IgxGridCellStylesPipe, pure: true });
/**
 * @hidden
 * @internal
 */
class IgxGridNotGroupedPipe {
    transform(value) {
        return value.filter(item => !item.columnGroup);
    }
}
IgxGridNotGroupedPipe.ɵfac = function IgxGridNotGroupedPipe_Factory(t) { return new (t || IgxGridNotGroupedPipe)(); };
IgxGridNotGroupedPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxNotGrouped", type: IgxGridNotGroupedPipe, pure: true });
/**
 * @hidden
 * @internal
 */
class IgxGridTopLevelColumns {
    transform(value) {
        return value.filter(item => item.level === 0);
    }
}
IgxGridTopLevelColumns.ɵfac = function IgxGridTopLevelColumns_Factory(t) { return new (t || IgxGridTopLevelColumns)(); };
IgxGridTopLevelColumns.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxTopLevel", type: IgxGridTopLevelColumns, pure: true });
/**
 * @hidden
 * @internal
 */
class IgxGridFilterConditionPipe {
    transform(value) {
        return value.split(/(?=[A-Z])/).join(' ');
    }
}
IgxGridFilterConditionPipe.ɵfac = function IgxGridFilterConditionPipe_Factory(t) { return new (t || IgxGridFilterConditionPipe)(); };
IgxGridFilterConditionPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "filterCondition", type: IgxGridFilterConditionPipe, pure: true });
/**
 * @hidden
 * @internal
 */
class IgxGridTransactionPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, id, pipeTrigger) {
        const grid = this.gridAPI.grid;
        if (grid.transactions.enabled) {
            const result = DataUtil.mergeTransactions(cloneArray(collection), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
            return result;
        }
        return collection;
    }
}
IgxGridTransactionPipe.ɵfac = function IgxGridTransactionPipe_Factory(t) { return new (t || IgxGridTransactionPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridTransactionPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridTransaction", type: IgxGridTransactionPipe, pure: true });
IgxGridTransactionPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 * @internal
 */
class IgxGridPaginatorOptionsPipe {
    transform(values) {
        return Array.from(new Set([...values])).sort((a, b) => a - b);
    }
}
IgxGridPaginatorOptionsPipe.ɵfac = function IgxGridPaginatorOptionsPipe_Factory(t) { return new (t || IgxGridPaginatorOptionsPipe)(); };
IgxGridPaginatorOptionsPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "paginatorOptions", type: IgxGridPaginatorOptionsPipe, pure: true });
/**
 * @hidden
 * @internal
 */
class IgxHasVisibleColumnsPipe {
    transform(values, hasVisibleColumns) {
        if (!(values && values.length)) {
            return values;
        }
        return hasVisibleColumns ? values : [];
    }
}
IgxHasVisibleColumnsPipe.ɵfac = function IgxHasVisibleColumnsPipe_Factory(t) { return new (t || IgxHasVisibleColumnsPipe)(); };
IgxHasVisibleColumnsPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "visibleColumns", type: IgxHasVisibleColumnsPipe, pure: true });
/**
 * @hidden
 */
class IgxGridRowPinningPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, id, isPinned = false, pipeTrigger) {
        const grid = this.gridAPI.grid;
        if (grid.hasPinnedRecords && isPinned) {
            const result = collection.filter(rec => grid.isRecordPinned(rec));
            result.sort((rec1, rec2) => grid.getInitialPinnedIndex(rec1) - grid.getInitialPinnedIndex(rec2));
            return result;
        }
        grid.unpinnedRecords = collection;
        if (!grid.hasPinnedRecords) {
            grid.pinnedRecords = [];
            return isPinned ? [] : collection;
        }
        return collection.map((rec) => {
            return grid.isRecordPinned(rec) ? { recordRef: rec, ghostRecord: true } : rec;
        });
    }
}
IgxGridRowPinningPipe.ɵfac = function IgxGridRowPinningPipe_Factory(t) { return new (t || IgxGridRowPinningPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridRowPinningPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridRowPinning", type: IgxGridRowPinningPipe, pure: true });
IgxGridRowPinningPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
class IgxColumnActionEnabledPipe {
    constructor(columnActions) {
        this.columnActions = columnActions;
    }
    transform(collection, actionFilter, pipeTrigger) {
        if (!collection) {
            return collection;
        }
        let copy = collection.slice(0);
        if (copy.length && copy[0].grid.hasColumnLayouts) {
            copy = copy.filter(c => c.columnLayout);
        }
        if (actionFilter) {
            copy = copy.filter(actionFilter);
        }
        // Preserve the actionable collection for use in the component
        this.columnActions.actionableColumns = copy;
        return copy;
    }
}
IgxColumnActionEnabledPipe.ɵfac = function IgxColumnActionEnabledPipe_Factory(t) { return new (t || IgxColumnActionEnabledPipe)(ɵngcc0.ɵɵdirectiveInject(IgxColumnActionsComponent)); };
IgxColumnActionEnabledPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "columnActionEnabled", type: IgxColumnActionEnabledPipe, pure: true });
IgxColumnActionEnabledPipe.ctorParameters = () => [
    { type: IgxColumnActionsComponent, decorators: [{ type: Inject, args: [IgxColumnActionsComponent,] }] }
];
class IgxFilterActionColumnsPipe {
    constructor(columnActions) {
        this.columnActions = columnActions;
    }
    transform(collection, filterCriteria, pipeTrigger) {
        if (!collection) {
            return collection;
        }
        let copy = collection.slice(0);
        if (filterCriteria && filterCriteria.length > 0) {
            const filterFunc = (c) => {
                var _a, _b;
                const filterText = c.header || c.field;
                if (!filterText) {
                    return false;
                }
                return filterText.toLocaleLowerCase().indexOf(filterCriteria.toLocaleLowerCase()) >= 0 ||
                    ((_b = (_a = c.children) === null || _a === void 0 ? void 0 : _a.some(filterFunc)) !== null && _b !== void 0 ? _b : false);
            };
            copy = collection.filter(filterFunc);
        }
        // Preserve the filtered collection for use in the component
        this.columnActions.filteredColumns = copy;
        return copy;
    }
}
IgxFilterActionColumnsPipe.ɵfac = function IgxFilterActionColumnsPipe_Factory(t) { return new (t || IgxFilterActionColumnsPipe)(ɵngcc0.ɵɵdirectiveInject(IgxColumnActionsComponent)); };
IgxFilterActionColumnsPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "filterActionColumns", type: IgxFilterActionColumnsPipe, pure: true });
IgxFilterActionColumnsPipe.ctorParameters = () => [
    { type: IgxColumnActionsComponent, decorators: [{ type: Inject, args: [IgxColumnActionsComponent,] }] }
];
class IgxSortActionColumnsPipe {
    transform(collection, displayOrder, pipeTrigger) {
        if (displayOrder === ColumnDisplayOrder.Alphabetical) {
            return collection.sort((a, b) => (a.header || a.field).localeCompare(b.header || b.field));
        }
        return collection;
    }
}
IgxSortActionColumnsPipe.ɵfac = function IgxSortActionColumnsPipe_Factory(t) { return new (t || IgxSortActionColumnsPipe)(); };
IgxSortActionColumnsPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "sortActionColumns", type: IgxSortActionColumnsPipe, pure: true });
class IgxGridDataMapperPipe {
    transform(data, field, _) {
        return resolveNestedPath(data, field);
    }
}
IgxGridDataMapperPipe.ɵfac = function IgxGridDataMapperPipe_Factory(t) { return new (t || IgxGridDataMapperPipe)(); };
IgxGridDataMapperPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "dataMapper", type: IgxGridDataMapperPipe, pure: true });
class IgxStringReplacePipe {
    transform(value, search, replacement) {
        return value.replace(search, replacement);
    }
}
IgxStringReplacePipe.ɵfac = function IgxStringReplacePipe_Factory(t) { return new (t || IgxStringReplacePipe)(); };
IgxStringReplacePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxStringReplace", type: IgxStringReplacePipe, pure: true });
class IgxGridTransactionStatePipe {
    transform(row_id, field, rowEditable, transactions, _, __, ___) {
        var _a;
        if (rowEditable) {
            const rowCurrentState = transactions.getAggregatedValue(row_id, false);
            if (rowCurrentState) {
                const value = resolveNestedPath(rowCurrentState, field);
                return value !== undefined && value !== null;
            }
        }
        else {
            const transaction = transactions.getState(row_id);
            const value = resolveNestedPath((_a = transaction === null || transaction === void 0 ? void 0 : transaction.value) !== null && _a !== void 0 ? _a : {}, field);
            return transaction && transaction.value && (value || value === 0 || value === false);
        }
    }
}
IgxGridTransactionStatePipe.ɵfac = function IgxGridTransactionStatePipe_Factory(t) { return new (t || IgxGridTransactionStatePipe)(); };
IgxGridTransactionStatePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "transactionState", type: IgxGridTransactionStatePipe, pure: true });
class IgxColumnFormatterPipe {
    transform(value, formatter) {
        return formatter(value);
    }
}
IgxColumnFormatterPipe.ɵfac = function IgxColumnFormatterPipe_Factory(t) { return new (t || IgxColumnFormatterPipe)(); };
IgxColumnFormatterPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "columnFormatter", type: IgxColumnFormatterPipe, pure: true });
class IgxGridAddRowPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, isPinned = false, pipeTrigger) {
        const grid = this.gridAPI.grid;
        if (!grid.rowEditable || !grid.addRowParent || grid.cancelAddMode || isPinned !== grid.addRowParent.isPinned) {
            return collection;
        }
        const copy = collection.slice(0);
        const parentIndex = grid.addRowParent.index;
        const row = grid.getEmptyRecordObjectFor(collection[parentIndex]);
        const rec = {
            recordRef: row,
            addRow: true
        };
        copy.splice(parentIndex + 1, 0, rec);
        if (isPinned) {
            grid.pinnedRecords = copy;
        }
        else {
            grid.unpinnedRecords = copy;
        }
        return copy;
    }
}
IgxGridAddRowPipe.ɵfac = function IgxGridAddRowPipe_Factory(t) { return new (t || IgxGridAddRowPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridAddRowPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridAddRow", type: IgxGridAddRowPipe, pure: true });
IgxGridAddRowPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

class IgxGridPipesModule {
}
IgxGridPipesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridPipesModule });
IgxGridPipesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridPipesModule_Factory(t) { return new (t || IgxGridPipesModule)(); }, imports: [[
            CommonModule
        ]] });

/**
 * @hidden
 */
class IgxGridExcelStyleFilteringModule {
}
IgxGridExcelStyleFilteringModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridExcelStyleFilteringModule });
IgxGridExcelStyleFilteringModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridExcelStyleFilteringModule_Factory(t) { return new (t || IgxGridExcelStyleFilteringModule)(); }, providers: [
        IgxSelectionAPIService
    ], imports: [[
            CommonModule,
            FormsModule,
            IgxGridPipesModule,
            IgxButtonModule,
            IgxButtonGroupModule,
            IgxDatePickerModule,
            IgxIconModule,
            IgxRippleModule,
            IgxInputGroupModule,
            IgxDropDownModule,
            IgxForOfModule,
            IgxCheckboxModule,
            IgxFilterModule,
            IgxToggleModule,
            IgxListModule,
            IgxProgressBarModule,
            IgxSelectModule,
        ]] });

class IgxGridSelectionModule {
}
IgxGridSelectionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridSelectionModule });
IgxGridSelectionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridSelectionModule_Factory(t) { return new (t || IgxGridSelectionModule)(); } });

/**
 * @hidden
 * @internal
 */
class IgxResizeHandleDirective {
    constructor(zone, element, colResizingService) {
        this.zone = zone;
        this.element = element;
        this.colResizingService = colResizingService;
        /**
         * @hidden
         */
        this._dblClick = false;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        this.DEBOUNCE_TIME = 200;
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        if (!this.column.columnGroup && this.column.resizable) {
            this.zone.runOutsideAngular(() => {
                fromEvent(this.element.nativeElement, 'mousedown').pipe(debounceTime(this.DEBOUNCE_TIME), takeUntil(this.destroy$)).subscribe((event) => {
                    if (this._dblClick) {
                        this._dblClick = false;
                        return;
                    }
                    if (event.button === 0) {
                        this._onResizeAreaMouseDown(event);
                        this.column.grid.resizeLine.resizer.onMousedown(event);
                    }
                });
            });
            fromEvent(this.element.nativeElement, 'mouseup').pipe(debounceTime(this.DEBOUNCE_TIME), takeUntil(this.destroy$)).subscribe(() => {
                this.colResizingService.isColumnResizing = false;
                this.colResizingService.showResizer = false;
                this.column.grid.cdr.detectChanges();
            });
        }
    }
    /**
     * @hidden
     */
    onMouseOver() {
        this.colResizingService.resizeCursor = 'col-resize';
    }
    /**
     * @hidden
     */
    onDoubleClick() {
        this._dblClick = true;
        this.colResizingService.column = this.column;
        this.colResizingService.autosizeColumnOnDblClick();
    }
    /**
     * @hidden
     */
    _onResizeAreaMouseDown(event) {
        this.colResizingService.column = this.column;
        this.colResizingService.isColumnResizing = true;
        this.colResizingService.startResizePos = event.clientX;
        this.colResizingService.showResizer = true;
        this.column.grid.cdr.detectChanges();
    }
}
IgxResizeHandleDirective.ɵfac = function IgxResizeHandleDirective_Factory(t) { return new (t || IgxResizeHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService)); };
IgxResizeHandleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxResizeHandleDirective, selectors: [["", "igxResizeHandle", ""]], hostBindings: function IgxResizeHandleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseover", function IgxResizeHandleDirective_mouseover_HostBindingHandler() { return ctx.onMouseOver(); })("dblclick", function IgxResizeHandleDirective_dblclick_HostBindingHandler() { return ctx.onDoubleClick(); });
    } }, inputs: { column: ["igxResizeHandle", "column"] } });
IgxResizeHandleDirective.ctorParameters = () => [
    { type: NgZone },
    { type: ElementRef },
    { type: IgxColumnResizingService }
];
IgxResizeHandleDirective.propDecorators = {
    column: [{ type: Input, args: ['igxResizeHandle',] }],
    onMouseOver: [{ type: HostListener, args: ['mouseover',] }],
    onDoubleClick: [{ type: HostListener, args: ['dblclick',] }]
};

class IgxGridResizingModule {
}
IgxGridResizingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridResizingModule });
IgxGridResizingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridResizingModule_Factory(t) { return new (t || IgxGridResizingModule)(); }, providers: [
        IgxColumnResizingService
    ], imports: [[
            CommonModule
        ]] });

class IgxColumnMovingDropDirective extends IgxDropDirective {
    constructor(elementRef, renderer, zone, cms) {
        super(elementRef, renderer, zone);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        this.cms = cms;
        this._dropIndicator = null;
        this._lastDropIndicator = null;
        this._dragLeave = new Subject();
        this._dropIndicatorClass = 'igx-grid__th-drop-indicator--active';
    }
    set data(val) {
        if (val instanceof IgxColumnComponent) {
            this._column = val;
        }
        if (val instanceof IgxGridForOfDirective) {
            this._hVirtDir = val;
        }
    }
    get column() {
        return this._column;
    }
    get isDropTarget() {
        return this._column && this._column.grid.hasMovableColumns && this.cms.column.movable &&
            ((!this._column.pinned && this.cms.column.disablePinning) || !this.cms.column.disablePinning);
    }
    get horizontalScroll() {
        if (this._hVirtDir) {
            return this._hVirtDir;
        }
    }
    ngOnDestroy() {
        this._dragLeave.next(true);
        this._dragLeave.complete();
    }
    onDragOver(event) {
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.isDropTarget &&
            this.cms.column !== this.column &&
            this.cms.column.level === this.column.level &&
            this.cms.column.parent === this.column.parent) {
            if (this._lastDropIndicator) {
                this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
            }
            const clientRect = this.elementRef.nativeElement.getBoundingClientRect();
            const pos = clientRect.left + clientRect.width / 2;
            const parent = this.elementRef.nativeElement.parentElement;
            if (event.detail.pageX < pos) {
                this._dropPos = DropPosition.BeforeDropTarget;
                this._lastDropIndicator = this._dropIndicator = parent.firstElementChild;
            }
            else {
                this._dropPos = DropPosition.AfterDropTarget;
                this._lastDropIndicator = this._dropIndicator = parent.lastElementChild;
            }
            if (this.cms.icon.innerText !== 'block') {
                this.renderer.addClass(this._dropIndicator, this._dropIndicatorClass);
            }
        }
    }
    onDragEnter(event) {
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.column && this.cms.column.grid.id !== this.column.grid.id) {
            this.cms.icon.innerText = 'block';
            return;
        }
        if (this.isDropTarget &&
            this.cms.column !== this.column &&
            this.cms.column.level === this.column.level &&
            this.cms.column.parent === this.column.parent) {
            if (!this.column.pinned || (this.column.pinned && this.cms.column.pinned)) {
                this.cms.icon.innerText = 'swap_horiz';
            }
            this.cms.icon.innerText = 'lock';
        }
        else {
            this.cms.icon.innerText = 'block';
        }
        if (this.horizontalScroll) {
            this.cms.icon.innerText = event.target.id === 'right' ? 'arrow_forward' : 'arrow_back';
            interval(100).pipe(takeUntil(this._dragLeave)).subscribe(() => {
                event.target.id === 'right' ? this.horizontalScroll.scrollPosition += 15 :
                    this.horizontalScroll.scrollPosition -= 15;
            });
        }
    }
    onDragLeave(event) {
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        this.cms.icon.innerText = 'block';
        if (this._dropIndicator) {
            this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
        }
        if (this.horizontalScroll) {
            this._dragLeave.next(true);
        }
    }
    onDragDrop(event) {
        event.preventDefault();
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.column && (this.cms.column.grid.id !== this.column.grid.id)) {
            return;
        }
        if (this.horizontalScroll) {
            this._dragLeave.next(true);
        }
        if (this.isDropTarget) {
            const args = {
                source: this.cms.column,
                target: this.column
            };
            this.column.grid.moveColumn(this.cms.column, this.column, this._dropPos);
            this.column.grid.draggedColumn = null;
            this.column.grid.cdr.detectChanges();
        }
    }
}
IgxColumnMovingDropDirective.ɵfac = function IgxColumnMovingDropDirective_Factory(t) { return new (t || IgxColumnMovingDropDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(IgxColumnMovingService)); };
IgxColumnMovingDropDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxColumnMovingDropDirective, selectors: [["", "igxColumnMovingDrop", ""]], inputs: { data: ["igxColumnMovingDrop", "data"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxColumnMovingDropDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone },
    { type: IgxColumnMovingService }
];
IgxColumnMovingDropDirective.propDecorators = {
    data: [{ type: Input, args: ['igxColumnMovingDrop',] }]
};

class IgxColumnMovingModule {
}
IgxColumnMovingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxColumnMovingModule });
IgxColumnMovingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxColumnMovingModule_Factory(t) { return new (t || IgxColumnMovingModule)(); } });

class IgxSummaryDataPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(id, trigger = 0) {
        const summaryService = this.gridAPI.grid.summaryService;
        return summaryService.calculateSummaries(summaryService.rootSummaryID, this.gridAPI.get_summary_data());
    }
}
IgxSummaryDataPipe.ɵfac = function IgxSummaryDataPipe_Factory(t) { return new (t || IgxSummaryDataPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxSummaryDataPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxGridSummaryDataPipe", type: IgxSummaryDataPipe, pure: true });
IgxSummaryDataPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

class IgxGridSummaryModule {
}
IgxGridSummaryModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridSummaryModule });
IgxGridSummaryModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridSummaryModule_Factory(t) { return new (t || IgxGridSummaryModule)(); }, imports: [[
            IgxGridPipesModule,
            IgxGridSharedModules
        ]] });

class IgxColumnPinningItemDirective extends ColumnChooserItemBaseDirective {
    constructor() {
        super('pinned');
    }
    /**
     * Returns whether a column could be pinned.
     * It's not possible to pin a column if there is not enough space for the unpinned area.
     * ```typescript
     * const columnItem: IgxColumnPinningItemDirective;
     * this.columnItem.pinnable;
     * ```
     */
    get pinnable() {
        return this.column.pinnable;
    }
    /**
     * Returns whether a column have pinning enabled
     */
    get pinningDisabled() {
        return this.column.disablePinning;
    }
}
IgxColumnPinningItemDirective.ɵfac = function IgxColumnPinningItemDirective_Factory(t) { return new (t || IgxColumnPinningItemDirective)(); };
IgxColumnPinningItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxColumnPinningItemDirective, selectors: [["", "igxColumnPinningItem", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxColumnPinningItemDirective.ctorParameters = () => [];

let IgxColumnPinningComponent = class IgxColumnPinningComponent extends ColumnChooserBaseDirective {
    constructor(cdr) {
        super(cdr);
        this.cdr = cdr;
    }
    /**
     * @hidden
     */
    createColumnItem(container, column) {
        if (column.level !== 0 || column.disablePinning) {
            return null;
        }
        const item = new IgxColumnPinningItemDirective();
        item.container = container;
        item.column = column;
        return item;
    }
    /**
     * @hidden
     */
    checkboxValueChange(event, columnItem) {
        if (event.checked && !columnItem.pinnable) {
            event.checkbox.checked = false;
            return false;
        }
        columnItem.value = !columnItem.value;
    }
    /**
     * @hidden @internal
     */
    get pinnableColumns() {
        return this.columnItems.filter((col) => !col.pinningDisabled);
    }
};
IgxColumnPinningComponent.ɵfac = function IgxColumnPinningComponent_Factory(t) { return new (t || IgxColumnPinningComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxColumnPinningComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxColumnPinningComponent, selectors: [["igx-column-pinning"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 5, consts: [[1, "igx-column-actions__header"], ["class", "igx-column-actions__header-title", 4, "ngIf"], ["class", "igx-column-actions__header-input", 4, "ngIf"], [1, "igx-column-actions__columns"], ["igxColumnPinningItem", "", "class", "igx-column-actions__columns-item", 3, "checked", "change", 4, "ngFor", "ngForOf"], [1, "igx-column-actions__header-title"], [1, "igx-column-actions__header-input"], ["igxInput", "", "type", "text", "autocomplete", "off", 3, "ngModel", "placeholder", "ngModelChange"], ["igxColumnPinningItem", "", 1, "igx-column-actions__columns-item", 3, "checked", "change"]], template: function IgxColumnPinningComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxColumnPinningComponent_h4_1_Template, 2, 1, "h4", 1);
        ɵngcc0.ɵɵtemplate(2, IgxColumnPinningComponent_igx_input_group_2_Template, 2, 2, "igx-input-group", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, IgxColumnPinningComponent_igx_checkbox_4_Template, 2, 2, "igx-checkbox", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.disableFilter);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("max-height", ctx.columnsAreaMaxHeight);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.pinnableColumns);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgForOf, IgxInputGroupComponent, ɵngcc3.DefaultValueAccessor, IgxInputDirective, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxCheckboxComponent, IgxColumnPinningItemDirective], encapsulation: 2 });
IgxColumnPinningComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
IgxColumnPinningComponent = __decorate([
    DeprecateClass(`The 'IgxColumnPinning' component is deprecated.
Please use the 'IgxColumnActions' component with the 'IgxColumnPinning' directive instead.`)
], IgxColumnPinningComponent);

class IgxColumnPinningModule {
}
IgxColumnPinningModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxColumnPinningModule });
IgxColumnPinningModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxColumnPinningModule_Factory(t) { return new (t || IgxColumnPinningModule)(); }, imports: [[
            IgxGridSharedModules
        ]] });

class IgxColumnActionsModule {
}
IgxColumnActionsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxColumnActionsModule });
IgxColumnActionsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxColumnActionsModule_Factory(t) { return new (t || IgxColumnActionsModule)(); }, imports: [[
            IgxGridSharedModules,
            IgxGridPipesModule
        ]] });

class IgxGridToolbarModule {
}
IgxGridToolbarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridToolbarModule });
IgxGridToolbarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridToolbarModule_Factory(t) { return new (t || IgxGridToolbarModule)(); }, imports: [[
            IgxGridSharedModules,
            IgxColumnHidingModule,
            IgxColumnPinningModule,
            IgxColumnActionsModule
        ]] });

class IgxColumnLayoutComponent extends IgxColumnGroupComponent {
    constructor() {
        super(...arguments);
        this.childrenVisibleIndexes = [];
    }
    /**
     * Gets the width of the column layout.
     * ```typescript
     * let columnGroupWidth = this.columnGroup.width;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get width() {
        const width = this.getFilledChildColumnSizes(this.children).reduce((acc, val) => acc + parseInt(val, 10), 0);
        return width;
    }
    set width(val) { }
    get columnLayout() {
        return true;
    }
    /**
     * @hidden
     */
    getCalcWidth() {
        let borderWidth = 0;
        if (this.headerGroup && this.headerGroup.hasLastPinnedChildColumn) {
            const headerStyles = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement.children[0]);
            borderWidth = parseInt(headerStyles.borderRightWidth, 10);
        }
        return super.getCalcWidth() + borderWidth;
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     * @memberof IgxColumnComponent
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => c.columnLayout && !c.hidden);
        const pinnedColumns = this.grid.pinnedColumns.filter(c => c.columnLayout && !c.hidden);
        let vIndex = -1;
        if (!this.pinned) {
            const indexInCollection = unpinnedColumns.indexOf(this);
            vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
        }
        else {
            vIndex = pinnedColumns.indexOf(this);
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /*
     * Gets whether the column layout is hidden.
     * ```typescript
     * let isHidden = this.columnGroup.hidden;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column layout hidden property.
     * ```typescript
     * <igx-column-layout [hidden] = "true"></igx-column->
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set hidden(value) {
        this._hidden = value;
        this.children.forEach(child => child.hidden = value);
        if (this.grid && this.grid.columns && this.grid.columns.length > 0) {
            // reset indexes in case columns are hidden/shown runtime
            const columns = this.grid && this.grid.pinnedColumns && this.grid.unpinnedColumns ?
                this.grid.pinnedColumns.concat(this.grid.unpinnedColumns) : [];
            if (!this._hidden && !columns.find(c => c.field === this.field)) {
                this.grid.resetColumnCollections();
            }
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (!this.hidden) {
            this.hidden = this.allChildren.some(x => x.hidden);
        }
        else {
            this.children.forEach(child => child.hidden = this.hidden);
        }
        this.children.forEach(child => {
            child.movable = false;
        });
    }
    /*
     * Gets whether the group contains the last pinned child column of the column layout.
     * ```typescript
     * let columsHasLastPinned = this.columnLayout.hasLastPinnedChildColumn;
     * ```
     * @memberof IgxColumnLayoutComponent
     */
    get hasLastPinnedChildColumn() {
        return this.children.some(child => child.isLastPinned);
    }
    /*
     * Gets whether the group contains the first pinned child column of the column layout.
     * ```typescript
     * let hasFirstPinnedChildColumn = this.columnLayout.hasFirstPinnedChildColumn;
     * ```
     * @memberof IgxColumnLayoutComponent
     */
    get hasFirstPinnedChildColumn() {
        return this.children.some(child => child.isFirstPinned);
    }
    /**
     * @hidden
     */
    populateVisibleIndexes() {
        this.childrenVisibleIndexes = [];
        const grid = this.gridAPI.grid;
        const columns = grid && grid.pinnedColumns && grid.unpinnedColumns ? grid.pinnedColumns.concat(grid.unpinnedColumns) : [];
        const orderedCols = columns
            .filter(x => !x.columnGroup && !x.hidden)
            .sort((a, b) => a.rowStart - b.rowStart || columns.indexOf(a.parent) - columns.indexOf(b.parent) || a.colStart - b.colStart);
        this.children.forEach(child => {
            const rs = child.rowStart || 1;
            let vIndex = 0;
            // filter out all cols with larger rowStart
            const cols = orderedCols.filter(c => !c.columnGroup && (c.rowStart || 1) <= rs);
            vIndex = cols.indexOf(child);
            this.childrenVisibleIndexes.push({ column: child, index: vIndex });
        });
    }
}
IgxColumnLayoutComponent.ɵfac = function IgxColumnLayoutComponent_Factory(t) { return ɵIgxColumnLayoutComponent_BaseFactory(t || IgxColumnLayoutComponent); };
IgxColumnLayoutComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxColumnLayoutComponent, selectors: [["igx-column-layout"]], inputs: { hidden: "hidden" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxColumnComponent, useExisting: forwardRef(() => IgxColumnLayoutComponent) }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IgxColumnLayoutComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
IgxColumnLayoutComponent.propDecorators = {
    hidden: [{ type: Input }]
};

class IgxGridColumnModule {
}
IgxGridColumnModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridColumnModule });
IgxGridColumnModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridColumnModule_Factory(t) { return new (t || IgxGridColumnModule)(); } });

class IgxGridFilteringModule {
}
IgxGridFilteringModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridFilteringModule });
IgxGridFilteringModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridFilteringModule_Factory(t) { return new (t || IgxGridFilteringModule)(); }, imports: [[
            IgxGridSharedModules,
            IgxGridPipesModule
        ]] });

class SortingIndexPipe {
    transform(columnField, sortingExpressions) {
        let sortIndex = sortingExpressions.findIndex(expression => expression.fieldName === columnField);
        return sortIndex !== -1 ? ++sortIndex : null;
    }
}
SortingIndexPipe.ɵfac = function SortingIndexPipe_Factory(t) { return new (t || SortingIndexPipe)(); };
SortingIndexPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "sortingIndex", type: SortingIndexPipe, pure: true });

class IgxGridHeadersModule {
}
IgxGridHeadersModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridHeadersModule });
IgxGridHeadersModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridHeadersModule_Factory(t) { return new (t || IgxGridHeadersModule)(); }, imports: [[
            IgxGridSharedModules,
            IgxGridFilteringModule,
            IgxColumnMovingModule,
            IgxGridResizingModule
        ]] });

/**
 * @hidden
 */
class IgxGridCommonModule {
}
IgxGridCommonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridCommonModule });
IgxGridCommonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridCommonModule_Factory(t) { return new (t || IgxGridCommonModule)(); }, providers: [
        { provide: IgxGridTransaction, useClass: IgxBaseTransactionService }
    ], imports: [[
            IgxGridColumnModule,
            IgxGridHeadersModule,
            IgxColumnMovingModule,
            IgxGridResizingModule,
            IgxColumnPinningModule,
            IgxGridSelectionModule,
            IgxGridSummaryModule,
            IgxGridToolbarModule,
            IgxColumnHidingModule,
            IgxColumnActionsModule,
            IgxGridPipesModule,
            IgxGridFilteringModule,
            IgxGridExcelStyleFilteringModule,
            IgxRowDragModule,
            IgxPaginatorModule,
            IgxGridSharedModules
        ], IgxColumnHidingModule, IgxColumnPinningModule, IgxColumnActionsModule, IgxGridColumnModule, IgxGridHeadersModule, IgxGridPipesModule, IgxGridFilteringModule, IgxGridExcelStyleFilteringModule, IgxRowDragModule, IgxPaginatorModule, IgxGridResizingModule, IgxColumnMovingModule, IgxGridSelectionModule, IgxGridSummaryModule, IgxGridToolbarModule, IgxGridSharedModules] });

/**
 * @hidden
 */
class IgxGridSortingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, expressions, sorting, id, pipeTrigger, pinned) {
        const grid = this.gridAPI.grid;
        let result;
        if (!expressions.length) {
            result = collection;
        }
        else {
            result = DataUtil.sort(cloneArray(collection), expressions, sorting, grid);
        }
        grid.setFilteredSortedData(result, pinned);
        return result;
    }
}
IgxGridSortingPipe.ɵfac = function IgxGridSortingPipe_Factory(t) { return new (t || IgxGridSortingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridSortingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridSort", type: IgxGridSortingPipe, pure: true });
IgxGridSortingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxGridGroupingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, expression, expansion, defaultExpanded, id, groupsRecords, pipeTrigger) {
        const state = { expressions: [], expansion: [], defaultExpanded };
        const grid = this.gridAPI.grid;
        state.expressions = grid.groupingExpressions;
        let result;
        const fullResult = { data: [], metadata: [] };
        if (!state.expressions.length) {
            // empty the array without changing reference
            groupsRecords.splice(0, groupsRecords.length);
            result = {
                data: collection,
                metadata: collection
            };
        }
        else {
            state.expansion = grid.groupingExpansionState;
            state.defaultExpanded = grid.groupsExpanded;
            result = DataUtil.group(cloneArray(collection), state, grid, groupsRecords, fullResult);
        }
        grid.groupingFlatResult = result.data;
        grid.groupingResult = fullResult.data;
        grid.groupingMetadata = fullResult.metadata;
        return result;
    }
}
IgxGridGroupingPipe.ɵfac = function IgxGridGroupingPipe_Factory(t) { return new (t || IgxGridGroupingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridGroupingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridGroupBy", type: IgxGridGroupingPipe, pure: true });
IgxGridGroupingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxGridPagingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, page = 0, perPage = 15, id, pipeTrigger) {
        if (!this.gridAPI.grid.paging || this.gridAPI.grid.pagingMode !== GridPagingMode.local) {
            return collection;
        }
        const state = {
            index: page,
            recordsPerPage: perPage
        };
        const total = this.gridAPI.grid._totalRecords >= 0 ? this.gridAPI.grid._totalRecords : collection.data.length;
        DataUtil.correctPagingState(state, total);
        const result = {
            data: DataUtil.page(cloneArray(collection.data), state, total),
            metadata: DataUtil.page(cloneArray(collection.metadata), state, total)
        };
        if (this.gridAPI.grid.page !== state.index) {
            this.gridAPI.grid.page = state.index;
        }
        this.gridAPI.grid.pagingState = state;
        return result;
    }
}
IgxGridPagingPipe.ɵfac = function IgxGridPagingPipe_Factory(t) { return new (t || IgxGridPagingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridPagingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridPaging", type: IgxGridPagingPipe, pure: true });
IgxGridPagingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxGridFilteringPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, expressionsTree, filterStrategy, advancedExpressionsTree, id, pipeTrigger, filteringPipeTrigger, pinned) {
        const grid = this.gridAPI.grid;
        const state = {
            expressionsTree: expressionsTree,
            strategy: filterStrategy,
            advancedExpressionsTree: advancedExpressionsTree
        };
        if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
            return collection;
        }
        const result = DataUtil.filter(cloneArray(collection), state, grid);
        grid.setFilteredData(result, pinned);
        return result;
    }
}
IgxGridFilteringPipe.ɵfac = function IgxGridFilteringPipe_Factory(t) { return new (t || IgxGridFilteringPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridFilteringPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridFiltering", type: IgxGridFilteringPipe, pure: true });
IgxGridFilteringPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

class IgxGridRowComponent extends IgxRowDirective {
    get hasColumnLayouts() {
        return this.grid.hasColumnLayouts;
    }
    getContext(col, row) {
        return {
            $implicit: col,
            row: row
        };
    }
    get mrlRightPinnedOffset() {
        return !this.grid.isPinningToStart ?
            -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' :
            null;
    }
    getContextMRL(pinnedCols, row) {
        return {
            $implicit: pinnedCols,
            row: row
        };
    }
    get expanded() {
        return this.gridAPI.get_row_expansion_state(this.rowData);
    }
}
IgxGridRowComponent.ɵfac = function IgxGridRowComponent_Factory(t) { return ɵIgxGridRowComponent_BaseFactory(t || IgxGridRowComponent); };
IgxGridRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridRowComponent, selectors: [["igx-grid-row"]], hostVars: 2, hostBindings: function IgxGridRowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-grid__tr--mrl", ctx.hasColumnLayouts);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxGridRowComponent) }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 17, vars: 1, consts: [[4, "ngTemplateOutlet"], ["addTemp", ""], ["defaultTemp", ""], ["mrlPinnedTemplate", ""], ["rowSelectorBaseTemplate", ""], ["cellTemplate", ""], ["expandableCellTemplate", ""], ["mrlCellTemplate", ""], ["mrlExpandableCellTemplate", ""], [1, "igx-grid__tr--inner", 3, "animationend"], [4, "ngIf"], [3, "pointerdown", "click"], [3, "igxRowDrag", "ghostTemplate", "click"], [1, "igx-grid__cbx-selection", 3, "pointerdown", "click"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollContainer", "igxForScrollOrientation", "igxForContainerSize", "igxForSizePropName", "igxForTrackBy"], ["igxDirRef", ""], ["ngFor", "", 3, "ngForOf"], [1, "igx-grid__mrl-block", 3, "ngStyle"], ["class", "igx-grid__mrl-block", 3, "igx-grid__td--pinned-last", "igx-grid__td--pinned-first", "left", "ngStyle", 4, "ngFor", "ngForOf"], [1, "igx-grid__cbx-padding"], ["disableRipple", "true", 3, "tabindex", "checked", "readonly", "disabled", "disableTransitions", "aria-label"], [1, "igx-grid__td", "igx-grid__td--fw", 3, "ngClass", "ngStyle", "editMode", "column", "formatter", "row", "lastPinned", "firstPinned", "rowData", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"], ["cell", ""], [1, "igx-grid__td", "igx-grid__td--fw", "igx-grid__td--tree-cell", 3, "ngClass", "ngStyle", "expanded", "editMode", "column", "formatter", "row", "lastPinned", "rowData", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"], [1, "igx-grid__td", "igx-grid__td--fw", 3, "ngClass", "ngStyle", "editMode", "column", "lastPinned", "firstPinned", "formatter", "row", "rowData", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"], [1, "igx-grid__td", "igx-grid__td--fw", "igx-grid__td--tree-cell", 3, "ngClass", "ngStyle", "expanded", "editMode", "column", "lastPinned", "formatter", "row", "rowData", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"]], template: function IgxGridRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_1_Template, 2, 3, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(3, IgxGridRowComponent_ng_template_3_Template, 5, 5, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, IgxGridRowComponent_ng_template_5_Template, 2, 3, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(7, IgxGridRowComponent_ng_template_7_Template, 2, 6, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(9, IgxGridRowComponent_ng_template_9_Template, 7, 88, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(11, IgxGridRowComponent_ng_template_11_Template, 7, 84, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(13, IgxGridRowComponent_ng_template_13_Template, 7, 93, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(15, IgxGridRowComponent_ng_template_15_Template, 7, 93, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        const _r3 = ɵngcc0.ɵɵreference(4);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.addRow ? _r1 : _r3);
    } }, directives: function () { return [ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxRowDragDirective, IgxGridForOfDirective, ɵngcc2.NgForOf, ɵngcc2.NgStyle, IgxCheckboxComponent, IgxGridCellComponent, ɵngcc2.NgClass, IgxGridExpandableCellComponent]; }, pipes: function () { return [IgxGridNotGroupedPipe, IgxGridTopLevelColumns, IgxGridTransactionStatePipe, IgxStringReplacePipe, IgxGridCellStyleClassesPipe, IgxGridCellStylesPipe, IgxGridDataMapperPipe]; }, encapsulation: 2, changeDetection: 0 });
IgxGridRowComponent.propDecorators = {
    hasColumnLayouts: [{ type: HostBinding, args: ['class.igx-grid__tr--mrl',] }]
};

/** @hidden */
class IgxGridSummaryPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, hasSummary, summaryCalculationMode, summaryPosition, id, showSummary, pipeTrigger, summaryPipeTrigger) {
        if (!collection.data || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
            return collection.data;
        }
        return this.addSummaryRows(id, collection, summaryPosition, showSummary);
    }
    addSummaryRows(gridId, collection, summaryPosition, showSummary) {
        const recordsWithSummary = [];
        const lastChildMap = new Map();
        const grid = this.gridAPI.grid;
        const maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
        if (collection.metadata.length && !grid.isGroupByRecord(collection.data[0]) &&
            grid.isGroupByRecord(collection.metadata[0]) && summaryPosition === GridSummaryPosition.bottom) {
            const groups = [];
            groups.push(collection.metadata[0]);
            while (groups[groups.length - 1].groupParent) {
                groups.push(groups[groups.length - 1].groupParent);
            }
            groups.reverse();
            groups.forEach(g => g.skip = true);
            collection.data.splice(0, 0, ...groups);
        }
        for (let i = 0; i < collection.data.length; i++) {
            const record = collection.data[i];
            let skipAdd = false;
            let recordId;
            let groupByRecord = null;
            if (grid.isGroupByRecord(record)) {
                skipAdd = !!record.skip;
                record.skip = null;
                groupByRecord = record;
                recordId = this.gridAPI.get_groupBy_record_id(groupByRecord);
            }
            else {
                recordId = this.gridAPI.get_row_id(record);
            }
            if (!skipAdd) {
                recordsWithSummary.push(record);
            }
            if (summaryPosition === GridSummaryPosition.bottom && showSummary && (groupByRecord && !grid.isExpandedGroup(groupByRecord))) {
                const records = this.removeDeletedRecord(grid, groupByRecord.records.slice());
                const summaries = grid.summaryService.calculateSummaries(recordId, records);
                const summaryRecord = {
                    summaries: summaries,
                    max: maxSummaryHeight
                };
                recordsWithSummary.push(summaryRecord);
            }
            if (summaryPosition === GridSummaryPosition.bottom && lastChildMap.has(recordId)) {
                const groupRecords = lastChildMap.get(recordId);
                for (let j = 0; j < groupRecords.length; j++) {
                    const groupRecord = groupRecords[j];
                    const groupRecordId = this.gridAPI.get_groupBy_record_id(groupRecord);
                    const records = this.removeDeletedRecord(grid, groupRecord.records.slice());
                    const summaries = grid.summaryService.calculateSummaries(groupRecordId, records);
                    const summaryRecord = {
                        summaries: summaries,
                        max: maxSummaryHeight
                    };
                    recordsWithSummary.push(summaryRecord);
                }
            }
            const showSummaries = showSummary ? false : (groupByRecord && !grid.isExpandedGroup(groupByRecord));
            if (groupByRecord === null || showSummaries) {
                continue;
            }
            if (summaryPosition === GridSummaryPosition.top) {
                const records = this.removeDeletedRecord(grid, groupByRecord.records.slice());
                const summaries = grid.summaryService.calculateSummaries(recordId, records);
                const summaryRecord = {
                    summaries: summaries,
                    max: maxSummaryHeight
                };
                recordsWithSummary.push(summaryRecord);
            }
            else if (summaryPosition === GridSummaryPosition.bottom) {
                let lastChild = groupByRecord;
                while (lastChild.groups && lastChild.groups.length > 0 && grid.isExpandedGroup(lastChild)) {
                    lastChild = lastChild.groups[lastChild.groups.length - 1];
                }
                let lastChildId;
                if (grid.isExpandedGroup(lastChild)) {
                    lastChildId = this.gridAPI.get_row_id(lastChild.records[lastChild.records.length - 1]);
                }
                else {
                    lastChildId = this.gridAPI.get_groupBy_record_id(lastChild);
                }
                let groupRecords = lastChildMap.get(lastChildId);
                if (!groupRecords) {
                    groupRecords = [];
                    lastChildMap.set(lastChildId, groupRecords);
                }
                groupRecords.unshift(groupByRecord);
            }
        }
        return recordsWithSummary;
    }
    removeDeletedRecord(grid, data) {
        if (!grid.transactions.enabled) {
            return data;
        }
        const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === 'delete').map(t => t.id);
        deletedRows.forEach(rowID => {
            const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
            const index = tempData.indexOf(rowID);
            if (index !== -1) {
                data.splice(index, 1);
            }
        });
        return data;
    }
}
IgxGridSummaryPipe.ɵfac = function IgxGridSummaryPipe_Factory(t) { return new (t || IgxGridSummaryPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridSummaryPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridSummary", type: IgxGridSummaryPipe, pure: true });
IgxGridSummaryPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/** @hidden */
class IgxGridDetailsPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, hasDetails, expansionStates, pipeTrigger) {
        if (!hasDetails) {
            return collection;
        }
        const res = this.addDetailRows(collection, expansionStates);
        return res;
    }
    addDetailRows(collection, expansionStates) {
        const result = [];
        collection.forEach((v) => {
            result.push(v);
            if (!this.gridAPI.grid.isGroupByRecord(v) && !this.gridAPI.grid.isSummaryRow(v) &&
                this.gridAPI.get_row_expansion_state(v)) {
                const detailsObj = { detailsData: v };
                result.push(detailsObj);
            }
        });
        return result;
    }
}
IgxGridDetailsPipe.ɵfac = function IgxGridDetailsPipe_Factory(t) { return new (t || IgxGridDetailsPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridDetailsPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridDetails", type: IgxGridDetailsPipe, pure: true });
IgxGridDetailsPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

class IgxGridExpandableCellComponent extends IgxGridCellComponent {
    constructor(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil) {
        super(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil);
        this.zone = zone;
        this.document = document;
        this.platformUtil = platformUtil;
        /**
         * @hidden
         */
        this.expanded = false;
    }
    /**
     * @hidden
     */
    toggle(event) {
        event.stopPropagation();
        const expansionState = this.gridAPI.get_row_expansion_state(this.row.rowData);
        this.gridAPI.set_row_expansion_state(this.row.rowID, !expansionState, event);
    }
    /**
     * @hidden
     */
    onIndicatorFocus() {
        this.gridAPI.submit_value();
    }
    /**
     * @hidden
     */
    calculateSizeToFit(range) {
        const indicatorWidth = this.indicator.nativeElement.getBoundingClientRect().width;
        const indicatorStyle = this.document.defaultView.getComputedStyle(this.indicator.nativeElement);
        const indicatorMargin = parseFloat(indicatorStyle.marginRight);
        let leftPadding = 0;
        if (this.indentationDiv) {
            const indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);
            leftPadding = parseFloat(indentationStyle.paddingLeft);
        }
        const largestWidth = Math.max(...Array.from(this.nativeElement.children)
            .map((child) => getNodeSizeViaRange(range, child)));
        return largestWidth + indicatorWidth + indicatorMargin + leftPadding;
    }
    /**
     * @hidden
     */
    get iconTemplate() {
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    /**
     * @hidden
     */
    get showExpanderIndicator() {
        const isGhost = this.row.pinned && this.row.disabled;
        return !this.editMode && (!this.row.pinned || isGhost);
    }
}
IgxGridExpandableCellComponent.ɵfac = function IgxGridExpandableCellComponent_Factory(t) { return new (t || IgxGridExpandableCellComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(HammerGesturesManager), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(PlatformUtil)); };
IgxGridExpandableCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridExpandableCellComponent, selectors: [["igx-expandable-grid-cell"]], viewQuery: function IgxGridExpandableCellComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c206, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c207, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c135, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c136, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.indicator = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.indentationDiv = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExpandedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultCollapsedTemplate = _t.first);
    } }, inputs: { expanded: "expanded" }, features: [ɵngcc0.ɵɵProvidersFeature([HammerGesturesManager]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 15, vars: 5, consts: [["defaultPinnedIndicator", ""], ["defaultCell", ""], ["addRowCell", ""], ["inlineEditor", ""], [4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["defaultExpandedTemplate", ""], ["defaultCollapsedTemplate", ""], ["class", "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity", 4, "ngIf"], [1, "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity"], ["igxTextHighlight", "", 1, "igx-grid__td-text", 2, "pointer-events", "none", 3, "cssClass", "activeCssClass", "groupName", "value", "row", "column", "containerClass", "metadata"], ["displayDensity", "compact"], ["igxInput", "", 3, "ngModel", "igxFocus", "ngModelChange"], ["igxInput", "", "type", "number", 3, "ngModel", "igxFocus", "ngModelChange"], [3, "value", "checked", "disableRipple", "change"], ["mode", "dropdown", 3, "outlet", "locale", "value", "igxFocus", "labelVisibility", "valueChange"], [1, "igx-grid__tree-grouping-indicator", 3, "click", "focus"], ["indicator", ""], ["fontSet", "material"]], template: function IgxGridExpandableCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridExpandableCellComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxGridExpandableCellComponent_ng_template_2_Template, 8, 33, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxGridExpandableCellComponent_ng_template_4_Template, 5, 21, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxGridExpandableCellComponent_ng_template_6_Template, 4, 4, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, IgxGridExpandableCellComponent_ng_container_8_Template, 4, 4, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(9, IgxGridExpandableCellComponent_ng_container_9_Template, 1, 0, "ng-container", 5);
        ɵngcc0.ɵɵtemplate(10, IgxGridExpandableCellComponent_ng_container_10_Template, 1, 0, "ng-container", 5);
        ɵngcc0.ɵɵtemplate(11, IgxGridExpandableCellComponent_ng_template_11_Template, 2, 0, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(13, IgxGridExpandableCellComponent_ng_template_13_Template, 2, 0, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(8);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showExpanderIndicator);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.pinnedIndicatorTemplate)("ngTemplateOutletContext", ctx.context);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, IgxChipComponent, IgxTextHighlightDirective, IgxInputGroupComponent, ɵngcc3.DefaultValueAccessor, IgxInputDirective, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxFocusDirective, ɵngcc3.NumberValueAccessor, IgxCheckboxComponent, IgxDatePickerComponent, IgxIconComponent], pipes: [IgxColumnFormatterPipe, ɵngcc2.DecimalPipe, ɵngcc2.DatePipe], encapsulation: 2, changeDetection: 0 });
IgxGridExpandableCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: HammerGesturesManager },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: PlatformUtil }
];
IgxGridExpandableCellComponent.propDecorators = {
    expanded: [{ type: Input }],
    indicator: [{ type: ViewChild, args: ['indicator', { read: ElementRef },] }],
    indentationDiv: [{ type: ViewChild, args: ['indentationDiv', { read: ElementRef },] }],
    defaultExpandedTemplate: [{ type: ViewChild, args: ['defaultExpandedTemplate', { read: TemplateRef, static: true },] }],
    defaultCollapsedTemplate: [{ type: ViewChild, args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true },] }]
};

/**
 * @hidden
 */
class IgxGridModule {
}
IgxGridModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridModule });
IgxGridModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridModule_Factory(t) { return new (t || IgxGridModule)(); }, imports: [[
            IgxGridCommonModule,
        ], IgxGridCommonModule] });

class IgxTreeGridAPIService extends GridBaseAPIService {
    get_all_data(transactions) {
        const grid = this.grid;
        const data = transactions ? grid.dataWithAddedInTransactionRows : grid.flatData;
        return data ? data : [];
    }
    get_summary_data() {
        const grid = this.grid;
        const data = grid.processedRootRecords.filter(row => row.isFilteredOutParent === undefined || row.isFilteredOutParent === false)
            .map(rec => rec.data);
        if (grid.transactions.enabled) {
            const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === TransactionType.DELETE).map(t => t.id);
            deletedRows.forEach(rowID => {
                const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
                const index = tempData.indexOf(rowID);
                if (index !== -1) {
                    data.splice(index, 1);
                }
            });
        }
        return data;
    }
    allow_expansion_state_change(rowID, expanded) {
        const grid = this.grid;
        const row = grid.records.get(rowID);
        if (row.expanded === expanded ||
            ((!row.children || !row.children.length) && (!grid.loadChildrenOnDemand ||
                (grid.hasChildrenKey && !row.data[grid.hasChildrenKey])))) {
            return false;
        }
        return true;
    }
    expand_path_to_record(record) {
        const grid = this.grid;
        const expandedStates = grid.expansionStates;
        while (record.parent) {
            record = record.parent;
            const expanded = this.get_row_expansion_state(record);
            if (!expanded) {
                expandedStates.set(record.rowID, true);
            }
        }
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
    }
    get_row_expansion_state(record) {
        const grid = this.grid;
        const states = grid.expansionStates;
        const expanded = states.get(record.rowID);
        if (expanded !== undefined) {
            return expanded;
        }
        else {
            return record.children && record.children.length && record.level < grid.expansionDepth;
        }
    }
    update_row_in_array(value, rowID, index) {
        const grid = this.grid;
        if (grid.primaryKey && grid.foreignKey) {
            super.update_row_in_array(value, rowID, index);
        }
        else {
            const record = grid.records.get(rowID);
            const childData = record.parent ? record.parent.data[grid.childDataKey] : grid.data;
            index = grid.primaryKey ? childData.map(c => c[grid.primaryKey]).indexOf(rowID) :
                childData.indexOf(rowID);
            childData[index] = value;
        }
    }
    should_apply_number_style(column) {
        return column.dataType === DataType.Number && column.visibleIndex !== 0;
    }
    deleteRowById(rowID) {
        const treeGrid = this.grid;
        const flatDataWithCascadeOnDeleteAndTransactions = treeGrid.primaryKey &&
            treeGrid.foreignKey &&
            treeGrid.cascadeOnDelete &&
            treeGrid.transactions.enabled;
        if (flatDataWithCascadeOnDeleteAndTransactions) {
            treeGrid.transactions.startPending();
        }
        super.deleteRowById(rowID);
        if (flatDataWithCascadeOnDeleteAndTransactions) {
            treeGrid.transactions.endPending(true);
        }
    }
    deleteRowFromData(rowID, index) {
        const treeGrid = this.grid;
        const record = treeGrid.records.get(rowID);
        if (treeGrid.primaryKey && treeGrid.foreignKey) {
            index = treeGrid.primaryKey ?
                treeGrid.data.map(c => c[treeGrid.primaryKey]).indexOf(rowID) :
                treeGrid.data.indexOf(rowID);
            super.deleteRowFromData(rowID, index);
            if (treeGrid.cascadeOnDelete) {
                if (record && record.children && record.children.length > 0) {
                    for (let i = 0; i < record.children.length; i++) {
                        const child = record.children[i];
                        super.deleteRowById(child.rowID);
                    }
                }
            }
        }
        else {
            const collection = record.parent ? record.parent.data[treeGrid.childDataKey] : treeGrid.data;
            index = treeGrid.primaryKey ?
                collection.map(c => c[treeGrid.primaryKey]).indexOf(rowID) :
                collection.indexOf(rowID);
            const selectedChildren = [];
            this.get_selected_children(record, selectedChildren);
            if (selectedChildren.length > 0) {
                treeGrid.deselectRows(selectedChildren);
            }
            if (treeGrid.transactions.enabled) {
                const path = treeGrid.generateRowPath(rowID);
                treeGrid.transactions.add({
                    id: rowID,
                    type: TransactionType.DELETE,
                    newValue: null,
                    path: path
                }, collection[index]);
            }
            else {
                collection.splice(index, 1);
            }
        }
    }
    /**
     * Updates related row of provided grid's data source with provided new row value
     * @param grid Grid to update data for
     * @param rowID ID of the row to update
     * @param rowValueInDataSource Initial value of the row as it is in data source
     * @param rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param rowNewValue New value of the row
     */
    updateData(grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
        if (grid.transactions.enabled) {
            const path = grid.generateRowPath(rowID);
            const transaction = {
                id: rowID,
                type: TransactionType.UPDATE,
                newValue: rowNewValue,
                path: path
            };
            grid.transactions.add(transaction, rowCurrentValue);
        }
        else {
            mergeObjects(rowValueInDataSource, rowNewValue);
        }
    }
    get_selected_children(record, selectedRowIDs) {
        const grid = this.grid;
        if (!record.children || record.children.length === 0) {
            return;
        }
        for (const child of record.children) {
            if (grid.selectionService.isRowSelected(child.rowID)) {
                selectedRowIDs.push(child.rowID);
            }
            this.get_selected_children(child, selectedRowIDs);
        }
    }
    row_deleted_transaction(rowID) {
        return this.row_deleted_parent(rowID) || super.row_deleted_transaction(rowID);
    }
    get_rec_by_id(rowID) {
        return this.grid.records.get(rowID);
    }
    row_deleted_parent(rowID) {
        const grid = this.grid;
        if (!grid) {
            return false;
        }
        if ((grid.cascadeOnDelete && grid.foreignKey) || grid.childDataKey) {
            let node = grid.records.get(rowID);
            while (node) {
                const state = grid.transactions.getState(node.rowID);
                if (state && state.type === TransactionType.DELETE) {
                    return true;
                }
                node = node.parent;
            }
        }
        return false;
    }
    addRowToData(data, parentRowID) {
        if (parentRowID !== undefined && parentRowID !== null) {
            const state = this.grid.transactions.getState(parentRowID);
            // we should not allow adding of rows as child of deleted row
            if (state && state.type === TransactionType.DELETE) {
                throw Error(`Cannot add child row to deleted parent row`);
            }
            const parentRecord = this.grid.records.get(parentRowID);
            if (!parentRecord) {
                throw Error('Invalid parent row ID!');
            }
            this.grid.summaryService.clearSummaryCache({ rowID: parentRecord.rowID });
            if (this.grid.primaryKey && this.grid.foreignKey) {
                data[this.grid.foreignKey] = parentRowID;
                super.addRowToData(data);
            }
            else {
                const parentData = parentRecord.data;
                const childKey = this.grid.childDataKey;
                if (this.grid.transactions.enabled) {
                    const rowId = this.grid.primaryKey ? data[this.grid.primaryKey] : data;
                    const path = [];
                    path.push(...this.grid.generateRowPath(parentRowID));
                    path.push(parentRowID);
                    this.grid.transactions.add({
                        id: rowId,
                        path: path,
                        newValue: data,
                        type: TransactionType.ADD
                    }, null);
                }
                else {
                    if (!parentData[childKey]) {
                        parentData[childKey] = [];
                    }
                    parentData[childKey].push(data);
                }
            }
        }
        else {
            super.addRowToData(data);
        }
    }
}
IgxTreeGridAPIService.ɵfac = function IgxTreeGridAPIService_Factory(t) { return ɵIgxTreeGridAPIService_BaseFactory(t || IgxTreeGridAPIService); };
IgxTreeGridAPIService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxTreeGridAPIService, factory: IgxTreeGridAPIService.ɵfac });

/**
 * @hidden
 */
class IgxRowLoadingIndicatorTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxRowLoadingIndicatorTemplateDirective.ɵfac = function IgxRowLoadingIndicatorTemplateDirective_Factory(t) { return new (t || IgxRowLoadingIndicatorTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxRowLoadingIndicatorTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowLoadingIndicatorTemplateDirective, selectors: [["", "igxRowLoadingIndicator", ""]] });
IgxRowLoadingIndicatorTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

let NEXT_ID$p = 0;
/**
 * **Ignite UI for Angular Tree Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid)
 *
 * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
 * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
 *
 * Example:
 * ```html
 * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-tree-grid>
 * ```
 */
class IgxTreeGridComponent extends IgxGridBaseDirective {
    constructor() {
        super(...arguments);
        this._id = `igx-tree-grid-${NEXT_ID$p++}`;
        /**
         * Returns a map of all `ITreeGridRecord`s.
         * ```typescript
         * // gets the record with primaryKey=2
         * const states = this.grid.records.get(2);
         * ```
         * @memberof IgxTreeGridComponent
         */
        this.records = new Map();
        /**
         * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
         * ```typescript
         * // gets the processed record with primaryKey=2
         * const states = this.grid.processedRecords.get(2);
         * ```
         * @memberof IgxTreeGridComponent
         */
        this.processedRecords = new Map();
        /**
         * An @Input property indicating whether child records should be deleted when their parent gets deleted.
         * By default it is set to true and deletes all children along with the parent.
         * ```html
         * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
         * </igx-tree-grid>
         * ```
         * @memberof IgxTreeGridComponent
         */
        this.cascadeOnDelete = true;
        this._expansionDepth = Infinity;
        /**
         * @hidden
         */
        this.loadingRows = new Set();
        this._filteredData = null;
    }
    /**
     * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
     * ```html
     * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    /**
     * An @Input property that lets you fill the `IgxTreeGridComponent` with an array of data.
     * ```html
     * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    get data() {
        return this._data;
    }
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
        }
        this.cdr.markForCheck();
    }
    /**
     * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     * @memberof IgxTreeGridComponent
     */
    get filteredData() {
        return this._filteredData;
    }
    /**
     * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * this.grid.filteredData = [{
     *       ID: 1,
     *       Name: "A"
     * }];
     * ```
     * @memberof IgxTreeGridComponent
     */
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Get transactions service for the grid.
     * @experimental @hidden
     */
    get transactions() {
        return this._transactions;
    }
    /**
     * An @Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
     * set to `Infinity` which means all levels would be expanded.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    get expansionDepth() {
        return this._expansionDepth;
    }
    set expansionDepth(value) {
        this._expansionDepth = value;
        this.notifyChanges();
    }
    /**
     * An @Input property that provides a template for the row loading indicator when load on demand is enabled.
     * ```html
     * <ng-template #rowLoadingTemplate>
     *     <igx-icon fontSet="material">loop</igx-icon>
     * </ng-template>
     *
     * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
     *                [loadChildrenOnDemand]="loadChildren"
     *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
     * </igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    get rowLoadingIndicatorTemplate() {
        return this._rowLoadingIndicatorTemplate;
    }
    set rowLoadingIndicatorTemplate(value) {
        this._rowLoadingIndicatorTemplate = value;
        this.notifyChanges();
    }
    // Kind of stupid
    get _gridAPI() {
        return this.gridAPI;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.onRowToggle.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.loadChildrenOnRowExpansion(args);
        });
        this.transactions.onStateUpdate.pipe(takeUntil(this.destroy$)).subscribe((event) => {
            let actions = [];
            if (event.origin === TransactionEventOrigin.REDO) {
                actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.DELETE) : [];
            }
            else if (event.origin === TransactionEventOrigin.UNDO) {
                actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.ADD) : [];
            }
            if (actions.length) {
                for (const action of actions) {
                    this.deselectChildren(action.transaction.id);
                }
            }
        });
    }
    ngDoCheck() {
        super.ngDoCheck();
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.rowLoadingTemplate) {
            this._rowLoadingIndicatorTemplate = this.rowLoadingTemplate.template;
        }
        super.ngAfterContentInit();
    }
    loadChildrenOnRowExpansion(args) {
        if (this.loadChildrenOnDemand) {
            const parentID = args.rowID;
            if (args.expanded && !this._expansionStates.has(parentID)) {
                this.loadingRows.add(parentID);
                this.loadChildrenOnDemand(parentID, children => {
                    this.loadingRows.delete(parentID);
                    this.addChildRows(children, parentID);
                    this.notifyChanges();
                });
            }
        }
    }
    addChildRows(children, parentID) {
        if (this.primaryKey && this.foreignKey) {
            for (const child of children) {
                child[this.foreignKey] = parentID;
            }
            this.data.push(...children);
        }
        else if (this.childDataKey) {
            let parent = this.records.get(parentID);
            let parentData = parent.data;
            if (this.transactions.enabled && this.transactions.getAggregatedChanges(true).length) {
                const path = [];
                while (parent) {
                    path.push(parent.rowID);
                    parent = parent.parent;
                }
                let collection = this.data;
                let record;
                for (let i = path.length - 1; i >= 0; i--) {
                    const pid = path[i];
                    record = collection.find(r => r[this.primaryKey] === pid);
                    if (!record) {
                        break;
                    }
                    collection = record[this.childDataKey];
                }
                if (record) {
                    parentData = record;
                }
            }
            parentData[this.childDataKey] = children;
        }
        this.selectionService.clearHeaderCBState();
        this._pipeTrigger++;
    }
    findRecordIndexInView(rec) {
        return this.dataView.findIndex(x => x.data[this.primaryKey] === rec[this.primaryKey]);
    }
    getUnpinnedIndexById(id) {
        return this.unpinnedRecords.findIndex(x => x.data[this.primaryKey] === id);
    }
    cloneMap(mapIn) {
        const mapCloned = new Map();
        mapIn.forEach((value, key, mapObj) => {
            mapCloned.set(key, value);
        });
        return mapCloned;
    }
    getDefaultExpandState(record) {
        return record.children && record.children.length && record.level < this.expansionDepth;
    }
    /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     * @memberof IgxTreeGridComponent
     */
    expandAll() {
        this._expansionDepth = Infinity;
        this.expansionStates = new Map();
    }
    /**
     * Collapses all rows.
     *
     * ```typescript
     * this.grid.collapseAll();
     *  ```
     * @memberof IgxTreeGridComponent
     */
    collapseAll() {
        this._expansionDepth = 0;
        this.expansionStates = new Map();
    }
    /**
     * @hidden
     */
    refreshGridState(args) {
        super.refreshGridState();
        if (this.primaryKey && this.foreignKey) {
            const rowID = args.data[this.foreignKey];
            this.summaryService.clearSummaryCache({ rowID: rowID });
            this._pipeTrigger++;
            this.cdr.detectChanges();
        }
    }
    /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     * @param data
     * @param parentRowID
     * @memberof IgxTreeGridComponent
     */
    addRow(data, parentRowID) {
        super.endEdit(true);
        this.gridAPI.addRowToData(data, parentRowID);
        this.onRowAdded.emit({ data });
        this._pipeTrigger++;
        this.notifyChanges();
    }
    /**
     * @hidden
     * @internal
     */
    _getParentRecordId() {
        var _a;
        if (this.addRowParent.asChild) {
            return super._getParentRecordId();
        }
        else if (this.addRowParent.rowID !== null && this.addRowParent.rowID !== undefined) {
            const spawnedForRecord = this._gridAPI.get_rec_by_id(this.addRowParent.rowID);
            return (_a = spawnedForRecord === null || spawnedForRecord === void 0 ? void 0 : spawnedForRecord.parent) === null || _a === void 0 ? void 0 : _a.rowID;
        }
    }
    /** @hidden */
    deleteRowById(rowId) {
        //  if this is flat self-referencing data, and CascadeOnDelete is set to true
        //  and if we have transactions we should start pending transaction. This allows
        //  us in case of delete action to delete all child rows as single undo action
        this._gridAPI.deleteRowById(rowId);
    }
    /** @hidden */
    generateRowPath(rowId) {
        const path = [];
        let record = this.records.get(rowId);
        while (record.parent) {
            path.push(record.parent.rowID);
            record = record.parent;
        }
        return path.reverse();
    }
    /**
     * @hidden @internal
     */
    getDataBasedBodyHeight() {
        return !this.flatData || (this.flatData.length < this._defaultTargetRecordNumber) ?
            0 : this.defaultTargetBodyHeight;
    }
    /**
     * @hidden
     */
    scrollTo(row, column) {
        let delayScrolling = false;
        let record;
        if (typeof (row) !== 'number') {
            const rowData = row;
            const rowID = this._gridAPI.get_row_id(rowData);
            record = this.processedRecords.get(rowID);
            this._gridAPI.expand_path_to_record(record);
            if (this.paging) {
                const rowIndex = this.processedExpandedFlatData.indexOf(rowData);
                const page = Math.floor(rowIndex / this.perPage);
                if (this.page !== page) {
                    delayScrolling = true;
                    this.page = page;
                }
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(first$1()).subscribe(() => {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(record));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(record));
        }
        this.scrollToHorizontally(column);
    }
    /**
     * @hidden
     */
    getContext(rowData, rowIndex, pinned) {
        return {
            $implicit: this.isGhostRecord(rowData) || this.isAddRowRecord(rowData) ? rowData.recordRef : rowData,
            index: this.getDataViewIndex(rowIndex, pinned),
            templateID: this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',
            disabled: this.isGhostRecord(rowData) ? rowData.recordRef.isFilteredOutParent === undefined : false,
            addRow: this.isAddRowRecord(rowData) ? rowData.addRow : false
        };
    }
    /**
     * @hidden
     * @internal
     */
    getInitialPinnedIndex(rec) {
        return this._pinnedRecordIDs.indexOf(rec.rowID);
    }
    /**
     * @inheritdoc
     */
    getSelectedData(formatters = false, headers = false) {
        let source = [];
        const process = (record) => {
            if (record.summaries) {
                source.push(null);
                return;
            }
            source.push(record.data);
        };
        this.unpinnedDataView.forEach(process);
        source = this.isRowPinningToTop ? [...this.pinnedDataView, ...source] : [...source, ...this.pinnedDataView];
        return this.extractDataFromSelection(source, formatters, headers);
    }
    getEmptyRecordObjectFor(rec) {
        const row = Object.assign({}, rec);
        const data = rec || {};
        row.data = Object.assign({}, data);
        Object.keys(row.data).forEach(key => {
            // persist foreign key if one is set.
            if (this.foreignKey && key === this.foreignKey) {
                row.data[key] = rec.data[key];
            }
            else {
                row.data[key] = undefined;
            }
        });
        let id = this.generateRowID();
        const rootRecPK = this.foreignKey && this.rootRecords && this.rootRecords.length > 0 ?
            this.rootRecords[0].data[this.foreignKey] : null;
        if (id === rootRecPK) {
            // safeguard in case generated id matches the root foreign key.
            id = this.generateRowID();
        }
        row.rowID = id;
        row.data[this.primaryKey] = id;
        return row;
    }
    writeToData(rowIndex, value) {
        mergeObjects(this.flatData[rowIndex], value);
    }
    /**
     * @hidden
     */
    initColumns(collection, cb = null) {
        if (this.hasColumnLayouts) {
            // invalid configuration - tree grid should not allow column layouts
            // remove column layouts
            const nonColumnLayoutColumns = this.columnList.filter((col) => !col.columnLayout && !col.columnLayoutChild);
            this.columnList.reset(nonColumnLayoutColumns);
        }
        super.initColumns(collection, cb);
    }
    /**
     * @description A recursive way to deselect all selected children of a given record
     * @param recordID ID of the record whose children to deselect
     * @hidden
     * @internal
     */
    deselectChildren(recordID) {
        const selectedChildren = [];
        const rowToDeselect = this.getRowByKey(recordID).treeRow;
        this.selectionService.deselectRow(recordID);
        this._gridAPI.get_selected_children(rowToDeselect, selectedChildren);
        if (selectedChildren.length > 0) {
            selectedChildren.forEach(x => this.deselectChildren(x));
        }
    }
}
IgxTreeGridComponent.ɵfac = function IgxTreeGridComponent_Factory(t) { return ɵIgxTreeGridComponent_BaseFactory(t || IgxTreeGridComponent); };
IgxTreeGridComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTreeGridComponent, selectors: [["igx-tree-grid"]], contentQueries: function IgxTreeGridComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowLoadingIndicatorTemplateDirective, true, IgxRowLoadingIndicatorTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowLoadingTemplate = _t.first);
    } }, viewQuery: function IgxTreeGridComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c157, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c167, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c170, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragIndicatorIconBase = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.recordTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.summaryTemplate = _t.first);
    } }, hostVars: 1, hostBindings: function IgxTreeGridComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { cascadeOnDelete: "cascadeOnDelete", id: "id", data: "data", expansionDepth: "expansionDepth", rowLoadingIndicatorTemplate: "rowLoadingIndicatorTemplate", childDataKey: "childDataKey", foreignKey: "foreignKey", hasChildrenKey: "hasChildrenKey", loadChildrenOnDemand: "loadChildrenOnDemand" }, features: [ɵngcc0.ɵɵProvidersFeature([
            IgxGridSelectionService,
            IgxGridCRUDService,
            IgxGridSummaryService,
            IgxGridNavigationService,
            { provide: GridBaseAPIService, useClass: IgxTreeGridAPIService },
            { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxTreeGridComponent) },
            IgxFilteringService,
            IgxForOfSyncService,
            IgxForOfScrollSyncService
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c186, decls: 103, vars: 189, consts: [["role", "toolbar", 3, "max-width", "flex-basis", "gridID", "displayDensity", 4, "ngIf"], [1, "igx-grid__thead"], ["role", "rowgroup", "tabindex", "0", 1, "igx-grid__thead-wrapper", 3, "focus", "keydown"], ["theadRow", ""], ["role", "row", 1, "igx-grid__tr"], ["id", "left", "class", "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop", "left", 4, "ngIf"], ["id", "left", "class", "igx-grid__scroll-on-drag-pinned", 3, "igxColumnMovingDrop", "left", 4, "ngIf"], [4, "ngIf"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollOrientation", "igxForScrollContainer", "igxForContainerSize", "igxForTrackBy", "igxForSizePropName"], ["hContainer", ""], [3, "column", 4, "ngIf"], [1, "igx-grid__thead-thumb", 3, "hidden"], ["loadingOverlay", ""], [3, "indeterminate", 4, "ngIf"], ["id", "right", "class", "igx-grid__scroll-on-drag-right", 3, "igxColumnMovingDrop", 4, "ngIf"], ["igxGridBody", "", 1, "igx-grid__tbody", 3, "keydown.control.c", "copy"], ["tabindex", "0", "role", "rowgroup", 1, "igx-grid__tbody-content", 3, "igxGridDragSelect", "focus", "keydown", "onDragStop", "onDragScroll", "scroll"], ["tbody", ""], ["id", "left", "class", "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop", 4, "ngIf"], ["pinnedRecordsTemplate", ""], [4, "ngTemplateOutlet"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollOrientation", "igxForScrollContainer", "igxForContainerSize", "igxForItemSize"], ["verticalScrollContainer", ""], ["record_template", ""], ["pinned_record_template", ""], ["summary_template", ""], ["igxOverlayOutlet", "", 1, "igx-grid__row-editing-outlet"], ["igxRowEditingOverlayOutlet", ""], [1, "igx-grid__tbody-scrollbar", 3, "hidden", "pointerdown"], [1, "igx-grid__tbody-scrollbar-start"], [1, "igx-grid__tbody-scrollbar-main"], ["igxGridFor", "", 3, "igxGridForOf"], ["verticalScrollHolder", ""], [1, "igx-grid__tbody-scrollbar-end"], [1, "igx-grid__addrow-snackbar"], [3, "actionText", "displayTime"], ["addRowSnackbar", ""], ["role", "rowgroup", "tabindex", "0", 1, "igx-grid__tfoot", 3, "focus", "keydown"], ["tfoot", ""], ["role", "row", "class", "igx-grid__summaries", 3, "width", "height", "gridID", "summaries", "index", 4, "ngIf"], [1, "igx-grid__tfoot-thumb", 3, "hidden"], [1, "igx-grid__scroll", 3, "hidden", "pointerdown"], ["scr", ""], [1, "igx-grid__scroll-start"], [1, "igx-grid__scroll-main"], ["scrollContainer", ""], [1, "igx-grid__scroll-end", 3, "hidden"], [1, "igx-grid__footer"], ["footer", ""], ["defaultPaginator", ""], ["emptyFilteredGrid", ""], ["defaultEmptyGrid", ""], ["defaultAddRowEmptyTemplate", ""], ["defaultLoadingGrid", ""], ["igxToggle", "", 4, "ngIf"], ["defaultRowEditText", ""], ["defaultRowEditActions", ""], ["defaultRowEditTemplate", ""], ["dragIndicatorIconBase", ""], ["igxHeadSelector", ""], ["headSelectorBaseTemplate", ""], ["igxOverlayOutlet", "", 1, "igx-grid__loading-outlet"], ["igxLoadingOverlayOutlet", ""], ["igxOverlayOutlet", "", 1, "igx-grid__outlet", 3, "keydown"], ["igxFilteringOverlayOutlet", ""], ["role", "toolbar", 3, "gridID", "displayDensity"], ["toolbar", ""], ["id", "left", 1, "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop"], ["id", "left", 1, "igx-grid__scroll-on-drag-pinned", 3, "igxColumnMovingDrop"], [1, "igx-grid__drag-indicator", 3, "pointerdown"], ["headerDragContainer", ""], [2, "visibility", "hidden"], [1, "igx-grid__cbx-selection", 3, "ngClass", "click", "pointerdown"], ["headerSelectorContainer", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["headSelector", ""], ["ngFor", "", 3, "ngForOf"], [3, "column", "gridID"], [3, "column"], ["filteringRow", ""], [3, "indeterminate"], ["id", "right", 1, "igx-grid__scroll-on-drag-right", 3, "igxColumnMovingDrop"], ["class", "igx-grid__tr--pinned", 3, "ngClass", "width", 4, "ngIf"], [1, "igx-grid__tr--pinned", 3, "ngClass"], ["pinContainer", ""], [4, "ngFor", "ngForOf"], [3, "igxTemplateOutlet", "igxTemplateOutletContext", "onCachedViewLoaded"], [3, "gridID", "index", "treeRow", "disabled", "addRow"], ["row", ""], [3, "gridID", "index", "treeRow", "addRow"], ["row", "", "pinnedRow", ""], [1, "igx-grid__summaries--body", 3, "gridID", "summaries", "firstCellIndentation", "index"], ["summaryRow", ""], ["role", "row", 1, "igx-grid__summaries", 3, "gridID", "summaries", "index"], [3, "overlaySettings", "displayDensity", "page", "totalRecords", "perPage", "pageChange", "perPageChange"], [1, "igx-grid__tbody-message"], ["igxButton", "raised", "igxRipple", "", 3, "click"], [1, "igx-grid__loading"], ["igxToggle", ""], [3, "className"], ["igxButton", "", "igxRowEditTabStop", "", 3, "click"], ["class", "igx-banner__message", 4, "ngIf"], [1, "igx-banner__actions"], [1, "igx-banner__row"], [1, "igx-banner__message"], [1, "igx-banner__text"], ["fontSet", "material"], [1, "igx-grid__cbx-padding"], ["disableRipple", "true", 3, "tabindex", "checked", "ngStyle", "readonly", "indeterminate", "aria-label"], ["headerCheckbox", ""]], template: function IgxTreeGridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c182);
        ɵngcc0.ɵɵtemplate(0, IgxTreeGridComponent_igx_grid_toolbar_0_Template, 2, 6, "igx-grid-toolbar", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2, 3);
        ɵngcc0.ɵɵlistener("focus", function IgxTreeGridComponent_Template_div_focus_2_listener() { return ctx.navigation.focusFirstCell(); })("keydown", function IgxTreeGridComponent_Template_div_keydown_2_listener($event) { return ctx.navigation.headerNavigation($event); });
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵtemplate(5, IgxTreeGridComponent_span_5_Template, 1, 4, "span", 5);
        ɵngcc0.ɵɵtemplate(6, IgxTreeGridComponent_span_6_Template, 1, 4, "span", 6);
        ɵngcc0.ɵɵtemplate(7, IgxTreeGridComponent_ng_container_7_Template, 5, 1, "ng-container", 7);
        ɵngcc0.ɵɵtemplate(8, IgxTreeGridComponent_ng_container_8_Template, 4, 10, "ng-container", 7);
        ɵngcc0.ɵɵtemplate(9, IgxTreeGridComponent_ng_container_9_Template, 3, 3, "ng-container", 7);
        ɵngcc0.ɵɵtemplate(10, IgxTreeGridComponent_ng_template_10_Template, 1, 6, "ng-template", 8, 9, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(12, "igxTopLevel");
        ɵngcc0.ɵɵtemplate(13, IgxTreeGridComponent_ng_container_13_Template, 3, 3, "ng-container", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(14, IgxTreeGridComponent_igx_grid_filtering_row_14_Template, 2, 1, "igx-grid-filtering-row", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(15, "div", 11);
        ɵngcc0.ɵɵelementStart(16, "div", null, 12);
        ɵngcc0.ɵɵtemplate(18, IgxTreeGridComponent_igx_circular_bar_18_Template, 1, 1, "igx-circular-bar", 13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(19, IgxTreeGridComponent_span_19_Template, 1, 2, "span", 14);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(20, "div", 15);
        ɵngcc0.ɵɵlistener("keydown.control.c", function IgxTreeGridComponent_Template_div_keydown_control_c_20_listener($event) { return ctx.copyHandler($event); })("copy", function IgxTreeGridComponent_Template_div_copy_20_listener($event) { return ctx.copyHandler($event); });
        ɵngcc0.ɵɵelementStart(21, "div", 16, 17);
        ɵngcc0.ɵɵlistener("focus", function IgxTreeGridComponent_Template_div_focus_21_listener($event) { return ctx.navigation.focusTbody($event); })("keydown", function IgxTreeGridComponent_Template_div_keydown_21_listener($event) { return ctx.navigation.handleNavigation($event); })("onDragStop", function IgxTreeGridComponent_Template_div_onDragStop_21_listener($event) { return ctx.selectionService.dragMode = $event; })("onDragScroll", function IgxTreeGridComponent_Template_div_onDragScroll_21_listener($event) { return ctx.dragScroll($event); })("scroll", function IgxTreeGridComponent_Template_div_scroll_21_listener($event) { return ctx.preventContainerScroll($event); });
        ɵngcc0.ɵɵtemplate(23, IgxTreeGridComponent_span_23_Template, 1, 2, "span", 18);
        ɵngcc0.ɵɵtemplate(24, IgxTreeGridComponent_span_24_Template, 1, 4, "span", 6);
        ɵngcc0.ɵɵtemplate(25, IgxTreeGridComponent_ng_template_25_Template, 8, 50, "ng-template", null, 19, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(27, IgxTreeGridComponent_ng_container_27_Template, 1, 0, "ng-container", 20);
        ɵngcc0.ɵɵtemplate(28, IgxTreeGridComponent_ng_template_28_Template, 1, 2, "ng-template", 21, 22, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(30, "gridAddRow");
        ɵngcc0.ɵɵpipe(31, "gridRowPinning");
        ɵngcc0.ɵɵpipe(32, "treeGridSummary");
        ɵngcc0.ɵɵpipe(33, "treeGridPaging");
        ɵngcc0.ɵɵpipe(34, "treeGridFlattening");
        ɵngcc0.ɵɵpipe(35, "treeGridSorting");
        ɵngcc0.ɵɵpipe(36, "treeGridFiltering");
        ɵngcc0.ɵɵpipe(37, "treeGridHierarchizing");
        ɵngcc0.ɵɵpipe(38, "visibleColumns");
        ɵngcc0.ɵɵpipe(39, "treeGridTransaction");
        ɵngcc0.ɵɵtemplate(40, IgxTreeGridComponent_ng_container_40_Template, 1, 0, "ng-container", 20);
        ɵngcc0.ɵɵtemplate(41, IgxTreeGridComponent_ng_template_41_Template, 2, 5, "ng-template", null, 23, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(43, IgxTreeGridComponent_ng_template_43_Template, 3, 4, "ng-template", null, 24, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(45, IgxTreeGridComponent_ng_template_45_Template, 2, 4, "ng-template", null, 25, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(47, IgxTreeGridComponent_ng_container_47_Template, 1, 0, "ng-container", 20);
        ɵngcc0.ɵɵelement(48, "div", 26, 27);
        ɵngcc0.ɵɵelement(50, "igc-trial-watermark");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(51, IgxTreeGridComponent_span_51_Template, 1, 2, "span", 14);
        ɵngcc0.ɵɵelementStart(52, "div", 28);
        ɵngcc0.ɵɵlistener("pointerdown", function IgxTreeGridComponent_Template_div_pointerdown_52_listener($event) { return $event.preventDefault(); });
        ɵngcc0.ɵɵelement(53, "div", 29);
        ɵngcc0.ɵɵelementStart(54, "div", 30);
        ɵngcc0.ɵɵtemplate(55, IgxTreeGridComponent_ng_template_55_Template, 0, 0, "ng-template", 31, 32, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(57, "div", 33);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(58, "div", 34);
        ɵngcc0.ɵɵelementStart(59, "igx-snackbar", 35, 36);
        ɵngcc0.ɵɵtext(61);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(62, "div", 37, 38);
        ɵngcc0.ɵɵlistener("focus", function IgxTreeGridComponent_Template_div_focus_62_listener() { return ctx.navigation.focusFirstCell(false); })("keydown", function IgxTreeGridComponent_Template_div_keydown_62_listener($event) { return ctx.navigation.summaryNav($event); });
        ɵngcc0.ɵɵtemplate(64, IgxTreeGridComponent_igx_grid_summary_row_64_Template, 3, 10, "igx-grid-summary-row", 39);
        ɵngcc0.ɵɵelement(65, "div", 40);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(66, "div", 41, 42);
        ɵngcc0.ɵɵlistener("pointerdown", function IgxTreeGridComponent_Template_div_pointerdown_66_listener($event) { return $event.preventDefault(); });
        ɵngcc0.ɵɵelement(68, "div", 43);
        ɵngcc0.ɵɵelementStart(69, "div", 44);
        ɵngcc0.ɵɵtemplate(70, IgxTreeGridComponent_ng_template_70_Template, 0, 0, "ng-template", 31, 45, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(72, "div", 46);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(73, "div", 47, 48);
        ɵngcc0.ɵɵprojection(75);
        ɵngcc0.ɵɵtemplate(76, IgxTreeGridComponent_ng_container_76_Template, 2, 4, "ng-container", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(77, IgxTreeGridComponent_ng_template_77_Template, 1, 5, "ng-template", null, 49, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(79, IgxTreeGridComponent_ng_template_79_Template, 4, 2, "ng-template", null, 50, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(81, IgxTreeGridComponent_ng_template_81_Template, 4, 2, "ng-template", null, 51, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(83, IgxTreeGridComponent_ng_template_83_Template, 2, 1, "ng-template", null, 52, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(85, IgxTreeGridComponent_ng_template_85_Template, 2, 1, "ng-template", null, 53, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(87, IgxTreeGridComponent_div_87_Template, 3, 6, "div", 54);
        ɵngcc0.ɵɵtemplate(88, IgxTreeGridComponent_ng_template_88_Template, 1, 1, "ng-template", null, 55, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(90, IgxTreeGridComponent_ng_template_90_Template, 4, 0, "ng-template", null, 56, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(92, IgxTreeGridComponent_ng_template_92_Template, 4, 5, "ng-template", null, 57, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(94, IgxTreeGridComponent_ng_template_94_Template, 2, 0, "ng-template", null, 58, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(96, IgxTreeGridComponent_ng_template_96_Template, 3, 8, "ng-template", 59, 60, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(98, IgxTreeGridComponent_igx_grid_column_resizer_98_Template, 1, 0, "igx-grid-column-resizer", 7);
        ɵngcc0.ɵɵelement(99, "div", 61, 62);
        ɵngcc0.ɵɵelementStart(101, "div", 63, 64);
        ɵngcc0.ɵɵlistener("keydown", function IgxTreeGridComponent_Template_div_keydown_101_listener($event) { return ctx.gridOutletKeyboardHandler($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r17 = ɵngcc0.ɵɵreference(26);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToolbar);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length <= 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowDraggable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showRowSelectors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(12, 85, ctx.unpinnedColumns))("igxForScrollOrientation", "horizontal")("igxForScrollContainer", ctx.parentVirtDir)("igxForContainerSize", ctx.unpinnedWidth)("igxForTrackBy", ctx.trackColumnChanges)("igxForSizePropName", "calcPixelWidth");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && !ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.filteringService.isFilterRowVisible);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollSize, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldOverlayLoading);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", ctx.totalHeight, "px")("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵproperty("igxGridDragSelect", ctx.selectionService.dragMode);
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length <= 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length > 0);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasPinnedRecords && ctx.isRowPinningToTop ? _r17 : null);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind3(30, 87, ɵngcc0.ɵɵpipeBind4(31, 91, ɵngcc0.ɵɵpipeBindV(32, 96, ɵngcc0.ɵɵpureFunction8(178, _c184, ɵngcc0.ɵɵpipeBindV(33, 105, ɵngcc0.ɵɵpureFunction5(172, _c66, ɵngcc0.ɵɵpipeBindV(34, 111, ɵngcc0.ɵɵpureFunction5(166, _c66, ɵngcc0.ɵɵpipeBindV(35, 117, ɵngcc0.ɵɵpureFunction5(160, _c66, ɵngcc0.ɵɵpipeBindV(36, 123, ɵngcc0.ɵɵpureFunction7(152, _c183, ɵngcc0.ɵɵpipeBindV(37, 131, ɵngcc0.ɵɵpureFunction6(145, _c205, ɵngcc0.ɵɵpipeBind2(38, 138, ɵngcc0.ɵɵpipeBind3(39, 141, ctx.data, ctx.id, ctx.pipeTrigger), ctx.hasVisibleColumns), ctx.primaryKey, ctx.foreignKey, ctx.childDataKey, ctx.id, ctx.pipeTrigger)), ctx.filteringExpressionsTree, ctx.filterStrategy, ctx.advancedFilteringExpressionsTree, ctx.id, ctx.pipeTrigger, ctx.filteringPipeTrigger)), ctx.sortingExpressions, ctx.sortStrategy, ctx.id, ctx.pipeTrigger)), ctx.id, ctx.expansionDepth, ctx.expansionStates, ctx.pipeTrigger)), ctx.page, ctx.perPage, ctx.id, ctx.pipeTrigger)), ctx.hasSummarizedColumns, ctx.summaryCalculationMode, ctx.summaryPosition, ctx.showSummaryOnCollapse, ctx.id, ctx.pipeTrigger, ctx.summaryPipeTrigger)), ctx.id, false, ctx.pipeTrigger), false, ctx.pipeTrigger))("igxForScrollOrientation", "vertical")("igxForScrollContainer", ctx.verticalScroll)("igxForContainerSize", ctx.calcHeight)("igxForItemSize", ctx.renderedRowHeight);
        ɵngcc0.ɵɵadvance(12);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasPinnedRecords && !ctx.isRowPinningToTop ? _r17 : null);
        ɵngcc0.ɵɵadvance(7);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollSize, "px")("height", ctx.calcHeight, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.calcHeight, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpureFunction0(187, _c185));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", !ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, "px");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("actionText", ctx.snackbarActionText)("displayTime", ctx.snackbarDisplayTime);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.snackbarLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.summariesHeight, "px");
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasSummarizedColumns && ctx.rootSummariesEnabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.summariesHeight, "px")("width", ctx.scrollSize, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.scrollSize, "px");
        ɵngcc0.ɵɵproperty("hidden", ctx.isHorizontalScrollHidden);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, "px")("min-width", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.unpinnedWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpureFunction0(188, _c185));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("float", "right")("width", ctx.pinnedWidth, "px")("min-width", ctx.pinnedWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", ctx.pinnedWidth === 0 || ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.paging && ctx.totalRecords);
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowEditable);
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngIf", ctx.colResizingService.showResizer);
    } }, directives: function () { return [ɵngcc2.NgIf, IgxGridForOfDirective, IgxGridBodyDirective, IgxGridDragSelectDirective, ɵngcc2.NgTemplateOutlet, IgxOverlayOutletDirective, IgxSnackbarComponent, IgxHeadSelectorDirective, IgxGridToolbarComponent, IgxColumnMovingDropDirective, ɵngcc2.NgClass, ɵngcc2.NgForOf, IgxGridHeaderGroupComponent, IgxGridFilteringRowComponent, IgxCircularProgressBarComponent, IgxTemplateOutletDirective, IgxTreeGridRowComponent, IgxSummaryRowComponent, IgxPaginatorComponent, IgxButtonDirective, IgxRippleDirective, IgxToggleDirective, IgxRowEditTabStopDirective, IgxIconComponent, IgxCheckboxComponent, ɵngcc2.NgStyle, IgxGridColumnResizerComponent]; }, pipes: function () { return [IgxGridTopLevelColumns, IgxGridAddRowPipe, IgxGridRowPinningPipe, IgxTreeGridSummaryPipe, IgxTreeGridPagingPipe, IgxTreeGridFlatteningPipe, IgxTreeGridSortingPipe, IgxTreeGridFilteringPipe, IgxTreeGridHierarchizingPipe, IgxHasVisibleColumnsPipe, IgxTreeGridTransactionPipe, IgxTreeGridNormalizeRecordsPipe, IgxSummaryDataPipe]; }, encapsulation: 2, changeDetection: 0 });
IgxTreeGridComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    data: [{ type: Input }],
    childDataKey: [{ type: Input }],
    foreignKey: [{ type: Input }],
    hasChildrenKey: [{ type: Input }],
    cascadeOnDelete: [{ type: Input }],
    expansionDepth: [{ type: Input }],
    rowLoadingTemplate: [{ type: ContentChild, args: [IgxRowLoadingIndicatorTemplateDirective, { read: IgxRowLoadingIndicatorTemplateDirective },] }],
    rowLoadingIndicatorTemplate: [{ type: Input }],
    loadChildrenOnDemand: [{ type: Input }],
    dragIndicatorIconBase: [{ type: ViewChild, args: ['dragIndicatorIconBase', { read: TemplateRef, static: true },] }],
    recordTemplate: [{ type: ViewChild, args: ['record_template', { read: TemplateRef, static: true },] }],
    summaryTemplate: [{ type: ViewChild, args: ['summary_template', { read: TemplateRef, static: true },] }]
};

class IgxTreeGridRowComponent extends IgxRowDirective {
    /**
     * The `ITreeGridRecord` passed to the row component.
     *
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * const treeRow = row.treeRow;
     * ```
     */
    get treeRow() {
        return this._treeRow;
    }
    set treeRow(value) {
        if (this._treeRow !== value) {
            this._treeRow = value;
            this.rowData = this._treeRow.data;
        }
    }
    /**
     * Gets whether the row is pinned.
     * ```typescript
     * let isPinned = row.pinned;
     * ```
     */
    get pinned() {
        return this.grid.isRecordPinned(this._treeRow);
    }
    /**
     * @hidden
     */
    get isRoot() {
        let treeRec = this.treeRow;
        const isPinnedArea = this.pinned && !this.disabled;
        if (isPinnedArea) {
            treeRec = this.grid.unpinnedRecords.find(x => x.data === this.rowData);
        }
        return treeRec.level === 0;
    }
    /**
     * @hidden
     */
    get hasChildren() {
        return true;
    }
    /**
     * Sets whether the row is pinned.
     * Default value is `false`.
     * ```typescript
     * this.grid.selectedRows[0].pinned = true;
     * ```
     */
    set pinned(value) {
        if (value) {
            this.grid.pinRow(this.rowID);
        }
        else {
            this.grid.unpinRow(this.rowID);
        }
    }
    /**
     * Returns a value indicating whether the row component is expanded.
     *
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * const expanded = row.expanded;
     * ```
     */
    get expanded() {
        return this._treeRow.expanded;
    }
    /**
     * Sets a value indicating whether the row component is expanded.
     *
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * row.expanded = true;
     * ```
     */
    set expanded(value) {
        this.gridAPI.set_row_expansion_state(this._treeRow.rowID, value);
    }
    /**
     * @hidden
     * @internal
     */
    get viewIndex() {
        return this.index + this.grid.page * this.grid.perPage;
    }
    /**
     * @hidden
     */
    get showIndicator() {
        return this.grid.loadChildrenOnDemand ?
            this.grid.expansionStates.has(this.rowID) ?
                this.treeRow.children && this.treeRow.children.length :
                this.grid.hasChildrenKey ?
                    this.rowData[this.grid.hasChildrenKey] :
                    true :
            this.treeRow.children && this.treeRow.children.length;
    }
    /**
     * @hidden
     */
    resolveClasses() {
        const classes = super.resolveClasses();
        const filteredClass = this.treeRow.isFilteredOutParent ? 'igx-grid__tr--filtered' : '';
        return `${classes} ${filteredClass}`;
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        this.isLoading = this.grid.loadChildrenOnDemand ? this.grid.loadingRows.has(this.rowID) : false;
        super.ngDoCheck();
    }
    /**
     * Spawns the add child row UI for the specific row.
     * @example
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * row.beginAddChild();
     * ```
     * @param rowID
     */
    beginAddChild() {
        this.grid.beginAddRowByIndex(this.rowID, this.index, true);
    }
}
IgxTreeGridRowComponent.ɵfac = function IgxTreeGridRowComponent_Factory(t) { return ɵIgxTreeGridRowComponent_BaseFactory(t || IgxTreeGridRowComponent); };
IgxTreeGridRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTreeGridRowComponent, selectors: [["igx-tree-grid-row"]], viewQuery: function IgxTreeGridRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c208, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._cells = _t);
    } }, hostVars: 1, hostBindings: function IgxTreeGridRowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.expanded);
    } }, inputs: { treeRow: "treeRow" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxTreeGridRowComponent) }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 1, consts: [[4, "ngTemplateOutlet"], ["addTemp", ""], ["defaultTemp", ""], [1, "igx-grid__tr--inner", 3, "animationend"], [4, "ngIf"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollContainer", "igxForScrollOrientation", "igxForContainerSize", "igxForSizePropName", "igxForTrackBy"], ["igxDirRef", ""], ["rowSelectorBaseTemplate", ""], ["pinnedCellsTemplate", ""], [3, "igxRowDrag", "ghostTemplate", "click"], [1, "igx-grid__cbx-selection", 3, "click", "pointerdown"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["cellTemplate", ""], ["treeCellTemplate", ""], [1, "igx-grid__td", "igx-grid__td--fw", 3, "ngClass", "ngStyle", "editMode", "column", "formatter", "row", "rowData", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"], ["treeCell", ""], [1, "igx-grid__td", "igx-grid__td--fw", "igx-grid__td--tree-cell", 3, "ngClass", "ngStyle", "level", "expanded", "showIndicator", "editMode", "column", "formatter", "row", "rowData", "width", "visibleColumnIndex", "value", "isLoading", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"], [1, "igx-grid__cbx-padding"], ["disableRipple", "true", 3, "tabindex", "readonly", "checked", "disabled", "disableTransitions", "aria-label"], ["ngFor", "", 3, "ngForOf"], [1, "igx-grid__td", "igx-grid__td--fw", "igx-grid__td--pinned", 3, "ngClass", "ngStyle", "editMode", "column", "formatter", "row", "firstPinned", "lastPinned", "rowData", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"], [1, "igx-grid__td", "igx-grid__td--fw", "igx-grid__td--tree-cell", "igx-grid__td--pinned", 3, "ngClass", "ngStyle", "level", "expanded", "showIndicator", "editMode", "column", "formatter", "row", "lastPinned", "rowData", "width", "visibleColumnIndex", "value", "isLoading", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"]], template: function IgxTreeGridRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, IgxTreeGridRowComponent_ng_template_1_Template, 2, 3, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(3, IgxTreeGridRowComponent_ng_template_3_Template, 11, 12, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        const _r3 = ɵngcc0.ɵɵreference(4);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.addRow ? _r1 : _r3);
    } }, directives: function () { return [ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxGridForOfDirective, IgxRowDragDirective, IgxGridCellComponent, ɵngcc2.NgClass, ɵngcc2.NgStyle, IgxTreeGridCellComponent, IgxCheckboxComponent, ɵngcc2.NgForOf]; }, pipes: function () { return [IgxGridNotGroupedPipe, IgxGridTransactionStatePipe, IgxStringReplacePipe, IgxGridCellStyleClassesPipe, IgxGridCellStylesPipe, IgxGridDataMapperPipe]; }, encapsulation: 2, changeDetection: 0 });
IgxTreeGridRowComponent.propDecorators = {
    _cells: [{ type: ViewChildren, args: ['treeCell',] }],
    treeRow: [{ type: Input }],
    expanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }]
};

/**
 * @hidden
 */
class IgxTreeGridHierarchizingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, primaryKey, foreignKey, childDataKey, id, pipeTrigger) {
        const grid = this.gridAPI.grid;
        let hierarchicalRecords = [];
        const treeGridRecordsMap = new Map();
        const flatData = [];
        if (primaryKey && foreignKey) {
            hierarchicalRecords = this.hierarchizeFlatData(id, collection, primaryKey, foreignKey, treeGridRecordsMap, flatData);
        }
        else if (childDataKey) {
            hierarchicalRecords = this.hierarchizeRecursive(id, collection, primaryKey, childDataKey, undefined, flatData, 0, treeGridRecordsMap);
        }
        grid.flatData = grid.transactions.enabled ?
            flatData.filter(rec => !grid.transactions.getState(this.getRowID(primaryKey, rec))) : flatData;
        grid.records = treeGridRecordsMap;
        grid.rootRecords = hierarchicalRecords;
        return hierarchicalRecords;
    }
    getRowID(primaryKey, rowData) {
        return primaryKey ? rowData[primaryKey] : rowData;
    }
    hierarchizeFlatData(id, collection, primaryKey, foreignKey, map, flatData) {
        const result = [];
        const missingParentRecords = [];
        collection.forEach(row => {
            const record = {
                rowID: this.getRowID(primaryKey, row),
                data: row,
                children: []
            };
            const parent = map.get(row[foreignKey]);
            if (parent) {
                record.parent = parent;
                parent.children.push(record);
            }
            else {
                missingParentRecords.push(record);
            }
            map.set(row[primaryKey], record);
        });
        missingParentRecords.forEach(record => {
            const parent = map.get(record.data[foreignKey]);
            if (parent) {
                record.parent = parent;
                parent.children.push(record);
            }
            else {
                result.push(record);
            }
        });
        this.setIndentationLevels(id, result, 0, flatData);
        return result;
    }
    setIndentationLevels(id, collection, indentationLevel, flatData) {
        for (let i = 0; i < collection.length; i++) {
            const record = collection[i];
            record.level = indentationLevel;
            record.expanded = this.gridAPI.get_row_expansion_state(record);
            flatData.push(record.data);
            if (record.children && record.children.length > 0) {
                this.setIndentationLevels(id, record.children, indentationLevel + 1, flatData);
            }
        }
    }
    hierarchizeRecursive(id, collection, primaryKey, childDataKey, parent, flatData, indentationLevel, map) {
        const result = [];
        for (let i = 0; i < collection.length; i++) {
            const item = collection[i];
            const record = {
                rowID: this.getRowID(primaryKey, item),
                data: item,
                parent: parent,
                level: indentationLevel
            };
            record.expanded = this.gridAPI.get_row_expansion_state(record);
            flatData.push(item);
            map.set(record.rowID, record);
            record.children = item[childDataKey] ?
                this.hierarchizeRecursive(id, item[childDataKey], primaryKey, childDataKey, record, flatData, indentationLevel + 1, map) :
                undefined;
            result.push(record);
        }
        return result;
    }
}
IgxTreeGridHierarchizingPipe.ɵfac = function IgxTreeGridHierarchizingPipe_Factory(t) { return new (t || IgxTreeGridHierarchizingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridHierarchizingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridHierarchizing", type: IgxTreeGridHierarchizingPipe, pure: true });
IgxTreeGridHierarchizingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxTreeGridFlatteningPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, id, expandedLevels, expandedStates, pipeTrigger) {
        const grid = this.gridAPI.grid;
        const data = [];
        grid.processedRootRecords = collection;
        grid.processedRecords = new Map();
        this.getFlatDataRecursive(collection, data, expandedLevels, expandedStates, id, true);
        grid.processedExpandedFlatData = data.map(r => r.data);
        return data;
    }
    getFlatDataRecursive(collection, data, expandedLevels, expandedStates, gridID, parentExpanded) {
        if (!collection || !collection.length) {
            return;
        }
        const grid = this.gridAPI.grid;
        for (let i = 0; i < collection.length; i++) {
            const hierarchicalRecord = collection[i];
            if (parentExpanded) {
                data.push(hierarchicalRecord);
            }
            hierarchicalRecord.expanded = this.gridAPI.get_row_expansion_state(hierarchicalRecord);
            this.updateNonProcessedRecordExpansion(grid, hierarchicalRecord);
            grid.processedRecords.set(hierarchicalRecord.rowID, hierarchicalRecord);
            this.getFlatDataRecursive(hierarchicalRecord.children, data, expandedLevels, expandedStates, gridID, parentExpanded && hierarchicalRecord.expanded);
        }
    }
    updateNonProcessedRecordExpansion(grid, record) {
        const rec = grid.records.get(record.rowID);
        rec.expanded = record.expanded;
    }
}
IgxTreeGridFlatteningPipe.ɵfac = function IgxTreeGridFlatteningPipe_Factory(t) { return new (t || IgxTreeGridFlatteningPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridFlatteningPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridFlattening", type: IgxTreeGridFlatteningPipe, pure: true });
IgxTreeGridFlatteningPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/** @hidden */
class IgxTreeGridSortingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(hierarchicalData, expressions, sorting, id, pipeTrigger, pinned) {
        const grid = this.gridAPI.grid;
        let result;
        if (!expressions.length) {
            result = hierarchicalData;
        }
        else {
            result = DataUtil.treeGridSort(hierarchicalData, expressions, sorting, null, grid);
        }
        const filteredSortedData = [];
        this.flattenTreeGridRecords(result, filteredSortedData);
        grid.setFilteredSortedData(filteredSortedData, pinned);
        return result;
    }
    flattenTreeGridRecords(records, flatData) {
        if (records && records.length) {
            for (const record of records) {
                flatData.push(record.data);
                this.flattenTreeGridRecords(record.children, flatData);
            }
        }
    }
}
IgxTreeGridSortingPipe.ɵfac = function IgxTreeGridSortingPipe_Factory(t) { return new (t || IgxTreeGridSortingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridSortingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridSorting", type: IgxTreeGridSortingPipe, pure: true });
IgxTreeGridSortingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/** @hidden */
class IgxTreeGridPagingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, page = 0, perPage = 15, id, pipeTrigger) {
        const grid = this.gridAPI.grid;
        if (!grid.paging || grid.pagingMode !== GridPagingMode.local) {
            return collection;
        }
        const len = grid._totalRecords >= 0 ? grid._totalRecords : collection.length;
        const totalPages = Math.ceil(len / perPage);
        const state = {
            index: (totalPages > 0 && page >= totalPages) ? totalPages - 1 : page,
            recordsPerPage: perPage
        };
        const result = DataUtil.page(cloneArray(collection), state, len);
        grid.pagingState = state;
        grid._page = state.index;
        return result;
    }
}
IgxTreeGridPagingPipe.ɵfac = function IgxTreeGridPagingPipe_Factory(t) { return new (t || IgxTreeGridPagingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridPagingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridPaging", type: IgxTreeGridPagingPipe, pure: true });
IgxTreeGridPagingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/** @hidden */
class IgxTreeGridTransactionPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, id, pipeTrigger) {
        const grid = this.gridAPI.grid;
        if (grid.transactions.enabled) {
            const aggregatedChanges = grid.transactions.getAggregatedChanges(true);
            if (aggregatedChanges.length > 0) {
                const primaryKey = grid.primaryKey;
                if (!primaryKey) {
                    return collection;
                }
                const foreignKey = grid.foreignKey;
                const childDataKey = grid.childDataKey;
                if (foreignKey) {
                    const flatDataClone = cloneArray(collection);
                    return DataUtil.mergeTransactions(flatDataClone, aggregatedChanges, grid.primaryKey);
                }
                else if (childDataKey) {
                    const hierarchicalDataClone = cloneHierarchicalArray(collection, childDataKey);
                    return DataUtil.mergeHierarchicalTransactions(hierarchicalDataClone, aggregatedChanges, childDataKey, grid.primaryKey);
                }
            }
        }
        return collection;
    }
}
IgxTreeGridTransactionPipe.ɵfac = function IgxTreeGridTransactionPipe_Factory(t) { return new (t || IgxTreeGridTransactionPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridTransactionPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridTransaction", type: IgxTreeGridTransactionPipe, pure: true });
IgxTreeGridTransactionPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * This pipe maps the original record to ITreeGridRecord format used in TreeGrid.
 */
class IgxTreeGridNormalizeRecordsPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, pipeTrigger) {
        const grid = this.gridAPI.grid;
        const primaryKey = grid.primaryKey;
        // using flattened data because origin data may be hierarchical.
        const flatData = grid.flatData;
        const res = flatData.map(rec => ({
            rowID: grid.primaryKey ? rec[primaryKey] : rec,
            data: rec,
            level: 0,
            children: []
        }));
        return res;
    }
}
IgxTreeGridNormalizeRecordsPipe.ɵfac = function IgxTreeGridNormalizeRecordsPipe_Factory(t) { return new (t || IgxTreeGridNormalizeRecordsPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridNormalizeRecordsPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridNormalizeRecord", type: IgxTreeGridNormalizeRecordsPipe, pure: true });
IgxTreeGridNormalizeRecordsPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

class IgxTreeGridCellComponent extends IgxGridExpandableCellComponent {
    constructor() {
        super(...arguments);
        /**
         * @hidden
         */
        this.level = 0;
        /**
         * @hidden
         */
        this.showIndicator = false;
    }
    get treeGridAPI() {
        return this.gridAPI;
    }
    /**
     * @hidden
     */
    toggle(event) {
        event.stopPropagation();
        this.treeGridAPI.set_row_expansion_state(this.row.rowID, !this.row.expanded, event);
    }
    /**
     * @hidden
     */
    onLoadingDblClick(event) {
        event.stopPropagation();
    }
}
IgxTreeGridCellComponent.ɵfac = function IgxTreeGridCellComponent_Factory(t) { return ɵIgxTreeGridCellComponent_BaseFactory(t || IgxTreeGridCellComponent); };
IgxTreeGridCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTreeGridCellComponent, selectors: [["igx-tree-grid-cell"]], inputs: { level: "level", showIndicator: "showIndicator", isLoading: "isLoading" }, features: [ɵngcc0.ɵɵProvidersFeature([HammerGesturesManager]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 14, vars: 3, consts: [["defaultPinnedIndicator", ""], ["defaultCell", ""], ["addRowCell", ""], ["inlineEditor", ""], [4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["defaultExpandedTemplate", ""], ["defaultCollapsedTemplate", ""], ["class", "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity", 4, "ngIf"], [1, "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity"], ["igxTextHighlight", "", "class", "igx-grid__td-text", "style", "pointer-events: none;", 3, "cssClass", "activeCssClass", "groupName", "value", "row", "column", "containerClass", "metadata", 4, "ngIf"], [3, "ngClass", 4, "ngIf"], ["igxTextHighlight", "", 1, "igx-grid__td-text", 2, "pointer-events", "none", 3, "cssClass", "activeCssClass", "groupName", "value", "row", "column", "containerClass", "metadata"], [3, "ngClass"], ["displayDensity", "compact"], ["igxInput", "", 3, "ngModel", "igxFocus", "ngModelChange"], ["igxInput", "", "type", "number", 3, "ngModel", "igxFocus", "ngModelChange"], [3, "value", "checked", "disableRipple", "change"], ["mode", "dropdown", 3, "outlet", "locale", "value", "igxFocus", "labelVisibility", "valueChange"], ["class", "igx-grid__tree-grouping-indicator", 3, "ngStyle", "click", "focus", 4, "ngIf"], ["class", "igx-grid__tree-loading-indicator", 3, "dblclick", 4, "ngIf"], ["defaultLoadingIndicatorTemplate", ""], ["indentationDiv", ""], [1, "igx-grid__tree-grouping-indicator", 3, "ngStyle", "click", "focus"], ["indicator", ""], [1, "igx-grid__tree-loading-indicator", 3, "dblclick"], [4, "ngTemplateOutlet"], [3, "indeterminate"], ["fontSet", "material"]], template: function IgxTreeGridCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxTreeGridCellComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxTreeGridCellComponent_ng_template_2_Template, 2, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxTreeGridCellComponent_ng_template_4_Template, 5, 21, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxTreeGridCellComponent_ng_template_6_Template, 4, 4, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, IgxTreeGridCellComponent_ng_container_8_Template, 6, 3, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(9, IgxTreeGridCellComponent_ng_container_9_Template, 1, 0, "ng-container", 5);
        ɵngcc0.ɵɵtemplate(10, IgxTreeGridCellComponent_ng_template_10_Template, 2, 0, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(12, IgxTreeGridCellComponent_ng_template_12_Template, 2, 0, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(8);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.editMode);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, IgxChipComponent, IgxTextHighlightDirective, IgxIconComponent, ɵngcc2.NgClass, IgxInputGroupComponent, ɵngcc3.DefaultValueAccessor, IgxInputDirective, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxFocusDirective, ɵngcc3.NumberValueAccessor, IgxCheckboxComponent, IgxDatePickerComponent, ɵngcc2.NgStyle, IgxCircularProgressBarComponent], pipes: [IgxColumnFormatterPipe, ɵngcc2.DecimalPipe, ɵngcc2.DatePipe], encapsulation: 2, changeDetection: 0 });
IgxTreeGridCellComponent.propDecorators = {
    level: [{ type: Input }],
    showIndicator: [{ type: Input }],
    isLoading: [{ type: Input }]
};

/** @hidden */
class IgxTreeGridSummaryPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(flatData, hasSummary, summaryCalculationMode, summaryPosition, showSummaryOnCollapse, id, pipeTrigger, summaryPipeTrigger) {
        const grid = this.gridAPI.grid;
        if (!flatData || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
            return flatData;
        }
        return this.addSummaryRows(grid, flatData, summaryPosition, showSummaryOnCollapse);
    }
    addSummaryRows(grid, collection, summaryPosition, showSummaryOnCollapse) {
        const recordsWithSummary = [];
        const maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
        for (let i = 0; i < collection.length; i++) {
            const record = collection[i];
            recordsWithSummary.push(record);
            const isCollapsed = !record.expanded && record.children && record.children.length > 0 && showSummaryOnCollapse;
            if (isCollapsed) {
                let childData = record.children.filter(r => !r.isFilteredOutParent).map(r => r.data);
                childData = this.removeDeletedRecord(grid, record.rowID, childData);
                const summaries = grid.summaryService.calculateSummaries(record.rowID, childData);
                const summaryRecord = {
                    summaries: summaries,
                    max: maxSummaryHeight,
                    cellIndentation: record.level + 1
                };
                recordsWithSummary.push(summaryRecord);
            }
            const isExpanded = record.children && record.children.length > 0 && record.expanded;
            if (summaryPosition === GridSummaryPosition.bottom && !isExpanded) {
                let childRecord = record;
                let parent = record.parent;
                while (parent) {
                    const children = parent.children;
                    if (children[children.length - 1] === childRecord) {
                        let childData = children.filter(r => !r.isFilteredOutParent).map(r => r.data);
                        childData = this.removeDeletedRecord(grid, parent.rowID, childData);
                        const summaries = grid.summaryService.calculateSummaries(parent.rowID, childData);
                        const summaryRecord = {
                            summaries: summaries,
                            max: maxSummaryHeight,
                            cellIndentation: parent.level + 1
                        };
                        recordsWithSummary.push(summaryRecord);
                        childRecord = parent;
                        parent = childRecord.parent;
                    }
                    else {
                        break;
                    }
                }
            }
            else if (summaryPosition === GridSummaryPosition.top && isExpanded) {
                let childData = record.children.filter(r => !r.isFilteredOutParent).map(r => r.data);
                childData = this.removeDeletedRecord(grid, record.rowID, childData);
                const summaries = grid.summaryService.calculateSummaries(record.rowID, childData);
                const summaryRecord = {
                    summaries: summaries,
                    max: maxSummaryHeight,
                    cellIndentation: record.level + 1
                };
                recordsWithSummary.push(summaryRecord);
            }
        }
        return recordsWithSummary;
    }
    removeDeletedRecord(grid, rowId, data) {
        if (!grid.transactions.enabled || !grid.cascadeOnDelete) {
            return data;
        }
        const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === 'delete').map(t => t.id);
        let row = grid.records.get(rowId);
        if (!row && deletedRows.lenght === 0) {
            return [];
        }
        row = row.children ? row : row.parent;
        while (row) {
            rowId = row.rowID;
            if (deletedRows.indexOf(rowId) !== -1) {
                return [];
            }
            row = row.parent;
        }
        deletedRows.forEach(rowID => {
            const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
            const index = tempData.indexOf(rowID);
            if (index !== -1) {
                data.splice(index, 1);
            }
        });
        return data;
    }
}
IgxTreeGridSummaryPipe.ɵfac = function IgxTreeGridSummaryPipe_Factory(t) { return new (t || IgxTreeGridSummaryPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridSummaryPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridSummary", type: IgxTreeGridSummaryPipe, pure: true });
IgxTreeGridSummaryPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/**
 * @hidden
 */
class IgxTreeGridModule {
}
IgxTreeGridModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTreeGridModule });
IgxTreeGridModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTreeGridModule_Factory(t) { return new (t || IgxTreeGridModule)(); }, imports: [[
            IgxGridCommonModule,
        ], IgxGridCommonModule] });

class IgxChildGridRowComponent {
    constructor(gridAPI, element, resolver, cdr) {
        this.gridAPI = gridAPI;
        this.element = element;
        this.cdr = cdr;
        /**
         * Returns whether the row is expanded.
         * ```typescript
         * const RowExpanded = this.grid1.rowList.first.expanded;
         * ```
         */
        this.expanded = false;
        /**
         *  The data passed to the row component.
         *
         * ```typescript
         * // get the row data for the first selected row
         * let selectedRowData = this.grid.selectedRows[0].rowData;
         * ```
         */
        this.rowData = [];
        /**
         * @hidden
         */
        this.role = 'row';
        this.resolver = resolver;
    }
    /**
     * @hidden
     */
    get parentHasScroll() {
        return !this.parentGrid.verticalScrollContainer.dc.instance.notVirtual;
    }
    /**
     * Get a reference to the grid that contains the selected row.
     *
     * ```typescript
     * handleRowSelection(event) {
     *  // the grid on which the onRowSelectionChange event was triggered
     *  const grid = event.row.grid;
     * }
     * ```
     *
     * ```html
     *  <igx-grid
     *    [data]="data"
     *    (onRowSelectionChange)="handleRowSelection($event)">
     *  </igx-grid>
     * ```
     */
    // TODO: Refactor
    get parentGrid() {
        return this.gridAPI.grid;
    }
    get level() {
        return this.layout.level;
    }
    /**
     * The native DOM element representing the row. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second selected row
     * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.layout.onLayoutChange.subscribe((ch) => {
            this._handleLayoutChanges(ch);
        });
        const changes = this.layout.initialChanges;
        changes.forEach(change => {
            this._handleLayoutChanges(change);
        });
        this.hGrid.parent = this.parentGrid;
        this.hGrid.parentIsland = this.layout;
        this.hGrid.childRow = this;
        // handler logic that re-emits hgrid events on the row island
        this.setupEventEmitters();
        this.layout.onGridCreated.emit({
            owner: this.layout,
            parentID: this.rowData.rowID,
            grid: this.hGrid
        });
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.hGrid.childLayoutList = this.layout.children;
        const layouts = this.hGrid.childLayoutList.toArray();
        layouts.forEach((l) => this.hGrid.hgridAPI.registerChildRowIsland(l));
        this.parentGrid.hgridAPI.registerChildGrid(this.rowData.rowID, this.layout.key, this.hGrid);
        this.layout.rowIslandAPI.registerChildGrid(this.rowData.rowID, this.hGrid);
        this.layout.onGridInitialized.emit({
            owner: this.layout,
            parentID: this.rowData.rowID,
            grid: this.hGrid
        });
        this.hGrid.cdr.detectChanges();
    }
    setupEventEmitters() {
        const destructor = takeUntil(this.hGrid.destroy$);
        const factory = this.resolver.resolveComponentFactory(IgxGridComponent);
        // exclude outputs related to two-way binding functionality
        const inputNames = factory.inputs.map(input => input.propName);
        const outputs = factory.outputs.filter(o => {
            const matchingInputPropName = o.propName.slice(0, o.propName.indexOf('Change'));
            return inputNames.indexOf(matchingInputPropName) === -1;
        });
        outputs.forEach(output => {
            if (this.hGrid[output.propName]) {
                this.hGrid[output.propName].pipe(destructor).subscribe((args) => {
                    if (!args) {
                        args = {};
                    }
                    args.owner = this.hGrid;
                    this.layout[output.propName].emit(args);
                });
            }
        });
    }
    _handleLayoutChanges(changes) {
        for (const change in changes) {
            if (changes.hasOwnProperty(change)) {
                this.hGrid[change] = changes[change].currentValue;
            }
        }
    }
}
IgxChildGridRowComponent.ɵfac = function IgxChildGridRowComponent_Factory(t) { return new (t || IgxChildGridRowComponent)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxChildGridRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxChildGridRowComponent, selectors: [["igx-child-grid-row"]], viewQuery: function IgxChildGridRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c210, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hGrid = _t.first);
    } }, hostVars: 2, hostBindings: function IgxChildGridRowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("data-level", ctx.level);
    } }, inputs: { rowData: "rowData", layout: "layout", parentGridID: "parentGridID", index: "index" }, decls: 3, vars: 4, consts: [[1, "igx-grid__hierarchical-indent", 3, "ngClass"], [3, "data"], ["hgrid", ""]], template: function IgxChildGridRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelement(1, "igx-hierarchical-grid", 1, 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c211, ctx.parentHasScroll));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("data", ctx.rowData.childGridsData[ctx.layout.key]);
    } }, directives: function () { return [ɵngcc2.NgClass, IgxHierarchicalGridComponent]; }, encapsulation: 2, changeDetection: 0 });
IgxChildGridRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ElementRef },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef }
];
IgxChildGridRowComponent.propDecorators = {
    layout: [{ type: Input }],
    parentGridID: [{ type: Input }],
    rowData: [{ type: Input }],
    index: [{ type: Input }],
    hGrid: [{ type: ViewChild, args: ['hgrid', { static: true },] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    level: [{ type: HostBinding, args: ['attr.data-level',] }]
};

class IgxHierarchicalGridNavigationService extends IgxGridNavigationService {
    constructor() {
        super(...arguments);
        this._pendingNavigation = false;
    }
    dispatchEvent(event) {
        const key = event.key.toLowerCase();
        if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) &&
            !this.grid.crudService.rowEditingBlocked && !this.grid.rowInEditMode) {
            return;
        }
        const targetGrid = this.getClosestElemByTag(event.target, 'igx-hierarchical-grid');
        if (targetGrid !== this.grid.nativeElement) {
            return;
        }
        if (this._pendingNavigation && NAVIGATION_KEYS.has(key)) {
            // In case focus needs to be moved from one grid to another, however there is a pending scroll operation
            // which is an async operation, any additional navigation keys should be ignored
            // untill operation complete.
            event.preventDefault();
            return;
        }
        super.dispatchEvent(event);
    }
    navigateInBody(rowIndex, visibleColIndex, cb = null) {
        const rec = this.grid.dataView[rowIndex];
        if (rec && this.grid.isChildGridRecord(rec)) {
            // target is child grid
            const virtState = this.grid.verticalScrollContainer.state;
            const inView = rowIndex >= virtState.startIndex && rowIndex <= virtState.startIndex + virtState.chunkSize;
            const isNext = this.activeNode.row < rowIndex;
            const targetLayoutIndex = isNext ? null : this.grid.childLayoutKeys.length - 1;
            if (inView) {
                this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            }
            else {
                let scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(rowIndex, !isNext);
                scrollAmount += isNext ? 1 : -1;
                this.grid.verticalScrollContainer.getScroll().scrollTop = scrollAmount;
                this._pendingNavigation = true;
                this.grid.verticalScrollContainer.onChunkLoad.pipe(first$1()).subscribe(() => {
                    this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
                    this._pendingNavigation = false;
                });
            }
            return;
        }
        const isLast = rowIndex === this.grid.dataView.length;
        if ((rowIndex === -1 || isLast) &&
            this.grid.parent !== null) {
            // reached end of child grid
            const nextSiblingIndex = this.nextSiblingIndex(isLast);
            if (nextSiblingIndex !== null) {
                this.grid.parent.navigation._moveToChild(this.grid.childRow.index, visibleColIndex, isLast, nextSiblingIndex, cb);
            }
            else {
                this._moveToParent(isLast, visibleColIndex, cb);
            }
            return;
        }
        if (this.grid.parent) {
            const isNext = this.activeNode && typeof this.activeNode.row === 'number' ? rowIndex > this.activeNode.row : false;
            const cbHandler = (args) => {
                this._handleScrollInChild(rowIndex, isNext);
                cb(args);
            };
            if (!this.activeNode) {
                this.activeNode = { row: null, column: null };
            }
            super.navigateInBody(rowIndex, visibleColIndex, cbHandler);
            return;
        }
        if (!this.activeNode) {
            this.activeNode = { row: null, column: null };
        }
        super.navigateInBody(rowIndex, visibleColIndex, cb);
    }
    shouldPerformVerticalScroll(index, visibleColumnIndex = -1, isNext) {
        const targetRec = this.grid.dataView[index];
        if (this.grid.isChildGridRecord(targetRec)) {
            const scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(index, !isNext);
            const currScroll = this.grid.verticalScrollContainer.getScroll().scrollTop;
            const shouldScroll = !isNext ? scrollAmount > currScroll : currScroll < scrollAmount;
            return shouldScroll;
        }
        else {
            return super.shouldPerformVerticalScroll(index, visibleColumnIndex);
        }
    }
    focusTbody(event) {
        if (!this.activeNode || this.activeNode.row === null) {
            this.activeNode = {
                row: 0,
                column: 0
            };
            this.grid.navigateTo(0, 0, (obj) => {
                this.grid.clearCellSelection();
                obj.target.activate(event);
            });
        }
        else {
            super.focusTbody(event);
        }
    }
    nextSiblingIndex(isNext) {
        const layoutKey = this.grid.childRow.layout.key;
        const layoutIndex = this.grid.parent.childLayoutKeys.indexOf(layoutKey);
        const nextIndex = isNext ? layoutIndex + 1 : layoutIndex - 1;
        if (nextIndex <= this.grid.parent.childLayoutKeys.length - 1 && nextIndex > -1) {
            return nextIndex;
        }
        else {
            return null;
        }
    }
    /**
     * Handles scrolling in child grid and ensures target child row is in main grid view port.
     * @param rowIndex The row index which should be in view.
     * @param isNext  Optional. Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    _handleScrollInChild(rowIndex, isNext, cb) {
        const shouldScroll = this.shouldPerformVerticalScroll(rowIndex, -1, isNext);
        if (shouldScroll) {
            this.grid.navigation.performVerticalScrollToCell(rowIndex, -1, () => {
                this.positionInParent(rowIndex, isNext, cb);
            });
        }
        else {
            this.positionInParent(rowIndex, isNext, cb);
        }
    }
    /**
     *
     * @param rowIndex Row index that should come in view.
     * @param isNext  Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    positionInParent(rowIndex, isNext, cb) {
        const rowObj = this.grid.getRowByIndex(rowIndex);
        if (!rowObj) {
            if (cb) {
                cb();
            }
            return;
        }
        const positionInfo = this.getPositionInfo(rowObj, isNext);
        if (!positionInfo.inView) {
            // stop event from triggering multiple times before scrolling is complete.
            this._pendingNavigation = true;
            const scrollableGrid = isNext ? this.getNextScrollableDown(this.grid) : this.getNextScrollableUp(this.grid);
            scrollableGrid.grid.verticalScrollContainer.recalcUpdateSizes();
            scrollableGrid.grid.verticalScrollContainer.addScrollTop(positionInfo.offset);
            scrollableGrid.grid.verticalScrollContainer.onChunkLoad.pipe(first$1()).subscribe(() => {
                this._pendingNavigation = false;
                if (cb) {
                    cb();
                }
            });
        }
        else {
            if (cb) {
                cb();
            }
        }
    }
    /**
     * Moves navigation to child grid.
     * @param parentRowIndex The parent row index, at which the child grid is rendered.
     * @param childLayoutIndex Optional. The index of the child row island to which the child grid belongs to. Uses first if not set.
     */
    _moveToChild(parentRowIndex, visibleColIndex, isNext, childLayoutIndex, cb) {
        const ri = typeof childLayoutIndex !== 'number' ?
            this.grid.childLayoutList.first : this.grid.childLayoutList.toArray()[childLayoutIndex];
        const rowId = this.grid.dataView[parentRowIndex].rowID;
        const pathSegment = {
            rowID: rowId,
            rowIslandKey: ri.key
        };
        const childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
        const targetIndex = isNext ? 0 : childGrid.dataView.length - 1;
        const targetRec = childGrid.dataView[targetIndex];
        if (!targetRec) {
            // if no target rec, then move on in next sibling or parent
            childGrid.navigation.navigateInBody(targetIndex, visibleColIndex, cb);
            return;
        }
        if (childGrid.isChildGridRecord(targetRec)) {
            // if target is a child grid record should move into it.
            this.grid.navigation.activeNode.row = null;
            childGrid.navigation.activeNode = { row: targetIndex, column: this.activeNode.column };
            childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
                const targetLayoutIndex = isNext ? 0 : childGrid.childLayoutList.toArray().length - 1;
                childGrid.navigation._moveToChild(targetIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            });
            return;
        }
        const childGridNav = childGrid.navigation;
        this.clearActivation();
        const lastVisibleIndex = childGridNav.lastColumnIndex;
        const columnIndex = visibleColIndex <= lastVisibleIndex ? visibleColIndex : lastVisibleIndex;
        childGridNav.activeNode = { row: targetIndex, column: columnIndex };
        childGrid.tbody.nativeElement.focus({ preventScroll: true });
        this._pendingNavigation = false;
        childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
            childGrid.navigateTo(targetIndex, columnIndex, cb);
        });
    }
    /**
     * Moves navigation back to parent grid.
     * @param rowIndex
     */
    _moveToParent(isNext, columnIndex, cb) {
        const indexInParent = this.grid.childRow.index;
        const hasNextTarget = this.hasNextTarget(this.grid.parent, indexInParent, isNext);
        if (!hasNextTarget) {
            return;
        }
        this.clearActivation();
        const targetRowIndex = isNext ? indexInParent + 1 : indexInParent - 1;
        const lastVisibleIndex = this.grid.parent.navigation.lastColumnIndex;
        const nextColumnIndex = columnIndex <= lastVisibleIndex ? columnIndex : lastVisibleIndex;
        this._pendingNavigation = true;
        const cbFunc = (args) => {
            this._pendingNavigation = false;
            cb(args);
            args.target.grid.tbody.nativeElement.focus();
        };
        this.grid.parent.navigation.navigateInBody(targetRowIndex, nextColumnIndex, cbFunc);
    }
    /**
     * Gets information on the row position relative to the root grid view port.
     * Returns whether the row is in view and its offset.
     * @param rowObj
     * @param isNext
     */
    getPositionInfo(rowObj, isNext) {
        let rowElem = rowObj.nativeElement;
        if (rowObj instanceof IgxChildGridRowComponent) {
            const childLayoutKeys = this.grid.childLayoutKeys;
            const riKey = isNext ? childLayoutKeys[0] : childLayoutKeys[childLayoutKeys.length - 1];
            const pathSegment = {
                rowID: rowObj.rowData.rowID,
                rowIslandKey: riKey
            };
            const childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
            rowElem = childGrid.tfoot.nativeElement;
        }
        const gridBottom = this._getMinBottom(this.grid);
        const diffBottom = rowElem.getBoundingClientRect().bottom - gridBottom;
        const gridTop = this._getMaxTop(this.grid);
        const diffTop = rowElem.getBoundingClientRect().bottom -
            rowElem.offsetHeight - gridTop;
        const isInView = isNext ? diffBottom <= 0 : diffTop >= 0;
        const calcOffset = isNext ? diffBottom : diffTop;
        return { inView: isInView, offset: calcOffset };
    }
    clearActivation() {
        // clear if previous activation exists.
        if (this.activeNode) {
            this.activeNode.row = null;
        }
    }
    hasNextTarget(grid, index, isNext) {
        const targetRowIndex = isNext ? index + 1 : index - 1;
        const hasTargetRecord = !!grid.dataView[targetRowIndex];
        if (hasTargetRecord) {
            return true;
        }
        else {
            let hasTargetRecordInParent = false;
            if (grid.parent) {
                const indexInParent = grid.childRow.index;
                hasTargetRecordInParent = this.hasNextTarget(grid.parent, indexInParent, isNext);
            }
            return hasTargetRecordInParent;
        }
    }
    /**
     * Gets closest element by its tag name.
     * @param sourceElem The element from which to start the search.
     * @param targetTag The target element tag name, for which to search.
     */
    getClosestElemByTag(sourceElem, targetTag) {
        let result = sourceElem;
        while (result !== null && result.nodeType === 1) {
            if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {
                return result;
            }
            result = result.parentNode;
        }
        return null;
    }
    /**
     * Gets the max top view in the current grid hierarchy.
     * @param grid
     */
    _getMaxTop(grid) {
        let currGrid = grid;
        let top = currGrid.tbody.nativeElement.getBoundingClientRect().top;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top + pinnedRowsHeight);
        }
        return top;
    }
    /**
     * Gets the min bottom view in the current grid hierarchy.
     * @param grid
     */
    _getMinBottom(grid) {
        let currGrid = grid;
        let bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && !currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom - pinnedRowsHeight);
        }
        return bottom;
    }
    /**
     * Finds the next grid that allows scrolling down.
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableDown(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid: grid, prev: null };
        }
        let scrollTop = currGrid.verticalScrollContainer.scrollPosition;
        let scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
        let nonScrollable = scrollHeight === 0 ||
            Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            scrollTop = currGrid.verticalScrollContainer.scrollPosition;
            scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
            nonScrollable = scrollHeight === 0 ||
                Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        }
        return { grid: currGrid, prev: prev };
    }
    /**
     * Finds the next grid that allows scrolling up.
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableUp(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid: grid, prev: null };
        }
        let nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        }
        return { grid: currGrid, prev: prev };
    }
}
IgxHierarchicalGridNavigationService.ɵfac = function IgxHierarchicalGridNavigationService_Factory(t) { return ɵIgxHierarchicalGridNavigationService_BaseFactory(t || IgxHierarchicalGridNavigationService); };
IgxHierarchicalGridNavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxHierarchicalGridNavigationService, factory: IgxHierarchicalGridNavigationService.ɵfac });

const IgxHierarchicalTransactionServiceFactory = {
    provide: IgxGridTransaction,
    useFactory: hierarchicalTransactionServiceFactory
};
function hierarchicalTransactionServiceFactory() {
    return new IgxTransactionService();
}
class IgxHierarchicalGridBaseDirective extends IgxGridBaseDirective {
    constructor(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId) {
        super(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId);
        this.selectionService = selectionService;
        this.colResizingService = colResizingService;
        this.transactionFactory = transactionFactory;
        this.document = document;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        this.showExpandAll = false;
        /**
         * Emitted when a new chunk of data is loaded from virtualization.
         * @example
         * ```typescript
         *  <igx-hierarchical-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true" (onDataPreLoad)="handleEvent()">
         *  </igx-hierarchical-grid>
         * ```
         */
        this.onDataPreLoad = new EventEmitter();
        this.hgridAPI = gridAPI;
    }
    /**
     * @hidden
     */
    get maxLevelHeaderDepth() {
        if (this._maxLevelHeaderDepth === null) {
            this._maxLevelHeaderDepth = this.columnList.reduce((acc, col) => Math.max(acc, col.level), 0);
        }
        return this._maxLevelHeaderDepth;
    }
    /**
     * Gets the outlet used to attach the grid's overlays to.
     * @remark
     * If set, returns the outlet defined outside the grid. Otherwise returns the grid's internal outlet directive.
     */
    get outlet() {
        return this.rootGrid ? this.rootGrid.resolveOutlet() : this.resolveOutlet();
    }
    /**
     * Sets the outlet used to attach the grid's overlays to.
     */
    set outlet(val) {
        this._userOutletDirective = val;
    }
    /**
     * @hidden
     */
    createColumnsList(cols) {
        const columns = [];
        const topLevelCols = this.onlyTopLevel(cols);
        topLevelCols.forEach((col) => {
            const ref = this._createColumn(col);
            ref.changeDetectorRef.detectChanges();
            columns.push(ref.instance);
        });
        const result = flatten$1(columns);
        this.columnList.reset(result);
        this.columnList.notifyOnChanges();
        this.initPinning();
    }
    _createColumn(col) {
        let ref;
        if (col instanceof IgxColumnGroupComponent) {
            ref = this._createColGroupComponent(col);
        }
        else {
            ref = this._createColComponent(col);
        }
        return ref;
    }
    _createColGroupComponent(col) {
        const factoryGroup = this.resolver.resolveComponentFactory(IgxColumnGroupComponent);
        const ref = this.viewRef.createComponent(factoryGroup, null, this.viewRef.injector);
        ref.changeDetectorRef.detectChanges();
        factoryGroup.inputs.forEach((input) => {
            const propName = input.propName;
            ref.instance[propName] = col[propName];
        });
        if (col.children.length > 0) {
            const newChildren = [];
            col.children.forEach(child => {
                const newCol = this._createColumn(child).instance;
                newCol.parent = ref.instance;
                newChildren.push(newCol);
            });
            ref.instance.children.reset(newChildren);
            ref.instance.children.notifyOnChanges();
        }
        return ref;
    }
    _createColComponent(col) {
        const factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);
        const ref = this.viewRef.createComponent(factoryColumn, null, this.viewRef.injector);
        factoryColumn.inputs.forEach((input) => {
            const propName = input.propName;
            if (!(col[propName] instanceof IgxSummaryOperand)) {
                ref.instance[propName] = col[propName];
            }
            else {
                ref.instance[propName] = col[propName].constructor;
            }
        });
        return ref;
    }
    getGridsForIsland(rowIslandID) {
        return this.hgridAPI.getChildGridsForRowIsland(rowIslandID);
    }
    getChildGrid(path) {
        if (!path) {
            return;
        }
        return this.hgridAPI.getChildGrid(path);
    }
}
IgxHierarchicalGridBaseDirective.ɵfac = function IgxHierarchicalGridBaseDirective_Factory(t) { return new (t || IgxHierarchicalGridBaseDirective)(ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(IgxGridTransaction), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(IgxHierarchicalGridNavigationService), ɵngcc0.ɵɵdirectiveInject(IgxFilteringService), ɵngcc0.ɵɵdirectiveInject(IgxOverlayService), ɵngcc0.ɵɵdirectiveInject(IgxGridSummaryService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID)); };
IgxHierarchicalGridBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxHierarchicalGridBaseDirective, viewQuery: function IgxHierarchicalGridBaseDirective_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c157, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragIndicatorIconBase = _t.first);
    } }, inputs: { showExpandAll: "showExpandAll", hasChildrenKey: "hasChildrenKey" }, outputs: { onDataPreLoad: "onDataPreLoad" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxHierarchicalGridBaseDirective.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: IgxColumnResizingService },
    { type: GridBaseAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
    { type: ElementRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: IterableDiffers },
    { type: ViewContainerRef },
    { type: IgxHierarchicalGridNavigationService },
    { type: IgxFilteringService },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxGridSummaryService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
IgxHierarchicalGridBaseDirective.propDecorators = {
    hasChildrenKey: [{ type: Input }],
    showExpandAll: [{ type: Input }],
    onDataPreLoad: [{ type: Output }],
    dragIndicatorIconBase: [{ type: ViewChild, args: ['dragIndicatorIconBase', { read: TemplateRef, static: true },] }]
};
function flatten$1(arr) {
    let result = [];
    arr.forEach(el => {
        result.push(el);
        if (el.children) {
            result = result.concat(flatten$1(el.children.toArray()));
        }
    });
    return result;
}

class IgxHierarchicalGridAPIService extends GridBaseAPIService {
    constructor() {
        super(...arguments);
        this.childRowIslands = new Map();
        this.childGrids = new Map();
    }
    registerChildRowIsland(rowIsland) {
        this.childRowIslands.set(rowIsland.key, rowIsland);
        this.destroyMap.set(rowIsland.key, new Subject());
    }
    unsetChildRowIsland(rowIsland) {
        this.childGrids.delete(rowIsland.key);
        this.childRowIslands.delete(rowIsland.key);
        this.destroyMap.delete(rowIsland.key);
    }
    getChildRowIsland(key) {
        return this.childRowIslands.get(key);
    }
    getChildGrid(path) {
        const currPath = path;
        let grid;
        const pathElem = currPath.shift();
        const childrenForLayout = this.childGrids.get(pathElem.rowIslandKey);
        if (childrenForLayout) {
            const childGrid = childrenForLayout.get(pathElem.rowID);
            if (currPath.length === 0) {
                grid = childGrid;
            }
            else {
                grid = childGrid.hgridAPI.getChildGrid(currPath);
            }
        }
        return grid;
    }
    getChildGrids(inDepth) {
        const allChildren = [];
        this.childGrids.forEach((layoutMap) => {
            layoutMap.forEach((grid) => {
                allChildren.push(grid);
                if (inDepth) {
                    const children = grid.hgridAPI.getChildGrids(inDepth);
                    children.forEach((item) => {
                        allChildren.push(item);
                    });
                }
            });
        });
        return allChildren;
    }
    getParentRowId(childGrid) {
        let rowID;
        this.childGrids.forEach((layoutMap) => {
            layoutMap.forEach((grid, key) => {
                if (grid === childGrid) {
                    rowID = key;
                    return;
                }
            });
        });
        return rowID;
    }
    registerChildGrid(parentRowID, rowIslandKey, grid) {
        let childrenForLayout = this.childGrids.get(rowIslandKey);
        if (!childrenForLayout) {
            this.childGrids.set(rowIslandKey, new Map());
            childrenForLayout = this.childGrids.get(rowIslandKey);
        }
        childrenForLayout.set(parentRowID, grid);
    }
    getChildGridsForRowIsland(rowIslandKey) {
        const childrenForLayout = this.childGrids.get(rowIslandKey);
        const children = [];
        if (childrenForLayout) {
            childrenForLayout.forEach((child) => {
                children.push(child);
            });
        }
        return children;
    }
    getChildGridByID(rowIslandKey, rowID) {
        const childrenForLayout = this.childGrids.get(rowIslandKey);
        return childrenForLayout.get(rowID);
    }
    get_row_expansion_state(record) {
        let inState;
        if (record.childGridsData !== undefined) {
            const ri = record.rowID;
            const states = this.grid.expansionStates;
            const expanded = states.get(ri);
            if (expanded !== undefined) {
                return expanded;
            }
            else {
                return this.grid.getDefaultExpandState(record);
            }
        }
        else {
            inState = !!super.get_row_expansion_state(record);
        }
        return inState && this.grid.childLayoutList.length !== 0;
    }
    allow_expansion_state_change(rowID, expanded) {
        const rec = this.get_rec_by_id(rowID);
        const grid = this.grid;
        if (grid.hasChildrenKey && !rec[grid.hasChildrenKey]) {
            return false;
        }
        return !!rec && this.grid.expansionStates.get(rowID) !== expanded;
    }
    get_rec_by_id(rowID) {
        const data = this.get_all_data(false);
        const index = this.get_row_index_in_data(rowID, data);
        return data[index];
    }
}
IgxHierarchicalGridAPIService.ɵfac = function IgxHierarchicalGridAPIService_Factory(t) { return ɵIgxHierarchicalGridAPIService_BaseFactory(t || IgxHierarchicalGridAPIService); };
IgxHierarchicalGridAPIService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxHierarchicalGridAPIService, factory: IgxHierarchicalGridAPIService.ɵfac });

class IgxRowIslandAPIService {
    constructor() {
        this.change = new Subject();
        this.state = new Map();
        this.destroyMap = new Map();
        this.childRowIslands = new Map();
        this.childGrids = new Map();
    }
    register(rowIsland) {
        this.state.set(rowIsland.id, rowIsland);
        this.destroyMap.set(rowIsland.id, new Subject());
    }
    unsubscribe(rowIsland) {
        this.state.delete(rowIsland.id);
    }
    get(id) {
        return this.state.get(id);
    }
    unset(id) {
        this.state.delete(id);
        this.destroyMap.delete(id);
    }
    reset(oldId, newId) {
        const destroy = this.destroyMap.get(oldId);
        const rowIsland = this.get(oldId);
        this.unset(oldId);
        if (rowIsland) {
            this.state.set(newId, rowIsland);
        }
        if (destroy) {
            this.destroyMap.set(newId, destroy);
        }
    }
    registerChildRowIsland(rowIsland) {
        this.childRowIslands.set(rowIsland.key, rowIsland);
        this.destroyMap.set(rowIsland.key, new Subject());
    }
    unsetChildRowIsland(rowIsland) {
        this.childRowIslands.delete(rowIsland.key);
        this.destroyMap.delete(rowIsland.key);
    }
    getChildRowIsland(rowIslandKey) {
        return this.childRowIslands.get(rowIslandKey);
    }
    registerChildGrid(parentRowID, grid) {
        this.childGrids.set(parentRowID, grid);
    }
    getChildGrids(inDepth) {
        let allChildren = [];
        this.childGrids.forEach((grid) => {
            allChildren.push(grid);
        });
        if (inDepth) {
            this.childRowIslands.forEach((layout) => {
                allChildren = allChildren.concat(layout.rowIslandAPI.getChildGrids(inDepth));
            });
        }
        return allChildren;
    }
    getChildGridByID(rowID) {
        return this.childGrids.get(rowID);
    }
}
IgxRowIslandAPIService.ɵfac = function IgxRowIslandAPIService_Factory(t) { return new (t || IgxRowIslandAPIService)(); };
IgxRowIslandAPIService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxRowIslandAPIService, factory: IgxRowIslandAPIService.ɵfac });

class IgxRowIslandComponent extends IgxHierarchicalGridBaseDirective {
    constructor(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, rowIslandAPI, localeId) {
        super(selectionService, crudService, colResizingService, gridAPI, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId);
        this.selectionService = selectionService;
        this.colResizingService = colResizingService;
        this.transactionFactory = transactionFactory;
        this.document = document;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        this.rowIslandAPI = rowIslandAPI;
        /**
         * @hidden
         */
        this.children = new QueryList();
        /**
         * @hidden
         */
        this.childColumns = new QueryList();
        /**
         * @hidden
         */
        this.onLayoutChange = new EventEmitter();
        /**
         * Event emmited when a grid is being created based on this row island.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
         *      <igx-row-island [key]="'childData'" (onGridCreated)="gridCreated($event)" #rowIsland>
         *          <!-- ... -->
         *      </igx-row-island>
         * </igx-hierarchical-grid>
         * ```
         * @memberof IgxRowIslandComponent
         */
        this.onGridCreated = new EventEmitter();
        /**
         * Emitted after a grid is being initialized for this row island.
         * The emitting is done in `ngAfterViewInit`.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
         *      <igx-row-island [key]="'childData'" (onGridInitialized)="gridInitialized($event)" #rowIsland>
         *          <!-- ... -->
         *      </igx-row-island>
         * </igx-hierarchical-grid>
         * ```
         * @memberof IgxRowIslandComponent
         */
        this.onGridInitialized = new EventEmitter();
        /**
         * @hidden
         */
        this.initialChanges = [];
        /**
         * @hidden
         */
        this.rootGrid = null;
        this.layout_id = `igx-row-island-`;
        this.isInit = false;
        this.hgridAPI = gridAPI;
    }
    /**
     * Sets if all immediate children of the grids for this `IgxRowIslandComponent` should be expanded/collapsed.
     * ```html
     * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
     *      <igx-row-island [key]="'childData'" [expandChildren]="true" #rowIsland>
     *          <!-- ... -->
     *      </igx-row-island>
     * </igx-hierarchical-grid>
     * ```
     * @memberof IgxRowIslandComponent
     */
    set expandChildren(value) {
        this._defaultExpandState = value;
        this.rowIslandAPI.getChildGrids().forEach((grid) => {
            if (document.body.contains(grid.nativeElement)) {
                // Detect changes right away if the grid is visible
                grid.expandChildren = value;
                grid.markForCheck();
            }
            else {
                // Else defer the detection on changes when the grid gets into view for performance.
                grid.updateOnRender = true;
            }
        });
    }
    /**
     * Gets if all immediate children of the grids for this `IgxRowIslandComponent` have been set to be expanded/collapsed.
     * ```typescript
     * const expanded = this.rowIsland.expandChildren;
     * ```
     * @memberof IgxRowIslandComponent
     */
    get expandChildren() {
        return this._defaultExpandState;
    }
    /**
     * @hidden
     */
    get id() {
        const pId = this.parentId ? this.parentId.substring(this.parentId.indexOf(this.layout_id) + this.layout_id.length) + '-' : '';
        return this.layout_id + pId + this.key;
    }
    /**
     * @hidden
     */
    get parentId() {
        return this.parentIsland ? this.parentIsland.id : null;
    }
    /**
     * @hidden
     */
    get level() {
        let ptr = this.parentIsland;
        let lvl = 0;
        while (ptr) {
            lvl++;
            ptr = ptr.parentIsland;
        }
        return lvl + 1;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.rootGrid = this.hgridAPI.grid;
        this.rowIslandAPI.rowIsland = this;
        this.ri_columnListDiffer = this.differs.find([]).create(null);
    }
    /**
     * @hidden
     */
    ngDoCheck() {
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.updateChildren();
        this.children.notifyOnChanges();
        this.children.changes.pipe(takeUntil(this.destroy$))
            .subscribe((change) => {
            this.updateChildren();
            // update existing grids since their child ri have been changed.
            this.getGridsForIsland(this.key).forEach(grid => {
                grid.onRowIslandChange(this.children);
            });
        });
        const nestedColumns = this.children.map((layout) => layout.columnList.toArray());
        const colsArray = [].concat.apply([], nestedColumns);
        const topCols = this.columnList.filter((item) => {
            return colsArray.indexOf(item) === -1;
        });
        this.childColumns.reset(topCols);
        this.columnList.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
            Promise.resolve().then(() => {
                this.updateColumnList();
            });
        });
        // handle column changes so that they are passed to child grid instances when onColumnChange is emitted.
        this.ri_columnListDiffer.diff(this.childColumns);
        this.childColumns.toArray().forEach(x => x.onColumnChange.pipe(takeUntil(x.destroy$)).subscribe(() => this.updateColumnList()));
        this.childColumns.changes.pipe(takeUntil(this.destroy$)).subscribe((change) => {
            const diff = this.ri_columnListDiffer.diff(change);
            if (diff) {
                diff.forEachAddedItem((record) => {
                    record.item.onColumnChange.pipe(takeUntil(record.item.destroy$)).subscribe(() => this.updateColumnList());
                });
            }
        });
        this.actionStrip = this.actionStrips.first;
        if (this.actionStrip) {
            this.actionStrip.menuOverlaySettings.outlet = this.outlet;
        }
    }
    updateChildren() {
        if (this.children.first === this) {
            this.children.reset(this.children.toArray().slice(1));
        }
        this.children.forEach(child => {
            child.parentIsland = this;
        });
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.rowIslandAPI.register(this);
        if (this.parentIsland) {
            this.parentIsland.rowIslandAPI.registerChildRowIsland(this);
        }
        else {
            this.rootGrid.hgridAPI.registerChildRowIsland(this);
        }
        this._init = false;
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        this.onLayoutChange.emit(changes);
        if (!this.isInit) {
            this.initialChanges.push(changes);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        // Override the base destroy because we don't have rendered anything to use removeEventListener on
        this.destroy$.next(true);
        this.destroy$.complete();
        this._destroyed = true;
        this.rowIslandAPI.unset(this.id);
        if (this.parentIsland) {
            this.getGridsForIsland(this.key).forEach(grid => {
                this.cleanGridState(grid);
                grid.hgridAPI.unsetChildRowIsland(this);
            });
            this.parentIsland.rowIslandAPI.unsetChildRowIsland(this);
        }
        else {
            this.rootGrid.hgridAPI.unsetChildRowIsland(this);
            this.cleanGridState(this.rootGrid);
        }
    }
    cleanGridState(grid) {
        grid.childGridTemplates.forEach((tmpl) => {
            tmpl.owner.cleanView(tmpl.context.templateID);
        });
        grid.childGridTemplates.clear();
        grid.onRowIslandChange();
    }
    /**
     * @hidden
     */
    reflow() { }
    /**
     * @hidden
     */
    calculateGridHeight() { }
    updateColumnList() {
        const nestedColumns = this.children.map((layout) => layout.columnList.toArray());
        const colsArray = [].concat.apply([], nestedColumns);
        const topCols = this.columnList.filter((item) => {
            if (colsArray.indexOf(item) === -1) {
                /* Reset the default width of the columns that come into this row island,
                because the root catches them first during the detectChanges() and sets their defaultWidth. */
                item.defaultWidth = undefined;
                return true;
            }
            return false;
        });
        this.childColumns.reset(topCols);
        if (this.parentIsland) {
            this.parentIsland.columnList.notifyOnChanges();
        }
        else {
            this.rootGrid.columnList.notifyOnChanges();
        }
        this.rowIslandAPI.getChildGrids().forEach((grid) => {
            grid.createColumnsList(this.childColumns.toArray());
            if (!document.body.contains(grid.nativeElement)) {
                grid.updateOnRender = true;
            }
        });
    }
}
IgxRowIslandComponent.ɵfac = function IgxRowIslandComponent_Factory(t) { return new (t || IgxRowIslandComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(IgxGridTransaction), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(IgxHierarchicalGridNavigationService), ɵngcc0.ɵɵdirectiveInject(IgxFilteringService), ɵngcc0.ɵɵdirectiveInject(IgxOverlayService), ɵngcc0.ɵɵdirectiveInject(IgxGridSummaryService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(IgxRowIslandAPIService), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID)); };
IgxRowIslandComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxRowIslandComponent, selectors: [["igx-row-island"]], contentQueries: function IgxRowIslandComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowIslandComponent, false, IgxRowIslandComponent);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxColumnComponent, false, IgxColumnComponent);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxActionStripComponent, false, IgxActionStripComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childColumns = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.actionStrips = _t);
    } }, inputs: { expandChildren: "expandChildren", key: "key" }, outputs: { onLayoutChange: "onLayoutChange", onGridCreated: "onGridCreated", onGridInitialized: "onGridInitialized" }, features: [ɵngcc0.ɵɵProvidersFeature([IgxRowIslandAPIService,
            IgxGridSelectionService]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function IgxRowIslandComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
IgxRowIslandComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: IgxColumnResizingService },
    { type: GridBaseAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
    { type: ElementRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: IterableDiffers },
    { type: ViewContainerRef },
    { type: IgxHierarchicalGridNavigationService },
    { type: IgxFilteringService },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxGridSummaryService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: IgxRowIslandAPIService },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
IgxRowIslandComponent.propDecorators = {
    key: [{ type: Input }],
    expandChildren: [{ type: Input }],
    children: [{ type: ContentChildren, args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false },] }],
    childColumns: [{ type: ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: false },] }],
    onLayoutChange: [{ type: Output }],
    onGridCreated: [{ type: Output }],
    onGridInitialized: [{ type: Output }],
    actionStrips: [{ type: ContentChildren, args: [IgxActionStripComponent, { read: IgxActionStripComponent, descendants: false },] }]
};

let NEXT_ID$q = 0;
class IgxHierarchicalGridComponent extends IgxHierarchicalGridBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * @hidden
         */
        this.childLayoutKeys = [];
        /**
         * @hidden
         */
        this.highlightedRowID = null;
        /**
         * @hidden
         */
        this.updateOnRender = false;
        /**
         * @hidden
         */
        this.parent = null;
        this._filteredData = null;
        this.h_id = `igx-hierarchical-grid-${NEXT_ID$q++}`;
        this.childGridTemplates = new Map();
        this.scrollTop = 0;
        this.scrollLeft = 0;
    }
    /**
     * Gets/Sets the value of the `id` attribute.
     * @remarks
     * If not provided it will be automatically generated.
     * @example
     * ```html
     * <igx-hierarchical-grid [id]="'igx-hgrid-1'" [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
     * ```
     */
    get id() {
        return this.h_id;
    }
    set id(value) {
        this.h_id = value;
    }
    /**
     * An @Input property that lets you fill the `IgxHierarchicalGridComponent` with an array of data.
     * ```html
     * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
            this.reflow();
        }
        this.cdr.markForCheck();
        if (this.parent && (this.height === null || this.height.indexOf('%') !== -1)) {
            // If the height will change based on how much data there is, recalculate sizes in igxForOf.
            this.notifyChanges(true);
        }
    }
    /**
     * Returns an array of data set to the `IgxHierarchicalGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    get data() {
        return this._data;
    }
    /**
     * Sets an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
     * ```typescript
     * this.grid.filteredData = [{
     *       ID: 1,
     *       Name: "A"
     * }];
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Returns an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    get filteredData() {
        return this._filteredData;
    }
    /**
     * Gets/Sets the total number of records in the data source.
     * @remarks
     * This property is required for remote grid virtualization to function when it is bound to remote data.
     * @example
     * ```typescript
     * const itemCount = this.grid1.totalItemCount;
     * this.grid1.totalItemCount = 55;
     * ```
     */
    set totalItemCount(count) {
        this.verticalScrollContainer.totalItemCount = count;
        this.cdr.detectChanges();
    }
    get totalItemCount() {
        return this.verticalScrollContainer.totalItemCount;
    }
    /**
     * Sets if all immediate children of the `IgxHierarchicalGridComponent` should be expanded/collapsed.
     * Defult value is false.
     * ```html
     * <igx-hierarchical-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true" [expandChildren]="true"></igx-hierarchical-grid>
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    set expandChildren(value) {
        this._defaultExpandState = value;
        this.expansionStates = new Map();
    }
    /**
     * Gets if all immediate children of the `IgxHierarchicalGridComponent` previously have been set to be expanded/collapsed.
     * If previously set and some rows have been manually expanded/collapsed it will still return the last set value.
     * ```typescript
     * const expanded = this.grid.expandChildren;
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    get expandChildren() {
        return this._defaultExpandState;
    }
    /**
     * Gets the unique identifier of the parent row. It may be a `string` or `number` if `primaryKey` of the
     * parent grid is set or an object reference of the parent record otherwise.
     * ```typescript
     * const foreignKey = this.grid.foreignKey;
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    get foreignKey() {
        if (!this.parent) {
            return null;
        }
        return this.parent.hgridAPI.getParentRowId(this);
    }
    /**
     * @hidden
     */
    get hasExpandableChildren() {
        return !!this.childLayoutKeys.length;
    }
    /**
     * @hidden
     */
    hideActionStrip(event) {
        if (!this.parent) {
            // hide child layout actions strips when
            // moving outside root grid.
            super.hideActionStrip(event);
            this.allLayoutList.forEach(ri => {
                var _a;
                (_a = ri.actionStrip) === null || _a === void 0 ? void 0 : _a.hide();
            });
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this._transactions instanceof IgxTransactionService) {
            // transaction service cannot be injected in a derived class in a factory manner
            this._transactions = new IgxTransactionService();
        }
        this.expansionStatesChange.pipe(takeUntil(this.destroy$)).subscribe((value) => {
            const res = Array.from(value.entries()).filter(({ 1: v }) => v === true).map(([k]) => k);
        });
        super.ngOnInit();
    }
    ngDoCheck() {
        if (this._cdrRequestRepaint && !this._init) {
            this.updateSizes();
        }
        super.ngDoCheck();
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.verticalScrollContainer.getScroll().addEventListener('scroll', this.hg_verticalScrollHandler.bind(this));
        this.headerContainer.getScroll().addEventListener('scroll', this.hg_horizontalScrollHandler.bind(this));
        this.verticalScrollContainer.onBeforeViewDestroyed.pipe(takeUntil(this.destroy$)).subscribe((view) => {
            const rowData = view.context.$implicit;
            if (this.isChildGridRecord(rowData)) {
                const cachedData = this.childGridTemplates.get(rowData.rowID);
                if (cachedData) {
                    const tmlpOutlet = cachedData.owner;
                    tmlpOutlet._viewContainerRef.detach(0);
                }
            }
        });
        if (this.parent) {
            this._displayDensity = this.rootGrid._displayDensity;
            this.rootGrid.onDensityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this._displayDensity = this.rootGrid._displayDensity;
                this.notifyChanges(true);
                this.cdr.markForCheck();
            });
            this.childLayoutKeys = this.parentIsland.children.map((item) => item.key);
        }
        this.toolbarCustomContentTemplates = this.parentIsland ?
            this.parentIsland.toolbarCustomContentTemplates :
            this.toolbarCustomContentTemplates;
        this.actionStrip = this.parentIsland ? this.parentIsland.actionStrip : this.actionStrip;
        this.headSelectorsTemplates = this.parentIsland ?
            this.parentIsland.headSelectorsTemplates :
            this.headSelectorsTemplates;
        this.rowSelectorsTemplates = this.parentIsland ?
            this.parentIsland.rowSelectorsTemplates :
            this.rowSelectorsTemplates;
        this.dragIndicatorIconTemplate = this.parentIsland ?
            this.parentIsland.dragIndicatorIconTemplate :
            this.dragIndicatorIconTemplate;
        this.rowExpandedIndicatorTemplate = this.rootGrid.rowExpandedIndicatorTemplate;
        this.rowCollapsedIndicatorTemplate = this.rootGrid.rowCollapsedIndicatorTemplate;
        this.headerCollapseIndicatorTemplate = this.rootGrid.headerCollapseIndicatorTemplate;
        this.headerExpandIndicatorTemplate = this.rootGrid.headerExpandIndicatorTemplate;
        this.hasChildrenKey = this.parentIsland ?
            this.parentIsland.hasChildrenKey || this.rootGrid.hasChildrenKey :
            this.rootGrid.hasChildrenKey;
        this.showExpandAll = this.parentIsland ?
            this.parentIsland.showExpandAll : this.rootGrid.showExpandAll;
        this.excelStyleFilteringComponents = this.parentIsland ?
            this.parentIsland.excelStyleFilteringComponents :
            this.excelStyleFilteringComponents;
    }
    updateSizes() {
        if (document.body.contains(this.nativeElement) && this.isPercentWidth) {
            this.reflow();
            this.hgridAPI.getChildGrids(false).forEach((grid) => {
                grid.updateSizes();
            });
        }
    }
    _shouldAutoSize(renderedHeight) {
        if (this.isPercentHeight && this.parent) {
            return true;
        }
        return super._shouldAutoSize(renderedHeight);
    }
    get outletDirective() {
        return this.rootGrid._outletDirective;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.updateColumnList(false);
        this.childLayoutKeys = this.parent ?
            this.parentIsland.children.map((item) => item.key) :
            this.childLayoutKeys = this.childLayoutList.map((item) => item.key);
        this.childLayoutList.notifyOnChanges();
        this.childLayoutList.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.onRowIslandChange());
        super.ngAfterContentInit();
    }
    /**
     * @hidden @internal
     */
    dataLoading(event) {
        this.onDataPreLoad.emit(event);
    }
    /** @hidden */
    featureColumnsWidth() {
        return super.featureColumnsWidth(this.headerHierarchyExpander);
    }
    /**
     * @hidden
     */
    onRowIslandChange() {
        if (this.parent) {
            this.childLayoutKeys = this.parentIsland.children.filter(item => !item._destroyed).map((item) => item.key);
        }
        else {
            this.childLayoutKeys = this.childLayoutList.filter(item => !item._destroyed).map((item) => item.key);
        }
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
    setupColumns() {
        if (this.parentIsland && this.parentIsland.childColumns.length > 0 && !this.autoGenerate) {
            this.createColumnsList(this.parentIsland.childColumns.toArray());
        }
        super.setupColumns();
    }
    onColumnsChanged(change) {
        Promise.resolve().then(() => {
            this.updateColumnList();
            const cols = change.filter(c => c.gridAPI.grid === this);
            if (cols.length > 0 || this.autoGenerate) {
                this.columnList.reset(cols);
                super.onColumnsChanged(this.columnList);
            }
        });
    }
    updateColumnList(recalcColSizes = true) {
        const childLayouts = this.parent ? this.childLayoutList : this.allLayoutList;
        const nestedColumns = childLayouts.map((layout) => {
            return layout.columnList.toArray();
        });
        const colsArray = [].concat.apply([], nestedColumns);
        const colLength = this.columnList.length;
        if (colsArray.length > 0) {
            const topCols = this.columnList.filter((item) => {
                return colsArray.indexOf(item) === -1;
            });
            this.columnList.reset(topCols);
            if (recalcColSizes && this.columnList.length !== colLength) {
                this.calculateGridSizes(false);
            }
        }
    }
    ngOnDestroy() {
        if (!this.parent) {
            this.hgridAPI.getChildGrids(true).forEach((grid) => {
                if (!grid.childRow.cdr.destroyed) {
                    grid.childRow.cdr.destroy();
                }
            });
        }
        if (this.parent && this.selectionService.activeElement) {
            // in case selection is in destroyed child grid, selection should be cleared.
            this._clearSeletionHighlights();
        }
        super.ngOnDestroy();
    }
    _clearSeletionHighlights() {
        [this.rootGrid, ...this.rootGrid.getChildGrids(true)].forEach(grid => {
            grid.selectionService.clear();
            grid.selectionService.activeElement = null;
            grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
            grid.highlightedRowID = null;
            grid.cdr.markForCheck();
        });
    }
    /**
     * @hidden
     */
    isRowHighlighted(rowData) {
        return this.highlightedRowID === rowData.rowID;
    }
    /**
     * @hidden
     */
    isHierarchicalRecord(record) {
        if (this.isGhostRecord(record)) {
            record = record.recordRef;
        }
        return this.childLayoutList.length !== 0 && record[this.childLayoutList.first.key];
    }
    /**
     * @hidden
     */
    isChildGridRecord(record) {
        // Can be null when there is defined layout but no child data was found
        return record.childGridsData !== undefined;
    }
    /**
     * @hidden
     */
    trackChanges(index, rec) {
        if (rec.childGridsData !== undefined) {
            // if is child rec
            return rec.rowID;
        }
        return rec;
    }
    /**
     * @hidden
     */
    getContext(rowData, rowIndex, pinned) {
        if (this.isChildGridRecord(rowData)) {
            const cachedData = this.childGridTemplates.get(rowData.rowID);
            if (cachedData) {
                const view = cachedData.view;
                const tmlpOutlet = cachedData.owner;
                return {
                    $implicit: rowData,
                    moveView: view,
                    owner: tmlpOutlet,
                    index: this.dataView.indexOf(rowData)
                };
            }
            else {
                const rowID = this.primaryKey ? rowData.rowID : this.data.indexOf(rowData.rowID);
                // child rows contain unique grids, hence should have unique templates
                return {
                    $implicit: rowData,
                    templateID: 'childRow-' + rowID,
                    index: this.dataView.indexOf(rowData)
                };
            }
        }
        else {
            return {
                $implicit: this.isGhostRecord(rowData) || this.isAddRowRecord(rowData) ? rowData.recordRef : rowData,
                templateID: 'dataRow',
                index: this.getDataViewIndex(rowIndex, pinned),
                disabled: this.isGhostRecord(rowData),
                addRow: this.isAddRowRecord(rowData) ? rowData.addRow : false
            };
        }
    }
    /**
     * @hidden
     */
    get rootGrid() {
        let currGrid = this;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
        }
        return currGrid;
    }
    /**
     * @hidden
     */
    get iconTemplate() {
        const expanded = this.hasExpandedRecords() && this.hasExpandableChildren;
        if (!expanded && this.showExpandAll) {
            return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
        }
        else {
            return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
        }
    }
    /**
     * @hidden
     * @internal
     */
    getDragGhostCustomTemplate() {
        if (this.parentIsland) {
            return this.parentIsland.getDragGhostCustomTemplate();
        }
        return super.getDragGhostCustomTemplate();
    }
    /**
     * @hidden
     */
    initColumns(collection, cb = null) {
        if (this.hasColumnLayouts) {
            // invalid configuration - hierarchical grid should not allow column layouts
            // remove column layouts
            const nonColumnLayoutColumns = this.columnList.filter((col) => !col.columnLayout && !col.columnLayoutChild);
            this.columnList.reset(nonColumnLayoutColumns);
        }
        super.initColumns(collection, cb);
    }
    /**
     * @hidden
     * Gets the visible content height that includes header + tbody + footer.
     * For hierarchical child grid it may be scrolled and not fully visible.
     */
    getVisibleContentHeight() {
        let height = super.getVisibleContentHeight();
        if (this.parent) {
            const rootHeight = this.rootGrid.getVisibleContentHeight();
            const topDiff = this.nativeElement.getBoundingClientRect().top - this.rootGrid.nativeElement.getBoundingClientRect().top;
            height = rootHeight - topDiff > height ? height : rootHeight - topDiff;
        }
        return height;
    }
    /**
     * @hidden
     */
    toggleAll() {
        const expanded = this.hasExpandedRecords() && this.hasExpandableChildren;
        if (!expanded && this.showExpandAll) {
            this.expandAll();
        }
        else {
            this.collapseAll();
        }
    }
    /**
     * @hidden
     * @internal
     */
    hasExpandedRecords() {
        if (this.expandChildren) {
            return true;
        }
        let hasExpandedEntry = false;
        this.expansionStates.forEach((value, key) => {
            if (value) {
                hasExpandedEntry = value;
            }
        });
        return hasExpandedEntry;
    }
    getDefaultExpandState(record) {
        if (this.hasChildrenKey && !record[this.hasChildrenKey]) {
            return false;
        }
        return this.expandChildren;
    }
    /**
     * @hidden
     */
    isExpanded(record) {
        return this.gridAPI.get_row_expansion_state(record);
    }
    /**
     * @hidden
     */
    viewCreatedHandler(args) {
        if (this.isChildGridRecord(args.context.$implicit)) {
            const key = args.context.$implicit.rowID;
            this.childGridTemplates.set(key, args);
        }
    }
    /**
     * @hidden
     */
    viewMovedHandler(args) {
        if (this.isChildGridRecord(args.context.$implicit)) {
            // view was moved, update owner in cache
            const key = args.context.$implicit.rowID;
            const cachedData = this.childGridTemplates.get(key);
            cachedData.owner = args.owner;
            this.childLayoutList.forEach((layout) => {
                const relatedGrid = this.hgridAPI.getChildGridByID(layout.key, args.context.$implicit.rowID);
                if (relatedGrid && relatedGrid.updateOnRender) {
                    // Detect changes if `expandChildren` has changed when the grid wasn't visible. This is for performance reasons.
                    relatedGrid.notifyChanges(true);
                    relatedGrid.updateOnRender = false;
                }
            });
            const childGrids = this.getChildGrids(true);
            childGrids.forEach((grid) => {
                if (grid.isPercentWidth) {
                    grid.notifyChanges(true);
                }
                grid.updateScrollPosition();
            });
        }
    }
    /**
     * @hidden
     */
    updateScrollPosition() {
        const vScr = this.verticalScrollContainer.getScroll();
        const hScr = this.headerContainer.getScroll();
        if (vScr) {
            vScr.scrollTop = this.scrollTop;
        }
        if (hScr) {
            hScr.scrollLeft = this.scrollLeft;
        }
    }
    getChildGrids(inDeph) {
        return this.hgridAPI.getChildGrids(inDeph);
    }
    generateDataFields(data) {
        return super.generateDataFields(data).filter((field) => {
            const layoutsList = this.parentIsland ? this.parentIsland.children : this.childLayoutList;
            const keys = layoutsList.map((item) => item.key);
            return keys.indexOf(field) === -1;
        });
    }
    hg_verticalScrollHandler(event) {
        this.scrollTop = event.target.scrollTop;
    }
    onContainerScroll() {
        this.hideOverlays();
    }
    hg_horizontalScrollHandler(event) {
        this.scrollLeft = event.target.scrollLeft;
    }
}
IgxHierarchicalGridComponent.ɵfac = function IgxHierarchicalGridComponent_Factory(t) { return ɵIgxHierarchicalGridComponent_BaseFactory(t || IgxHierarchicalGridComponent); };
IgxHierarchicalGridComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxHierarchicalGridComponent, selectors: [["igx-hierarchical-grid"]], contentQueries: function IgxHierarchicalGridComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowIslandComponent, false, IgxRowIslandComponent);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowIslandComponent, true, IgxRowIslandComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childLayoutList = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.allLayoutList = _t);
    } }, viewQuery: function IgxHierarchicalGridComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c212, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c213, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c214, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(IgxTemplateOutletDirective, true, IgxTemplateOutletDirective);
        ɵngcc0.ɵɵviewQuery(IgxChildGridRowComponent, true, IgxChildGridRowComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hierarchicalRecordTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerHierarchyExpander = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateOutlets = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hierarchicalRows = _t);
    } }, hostVars: 1, hostBindings: function IgxHierarchicalGridComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { id: "id", data: "data", expandChildren: "expandChildren" }, features: [ɵngcc0.ɵɵProvidersFeature([
            IgxGridSelectionService,
            IgxGridCRUDService,
            { provide: GridBaseAPIService, useClass: IgxHierarchicalGridAPIService },
            { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxHierarchicalGridComponent) },
            IgxGridSummaryService,
            IgxFilteringService,
            IgxHierarchicalGridNavigationService,
            IgxForOfSyncService,
            IgxForOfScrollSyncService,
            IgxRowIslandAPIService
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c186, decls: 109, vars: 170, consts: [["role", "toolbar", 3, "max-width", "flex-basis", "gridID", "displayDensity", 4, "ngIf"], [1, "igx-grid__thead"], ["tabindex", "0", "role", "rowgroup", 1, "igx-grid__thead-wrapper", 3, "focus", "keydown"], ["theadRow", ""], ["role", "row", 1, "igx-grid__tr"], ["id", "left", "class", "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop", 4, "ngIf"], ["id", "left", "class", "igx-grid__scroll-on-drag-pinned", 3, "igxColumnMovingDrop", "left", 4, "ngIf"], [3, "hidden", "ngClass", "click", "mousedown"], ["headerHierarchyExpander", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngIf"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollOrientation", "igxForScrollContainer", "igxForContainerSize", "igxForTrackBy", "igxForSizePropName"], ["hContainer", ""], [3, "width", "column", 4, "ngIf"], ["loadingOverlay", ""], [3, "indeterminate", 4, "ngIf"], ["id", "right", "class", "igx-grid__scroll-on-drag-right", 3, "igxColumnMovingDrop", 4, "ngIf"], [1, "igx-grid__thead-thumb", 3, "hidden"], ["igxGridBody", "", 1, "igx-grid__tbody", 3, "keydown.control.c", "copy"], ["tabindex", "0", "role", "rowgroup", 1, "igx-grid__tbody-content", 3, "igxGridDragSelect", "focus", "keydown", "onDragStop", "onDragScroll", "scroll"], ["tbody", ""], ["pinnedRecordsTemplate", ""], [4, "ngTemplateOutlet"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollOrientation", "igxForScrollContainer", "igxForContainerSize", "igxForItemSize", "igxForTrackBy", "onChunkPreload"], ["verticalScrollContainer", ""], ["hierarchical_record_template", ""], ["pinned_hierarchical_record_template", ""], ["child_record_template", ""], ["igxOverlayOutlet", "", 1, "igx-grid__row-editing-outlet"], ["igxRowEditingOverlayOutlet", ""], [1, "igx-grid__tbody-scrollbar", 3, "hidden", "pointerdown"], [1, "igx-grid__tbody-scrollbar-start"], [1, "igx-grid__tbody-scrollbar-main"], ["igxGridFor", "", 3, "igxGridForOf"], ["verticalScrollHolder", ""], [1, "igx-grid__tbody-scrollbar-end"], [1, "igx-grid__addrow-snackbar"], [3, "actionText", "displayTime"], ["addRowSnackbar", ""], ["tabindex", "0", "role", "rowgroup", 1, "igx-grid__tfoot", 3, "focus", "keydown"], ["tfoot", ""], ["role", "row", "class", "igx-grid__summaries", 3, "width", "height", "gridID", "summaries", "index", 4, "ngIf"], [1, "igx-grid__tfoot-thumb", 3, "hidden"], [1, "igx-grid__scroll", 3, "hidden", "pointerdown"], ["scr", ""], [1, "igx-grid__scroll-start"], [1, "igx-grid__scroll-main"], ["scrollContainer", ""], [1, "igx-grid__scroll-end", 3, "hidden"], [1, "igx-grid__footer"], ["footer", ""], ["defaultPaginator", ""], ["emptyFilteredGrid", ""], ["defaultEmptyGrid", ""], ["defaultAddRowEmptyTemplate", ""], ["defaultLoadingGrid", ""], ["defaultCollapsedTemplate", ""], ["defaultExpandedTemplate", ""], ["igxToggle", "", 4, "ngIf"], ["defaultRowEditText", ""], ["defaultRowEditActions", ""], ["defaultRowEditTemplate", ""], ["dragIndicatorIconBase", ""], ["igxHeadSelector", ""], ["headSelectorBaseTemplate", ""], ["igxOverlayOutlet", "", 1, "igx-grid__loading-outlet"], ["igxLoadingOverlayOutlet", ""], ["igxOverlayOutlet", "", 1, "igx-grid__outlet", 3, "keydown"], ["igxFilteringOverlayOutlet", ""], ["role", "toolbar", 3, "gridID", "displayDensity"], ["toolbar", ""], ["id", "left", 1, "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop"], ["id", "left", 1, "igx-grid__scroll-on-drag-pinned", 3, "igxColumnMovingDrop"], [1, "igx-grid__drag-indicator", 3, "ngClass", "pointerdown"], ["headerDragContainer", ""], [2, "visibility", "hidden"], [1, "igx-grid__cbx-selection", 3, "ngClass", "click", "pointerdown"], ["headerSelectorContainer", ""], ["headSelector", ""], ["ngFor", "", 3, "ngForOf"], [3, "column", "gridID"], [3, "column"], ["filteringRow", ""], [3, "indeterminate"], ["id", "right", 1, "igx-grid__scroll-on-drag-right", 3, "igxColumnMovingDrop"], ["class", "igx-grid__tr--pinned", 3, "ngClass", "width", 4, "ngIf"], [1, "igx-grid__tr--pinned", 3, "ngClass"], ["pinContainer", ""], [4, "ngFor", "ngForOf"], [3, "igxTemplateOutlet", "igxTemplateOutletContext", "onViewCreated", "onViewMoved", "onCachedViewLoaded"], [3, "gridID", "index", "disabled", "rowData", "addRow"], ["row", ""], [3, "gridID", "index", "rowData", "addRow"], ["row", "", "pinnedRow", ""], [2, "overflow", "auto", "width", "100%", 3, "ngClass", "scroll"], [3, "parentGridID", "index", "rowData", "layout", 4, "ngFor", "ngForOf"], [3, "parentGridID", "index", "rowData", "layout"], ["role", "row", 1, "igx-grid__summaries", 3, "gridID", "summaries", "index"], ["summaryRow", ""], [3, "overlaySettings", "displayDensity", "page", "totalRecords", "perPage", "pageChange", "perPageChange"], [1, "igx-grid__tbody-message"], ["igxButton", "raised", "igxRipple", "", 3, "click"], [1, "igx-grid__loading"], ["role", "button", "fontSet", "material"], ["role", "button", "fontSet", "material", 3, "isActive"], ["igxToggle", ""], [3, "className"], ["igxButton", "", "igxRowEditTabStop", "", 3, "click"], ["class", "igx-banner__message", 4, "ngIf"], [1, "igx-banner__actions"], [1, "igx-banner__row"], [1, "igx-banner__message"], [1, "igx-banner__text"], ["fontSet", "material"], [1, "igx-grid__cbx-padding"], ["disableRipple", "true", 3, "tabindex", "readonly", "checked", "ngStyle", "indeterminate", "aria-label"], ["headerCheckbox", ""]], template: function IgxHierarchicalGridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c182);
        ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridComponent_igx_grid_toolbar_0_Template, 2, 6, "igx-grid-toolbar", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2, 3);
        ɵngcc0.ɵɵlistener("focus", function IgxHierarchicalGridComponent_Template_div_focus_2_listener() { return ctx.navigation.focusFirstCell(); })("keydown", function IgxHierarchicalGridComponent_Template_div_keydown_2_listener($event) { return ctx.navigation.headerNavigation($event); });
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵtemplate(5, IgxHierarchicalGridComponent_span_5_Template, 1, 2, "span", 5);
        ɵngcc0.ɵɵtemplate(6, IgxHierarchicalGridComponent_span_6_Template, 1, 4, "span", 6);
        ɵngcc0.ɵɵelementStart(7, "div", 7, 8);
        ɵngcc0.ɵɵlistener("click", function IgxHierarchicalGridComponent_Template_div_click_7_listener() { return ctx.toggleAll(); })("mousedown", function IgxHierarchicalGridComponent_Template_div_mousedown_7_listener($event) { return $event.preventDefault(); });
        ɵngcc0.ɵɵtemplate(9, IgxHierarchicalGridComponent_ng_container_9_Template, 1, 0, "ng-container", 9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, IgxHierarchicalGridComponent_ng_container_10_Template, 5, 4, "ng-container", 10);
        ɵngcc0.ɵɵtemplate(11, IgxHierarchicalGridComponent_ng_container_11_Template, 4, 12, "ng-container", 10);
        ɵngcc0.ɵɵtemplate(12, IgxHierarchicalGridComponent_ng_container_12_Template, 3, 3, "ng-container", 10);
        ɵngcc0.ɵɵtemplate(13, IgxHierarchicalGridComponent_ng_template_13_Template, 1, 6, "ng-template", 11, 12, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(15, "igxTopLevel");
        ɵngcc0.ɵɵtemplate(16, IgxHierarchicalGridComponent_ng_container_16_Template, 3, 3, "ng-container", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(17, IgxHierarchicalGridComponent_igx_grid_filtering_row_17_Template, 2, 3, "igx-grid-filtering-row", 13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(18, "div", null, 14);
        ɵngcc0.ɵɵtemplate(20, IgxHierarchicalGridComponent_igx_circular_bar_20_Template, 1, 1, "igx-circular-bar", 15);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(21, IgxHierarchicalGridComponent_span_21_Template, 1, 2, "span", 16);
        ɵngcc0.ɵɵelement(22, "div", 17);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(23, "div", 18);
        ɵngcc0.ɵɵlistener("keydown.control.c", function IgxHierarchicalGridComponent_Template_div_keydown_control_c_23_listener($event) { return ctx.copyHandler($event); })("copy", function IgxHierarchicalGridComponent_Template_div_copy_23_listener($event) { return ctx.copyHandler($event); });
        ɵngcc0.ɵɵelementStart(24, "div", 19, 20);
        ɵngcc0.ɵɵlistener("focus", function IgxHierarchicalGridComponent_Template_div_focus_24_listener($event) { return ctx.navigation.focusTbody($event); })("keydown", function IgxHierarchicalGridComponent_Template_div_keydown_24_listener($event) { return ctx.navigation.handleNavigation($event); })("onDragStop", function IgxHierarchicalGridComponent_Template_div_onDragStop_24_listener($event) { return ctx.selectionService.dragMode = $event; })("onDragScroll", function IgxHierarchicalGridComponent_Template_div_onDragScroll_24_listener($event) { return ctx.dragScroll($event); })("scroll", function IgxHierarchicalGridComponent_Template_div_scroll_24_listener($event) { return ctx.preventContainerScroll($event); });
        ɵngcc0.ɵɵtemplate(26, IgxHierarchicalGridComponent_span_26_Template, 1, 2, "span", 5);
        ɵngcc0.ɵɵtemplate(27, IgxHierarchicalGridComponent_span_27_Template, 1, 4, "span", 6);
        ɵngcc0.ɵɵtemplate(28, IgxHierarchicalGridComponent_ng_template_28_Template, 7, 47, "ng-template", null, 21, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(30, IgxHierarchicalGridComponent_ng_container_30_Template, 1, 0, "ng-container", 22);
        ɵngcc0.ɵɵtemplate(31, IgxHierarchicalGridComponent_ng_template_31_Template, 1, 2, "ng-template", 23, 24, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(33, "gridAddRow");
        ɵngcc0.ɵɵpipe(34, "gridRowPinning");
        ɵngcc0.ɵɵpipe(35, "gridHierarchical");
        ɵngcc0.ɵɵpipe(36, "gridHierarchicalPaging");
        ɵngcc0.ɵɵpipe(37, "gridSort");
        ɵngcc0.ɵɵpipe(38, "gridFiltering");
        ɵngcc0.ɵɵpipe(39, "visibleColumns");
        ɵngcc0.ɵɵpipe(40, "gridTransaction");
        ɵngcc0.ɵɵlistener("onChunkPreload", function IgxHierarchicalGridComponent_Template_ng_template_onChunkPreload_31_listener($event) { return ctx.dataLoading($event); });
        ɵngcc0.ɵɵtemplate(41, IgxHierarchicalGridComponent_ng_template_41_Template, 2, 5, "ng-template", null, 25, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(43, IgxHierarchicalGridComponent_ng_template_43_Template, 3, 4, "ng-template", null, 26, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(45, IgxHierarchicalGridComponent_ng_template_45_Template, 2, 5, "ng-template", null, 27, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(47, IgxHierarchicalGridComponent_ng_container_47_Template, 1, 0, "ng-container", 22);
        ɵngcc0.ɵɵtemplate(48, IgxHierarchicalGridComponent_ng_container_48_Template, 1, 0, "ng-container", 22);
        ɵngcc0.ɵɵtemplate(49, IgxHierarchicalGridComponent_span_49_Template, 1, 2, "span", 16);
        ɵngcc0.ɵɵelement(50, "div", 28, 29);
        ɵngcc0.ɵɵtemplate(52, IgxHierarchicalGridComponent_igc_trial_watermark_52_Template, 1, 0, "igc-trial-watermark", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(53, IgxHierarchicalGridComponent_span_53_Template, 1, 2, "span", 16);
        ɵngcc0.ɵɵelementStart(54, "div", 30);
        ɵngcc0.ɵɵlistener("pointerdown", function IgxHierarchicalGridComponent_Template_div_pointerdown_54_listener($event) { return $event.preventDefault(); });
        ɵngcc0.ɵɵelement(55, "div", 31);
        ɵngcc0.ɵɵelementStart(56, "div", 32);
        ɵngcc0.ɵɵtemplate(57, IgxHierarchicalGridComponent_ng_template_57_Template, 0, 0, "ng-template", 33, 34, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(59, "div", 35);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(60, "div", 36);
        ɵngcc0.ɵɵelementStart(61, "igx-snackbar", 37, 38);
        ɵngcc0.ɵɵtext(63);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(64, "div", 39, 40);
        ɵngcc0.ɵɵlistener("focus", function IgxHierarchicalGridComponent_Template_div_focus_64_listener() { return ctx.navigation.focusFirstCell(false); })("keydown", function IgxHierarchicalGridComponent_Template_div_keydown_64_listener($event) { return ctx.navigation.summaryNav($event); });
        ɵngcc0.ɵɵtemplate(66, IgxHierarchicalGridComponent_igx_grid_summary_row_66_Template, 3, 10, "igx-grid-summary-row", 41);
        ɵngcc0.ɵɵelement(67, "div", 42);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(68, "div", 43, 44);
        ɵngcc0.ɵɵlistener("pointerdown", function IgxHierarchicalGridComponent_Template_div_pointerdown_68_listener($event) { return $event.preventDefault(); });
        ɵngcc0.ɵɵelement(70, "div", 45);
        ɵngcc0.ɵɵelementStart(71, "div", 46);
        ɵngcc0.ɵɵtemplate(72, IgxHierarchicalGridComponent_ng_template_72_Template, 0, 0, "ng-template", 33, 47, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(74, "div", 48);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(75, "div", 49, 50);
        ɵngcc0.ɵɵprojection(77);
        ɵngcc0.ɵɵtemplate(78, IgxHierarchicalGridComponent_ng_container_78_Template, 2, 4, "ng-container", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(79, IgxHierarchicalGridComponent_ng_template_79_Template, 1, 5, "ng-template", null, 51, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(81, IgxHierarchicalGridComponent_ng_template_81_Template, 4, 2, "ng-template", null, 52, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(83, IgxHierarchicalGridComponent_ng_template_83_Template, 4, 2, "ng-template", null, 53, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(85, IgxHierarchicalGridComponent_ng_template_85_Template, 2, 1, "ng-template", null, 54, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(87, IgxHierarchicalGridComponent_ng_template_87_Template, 2, 1, "ng-template", null, 55, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(89, IgxHierarchicalGridComponent_ng_template_89_Template, 2, 0, "ng-template", null, 56, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(91, IgxHierarchicalGridComponent_ng_template_91_Template, 2, 1, "ng-template", null, 57, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(93, IgxHierarchicalGridComponent_div_93_Template, 3, 6, "div", 58);
        ɵngcc0.ɵɵtemplate(94, IgxHierarchicalGridComponent_ng_template_94_Template, 1, 1, "ng-template", null, 59, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(96, IgxHierarchicalGridComponent_ng_template_96_Template, 4, 0, "ng-template", null, 60, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(98, IgxHierarchicalGridComponent_ng_template_98_Template, 4, 5, "ng-template", null, 61, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(100, IgxHierarchicalGridComponent_ng_template_100_Template, 2, 0, "ng-template", null, 62, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(102, IgxHierarchicalGridComponent_ng_template_102_Template, 3, 8, "ng-template", 63, 64, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(104, IgxHierarchicalGridComponent_igx_grid_column_resizer_104_Template, 1, 0, "igx-grid-column-resizer", 10);
        ɵngcc0.ɵɵelement(105, "div", 65, 66);
        ɵngcc0.ɵɵelementStart(107, "div", 67, 68);
        ɵngcc0.ɵɵlistener("keydown", function IgxHierarchicalGridComponent_Template_div_keydown_107_listener($event) { return ctx.gridOutletKeyboardHandler($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r19 = ɵngcc0.ɵɵreference(29);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToolbar);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length <= 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasExpandableChildren || !ctx.hasVisibleColumns)("ngClass", ɵngcc0.ɵɵpureFunction3(135, _c217, ctx.hasExpandableChildren, ctx.filteringService.isFilterRowVisible, ctx.isRowSelectable || ctx.rowDraggable));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.iconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(139, _c17, ctx));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowDraggable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showRowSelectors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(15, 90, ctx.unpinnedColumns))("igxForScrollOrientation", "horizontal")("igxForScrollContainer", ctx.parentVirtDir)("igxForContainerSize", ctx.unpinnedWidth)("igxForTrackBy", ctx.trackColumnChanges)("igxForSizePropName", "calcPixelWidth");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && !ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.filteringService.isFilterRowVisible);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldOverlayLoading);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollSize, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", ctx.totalHeight, "px")("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵproperty("igxGridDragSelect", ctx.selectionService.dragMode);
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length <= 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length > 0);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasPinnedRecords && ctx.isRowPinningToTop ? _r19 : null);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind3(33, 92, ɵngcc0.ɵɵpipeBind4(34, 96, ɵngcc0.ɵɵpipeBindV(35, 101, ɵngcc0.ɵɵpureFunction6(161, _c205, ɵngcc0.ɵɵpipeBindV(36, 108, ɵngcc0.ɵɵpureFunction5(155, _c66, ɵngcc0.ɵɵpipeBindV(37, 114, ɵngcc0.ɵɵpureFunction5(149, _c66, ɵngcc0.ɵɵpipeBindV(38, 120, ɵngcc0.ɵɵpureFunction7(141, _c183, ɵngcc0.ɵɵpipeBind2(39, 128, ɵngcc0.ɵɵpipeBind3(40, 131, ctx.data, ctx.id, ctx.pipeTrigger), ctx.hasVisibleColumns), ctx.filteringExpressionsTree, ctx.filterStrategy, ctx.advancedFilteringExpressionsTree, ctx.id, ctx.pipeTrigger, ctx.filteringPipeTrigger)), ctx.sortingExpressions, ctx.sortStrategy, ctx.id, ctx.pipeTrigger)), ctx.page, ctx.perPage, ctx.id, ctx.pipeTrigger)), ctx.expansionStates, ctx.id, ctx.primaryKey, ctx.childLayoutKeys, ctx.pipeTrigger)), ctx.id, false, ctx.pipeTrigger), false, ctx.pipeTrigger))("igxForScrollOrientation", "vertical")("igxForScrollContainer", ctx.verticalScroll)("igxForContainerSize", ctx.calcHeight)("igxForItemSize", ctx.renderedRowHeight)("igxForTrackBy", ctx.trackChanges);
        ɵngcc0.ɵɵadvance(16);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasPinnedRecords && !ctx.isRowPinningToTop ? _r19 : null);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.parent);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollSize, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.calcHeight, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpureFunction0(168, _c185));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", !ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, "px");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("actionText", ctx.snackbarActionText)("displayTime", ctx.snackbarDisplayTime);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.snackbarLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.summariesHeight, "px");
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasSummarizedColumns && ctx.rootSummariesEnabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.summariesHeight, "px")("width", ctx.scrollSize, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.scrollSize, "px");
        ɵngcc0.ɵɵproperty("hidden", ctx.isHorizontalScrollHidden);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, "px")("min-width", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.unpinnedWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpureFunction0(169, _c185));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("float", "right")("width", ctx.pinnedWidth, "px")("min-width", ctx.pinnedWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", ctx.pinnedWidth === 0 || ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.paging && ctx.totalRecords);
        ɵngcc0.ɵɵadvance(15);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowEditable);
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngIf", ctx.colResizingService.showResizer);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgClass, ɵngcc2.NgTemplateOutlet, IgxGridForOfDirective, IgxGridBodyDirective, IgxGridDragSelectDirective, IgxOverlayOutletDirective, IgxSnackbarComponent, IgxHeadSelectorDirective, IgxGridToolbarComponent, IgxColumnMovingDropDirective, ɵngcc2.NgForOf, IgxGridHeaderGroupComponent, IgxGridFilteringRowComponent, IgxCircularProgressBarComponent, IgxTemplateOutletDirective, IgxHierarchicalRowComponent, IgxChildGridRowComponent, IgxSummaryRowComponent, IgxPaginatorComponent, IgxButtonDirective, IgxRippleDirective, IgxIconComponent, IgxToggleDirective, IgxRowEditTabStopDirective, IgxCheckboxComponent, ɵngcc2.NgStyle, IgxGridColumnResizerComponent]; }, pipes: function () { return [IgxGridTopLevelColumns, IgxGridAddRowPipe, IgxGridRowPinningPipe, IgxGridHierarchicalPipe, IgxGridHierarchicalPagingPipe, IgxGridSortingPipe, IgxGridFilteringPipe, IgxHasVisibleColumnsPipe, IgxGridTransactionPipe, IgxSummaryDataPipe]; }, encapsulation: 2, changeDetection: 0 });
IgxHierarchicalGridComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    data: [{ type: Input }],
    expandChildren: [{ type: Input }],
    childLayoutList: [{ type: ContentChildren, args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false },] }],
    allLayoutList: [{ type: ContentChildren, args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: true },] }],
    hierarchicalRecordTemplate: [{ type: ViewChild, args: ['hierarchical_record_template', { read: TemplateRef, static: true },] }],
    childTemplate: [{ type: ViewChild, args: ['child_record_template', { read: TemplateRef, static: true },] }],
    headerHierarchyExpander: [{ type: ViewChild, args: ['headerHierarchyExpander', { read: ElementRef, static: true },] }],
    templateOutlets: [{ type: ViewChildren, args: [IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective },] }],
    hierarchicalRows: [{ type: ViewChildren, args: [IgxChildGridRowComponent, { read: IgxChildGridRowComponent },] }]
};

class IgxHierarchicalGridCellComponent extends IgxGridCellComponent {
    constructor(selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil) {
        super(selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil);
        this.selectionService = selectionService;
        this.crudService = crudService;
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.helement = helement;
        this.zone = zone;
        this.platformUtil = platformUtil;
    }
    ngOnInit() {
        super.ngOnInit();
        this._rootGrid = this._getRootGrid();
    }
    _getRootGrid() {
        let currGrid = this.grid;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
        }
        return currGrid;
    }
    // TODO: Extend the new selection service to avoid complete traversal
    _clearAllHighlights() {
        [this._rootGrid, ...this._rootGrid.getChildGrids(true)].forEach(grid => {
            if (grid !== this.grid && grid.navigation.activeNode) {
                grid.navigation.clearActivation();
                grid.selectionService.initKeyboardState();
                grid.selectionService.clear();
            }
            grid.selectionService.activeElement = null;
            grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
            grid.highlightedRowID = null;
            grid.cdr.markForCheck();
        });
    }
    /**
     * @hidden
     * @internal
     */
    activate(event) {
        this._clearAllHighlights();
        const currentElement = this.grid.nativeElement;
        let parentGrid = this.grid;
        let childGrid;
        // add highligh to the current grid
        if (this._rootGrid.id !== currentElement.id) {
            currentElement.classList.add('igx-grid__tr--highlighted');
        }
        // add highligh to the current grid
        while (this._rootGrid.id !== parentGrid.id) {
            childGrid = parentGrid;
            parentGrid = parentGrid.parent;
            const parentRowID = parentGrid.hgridAPI.getParentRowId(childGrid);
            parentGrid.highlightedRowID = parentRowID;
        }
        this.grid.navigation.activeNode.gridID = this.gridID;
        super.activate(event);
    }
}
IgxHierarchicalGridCellComponent.ɵfac = function IgxHierarchicalGridCellComponent_Factory(t) { return new (t || IgxHierarchicalGridCellComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(HammerGesturesManager), ɵngcc0.ɵɵdirectiveInject(PlatformUtil)); };
IgxHierarchicalGridCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxHierarchicalGridCellComponent, selectors: [["igx-hierarchical-grid-cell"]], features: [ɵngcc0.ɵɵProvidersFeature([HammerGesturesManager]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 4, consts: [["defaultPinnedIndicator", ""], ["defaultCell", ""], ["addRowCell", ""], ["inlineEditor", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity", 4, "ngIf"], [1, "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity"], ["igxTextHighlight", "", "class", "igx-grid__td-text", "style", "pointer-events: none;", 3, "cssClass", "activeCssClass", "groupName", "value", "row", "column", "containerClass", "metadata", 4, "ngIf"], [3, "ngClass", 4, "ngIf"], ["igxTextHighlight", "", 1, "igx-grid__td-text", 2, "pointer-events", "none", 3, "cssClass", "activeCssClass", "groupName", "value", "row", "column", "containerClass", "metadata"], [3, "ngClass"], [4, "ngIf"], ["displayDensity", "compact"], ["igxInput", "", 3, "value", "igxFocus", "input"], ["igxInput", "", "type", "number", 3, "value", "igxFocus", "input"], [3, "value", "checked", "igxFocus", "disableRipple", "change"], ["mode", "dropdown", 3, "outlet", "locale", "value", "igxFocus", "labelVisibility", "valueChange"]], template: function IgxHierarchicalGridCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridCellComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxHierarchicalGridCellComponent_ng_template_2_Template, 2, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxHierarchicalGridCellComponent_ng_template_4_Template, 5, 21, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxHierarchicalGridCellComponent_ng_template_6_Template, 4, 4, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, IgxHierarchicalGridCellComponent_ng_container_8_Template, 1, 0, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(9, IgxHierarchicalGridCellComponent_ng_container_9_Template, 1, 0, "ng-container", 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(8);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.pinnedIndicatorTemplate)("ngTemplateOutletContext", ctx.context);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
    } }, directives: [ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxChipComponent, IgxTextHighlightDirective, IgxIconComponent, ɵngcc2.NgClass, IgxInputGroupComponent, IgxInputDirective, IgxFocusDirective, IgxCheckboxComponent, IgxDatePickerComponent], pipes: [IgxColumnFormatterPipe, ɵngcc2.DecimalPipe, ɵngcc2.DatePipe], encapsulation: 2, changeDetection: 0 });
IgxHierarchicalGridCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];

class IgxHierarchicalRowComponent extends IgxRowDirective {
    constructor() {
        super(...arguments);
        this.expanderClass = 'igx-grid__hierarchical-expander';
        /**
         * @hidden
         * @internal
         */
        this.select = () => {
            this.grid.selectRows([this.rowID]);
        };
        /**
         * @hidden
         * @internal
         */
        this.deselect = () => {
            this.grid.deselectRows([this.rowID]);
        };
    }
    /**
     * @hidden
     */
    get expanderClassResolved() {
        return {
            [this.expanderClass]: !this.pinned || this.disabled,
            [`${this.expanderClass}--empty`]: this.pinned && !this.disabled
        };
    }
    get viewIndex() {
        return this.index + this.grid.page * this.grid.perPage;
    }
    /**
     * Returns whether the row is expanded.
     * ```typescript
     * const RowExpanded = this.grid1.rowList.first.expanded;
     * ```
     */
    get expanded() {
        return this.gridAPI.get_row_expansion_state(this.rowData);
    }
    /**
     * @hidden
     */
    get expandedClass() {
        return this.expanded && !this.pinned;
    }
    get hasChildren() {
        return !!this.grid.childLayoutKeys.length;
    }
    /**
     * @hidden
     */
    get highlighted() {
        return this.grid && this.grid.highlightedRowID === this.rowID;
    }
    /**
     * @hidden
     */
    expanderClick(event) {
        event.stopPropagation();
        this.toggle();
    }
    /**
     * Toggles the hierarchical row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     */
    toggle() {
        if (this.added) {
            return;
        }
        const grid = this.gridAPI.grid;
        this.endEdit(grid.rootGrid);
        this.gridAPI.set_row_expansion_state(this.rowID, !this.expanded);
        grid.cdr.detectChanges();
    }
    /**
     * @hidden
     */
    get iconTemplate() {
        let expandable = true;
        if (this.grid.hasChildrenKey) {
            expandable = this.rowData[this.grid.hasChildrenKey];
        }
        if (!expandable || (this.pinned && !this.disabled)) {
            return this.defaultEmptyTemplate;
        }
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    endEdit(grid) {
        if (grid.crudService.cellInEditMode) {
            grid.endEdit();
        }
        grid.hgridAPI.getChildGrids(true).forEach(g => {
            if (g.crudService.cellInEditMode) {
                g.endEdit();
            }
        });
    }
}
IgxHierarchicalRowComponent.ɵfac = function IgxHierarchicalRowComponent_Factory(t) { return ɵIgxHierarchicalRowComponent_BaseFactory(t || IgxHierarchicalRowComponent); };
IgxHierarchicalRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxHierarchicalRowComponent, selectors: [["igx-hierarchical-grid-row"]], viewQuery: function IgxHierarchicalRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c218, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c135, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c219, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c136, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(IgxHierarchicalGridCellComponent, true, IgxHierarchicalGridCellComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.expander = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExpandedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultEmptyTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultCollapsedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._cells = _t);
    } }, hostVars: 4, hostBindings: function IgxHierarchicalRowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-grid__tr--expanded", ctx.expandedClass)("igx-grid__tr--highlighted", ctx.highlighted);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxHierarchicalRowComponent) }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 1, consts: [[4, "ngTemplateOutlet"], ["defaultExpandedTemplate", ""], ["defaultCollapsedTemplate", ""], ["defaultEmptyTemplate", ""], ["addTemp", ""], ["defaultTemp", ""], ["fontSet", "material", 3, "isActive"], ["fontSet", "material"], [1, "igx-grid__tr--inner", 3, "animationend"], [3, "ngClass", "click", "mousedown", 4, "ngIf"], [4, "ngIf"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollContainer", "igxForSizePropName", "igxForScrollOrientation", "igxForContainerSize", "igxForTrackBy"], ["igxDirRef", ""], ["rowSelectorBaseTemplate", ""], ["pinnedCellsTemplate", ""], [3, "ngClass", "click", "mousedown"], ["expander", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "igxRowDrag", "ghostTemplate", "click", "pointerdown"], [1, "igx-grid__cbx-selection", 3, "click", "pointerdown"], [1, "igx-grid__td", "igx-grid__td--fw", 3, "ngClass", "ngStyle", "editMode", "column", "formatter", "row", "active", "rowData", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "cellSelectionMode", "displayPinnedChip"], [1, "igx-grid__cbx-padding"], ["disableRipple", "true", 3, "tabindex", "readonly", "checked", "disabled", "disableTransitions", "aria-label"], ["class", "igx-grid__td igx-grid__td--fw igx-grid__td--pinned", 3, "igx-grid__td--edited", "igx-grid__td--number", "ngClass", "ngStyle", "editMode", "column", "formatter", "row", "active", "firstPinned", "lastPinned", "min-height", "rowData", "min-width", "max-width", "flex-basis", "left", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "cellSelectionMode", "displayPinnedChip", 4, "ngFor", "ngForOf"], [1, "igx-grid__td", "igx-grid__td--fw", "igx-grid__td--pinned", 3, "ngClass", "ngStyle", "editMode", "column", "formatter", "row", "active", "firstPinned", "lastPinned", "rowData", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "cellSelectionMode", "displayPinnedChip"]], template: function IgxHierarchicalRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, IgxHierarchicalRowComponent_ng_template_1_Template, 2, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(3, IgxHierarchicalRowComponent_ng_template_3_Template, 2, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, IgxHierarchicalRowComponent_ng_template_5_Template, 1, 0, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(7, IgxHierarchicalRowComponent_ng_template_7_Template, 2, 3, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(9, IgxHierarchicalRowComponent_ng_template_9_Template, 12, 13, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r7 = ɵngcc0.ɵɵreference(8);
        const _r9 = ɵngcc0.ɵɵreference(10);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.addRow ? _r7 : _r9);
    } }, directives: [ɵngcc2.NgTemplateOutlet, IgxIconComponent, ɵngcc2.NgIf, IgxGridForOfDirective, ɵngcc2.NgClass, IgxRowDragDirective, IgxHierarchicalGridCellComponent, ɵngcc2.NgStyle, IgxCheckboxComponent, ɵngcc2.NgForOf], pipes: [IgxGridNotGroupedPipe, IgxGridTransactionStatePipe, IgxStringReplacePipe, IgxGridCellStyleClassesPipe, IgxGridCellStylesPipe, IgxGridDataMapperPipe], encapsulation: 2, changeDetection: 0 });
IgxHierarchicalRowComponent.propDecorators = {
    _cells: [{ type: ViewChildren, args: [forwardRef(() => IgxHierarchicalGridCellComponent), { read: IgxHierarchicalGridCellComponent },] }],
    expander: [{ type: ViewChild, args: ['expander', { read: ElementRef },] }],
    defaultExpandedTemplate: [{ type: ViewChild, args: ['defaultExpandedTemplate', { read: TemplateRef, static: true },] }],
    defaultEmptyTemplate: [{ type: ViewChild, args: ['defaultEmptyTemplate', { read: TemplateRef, static: true },] }],
    defaultCollapsedTemplate: [{ type: ViewChild, args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true },] }],
    expandedClass: [{ type: HostBinding, args: ['class.igx-grid__tr--expanded',] }],
    highlighted: [{ type: HostBinding, args: ['class.igx-grid__tr--highlighted',] }]
};

/**
 * @hidden
 */
class IgxGridHierarchicalPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, state = new Map(), id, primaryKey, childKeys, pipeTrigger) {
        if (childKeys.length === 0) {
            return collection;
        }
        const grid = this.gridAPI.grid;
        if (grid.verticalScrollContainer.isRemote) {
            return collection;
        }
        const result = this.addHierarchy(grid, cloneArray(collection), state, primaryKey, childKeys);
        return result;
    }
    addHierarchy(grid, data, state, primaryKey, childKeys) {
        const result = [];
        data.forEach((v) => {
            result.push(v);
            const childGridsData = {};
            childKeys.forEach((childKey) => {
                const childData = v[childKey] ? v[childKey] : null;
                childGridsData[childKey] = childData;
            });
            if (grid.gridAPI.get_row_expansion_state(v)) {
                result.push({ rowID: primaryKey ? v[primaryKey] : v, childGridsData: childGridsData });
            }
        });
        return result;
    }
}
IgxGridHierarchicalPipe.ɵfac = function IgxGridHierarchicalPipe_Factory(t) { return new (t || IgxGridHierarchicalPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridHierarchicalPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridHierarchical", type: IgxGridHierarchicalPipe, pure: true });
IgxGridHierarchicalPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
class IgxGridHierarchicalPagingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, page = 0, perPage = 15, id, pipeTrigger) {
        if (!this.gridAPI.grid.paging || this.gridAPI.grid.pagingMode !== GridPagingMode.local) {
            return collection;
        }
        const state = {
            index: page,
            recordsPerPage: perPage
        };
        const total = this.gridAPI.grid._totalRecords >= 0 ? this.gridAPI.grid._totalRecords : collection.length;
        const result = DataUtil.page(cloneArray(collection), state, total);
        this.gridAPI.grid.pagingState = state;
        return result;
    }
}
IgxGridHierarchicalPagingPipe.ɵfac = function IgxGridHierarchicalPagingPipe_Factory(t) { return new (t || IgxGridHierarchicalPagingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridHierarchicalPagingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridHierarchicalPaging", type: IgxGridHierarchicalPagingPipe, pure: true });
IgxGridHierarchicalPagingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/**
 * @hidden
 */
class IgxHierarchicalGridModule {
}
IgxHierarchicalGridModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxHierarchicalGridModule });
IgxHierarchicalGridModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxHierarchicalGridModule_Factory(t) { return new (t || IgxHierarchicalGridModule)(); }, imports: [[
            IgxGridModule,
        ], IgxGridModule] });

/**
 * IgxActionIcon is a container for the action nav icon of the IgxNavbar.
 */
class IgxNavbarActionDirective {
}
IgxNavbarActionDirective.ɵfac = function IgxNavbarActionDirective_Factory(t) { return new (t || IgxNavbarActionDirective)(); };
IgxNavbarActionDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxNavbarActionDirective, selectors: [["igx-navbar-action"], ["", "igxNavbarAction", ""]] });
class IgxNavbarTitleDirective {
}
IgxNavbarTitleDirective.ɵfac = function IgxNavbarTitleDirective_Factory(t) { return new (t || IgxNavbarTitleDirective)(); };
IgxNavbarTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxNavbarTitleDirective, selectors: [["igx-navbar-title"], ["", "igxNavbarTitle", ""]] });
let NEXT_ID$r = 0;
/**
 * **Ignite UI for Angular Navbar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navbar.html)
 *
 * The Ignite UI Navbar is most commonly used to provide an app header with a hamburger menu and navigation
 * state such as a "Go Back" button. It also supports other actions represented by icons.
 *
 * Example:
 * ```html
 * <igx-navbar title="Sample App" actionButtonIcon="menu">
 *   <igx-icon>search</igx-icon>
 *   <igx-icon>favorite</igx-icon>
 *   <igx-icon>more_vert</igx-icon>
 * </igx-navbar>
 * ```
 */
class IgxNavbarComponent {
    constructor() {
        this.isVisible = true;
        /**
         * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-navbar [id]="'igx-navbar-12'" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.id = `igx-navbar-${NEXT_ID$r++}`;
        /**
         * The event that will be thrown when the action is executed,
         * provides reference to the `IgxNavbar` component as argument
         * ```typescript
         * public actionExc(event){
         *     alert("Action Execute!");
         * }
         *  //..
         * ```
         * ```html
         * <igx-navbar (onAction)="actionExc($event)" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.onAction = new EventEmitter();
        /**
         * An @Input property that sets the titleId of the `IgxNavbarComponent`. If not set it will be automatically generated.
         * ```html
         * <igx-navbar [titleId]="'igx-navbar-7'" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.titleId = `igx-navbar-${IgxNavbarComponent.NEXT_ID++}`;
    }
    /**
     * Returns whether the `IgxNavbarComponent` action button is visible, true/false.
     * ```typescript
     *  @ViewChild("MyChild")
     * public navBar: IgxNavbarComponent;
     * ngAfterViewInit(){
     *     let actionButtonVisibile = this.navBar.isActionButtonVisible;
     * }
     * ```
     */
    get isActionButtonVisible() {
        if (this.actionIconTemplate || !this.actionButtonIcon) {
            return false;
        }
        return this.isVisible;
    }
    get isTitleContentVisible() {
        return this.titleContent ? true : false;
    }
    /**
     * Sets whether the action button of the `IgxNavbarComponent` is visible.
     * ```html
     * <igx-navbar [title]="currentView" [isActionButtonVisible]="'false'"></igx-navbar>
     * ```
     */
    set isActionButtonVisible(value) {
        this.isVisible = value;
    }
    /**
     * @hidden
     */
    _triggerAction() {
        this.onAction.emit(this);
    }
}
IgxNavbarComponent.ɵfac = function IgxNavbarComponent_Factory(t) { return new (t || IgxNavbarComponent)(); };
IgxNavbarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxNavbarComponent, selectors: [["igx-navbar"]], contentQueries: function IgxNavbarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxNavbarActionDirective, true, IgxNavbarActionDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxNavbarTitleDirective, true, IgxNavbarTitleDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.actionIconTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.titleContent = _t.first);
    } }, hostVars: 1, hostBindings: function IgxNavbarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { id: "id", titleId: "titleId", isActionButtonVisible: "isActionButtonVisible", actionButtonIcon: "actionButtonIcon", title: "title" }, outputs: { onAction: "onAction" }, ngContentSelectors: _c222, decls: 8, vars: 3, consts: [["role", "navigation", 1, "igx-navbar"], [1, "igx-navbar__left"], ["fontSet", "material", 3, "click", 4, "ngIf"], ["class", "igx-navbar__title", 4, "ngIf"], [1, "igx-navbar__right"], ["fontSet", "material", 3, "click"], [1, "igx-navbar__title"]], template: function IgxNavbarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c221);
        ɵngcc0.ɵɵelementStart(0, "nav", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, IgxNavbarComponent_igx_icon_2_Template, 2, 1, "igx-icon", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵtemplate(4, IgxNavbarComponent_h1_4_Template, 2, 2, "h1", 3);
        ɵngcc0.ɵɵprojection(5, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "div", 4);
        ɵngcc0.ɵɵprojection(7, 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-labelledby", ctx.titleId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isActionButtonVisible);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isTitleContentVisible);
    } }, directives: [ɵngcc2.NgIf, IgxIconComponent], styles: [_c80] });
IgxNavbarComponent.NEXT_ID = 1;
IgxNavbarComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    isActionButtonVisible: [{ type: Input }],
    actionButtonIcon: [{ type: Input }],
    title: [{ type: Input }],
    onAction: [{ type: Output }],
    titleId: [{ type: Input }],
    actionIconTemplate: [{ type: ContentChild, args: [IgxNavbarActionDirective, { read: IgxNavbarActionDirective },] }],
    titleContent: [{ type: ContentChild, args: [IgxNavbarTitleDirective, { read: IgxNavbarTitleDirective },] }]
};
/**
 * @hidden
 */
class IgxNavbarModule {
}
IgxNavbarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxNavbarModule });
IgxNavbarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxNavbarModule_Factory(t) { return new (t || IgxNavbarModule)(); }, imports: [[IgxButtonModule, IgxIconModule, CommonModule]] });

class IgxNavDrawerItemDirective {
    constructor() {
        /**
         * @hidden
         */
        this.active = false;
        /**
         * @hidden
         */
        this.isHeader = false;
        /**
         * @hidden
         */
        this.activeClass = 'igx-nav-drawer__item--active';
    }
    /**
     * @hidden
     */
    get defaultCSS() {
        return !this.active && !this.isHeader;
    }
    /**
     * @hidden
     */
    get currentCSS() {
        return this.active && !this.isHeader;
    }
    /**
     * @hidden
     */
    get headerCSS() {
        return this.isHeader;
    }
}
IgxNavDrawerItemDirective.ɵfac = function IgxNavDrawerItemDirective_Factory(t) { return new (t || IgxNavDrawerItemDirective)(); };
IgxNavDrawerItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxNavDrawerItemDirective, selectors: [["", "igxDrawerItem", ""]], hostVars: 6, hostBindings: function IgxNavDrawerItemDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-nav-drawer__item", ctx.defaultCSS)("igx-nav-drawer__item--active", ctx.currentCSS)("igx-nav-drawer__item--header", ctx.headerCSS);
    } }, inputs: { active: "active", isHeader: "isHeader" }, exportAs: ["igxDrawerItem"] });
IgxNavDrawerItemDirective.propDecorators = {
    active: [{ type: Input, args: ['active',] }],
    isHeader: [{ type: Input, args: ['isHeader',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-nav-drawer__item',] }],
    currentCSS: [{ type: HostBinding, args: ['class.igx-nav-drawer__item--active',] }],
    headerCSS: [{ type: HostBinding, args: ['class.igx-nav-drawer__item--header',] }]
};
class IgxNavDrawerTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxNavDrawerTemplateDirective.ɵfac = function IgxNavDrawerTemplateDirective_Factory(t) { return new (t || IgxNavDrawerTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxNavDrawerTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxNavDrawerTemplateDirective, selectors: [["", "igxDrawer", ""]] });
IgxNavDrawerTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class IgxNavDrawerMiniTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxNavDrawerMiniTemplateDirective.ɵfac = function IgxNavDrawerMiniTemplateDirective_Factory(t) { return new (t || IgxNavDrawerMiniTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxNavDrawerMiniTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxNavDrawerMiniTemplateDirective, selectors: [["", "igxDrawerMini", ""]] });
IgxNavDrawerMiniTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

let NEXT_ID$s = 0;
/**
 * **Ignite UI for Angular Navigation Drawer** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer)
 *
 * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
 *
 * Example:
 * ```html
 * <igx-nav-drawer id="navigation" [isOpen]="true">
 *   <ng-template igxDrawer>
 *     <nav>
 *       <span igxDrawerItem [isHeader]="true">Email</span>
 *       <span igxDrawerItem igxRipple>Inbox</span>
 *       <span igxDrawerItem igxRipple>Deleted</span>
 *       <span igxDrawerItem igxRipple>Sent</span>
 *     </nav>
 *   </ng-template>
 * </igx-nav-drawer>
 * ```
 */
class IgxNavigationDrawerComponent {
    constructor(elementRef, _state, renderer, _touchManager, platformUtil) {
        this.elementRef = elementRef;
        this._state = _state;
        this.renderer = renderer;
        this._touchManager = _touchManager;
        this.platformUtil = platformUtil;
        this._isOpen = false;
        /** @hidden @internal */
        this.cssClass = true;
        /**
         * ID of the component
         *
         * ```typescript
         * // get
         * let myNavDrawerId = this.navdrawer.id;
         * ```
         *
         * ```html
         * <!--set-->
         *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
         * ```
         */
        this.id = `igx-nav-drawer-${NEXT_ID$s++}`;
        /**
         * Position of the Navigation Drawer. Can be "left"(default) or "right".
         *
         * ```typescript
         * // get
         * let myNavDrawerPosition = this.navdrawer.position;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
         * ```
         */
        this.position = 'left';
        /**
         * Enables the use of touch gestures to manipulate the drawer:
         * - swipe/pan from edge to open, swipe-toggle and pan-drag.
         *
         * ```typescript
         * // get
         * let gesturesEnabled = this.navdrawer.enableGestures;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
         * ```
         */
        this.enableGestures = true;
        /**
         * @hidden
         */
        this.isOpenChange = new EventEmitter();
        /**
         * When pinned the drawer is relatively positioned instead of sitting above content.
         * May require additional layout styling.
         *
         * ```typescript
         * // get
         * let navDrawerIsPinned = this.navdrawer.pin;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
         * ```
         */
        this.pin = false;
        /**
         * Minimum device width required for automatic pin to be toggled.
         * Default is 1024, can be set to a falsy value to disable this behavior.
         *
         * ```typescript
         * // get
         * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
         * ```
         */
        this.pinThreshold = 1024;
        /**
         * Width of the drawer in its open state. Defaults to "280px".
         *
         * ```typescript
         * // get
         * let navDrawerWidth = this.navdrawer.width;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
         * ```
         */
        this.width = '280px';
        /**
         * Enables/disables the animation, when toggling the drawer. Set to `false` by default.
         * ````html
         * <igx-nav-drawer [disableAnimation]="true"></igx-nav-drawer>
         * ````
         */
        this.disableAnimation = false;
        /**
         * Width of the drawer in its mini state. Defaults to 68px.
         *
         * ```typescript
         * // get
         * let navDrawerMiniWidth = this.navdrawer.miniWidth;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
         * ```
         */
        this.miniWidth = '68px';
        /**
         * Pinned state change output for two-way binding.
         *
         * ```html
         * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
         * ```
         */
        this.pinChange = new EventEmitter(true);
        /**
         * Event fired as the Navigation Drawer is about to open.
         *
         * ```html
         *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
         * ```
         */
        this.opening = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has opened.
         *
         * ```html
         * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
         * ```
         */
        this.opened = new EventEmitter();
        /**
         * Event fired as the Navigation Drawer is about to close.
         *
         * ```html
         * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
         * ```
         */
        this.closing = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has closed.
         *
         * ```html
         * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
         * ```
         */
        this.closed = new EventEmitter();
        this._gesturesAttached = false;
        this._widthCache = { width: null, miniWidth: null, windowWidth: null };
        this.css = {
            drawer: 'igx-nav-drawer__aside',
            mini: 'igx-nav-drawer__aside--mini',
            overlay: 'igx-nav-drawer__overlay',
            styleDummy: 'igx-nav-drawer__style-dummy'
        };
        /** Pan animation properties */
        this._panning = false;
        this._maxEdgeZone = 50;
        this.checkPinThreshold = (evt) => {
            if (!this.platformUtil.isBrowser) {
                return;
            }
            let windowWidth;
            if (this.pinThreshold) {
                windowWidth = this.getWindowWidth();
                if (evt && this._widthCache.windowWidth === windowWidth) {
                    return;
                }
                this._widthCache.windowWidth = windowWidth;
                if (!this.pin && windowWidth >= this.pinThreshold) {
                    this.pin = true;
                    this.pinChange.emit(true);
                }
                else if (this.pin && windowWidth < this.pinThreshold) {
                    this.pin = false;
                    this.pinChange.emit(false);
                }
            }
        };
        this.swipe = (evt) => {
            // TODO: Could also force input type: http://stackoverflow.com/a/27108052
            if (!this.enableGestures || evt.pointerType !== 'touch') {
                return;
            }
            // HammerJS swipe is horizontal-only by default, don't check deltaY
            let deltaX;
            let startPosition;
            if (this.position === 'right') {
                // when on the right use inverse of deltaX
                deltaX = -evt.deltaX;
                startPosition = this.getWindowWidth() - (evt.center.x + evt.distance);
            }
            else {
                deltaX = evt.deltaX;
                startPosition = evt.center.x - evt.distance;
            }
            // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
            if ((this.isOpen && deltaX < 0) ||
                // positive deltaX from the edge:
                (deltaX > 0 && startPosition < this.maxEdgeZone)) {
                this.toggle();
            }
        };
        this.panstart = (evt) => {
            if (!this.enableGestures || this.pin || evt.pointerType !== 'touch') {
                return;
            }
            const startPosition = this.position === 'right' ? this.getWindowWidth() - (evt.center.x + evt.distance)
                : evt.center.x - evt.distance;
            // cache width during animation, flag to allow further handling
            if (this.isOpen || (startPosition < this.maxEdgeZone)) {
                this._panning = true;
                this._panStartWidth = this.getExpectedWidth(!this.isOpen);
                this._panLimit = this.getExpectedWidth(this.isOpen);
                this.renderer.addClass(this.overlay, 'panning');
                this.renderer.addClass(this.drawer, 'panning');
            }
        };
        this.pan = (evt) => {
            // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
            // get actual delta (not total session one) from event?
            // pan WILL also fire after a full swipe, only resize on flag
            if (!this._panning) {
                return;
            }
            const right = this.position === 'right';
            // when on the right use inverse of deltaX
            const deltaX = right ? -evt.deltaX : evt.deltaX;
            let visibleWidth;
            let newX;
            let percent;
            visibleWidth = this._panStartWidth + deltaX;
            if (this.isOpen && deltaX < 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth <= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panLimit) / (this._panStartWidth - this._panLimit);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panStartWidth;
                    newX = evt.deltaX;
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
            else if (!this.isOpen && deltaX > 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth >= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panStartWidth) / (this._panLimit - this._panStartWidth);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panLimit;
                    newX = (this._panLimit - visibleWidth) * (right ? 1 : -1);
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
        };
        this.panEnd = (evt) => {
            if (this._panning) {
                const deltaX = this.position === 'right' ? -evt.deltaX : evt.deltaX;
                const visibleWidth = this._panStartWidth + deltaX;
                this.resetPan();
                // check if pan brought the drawer to 50%
                if (this.isOpen && visibleWidth <= this._panStartWidth / 2) {
                    this.close();
                }
                else if (!this.isOpen && visibleWidth >= this._panLimit / 2) {
                    this.open();
                }
                this._panStartWidth = null;
            }
        };
        this.toggleOpenedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleOpenedEvent, false);
            this.opened.emit();
        };
        this.toggleClosedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleClosedEvent, false);
            this.closed.emit();
        };
    }
    /**
     * State of the drawer.
     *
     * ```typescript
     * // get
     * let navDrawerIsOpen = this.navdrawer.isOpen;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <!--set-->
     * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>
     * ```
     */
    get isOpen() {
        return this._isOpen;
    }
    set isOpen(value) {
        this._isOpen = value;
        this.isOpenChange.emit(this._isOpen);
    }
    /**
     * Returns nativeElement of the component.
     *
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get template() {
        if (this.miniTemplate && !this.isOpen) {
            return this.miniTemplate.template;
        }
        else if (this.contentTemplate) {
            return this.contentTemplate.template;
        }
    }
    /**
     * @hidden
     */
    get miniTemplate() {
        return this._miniTemplate;
    }
    /**
     * @hidden
     */
    set miniTemplate(v) {
        if (!this.isOpen) {
            this.setDrawerWidth(v ? this.miniWidth : '');
        }
        this._miniTemplate = v;
    }
    /**
     * @hidden
     */
    get flexWidth() {
        if (!this.pin) {
            return '0px';
        }
        if (this.isOpen) {
            return this.width;
        }
        if (this.miniTemplate && this.miniWidth) {
            return this.miniWidth;
        }
        return '0px';
    }
    /** @hidden */
    get isPinnedRight() {
        return this.pin && this.position === 'right' ? '1' : '0';
    }
    /**
     * @hidden
     */
    get drawer() {
        return this._drawer.nativeElement;
    }
    /**
     * @hidden
     */
    get overlay() {
        return this._overlay.nativeElement;
    }
    /**
     * @hidden
     */
    get styleDummy() {
        return this._styleDummy.nativeElement;
    }
    /**
     * Property to decide whether to change width or translate the drawer from pan gesture.
     *
     * @hidden
     */
    get hasAnimateWidth() {
        return this.pin || !!this.miniTemplate;
    }
    /**
     * Used for touch gestures (swipe and pan).
     * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
     *
     * @hidden
     */
    get maxEdgeZone() {
        return this._maxEdgeZone;
    }
    /**
     * Gets the Drawer width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     *
     * @hidden
     */
    get expectedWidth() {
        return this.getExpectedWidth(false);
    }
    /**
     * Get the Drawer mini width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     * @hidden
     */
    get expectedMiniWidth() {
        return this.getExpectedWidth(true);
    }
    /**
     * @hidden
     */
    get touchManager() {
        return this._touchManager;
    }
    /**
     * Exposes optional navigation service
     *
     * @hidden
     */
    get state() {
        return this._state;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        // DOM and @Input()-s initialized
        if (this._state) {
            this._state.add(this.id, this);
        }
        if (this.isOpen) {
            this.setDrawerWidth(this.width);
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        // wait for template and ng-content to be ready
        this.updateEdgeZone();
        this.checkPinThreshold();
        this.ensureEvents();
        // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
        // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._touchManager.destroy();
        if (this._state) {
            this._state.remove(this.id);
        }
        if (this._resizeObserver) {
            this._resizeObserver.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
        if (changes.enableGestures && changes.enableGestures.currentValue !== undefined) {
            this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
            this.ensureEvents();
        }
        if (changes.pin && changes.pin.currentValue !== undefined) {
            this.pin = !!(this.pin && this.pin.toString() === 'true');
            if (this.pin) {
                this._touchManager.destroy();
                this._gesturesAttached = false;
            }
            else {
                this.ensureEvents();
            }
        }
        if (changes.pinThreshold) {
            if (this.pinThreshold) {
                this.ensureEvents();
                this.checkPinThreshold();
            }
        }
        if (changes.width && this.isOpen) {
            this.setDrawerWidth(changes.width.currentValue);
        }
        if (changes.isOpen) {
            this.setDrawerWidth(this.isOpen ? this.width : (this.miniTemplate ? this.miniWidth : ''));
        }
        if (changes.miniWidth) {
            if (!this.isOpen) {
                this.setDrawerWidth(changes.miniWidth.currentValue);
            }
            this.updateEdgeZone();
        }
    }
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     */
    toggle() {
        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     */
    open() {
        if (this._panning) {
            this.resetPan();
        }
        if (this.isOpen) {
            return;
        }
        this.opening.emit();
        this.isOpen = true;
        // TODO: Switch to animate API when available
        // var animationCss = this.animate.css();
        //     animationCss
        //         .setStyles({'width':'50px'}, {'width':'400px'})
        //         .start(this.elementRef.nativeElement)
        //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
        this.setDrawerWidth(this.width);
    }
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     */
    close() {
        if (this._panning) {
            this.resetPan();
        }
        if (!this.isOpen) {
            return;
        }
        this.closing.emit();
        this.isOpen = false;
        this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
    }
    /**
     * @hidden
     */
    set_maxEdgeZone(value) {
        this._maxEdgeZone = value;
    }
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @param [mini] - Request mini width instead
     */
    getExpectedWidth(mini) {
        if (mini) {
            if (!this.miniTemplate) {
                return 0;
            }
            if (this.miniWidth) {
                return parseFloat(this.miniWidth);
            }
            else {
                // if (!this.isOpen) { // This WON'T work due to transition timings...
                //     return this.elementRef.nativeElement.children[1].offsetWidth;
                // } else {
                if (this._widthCache.miniWidth === null) {
                    // force class for width calc. TODO?
                    // force class for width calc. TODO?
                    this.renderer.addClass(this.styleDummy, this.css.drawer);
                    this.renderer.addClass(this.styleDummy, this.css.mini);
                    this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                    this.renderer.removeClass(this.styleDummy, this.css.drawer);
                    this.renderer.removeClass(this.styleDummy, this.css.mini);
                }
                return this._widthCache.miniWidth;
            }
        }
        else {
            if (this.width) {
                return parseFloat(this.width);
            }
            else {
                if (this._widthCache.width === null) {
                    // force class for width calc. TODO?
                    // force class for width calc. TODO?
                    this.renderer.addClass(this.styleDummy, this.css.drawer);
                    this._widthCache.width = this.styleDummy.offsetWidth;
                    this.renderer.removeClass(this.styleDummy, this.css.drawer);
                }
                return this._widthCache.width;
            }
        }
    }
    getWindowWidth() {
        return (window.innerWidth > 0) ? window.innerWidth : screen.width;
    }
    /**
     * Sets the drawer width.
     */
    setDrawerWidth(width) {
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(() => {
                if (this.drawer) {
                    this.renderer.setStyle(this.drawer, 'width', width);
                }
            });
        }
        else {
            this.renderer.setStyle(this.drawer, 'width', width);
        }
    }
    /**
     * Get current Drawer width.
     */
    getDrawerWidth() {
        return this.drawer.offsetWidth;
    }
    ensureEvents() {
        // set listeners for swipe/pan only if needed, but just once
        if (this.enableGestures && !this.pin && !this._gesturesAttached) {
            // Built-in manager handler(L20887) causes endless loop and max stack exception.
            // https://github.com/angular/angular/issues/6993
            // Use ours for now (until beta.10):
            // this.renderer.listen(document, "swipe", this.swipe);
            this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);
            this._gesturesAttached = true;
            // this.renderer.listen(document, "panstart", this.panstart);
            // this.renderer.listen(document, "pan", this.pan);
            this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);
            this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);
            this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
        }
        if (!this._resizeObserver && this.platformUtil.isBrowser) {
            this._resizeObserver = fromEvent(window, 'resize').pipe(debounce(() => interval(150)))
                .subscribe((value) => {
                this.checkPinThreshold(value);
            });
        }
    }
    updateEdgeZone() {
        let maxValue;
        if (this.miniTemplate) {
            maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
            this.set_maxEdgeZone(maxValue);
        }
    }
    resetPan() {
        this._panning = false;
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        this.renderer.removeClass(this.overlay, 'panning');
        this.renderer.removeClass(this.drawer, 'panning');
        this.setXSize(0, '');
    }
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @param x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param opacity optional value to apply to the overlay
     */
    setXSize(x, opacity) {
        // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
        window.requestAnimationFrame(() => {
            if (this.hasAnimateWidth) {
                this.renderer.setStyle(this.drawer, 'width', x ? Math.abs(x) + 'px' : '');
            }
            else {
                this.renderer.setStyle(this.drawer, 'transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
                this.renderer.setStyle(this.drawer, '-webkit-transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
            }
            if (opacity !== undefined) {
                this.renderer.setStyle(this.overlay, 'opacity', opacity);
            }
        });
    }
}
IgxNavigationDrawerComponent.ɵfac = function IgxNavigationDrawerComponent_Factory(t) { return new (t || IgxNavigationDrawerComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HammerGesturesManager), ɵngcc0.ɵɵdirectiveInject(PlatformUtil)); };
IgxNavigationDrawerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxNavigationDrawerComponent, selectors: [["igx-nav-drawer"]], contentQueries: function IgxNavigationDrawerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxNavDrawerMiniTemplateDirective, true, IgxNavDrawerMiniTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxNavDrawerTemplateDirective, true, IgxNavDrawerTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.miniTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
    } }, viewQuery: function IgxNavigationDrawerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c223, true);
        ɵngcc0.ɵɵstaticViewQuery(_c224, true);
        ɵngcc0.ɵɵstaticViewQuery(_c225, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._drawer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._overlay = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._styleDummy = _t.first);
    } }, hostVars: 9, hostBindings: function IgxNavigationDrawerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵstyleProp("flex-basis", ctx.flexWidth)("order", ctx.isPinnedRight);
        ɵngcc0.ɵɵclassProp("igx-nav-drawer", ctx.cssClass)("igx-nav-drawer--disable-animation", ctx.disableAnimation);
    } }, inputs: { id: "id", position: "position", enableGestures: "enableGestures", pin: "pin", pinThreshold: "pinThreshold", width: "width", disableAnimation: "disableAnimation", miniWidth: "miniWidth", isOpen: "isOpen" }, outputs: { isOpenChange: "isOpenChange", pinChange: "pinChange", opening: "opening", opened: "opened", closing: "closing", closed: "closed" }, features: [ɵngcc0.ɵɵProvidersFeature([HammerGesturesManager]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 9, vars: 18, consts: [["defaultItemsTemplate", ""], [1, "igx-nav-drawer__overlay", 3, "hidden", "click"], ["overlay", ""], ["role", "navigation", 1, "igx-nav-drawer__aside"], ["aside", ""], [4, "ngTemplateOutlet"], [1, "igx-nav-drawer__style-dummy"], ["dummy", ""], ["igxDrawerItem", "", 3, "isHeader"], ["igxDrawerItem", ""]], template: function IgxNavigationDrawerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxNavigationDrawerComponent_ng_template_0_Template, 13, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵlistener("click", function IgxNavigationDrawerComponent_Template_div_click_2_listener() { return ctx.close(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "aside", 3, 4);
        ɵngcc0.ɵɵtemplate(6, IgxNavigationDrawerComponent_ng_container_6_Template, 1, 0, "ng-container", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(7, "div", 6, 7);
    } if (rf & 2) {
        const _r0 = ɵngcc0.ɵɵreference(1);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("igx-nav-drawer__overlay--hidden", !ctx.isOpen)("igx-nav-drawer--disable-animation", ctx.disableAnimation);
        ɵngcc0.ɵɵproperty("hidden", ctx.pin);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("igx-nav-drawer__aside--collapsed", !ctx.miniTemplate && !ctx.isOpen)("igx-nav-drawer__aside--mini", ctx.miniTemplate && !ctx.isOpen)("igx-nav-drawer__aside--normal", !ctx.miniTemplate || ctx.isOpen)("igx-nav-drawer__aside--pinned", ctx.pin)("igx-nav-drawer__aside--right", ctx.position == "right")("igx-nav-drawer--disable-animation", ctx.disableAnimation);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template || _r0);
    } }, directives: [ɵngcc2.NgTemplateOutlet, IgxNavDrawerItemDirective], styles: ["[_nghost-%COMP%] {\n            display: block;\n            height: 100%;\n        }"] });
IgxNavigationDrawerComponent.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] },
    { type: Renderer2 },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];
IgxNavigationDrawerComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-nav-drawer',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    position: [{ type: Input }],
    enableGestures: [{ type: Input }],
    isOpen: [{ type: Input }],
    isOpenChange: [{ type: Output }],
    pin: [{ type: Input }],
    pinThreshold: [{ type: Input }],
    width: [{ type: Input }],
    disableAnimation: [{ type: HostBinding, args: ['class.igx-nav-drawer--disable-animation',] }, { type: Input }],
    miniWidth: [{ type: Input }],
    pinChange: [{ type: Output }],
    opening: [{ type: Output }],
    opened: [{ type: Output }],
    closing: [{ type: Output }],
    closed: [{ type: Output }],
    miniTemplate: [{ type: ContentChild, args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective },] }],
    contentTemplate: [{ type: ContentChild, args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective },] }],
    flexWidth: [{ type: HostBinding, args: ['style.flexBasis',] }],
    isPinnedRight: [{ type: HostBinding, args: ['style.order',] }],
    _drawer: [{ type: ViewChild, args: ['aside', { static: true },] }],
    _overlay: [{ type: ViewChild, args: ['overlay', { static: true },] }],
    _styleDummy: [{ type: ViewChild, args: ['dummy', { static: true },] }]
};

/**
 * @hidden
 */
class IgxNavigationDrawerModule {
}
IgxNavigationDrawerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxNavigationDrawerModule });
IgxNavigationDrawerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxNavigationDrawerModule_Factory(t) { return new (t || IgxNavigationDrawerModule)(); }, imports: [[CommonModule]] });

/**
 * Template directive that allows you to set a custom template representing the lower label value of the {@link IgxSliderComponent}
 *
 * ```html
 * <igx-slider>
 *  <ng-template igxSliderThumbFrom let-value let-labels>{{value}}</ng-template>
 * </igx-slider>
 * ```
 *
 * @context {@link IgxSliderComponent.context}
 */
class IgxThumbFromTemplateDirective {
}
IgxThumbFromTemplateDirective.ɵfac = function IgxThumbFromTemplateDirective_Factory(t) { return new (t || IgxThumbFromTemplateDirective)(); };
IgxThumbFromTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxThumbFromTemplateDirective, selectors: [["", "igxSliderThumbFrom", ""]] });
/**
 * Template directive that allows you to set a custom template representing the upper label value of the {@link IgxSliderComponent}
 *
 * ```html
 * <igx-slider>
 *  <ng-template igxSliderThumbTo let-value let-labels>{{value}}</ng-template>
 * </igx-slider>
 * ```
 *
 * @context {@link IgxSliderComponent.context}
 */
class IgxThumbToTemplateDirective {
}
IgxThumbToTemplateDirective.ɵfac = function IgxThumbToTemplateDirective_Factory(t) { return new (t || IgxThumbToTemplateDirective)(); };
IgxThumbToTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxThumbToTemplateDirective, selectors: [["", "igxSliderThumbTo", ""]] });
/**
 * Template directive that allows you to set a custom template, represeting primary/secondary tick labels of the {@link IgxSliderComponent}
 *
 * @context {@link IgxTicksComponent.context}
 */
class IgxTickLabelTemplateDirective {
}
IgxTickLabelTemplateDirective.ɵfac = function IgxTickLabelTemplateDirective_Factory(t) { return new (t || IgxTickLabelTemplateDirective)(); };
IgxTickLabelTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTickLabelTemplateDirective, selectors: [["", "igxSliderTickLabel", ""]] });
var IgxSliderType;
(function (IgxSliderType) {
    /**
     * Slider with single thumb.
     */
    IgxSliderType[IgxSliderType["SLIDER"] = 0] = "SLIDER";
    /**
     *  Range slider with multiple thumbs, that can mark the range.
     */
    IgxSliderType[IgxSliderType["RANGE"] = 1] = "RANGE";
})(IgxSliderType || (IgxSliderType = {}));
var SliderHandle;
(function (SliderHandle) {
    SliderHandle[SliderHandle["FROM"] = 0] = "FROM";
    SliderHandle[SliderHandle["TO"] = 1] = "TO";
})(SliderHandle || (SliderHandle = {}));
/**
 * Slider Tick labels Orientation
 */
var TickLabelsOrientation;
(function (TickLabelsOrientation) {
    TickLabelsOrientation[TickLabelsOrientation["Horizontal"] = 0] = "Horizontal";
    TickLabelsOrientation[TickLabelsOrientation["TopToBottom"] = 1] = "TopToBottom";
    TickLabelsOrientation[TickLabelsOrientation["BottomToTop"] = 2] = "BottomToTop";
})(TickLabelsOrientation || (TickLabelsOrientation = {}));
/**
 * Slider Ticks orientation
 */
var TicksOrientation;
(function (TicksOrientation) {
    TicksOrientation[TicksOrientation["Top"] = 0] = "Top";
    TicksOrientation[TicksOrientation["Bottom"] = 1] = "Bottom";
    TicksOrientation[TicksOrientation["Mirror"] = 2] = "Mirror";
})(TicksOrientation || (TicksOrientation = {}));

/**
 * @hidden
 */
class IgxSliderThumbComponent {
    constructor(_elementRef, _dir) {
        this._elementRef = _elementRef;
        this._dir = _dir;
        this._isActive = false;
        this._isPressed = false;
        this._destroy$ = new Subject();
        this.isActive = false;
        this.onThumbValueChange = new EventEmitter();
        this.onChange = new EventEmitter();
        this.onHoverChange = new EventEmitter();
        this.tabindex = 0;
        this.zIndex = 0;
    }
    get thumbPositionX() {
        const thumbBounderies = this.nativeElement.getBoundingClientRect();
        const thumbCenter = (thumbBounderies.right - thumbBounderies.left) / 2;
        return thumbBounderies.left + thumbCenter;
    }
    get thumbFromClass() {
        return this.type === SliderHandle.FROM;
    }
    get thumbToClass() {
        return this.type === SliderHandle.TO;
    }
    get thumbFromActiveClass() {
        return this.type === SliderHandle.FROM && this._isActive;
    }
    get thumbToActiveClass() {
        return this.type === SliderHandle.TO && this._isActive;
    }
    get thumbPressedClass() {
        return this.isActive && this._isPressed;
    }
    get nativeElement() {
        return this._elementRef.nativeElement;
    }
    get destroy() {
        return this._destroy$;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.onPan
            .pipe(takeUntil(this._destroy$))
            .subscribe(mouseX => this.updateThumbValue(mouseX));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
    }
    onPinterEnter() {
        this.onHoverChange.emit(true);
    }
    onPointerLeave() {
        this.onHoverChange.emit(false);
    }
    onKeyDown(event) {
        if (this.disabled) {
            return;
        }
        let increment = 0;
        if (event.key.endsWith('Left')) {
            increment = this.step * -1;
        }
        else if (event.key.endsWith('Right')) {
            increment = this.step;
        }
        else {
            return;
        }
        this.onChange.emit();
        this.onThumbValueChange.emit(increment);
    }
    onBlur() {
        this.isActive = false;
        this.zIndex = 0;
    }
    onFocusListener() {
        this.isActive = true;
        this.zIndex = 1;
    }
    /**
     * Show thumb label and ripple.
     */
    showThumbIndicators() {
        this.toggleThumbIndicators(true);
    }
    /**
     * Hide thumb label and ripple.
     */
    hideThumbIndicators() {
        this.toggleThumbIndicators(false);
    }
    updateThumbValue(mouseX) {
        const updateValue = this.calculateTrackUpdate(mouseX);
        if (this.isActive && updateValue !== 0) {
            this.onThumbValueChange.emit(updateValue);
        }
    }
    calculateTrackUpdate(mouseX) {
        const scaleX = this._dir.rtl ? this.thumbPositionX - mouseX : mouseX - this.thumbPositionX;
        const stepDistanceCenter = this.stepDistance / 2;
        // If the thumb scale range (slider update) is less thàn a half step,
        // the position stays the same.
        const scaleXPositive = Math.abs(scaleX);
        if (scaleXPositive < stepDistanceCenter) {
            return 0;
        }
        return this.stepToProceed(scaleX, this.stepDistance);
    }
    stepToProceed(scaleX, stepDist) {
        return Math.round(scaleX / stepDist) * this.step;
    }
    toggleThumbIndicators(visible) {
        this._isPressed = visible;
        if (this.continuous || this.deactiveState) {
            this._isActive = false;
        }
        else {
            this._isActive = visible;
        }
    }
}
IgxSliderThumbComponent.ɵfac = function IgxSliderThumbComponent_Factory(t) { return new (t || IgxSliderThumbComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxDirectionality)); };
IgxSliderThumbComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSliderThumbComponent, selectors: [["igx-thumb"]], hostVars: 12, hostBindings: function IgxSliderThumbComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("pointerenter", function IgxSliderThumbComponent_pointerenter_HostBindingHandler() { return ctx.onPinterEnter(); })("pointerleave", function IgxSliderThumbComponent_pointerleave_HostBindingHandler() { return ctx.onPointerLeave(); })("keydown", function IgxSliderThumbComponent_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); })("blur", function IgxSliderThumbComponent_blur_HostBindingHandler() { return ctx.onBlur(); })("focus", function IgxSliderThumbComponent_focus_HostBindingHandler() { return ctx.onFocusListener(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("z-index", ctx.zIndex);
        ɵngcc0.ɵɵclassProp("igx-slider__thumb-from", ctx.thumbFromClass)("igx-slider__thumb-to", ctx.thumbToClass)("igx-slider__thumb-from--active", ctx.thumbFromActiveClass)("igx-slider__thumb-to--active", ctx.thumbToActiveClass)("igx-slider__thumb--pressed", ctx.thumbPressedClass);
    } }, inputs: { value: "value", continuous: "continuous", thumbLabelVisibilityDuration: "thumbLabelVisibilityDuration", disabled: "disabled", onPan: "onPan", stepDistance: "stepDistance", step: "step", templateRef: "templateRef", context: "context", type: "type", deactiveState: "deactiveState" }, outputs: { onThumbValueChange: "onThumbValueChange", onChange: "onChange", onHoverChange: "onHoverChange" }, decls: 1, vars: 0, consts: [[1, "dot"]], template: function IgxSliderThumbComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0);
    } }, encapsulation: 2 });
IgxSliderThumbComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxDirectionality }
];
IgxSliderThumbComponent.propDecorators = {
    value: [{ type: Input }],
    continuous: [{ type: Input }],
    thumbLabelVisibilityDuration: [{ type: Input }],
    disabled: [{ type: Input }],
    onPan: [{ type: Input }],
    stepDistance: [{ type: Input }],
    step: [{ type: Input }],
    templateRef: [{ type: Input }],
    context: [{ type: Input }],
    type: [{ type: Input }],
    deactiveState: [{ type: Input }],
    onThumbValueChange: [{ type: Output }],
    onChange: [{ type: Output }],
    onHoverChange: [{ type: Output }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    zIndex: [{ type: HostBinding, args: ['attr.z-index',] }],
    thumbFromClass: [{ type: HostBinding, args: ['class.igx-slider__thumb-from',] }],
    thumbToClass: [{ type: HostBinding, args: ['class.igx-slider__thumb-to',] }],
    thumbFromActiveClass: [{ type: HostBinding, args: ['class.igx-slider__thumb-from--active',] }],
    thumbToActiveClass: [{ type: HostBinding, args: ['class.igx-slider__thumb-to--active',] }],
    thumbPressedClass: [{ type: HostBinding, args: ['class.igx-slider__thumb--pressed',] }],
    onPinterEnter: [{ type: HostListener, args: ['pointerenter',] }],
    onPointerLeave: [{ type: HostListener, args: ['pointerleave',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onBlur: [{ type: HostListener, args: ['blur',] }],
    onFocusListener: [{ type: HostListener, args: ['focus',] }]
};

class IgxThumbLabelComponent {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
    get thumbFromClass() {
        return this.type === SliderHandle.FROM;
    }
    get thumbToClass() {
        return this.type === SliderHandle.TO;
    }
    get thumbFromActiveClass() {
        return this.type === SliderHandle.FROM && this.active;
    }
    get thumbToActiveClass() {
        return this.type === SliderHandle.TO && this.active;
    }
    get nativeElement() {
        return this._elementRef.nativeElement;
    }
    get active() {
        return this._active;
    }
    set active(val) {
        if (this.continuous || this.deactiveState) {
            this._active = false;
        }
        else {
            this._active = val;
        }
    }
}
IgxThumbLabelComponent.ɵfac = function IgxThumbLabelComponent_Factory(t) { return new (t || IgxThumbLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxThumbLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxThumbLabelComponent, selectors: [["igx-thumb-label"]], hostVars: 8, hostBindings: function IgxThumbLabelComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-slider__label-from", ctx.thumbFromClass)("igx-slider__label-to", ctx.thumbToClass)("igx-slider__label-from--active", ctx.thumbFromActiveClass)("igx-slider__label-to--active", ctx.thumbToActiveClass);
    } }, inputs: { value: "value", templateRef: "templateRef", context: "context", type: "type", continuous: "continuous", deactiveState: "deactiveState" }, decls: 4, vars: 2, consts: [[1, "label"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["thumbFromDefaultTemplate", ""]], template: function IgxThumbLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxThumbLabelComponent_ng_container_1_Template, 1, 0, "ng-container", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, IgxThumbLabelComponent_ng_template_2_Template, 1, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.templateRef ? ctx.templateRef : _r1)("ngTemplateOutletContext", ctx.context);
    } }, directives: [ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
IgxThumbLabelComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxThumbLabelComponent.propDecorators = {
    value: [{ type: Input }],
    templateRef: [{ type: Input }],
    context: [{ type: Input }],
    type: [{ type: Input }],
    continuous: [{ type: Input }],
    deactiveState: [{ type: Input }],
    thumbFromClass: [{ type: HostBinding, args: ['class.igx-slider__label-from',] }],
    thumbToClass: [{ type: HostBinding, args: ['class.igx-slider__label-to',] }],
    thumbFromActiveClass: [{ type: HostBinding, args: ['class.igx-slider__label-from--active',] }],
    thumbToActiveClass: [{ type: HostBinding, args: ['class.igx-slider__label-to--active',] }]
};

/**
 * @hidden
 */
class IgxTicksComponent {
    constructor() {
        /**
         * @hidden
         */
        this.ticksClass = true;
    }
    /**
     * @hidden
     */
    get ticksTopClass() {
        return this.ticksOrientation === TicksOrientation.Top;
    }
    /**
     * @hidden
     */
    get hasPrimaryClass() {
        return this.primaryTicks > 0;
    }
    /**
     * @hidden
     */
    get labelsTopToBottomClass() {
        return this.tickLabelsOrientation === TickLabelsOrientation.TopToBottom;
    }
    /**
     * @hidden
     */
    get labelsBottomToTopClass() {
        return this.tickLabelsOrientation === TickLabelsOrientation.BottomToTop;
    }
    /**
     * Returns the template context corresponding to
     * {@link IgxTickLabelTemplateDirective}
     *
     * ```typescript
     * return {
     *  $implicit //returns the value per each tick label.
     *  isPrimery //returns if the tick is primary.
     *  labels // returns the {@link labels} collection.
     *  index // returns the index per each tick of the whole sequence.
     * }
     * ```
     *
     * @param idx the index per each tick label.
     */
    context(idx) {
        return {
            $implicit: this.tickLabel(idx),
            isPrimary: this.isPrimary(idx),
            labels: this.labels,
            index: idx
        };
    }
    /**
     * @hidden
     */
    get ticksLength() {
        return this.primaryTicks > 0 ?
            ((this.primaryTicks - 1) * this.secondaryTicks) + this.primaryTicks :
            this.secondaryTicks > 0 ? this.secondaryTicks : 0;
    }
    hiddenTickLabels(idx) {
        return this.isPrimary(idx) ? this.primaryTickLabels : this.secondaryTickLabels;
    }
    /**
     * @hidden
     */
    isPrimary(idx) {
        return this.primaryTicks <= 0 ? false :
            idx % (this.secondaryTicks + 1) === 0;
    }
    /**
     * @hidden
     */
    tickLabel(idx) {
        if (this.labelsViewEnabled) {
            return this.labels[idx];
        }
        const labelStep = (Math.max(this.minValue, this.maxValue) - Math.min(this.minValue, this.maxValue)) / (this.ticksLength - 1);
        const labelVal = labelStep * idx;
        return (this.minValue + labelVal).toFixed(2);
    }
}
IgxTicksComponent.ɵfac = function IgxTicksComponent_Factory(t) { return new (t || IgxTicksComponent)(); };
IgxTicksComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTicksComponent, selectors: [["igx-ticks"]], hostVars: 10, hostBindings: function IgxTicksComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-slider__ticks", ctx.ticksClass)("igx-slider__ticks--top", ctx.ticksTopClass)("igx-slider__ticks--tall", ctx.hasPrimaryClass)("igx-slider__tick-labels--top-bottom", ctx.labelsTopToBottomClass)("igx-slider__tick-labels--bottom-top", ctx.labelsBottomToTopClass);
    } }, inputs: { primaryTicks: "primaryTicks", secondaryTicks: "secondaryTicks", primaryTickLabels: "primaryTickLabels", secondaryTickLabels: "secondaryTickLabels", ticksOrientation: "ticksOrientation", tickLabelsOrientation: "tickLabelsOrientation", maxValue: "maxValue", minValue: "minValue", labelsViewEnabled: "labelsViewEnabled", labels: "labels", tickLabelTemplateRef: "tickLabelTemplateRef" }, decls: 3, vars: 2, consts: [["class", "igx-slider__ticks-group", 3, "ngClass", 4, "ngFor", "ngForOf"], ["tickLabelDefaultTemplate", ""], [1, "igx-slider__ticks-group", 3, "ngClass"], [1, "igx-slider__ticks-tick"], [1, "igx-slider__ticks-label", 3, "ngClass"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function IgxTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxTicksComponent_div_0_Template, 4, 8, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxTicksComponent_ng_template_1_Template, 1, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpureFunction0(1, _c185).constructor(ctx.ticksLength));
    } }, directives: [ɵngcc2.NgForOf, ɵngcc2.NgClass, ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
IgxTicksComponent.propDecorators = {
    primaryTicks: [{ type: Input }],
    secondaryTicks: [{ type: Input }],
    primaryTickLabels: [{ type: Input }],
    secondaryTickLabels: [{ type: Input }],
    ticksOrientation: [{ type: Input }],
    tickLabelsOrientation: [{ type: Input }],
    maxValue: [{ type: Input }],
    minValue: [{ type: Input }],
    labelsViewEnabled: [{ type: Input }],
    labels: [{ type: Input }],
    tickLabelTemplateRef: [{ type: Input }],
    ticksClass: [{ type: HostBinding, args: ['class.igx-slider__ticks',] }],
    ticksTopClass: [{ type: HostBinding, args: ['class.igx-slider__ticks--top',] }],
    hasPrimaryClass: [{ type: HostBinding, args: ['class.igx-slider__ticks--tall',] }],
    labelsTopToBottomClass: [{ type: HostBinding, args: ['class.igx-slider__tick-labels--top-bottom',] }],
    labelsBottomToTopClass: [{ type: HostBinding, args: ['class.igx-slider__tick-labels--bottom-top',] }]
};

class IgxTickLabelsPipe {
    transform(labels, secondaryTicks) {
        if (!labels) {
            return;
        }
        const result = [];
        labels.forEach(item => {
            result.push(item);
            for (let i = 0; i < secondaryTicks; i++) {
                result.push('');
            }
        });
        return result;
    }
}
IgxTickLabelsPipe.ɵfac = function IgxTickLabelsPipe_Factory(t) { return new (t || IgxTickLabelsPipe)(); };
IgxTickLabelsPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "spreadTickLabels", type: IgxTickLabelsPipe, pure: true });

const noop$7 = () => {
};
const ɵ0$9 = noop$7;
let NEXT_ID$t = 0;
/**
 * **Ignite UI for Angular Slider** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider/slider)
 *
 * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
 * can be defined as continuous or stepped, and you can choose between single and range slider types.
 *
 * Example:
 * ```html
 * <igx-slider id="slider"
 *            [minValue]="0" [maxValue]="100"
 *            [continuous]=true [(ngModel)]="volume">
 * </igx-slider>
 * ```
 */
class IgxSliderComponent {
    constructor(renderer, _el, _cdr, _ngZone, _dir) {
        this.renderer = renderer;
        this._el = _el;
        this._cdr = _cdr;
        this._ngZone = _ngZone;
        this._dir = _dir;
        // Limit handle travel zone
        this._pMin = 0;
        this._pMax = 1;
        // From/upperValue in percent values
        this._hasViewInit = false;
        this._minValue = 0;
        this._maxValue = 100;
        this._continuous = false;
        this._disabled = false;
        this._step = 1;
        this._value = 0;
        // ticks
        this._primaryTicks = 0;
        this._secondaryTicks = 0;
        this._labels = new Array();
        this._type = IgxSliderType.SLIDER;
        this._destroyer$ = new Subject();
        this._indicatorsDestroyer$ = new Subject();
        this._onChangeCallback = noop$7;
        this._onTouchedCallback = noop$7;
        /**
         * @hidden
         */
        this.thumbs = new QueryList();
        /**
         * @hidden
         */
        this.labelRefs = new QueryList();
        /**
         * @hidden
         */
        this.stepDistance = this._step;
        /**
         * @hidden
         */
        this.onPan = new Subject();
        /**
         * @hidden
         */
        this.role = 'slider';
        /**
         * @hidden
         */
        this.slierClass = true;
        /**
         * An @Input property that sets the value of the `id` attribute.
         * If not provided it will be automatically generated.
         * ```html
         * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */
        this.id = `igx-slider-${NEXT_ID$t++}`;
        /**
         * An @Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
         * ```html
         * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.thumbLabelVisibilityDuration = 750;
        /**
         * Show/hide slider ticks
         * ```html
         * <igx-slier [showTicks]="true" [primaryTicks]="5"></igx-slier>
         * ```
         */
        this.showTicks = false;
        /**
         * show/hide primary tick labels
         * ```html
         * <igx-slider [primaryTicks]="5" [primaryTickLabels]="false"></igx-slider>
         * ```
         */
        this.primaryTickLabels = true;
        /**
         * show/hide secondary tick labels
         * ```html
         * <igx-slider [secondaryTicks]="5" [secondaryTickLabels]="false"></igx-slider>
         * ```
         */
        this.secondaryTickLabels = true;
        /**
         * Changes ticks orientation:
         * bottom - The default orienation, below the slider track.
         * top - Above the slider track
         * mirror - combines top and bottom orientation.
         * ```html
         * <igx-slider [primaryTicks]="5" [ticksOrientation]="ticksOrientation"></igx-slider>
         * ```
         */
        this.ticksOrientation = TicksOrientation.Bottom;
        /**
         * Changes tick labels rotation:
         * horizontal - The default rotation
         * toptobottom - Rotates tick labels vertically to 90deg
         * bottomtotop - Rotate tick labels vertically to -90deg
         * ```html
         * <igx-slider [primaryTicks]="5" [secondaryTicks]="3" [tickLabelsOrientation]="tickLabelsOrientaiton"></igx-slider>
         * ```
         */
        this.tickLabelsOrientation = TickLabelsOrientation.Horizontal;
        /**
         * This event is emitted every time the value is changed.
         * ```typescript
         * public change(event){
         *    alert("The value has been changed!");
         * }
         * ```
         * ```html
         * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.onValueChange = new EventEmitter();
        /**
         * This event is emitted at the end of every slide interaction.
         * ```typescript
         * public change(event){
         *    alert("The value has been changed!");
         * }
         * ```
         * ```html
         * <igx-slider (onValueChanged)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.onValueChanged = new EventEmitter();
    }
    get thumbFrom() {
        return this.thumbs.find(thumb => thumb.type === SliderHandle.FROM);
    }
    get thumbTo() {
        return this.thumbs.find(thumb => thumb.type === SliderHandle.TO);
    }
    get labelFrom() {
        return this.labelRefs.find(label => label.type === SliderHandle.FROM);
    }
    get labelTo() {
        return this.labelRefs.find(label => label.type === SliderHandle.TO);
    }
    /**
     * @hidden
     */
    get valuemin() {
        return this.minValue;
    }
    /**
     * @hidden
     */
    get valuemax() {
        return this.maxValue;
    }
    /**
     * @hidden
     */
    get readonly() {
        return this.disabled;
    }
    /**
     * @hidden
     */
    get disabledClass() {
        return this.disabled;
    }
    /**
     * An @Input property that gets the type of the `IgxSliderComponent`.
     * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let type = this.slider.type;
     * }
     */
    get type() {
        return this._type;
    }
    /**
     * An @Input property that sets the type of the `IgxSliderComponent`.
     * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
     * ```typescript
     * sliderType: IgxSliderType = IgxSliderType.RANGE;
     * ```
     * ```html
     * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
     * ```
     */
    set type(type) {
        this._type = type;
        if (type === IgxSliderType.SLIDER) {
            this.lowerValue = 0;
        }
        if (this.labelsViewEnabled && this.upperValue > this.maxValue) {
            this.upperValue = this.labels.length - 1;
        }
        if (this._hasViewInit) {
            this.updateTrack();
        }
    }
    /**
     * Enables `labelView`, by accepting a collection of primitive values with more than one element.
     * Each element will be equally spread over the slider and it will serve as a thumb label.
     * Once the property is set, it will precendence over {@link maxValue}, {@link minValue}, {@link step}.
     * This means that the manipulation for those properties won't be allowed.
     */
    get labels() {
        return this._labels;
    }
    set labels(labels) {
        this._labels = labels;
        this._pMax = this.valueToFraction(this.upperBound, 0, 1);
        this._pMin = this.valueToFraction(this.lowerBound, 0, 1);
        this.positionHandlersAndUpdateTrack();
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.setTickInterval();
        }
    }
    /**
     * Returns the template context corresponding
     * to {@link IgxThumbFromTemplateDirective} and {@link IgxThumbToTemplateDirective} templates.
     *
     * ```typescript
     * return {
     *  $implicit // returns the value of the label,
     *  labels // returns the labels collection the user has passed.
     * }
     * ```
     */
    get context() {
        return {
            $implicit: this.value,
            labels: this.labels
        };
    }
    /**
     * An @Input property that sets the incremental/decremental step of the value when dragging the thumb.
     * The default step is 1, and step should not be less or equal than 0.
     * ```html
     * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     */
    set step(step) {
        this._step = step;
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.normalizeByStep(this.value);
            this.setTickInterval();
        }
    }
    /**
     * Returns the incremental/decremental dragging step of the {@link IgxSliderComponent}.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let step = this.slider.step;
     * }
     * ```
     */
    get step() {
        return this.labelsViewEnabled ? 1 : this._step;
    }
    /**
     * Returns if the {@link IgxSliderComponent} is disabled.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let isDisabled = this.slider.disabled;
     * }
     * ```
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * An @Input property that disables or enables UI interaction.
     * ```html
     * <igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     */
    set disabled(disable) {
        this._disabled = disable;
        if (this._hasViewInit) {
            this.changeThumbFocusableState(disable);
        }
    }
    /**
     * Returns if the {@link IgxSliderComponent} is set as continuous.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let continuous = this.slider.continuous;
     * }
     * ```
     */
    get continuous() {
        return this._continuous;
    }
    /**
     * An @Input property that marks the {@link IgxSliderComponent} as continuous.
     * By default is considered that the {@link IgxSliderComponent} is discrete.
     * Discrete {@link IgxSliderComponent} does not have ticks and does not show bubble labels for values.
     * ```html
     * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     */
    set continuous(continuous) {
        this._continuous = continuous;
        if (this._hasViewInit) {
            this.setTickInterval();
        }
    }
    /**
     * Returns the minimal value of the `IgxSliderComponent`.
     * ```typescript
     *  @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let sliderMin = this.slider.minValue;
     * }
     * ```
     */
    get minValue() {
        if (this.labelsViewEnabled) {
            return 0;
        }
        return this._minValue;
    }
    /**
     * Sets the minimal value for the `IgxSliderComponent`.
     * The default minimal value is 0.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
     * ```
     */
    set minValue(value) {
        if (value >= this.maxValue) {
            return;
        }
        else {
            this._minValue = value;
        }
        if (value > this.upperBound) {
            this.updateUpperBoundAndMaxTravelZone();
            this.lowerBound = value;
        }
        // Refresh min travel zone limit.
        this._pMin = 0;
        // Recalculate step distance.
        this.positionHandlersAndUpdateTrack();
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.setTickInterval();
        }
    }
    /**
     * Returns the maximum value for the {@link IgxSliderComponent}.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let sliderMax = this.slider.maxValue;
     * }
     *  ```
     */
    get maxValue() {
        return this.labelsViewEnabled ?
            this.labels.length - 1 :
            this._maxValue;
    }
    /**
     * Sets the maximal value for the `IgxSliderComponent`.
     * The default maximum value is 100.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
     * ```
     */
    set maxValue(value) {
        if (value <= this._minValue) {
            return;
        }
        else {
            this._maxValue = value;
        }
        if (value < this.lowerBound) {
            this.updateLowerBoundAndMinTravelZone();
            this.upperBound = value;
        }
        // refresh max travel zone limits.
        this._pMax = 1;
        // recalculate step distance.
        this.positionHandlersAndUpdateTrack();
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.setTickInterval();
        }
    }
    /**
     * Returns the lower boundary of the `IgxSliderComponent`.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let sliderLowBound = this.slider.lowerBound;
     * }
     * ```
     */
    get lowerBound() {
        if (!Number.isNaN(this._lowerBound) && this._lowerBound !== undefined) {
            return this.valueInRange(this._lowerBound, this.minValue, this.maxValue);
        }
        return this.minValue;
    }
    /**
     * Sets the lower boundary of the `IgxSliderComponent`.
     * If not set is the same as min value.
     * ```html
     * <igx-slider [step]="5" [lowerBound]="20">
     * ```
     */
    set lowerBound(value) {
        if (value >= this.upperBound || (this.labelsViewEnabled && value < 0)) {
            return;
        }
        this._lowerBound = this.valueInRange(value, this.minValue, this.maxValue);
        // Refresh min travel zone.
        this._pMin = this.valueToFraction(this._lowerBound, 0, 1);
        this.positionHandlersAndUpdateTrack();
    }
    /**
     * Returns the upper boundary of the `IgxSliderComponent`.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderUpBound = this.slider.upperBound;
     * }
     * ```
     */
    get upperBound() {
        if (!Number.isNaN(this._upperBound) && this._upperBound !== undefined) {
            return this.valueInRange(this._upperBound, this.minValue, this.maxValue);
        }
        return this.maxValue;
    }
    /**
     * Sets the upper boundary of the `IgxSliderComponent`.
     * If not set is the same as max value.
     * ```html
     * <igx-slider [step]="5" [upperBound]="20">
     * ```
     */
    set upperBound(value) {
        if (value <= this.lowerBound || (this.labelsViewEnabled && value > this.labels.length - 1)) {
            return;
        }
        this._upperBound = this.valueInRange(value, this.minValue, this.maxValue);
        // Refresh time travel zone.
        this._pMax = this.valueToFraction(this._upperBound, 0, 1);
        this.positionHandlersAndUpdateTrack();
    }
    /**
     * Returns the slider value. If the slider is of type {@link IgxSliderType.SLIDER} the returned value is number.
     * If the slider type is {@link IgxSliderType.RANGE}.
     * The returned value represents an object of {@link lowerValue} and {@link upperValue}.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public sliderValue(event){
     *     let sliderVal = this.slider.value;
     * }
     * ```
     */
    get value() {
        if (this.isRange) {
            return {
                lower: this.valueInRange(this.lowerValue, this.lowerBound, this.upperBound),
                upper: this.valueInRange(this.upperValue, this.lowerBound, this.upperBound)
            };
        }
        else {
            return this.valueInRange(this.upperValue, this.lowerBound, this.upperBound);
        }
    }
    /**
     * Sets the slider value.
     * If the slider is of type {@link IgxSliderType.SLIDER}.
     * The argument is number. By default the {@link value} gets the {@link lowerBound}.
     * If the slider type is {@link IgxSliderType.RANGE} the argument
     * represents an object of {@link lowerValue} and {@link upperValue} properties.
     * By default the object is associated with the {@link lowerBound} and {@link upperBound} property values.
     * ```typescript
     * rangeValue = {
     *   lower: 30,
     *   upper: 60
     * };
     * ```
     * ```html
     * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
     * ```
     */
    set value(value) {
        if (this._hasViewInit) {
            this.setValue(value, true);
            this.positionHandlersAndUpdateTrack();
        }
        else {
            this._value = value;
        }
    }
    /**
     * Returns the number of the presented primary ticks.
     * ```typescript
     * const primaryTicks = this.slider.primaryTicks;
     * ```
     */
    get primaryTicks() {
        if (this.labelsViewEnabled) {
            return this._primaryTicks = this.labels.length;
        }
        return this._primaryTicks;
    }
    /**
     * Sets the number of primary ticks. If {@link @labels} is enabled, this property won't function.
     * Insted enable ticks by {@link showTicks} property.
     * ```typescript
     * this.slider.primaryTicks = 5;
     * ```
     */
    set primaryTicks(val) {
        if (val <= 1) {
            return;
        }
        this._primaryTicks = val;
    }
    /**
     * Returns the number of the presented secondary ticks.
     * ```typescript
     * const secondaryTicks = this.slider.secondaryTicks;
     * ```
     */
    get secondaryTicks() {
        return this._secondaryTicks;
    }
    /**
     * Sets the number of secondary ticks. The property functions even when {@link labels} is enabled,
     * but all secondary ticks won't present any tick labels.
     * ```typescript
     * this.slider.secondaryTicks = 5;
     * ```
     */
    set secondaryTicks(val) {
        if (val < 1) {
            return;
        }
        this._secondaryTicks = val;
    }
    /**
     * @hidden
     */
    get deactivateThumbLabel() {
        return ((this.primaryTicks && this.primaryTickLabels) || (this.secondaryTicks && this.secondaryTickLabels)) &&
            (this.ticksOrientation === TicksOrientation.Top || this.ticksOrientation === TicksOrientation.Mirror);
    }
    /**
     * @hidden
     */
    onPointerDown($event) {
        this.findClosestThumb($event);
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        const activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbFrom;
        activeThumb.nativeElement.setPointerCapture($event.pointerId);
        this.showSliderIndicators();
        $event.preventDefault();
    }
    /**
     * @hidden
     */
    onPointerUp($event) {
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        const activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbTo;
        activeThumb.nativeElement.releasePointerCapture($event.pointerId);
        this.hideSliderIndicators();
        this.onValueChanged.emit(this.value);
    }
    /**
     * @hidden
     */
    onFocus() {
        this.toggleSliderIndicators();
    }
    /**
     * @hidden
     */
    onPanListener($event) {
        this.update($event.srcEvent.clientX);
    }
    /**
     * Returns whether the `IgxSliderComponent` type is RANGE.
     * ```typescript
     *  @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let sliderRange = this.slider.isRange;
     * }
     * ```
     */
    get isRange() {
        return this.type === IgxSliderType.RANGE;
    }
    /**
     * Returns the lower value of the `IgxSliderComponent`.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *    let sliderLowValue = this.slider.lowerValue;
     * }
     * ```
     */
    get lowerValue() {
        if (!Number.isNaN(this._lowerValue) && this._lowerValue !== undefined && this._lowerValue >= this.lowerBound) {
            return this._lowerValue;
        }
        return this.lowerBound;
    }
    /**
     * Sets the lower value of the `IgxSliderComponent`.
     * ```typescript
     *  @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *     this.slider.lowerValue = 120;
     * }
     * ```
     */
    set lowerValue(value) {
        value = this.valueInRange(value, this.lowerBound, this.upperBound);
        this._lowerValue = value;
    }
    /**
     * Returns the upper value of the `IgxSliderComponent`.
     * ```typescript
     *  @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public upperValue(event){
     *     let upperValue = this.slider.upperValue;
     * }
     * ```
     */
    get upperValue() {
        if (!Number.isNaN(this._upperValue) && this._upperValue !== undefined && this._upperValue <= this.upperBound) {
            return this._upperValue;
        }
        return this.upperBound;
    }
    /**
     * Sets the upper value of the `IgxSliderComponent`.
     * ```typescript
     *  @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public upperValue(event){
     *     this.slider.upperValue = 120;
     * }
     * ```
     */
    set upperValue(value) {
        value = this.valueInRange(value, this.lowerBound, this.upperBound);
        this._upperValue = value;
    }
    /**
     * Returns the value corresponding the lower label.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.lowerLabel;
     * ```
     */
    get lowerLabel() {
        return this.labelsViewEnabled ?
            this.labels[this.lowerValue] :
            this.lowerValue;
    }
    /**
     * Returns the value corresponding the upper label.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.upperLabel;
     * ```
     */
    get upperLabel() {
        return this.labelsViewEnabled ?
            this.labels[this.upperValue] :
            this.upperValue;
    }
    /**
     * Returns if label view is enabled.
     * If the {@link labels} is set, the view is automatically activated.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let labelView = this.slider.labelsViewEnabled;
     * ```
     */
    get labelsViewEnabled() {
        return !!(this.labels && this.labels.length > 1);
    }
    /**
     * @hidden
     */
    get showTopTicks() {
        return this.ticksOrientation === TicksOrientation.Top ||
            this.ticksOrientation === TicksOrientation.Mirror;
    }
    /**
     * @hidden
     */
    get showBottomTicks() {
        return this.ticksOrientation === TicksOrientation.Bottom ||
            this.ticksOrientation === TicksOrientation.Mirror;
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (changes.minValue && changes.maxValue &&
            changes.minValue.currentValue < changes.maxValue.currentValue) {
            this._maxValue = changes.maxValue.currentValue;
            this._minValue = changes.minValue.currentValue;
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.sliderSetup();
        // Set track travel zone
        this._pMin = this.valueToFraction(this.lowerBound) || 0;
        this._pMax = this.valueToFraction(this.upperBound) || 1;
    }
    ngAfterContentInit() {
        this.setValue(this._value, false);
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this._hasViewInit = true;
        this.stepDistance = this.calculateStepDistance();
        this.positionHandlersAndUpdateTrack();
        this.setTickInterval();
        this.changeThumbFocusableState(this.disabled);
        this.subscribeTo(this.thumbFrom, this.thumbChanged.bind(this));
        this.subscribeTo(this.thumbTo, this.thumbChanged.bind(this));
        this.thumbs.changes.pipe(takeUntil(this._destroyer$)).subscribe(change => {
            const thumbFrom = change.find((thumb) => thumb.type === SliderHandle.FROM);
            this.positionHandler(thumbFrom, null, this.lowerValue);
            this.subscribeTo(thumbFrom, this.thumbChanged.bind(this));
            this.changeThumbFocusableState(this.disabled);
        });
        this.labelRefs.changes.pipe(takeUntil(this._destroyer$)).subscribe(change => {
            const labelFrom = this.labelRefs.find((label) => label.type === SliderHandle.FROM);
            this.positionHandler(null, labelFrom, this.lowerValue);
        });
        this._ngZone.runOutsideAngular(() => {
            resizeObservable(this._el.nativeElement).pipe(throttleTime(40), takeUntil(this._destroyer$)).subscribe(() => this._ngZone.run(() => {
                this.stepDistance = this.calculateStepDistance();
            }));
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroyer$.next(true);
        this._destroyer$.complete();
        this._indicatorsDestroyer$.next(true);
        this._indicatorsDestroyer$.complete();
    }
    /**
     * @hidden
     */
    writeValue(value) {
        if (!value) {
            return;
        }
        this.normalizeByStep(value);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /** @hidden */
    getEditElement() {
        return this.isRange ? this.thumbFrom.nativeElement : this.thumbTo.nativeElement;
    }
    /**
     *
     * @hidden
     */
    update(mouseX) {
        if (this.disabled) {
            return;
        }
        // Update To/From Values
        this.onPan.next(mouseX);
        // Finally do positionHandlersAndUpdateTrack the DOM
        // based on data values
        this.positionHandlersAndUpdateTrack();
        this._onTouchedCallback();
    }
    /**
     * @hidden
     */
    thumbChanged(value, thumbType) {
        const oldValue = this.value;
        let newVal;
        if (this.isRange) {
            if (thumbType === SliderHandle.FROM) {
                newVal = {
                    lower: this.value.lower + value,
                    upper: this.value.upper
                };
            }
            else {
                newVal = {
                    lower: this.value.lower,
                    upper: this.value.upper + value
                };
            }
            // Swap the thumbs if a collision appears.
            if (newVal.lower >= newVal.upper) {
                this.value = this.swapThumb(newVal);
            }
            else {
                this.value = newVal;
            }
        }
        else {
            this.value = this.value + value;
        }
        if (this.hasValueChanged(oldValue)) {
            this.emitValueChanged(oldValue);
        }
    }
    /**
     * @hidden
     */
    onThumbChange() {
        this.toggleSliderIndicators();
    }
    /**
     * @hidden
     */
    onHoverChange(state) {
        return state ? this.showSliderIndicators() : this.hideSliderIndicators();
    }
    swapThumb(value) {
        if (this.thumbFrom.isActive) {
            value.upper = this.upperValue;
            value.lower = this.upperValue;
        }
        else {
            value.upper = this.lowerValue;
            value.lower = this.lowerValue;
        }
        this.toggleThumb();
        return value;
    }
    findClosestThumb(event) {
        if (this.isRange) {
            this.closestHandle(event);
        }
        else {
            this.thumbTo.nativeElement.focus();
        }
        this.update(event.clientX);
    }
    updateLowerBoundAndMinTravelZone() {
        this.lowerBound = this.minValue;
        this._pMin = 0;
    }
    updateUpperBoundAndMaxTravelZone() {
        this.upperBound = this.maxValue;
        this._pMax = 1;
    }
    sliderSetup() {
        /**
         * if {@link SliderType.SLIDER} than the initial value shold be the lowest one.
         */
        if (!this.isRange && this._upperValue === undefined) {
            this._upperValue = this.lowerBound;
        }
    }
    calculateStepDistance() {
        return this._el.nativeElement.getBoundingClientRect().width / (this.maxValue - this.minValue) * this.step;
    }
    toggleThumb() {
        return this.thumbFrom.isActive ?
            this.thumbTo.nativeElement.focus() :
            this.thumbFrom.nativeElement.focus();
    }
    valueInRange(value, min = 0, max = 100) {
        return Math.max(Math.min(value, max), min);
    }
    generateTickMarks(color, interval) {
        return interval !== null ? `repeating-linear-gradient(
            ${'to left'},
            ${color},
            ${color} 1.5px,
            transparent 1.5px,
            transparent ${interval}%
        ), repeating-linear-gradient(
            ${'to right'},
            ${color},
            ${color} 1.5px,
            transparent 1.5px,
            transparent ${interval}%
        )` : interval;
    }
    positionHandler(thumbHandle, labelHandle, position) {
        const percent = `${this.valueToFraction(position) * 100}%`;
        const dir = this._dir.rtl ? 'right' : 'left';
        if (thumbHandle) {
            thumbHandle.nativeElement.style[dir] = percent;
        }
        if (labelHandle) {
            labelHandle.nativeElement.style[dir] = percent;
        }
    }
    positionHandlersAndUpdateTrack() {
        if (!this.isRange) {
            this.positionHandler(this.thumbTo, this.labelTo, this.value);
        }
        else {
            this.positionHandler(this.thumbTo, this.labelTo, this.value.upper);
            this.positionHandler(this.thumbFrom, this.labelFrom, this.value.lower);
        }
        if (this._hasViewInit) {
            this.updateTrack();
        }
    }
    closestHandle(event) {
        const fromOffset = this.thumbFrom.nativeElement.offsetLeft + this.thumbFrom.nativeElement.offsetWidth / 2;
        const toOffset = this.thumbTo.nativeElement.offsetLeft + this.thumbTo.nativeElement.offsetWidth / 2;
        const xPointer = event.clientX - this._el.nativeElement.getBoundingClientRect().left;
        const match = this.closestTo(xPointer, [fromOffset, toOffset]);
        if (fromOffset === toOffset && toOffset < xPointer) {
            this.thumbTo.nativeElement.focus();
        }
        else if (fromOffset === toOffset && toOffset > xPointer) {
            this.thumbFrom.nativeElement.focus();
        }
        else if (match === fromOffset) {
            this.thumbFrom.nativeElement.focus();
        }
        else {
            this.thumbTo.nativeElement.focus();
        }
    }
    setTickInterval() {
        let interval;
        const trackProgress = 100;
        if (this.labelsViewEnabled) {
            // Calc ticks depending on the labels length;
            interval = ((trackProgress / (this.labels.length - 1) * 10)) / 10;
        }
        else {
            const trackRange = this.maxValue - this.minValue;
            interval = this.step > 1 ?
                (trackProgress / ((trackRange / this.step)) * 10) / 10
                : null;
        }
        const renderCallbackExecution = !this.continuous ? this.generateTickMarks('white', interval) : null;
        this.renderer.setStyle(this.ticks.nativeElement, 'background', renderCallbackExecution);
    }
    showSliderIndicators() {
        if (this.disabled) {
            return;
        }
        if (this._indicatorsTimer) {
            this._indicatorsDestroyer$.next(true);
            this._indicatorsTimer = null;
        }
        this.thumbTo.showThumbIndicators();
        this.labelTo.active = true;
        if (this.thumbFrom) {
            this.thumbFrom.showThumbIndicators();
        }
        if (this.labelFrom) {
            this.labelFrom.active = true;
        }
    }
    hideSliderIndicators() {
        if (this.disabled) {
            return;
        }
        this._indicatorsTimer = timer(this.thumbLabelVisibilityDuration);
        this._indicatorsTimer.pipe(takeUntil(this._indicatorsDestroyer$)).subscribe(() => {
            this.thumbTo.hideThumbIndicators();
            this.labelTo.active = false;
            if (this.thumbFrom) {
                this.thumbFrom.hideThumbIndicators();
            }
            if (this.labelFrom) {
                this.labelFrom.active = false;
            }
        });
    }
    toggleSliderIndicators() {
        this.showSliderIndicators();
        this.hideSliderIndicators();
    }
    changeThumbFocusableState(state) {
        const value = state ? -1 : 1;
        if (this.isRange) {
            this.thumbFrom.tabindex = value;
        }
        this.thumbTo.tabindex = value;
        this._cdr.detectChanges();
    }
    closestTo(goal, positions) {
        return positions.reduce((previous, current) => {
            return (Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous);
        });
    }
    valueToFraction(value, pMin = this._pMin, pMax = this._pMax) {
        return this.valueInRange((value - this.minValue) / (this.maxValue - this.minValue), pMin, pMax);
    }
    /**
     * @hidden
     * Normalizе the value when two-way data bind is used and {@link this.step} is set.
     * @param value
     */
    normalizeByStep(value) {
        if (this.isRange) {
            this.value = {
                lower: value.lower - (value.lower % this.step),
                upper: value.upper - (value.upper % this.step)
            };
        }
        else {
            this.value = value - (value % this.step);
        }
        this._cdr.detectChanges();
    }
    updateTrack() {
        const fromPosition = this.valueToFraction(this.lowerValue);
        const toPosition = this.valueToFraction(this.upperValue);
        const positionGap = toPosition - fromPosition;
        let trackLeftIndention = fromPosition;
        if (this.isRange) {
            if (positionGap) {
                trackLeftIndention = Math.round((1 / positionGap * fromPosition) * 100);
            }
            trackLeftIndention = this._dir.rtl ? -trackLeftIndention : trackLeftIndention;
            this.renderer.setStyle(this.trackRef.nativeElement, 'transform', `scaleX(${positionGap}) translateX(${trackLeftIndention}%)`);
        }
        else {
            this.renderer.setStyle(this.trackRef.nativeElement, 'transform', `scaleX(${toPosition})`);
        }
    }
    validateInitialValue(value) {
        if (value.lower < this.lowerBound && value.upper < this.lowerBound) {
            value.upper = this.lowerBound;
            value.lower = this.lowerBound;
        }
        if (value.lower > this.upperBound && value.upper > this.upperBound) {
            value.upper = this.upperBound;
            value.lower = this.upperBound;
        }
        if (value.upper < value.lower) {
            value.upper = this.upperValue;
            value.lower = this.lowerValue;
        }
        return value;
    }
    subscribeTo(thumb, callback) {
        if (!thumb) {
            return;
        }
        thumb.onThumbValueChange
            .pipe(takeUntil(this.unsubscriber(thumb)))
            .subscribe(value => callback(value, thumb.type));
    }
    unsubscriber(thumb) {
        return merge$1(this._destroyer$, thumb.destroy);
    }
    hasValueChanged(oldValue) {
        const isSliderWithDifferentValue = !this.isRange && oldValue !== this.value;
        const isRangeWithOneDifferentValue = this.isRange &&
            (oldValue.lower !== this.value.lower ||
                oldValue.upper !== this.value.upper);
        return isSliderWithDifferentValue || isRangeWithOneDifferentValue;
    }
    setValue(value, triggerChange) {
        let res;
        if (!this.isRange) {
            this.upperValue = value - (value % this.step);
            res = this.upperValue;
        }
        else {
            value = this.validateInitialValue(value);
            this.upperValue = value.upper;
            this.lowerValue = value.lower;
            res = { lower: this.lowerValue, upper: this.upperValue };
        }
        if (triggerChange) {
            this._onChangeCallback(res);
        }
    }
    emitValueChanged(oldValue) {
        this.onValueChange.emit({ oldValue, value: this.value });
    }
}
IgxSliderComponent.ɵfac = function IgxSliderComponent_Factory(t) { return new (t || IgxSliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(IgxDirectionality)); };
IgxSliderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSliderComponent, selectors: [["igx-slider"]], contentQueries: function IgxSliderComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxThumbFromTemplateDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxThumbToTemplateDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTickLabelTemplateDirective, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumbFromTemplateRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumbToTemplateRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tickLabelTemplateRef = _t.first);
    } }, viewQuery: function IgxSliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c228, true);
        ɵngcc0.ɵɵstaticViewQuery(_c229, true);
        ɵngcc0.ɵɵviewQuery(IgxSliderThumbComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxThumbLabelComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticks = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.trackRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumbs = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.labelRefs = _t);
    } }, hostVars: 9, hostBindings: function IgxSliderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("pointerdown", function IgxSliderComponent_pointerdown_HostBindingHandler($event) { return ctx.onPointerDown($event); })("pointerup", function IgxSliderComponent_pointerup_HostBindingHandler($event) { return ctx.onPointerUp($event); })("focus", function IgxSliderComponent_focus_HostBindingHandler() { return ctx.onFocus(); })("pan", function IgxSliderComponent_pan_HostBindingHandler($event) { return ctx.onPanListener($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("id", ctx.id)("aria-valuemin", ctx.valuemin)("aria-valuemax", ctx.valuemax)("aria-readonly", ctx.readonly);
        ɵngcc0.ɵɵclassProp("igx-slider", ctx.slierClass)("igx-slider--disabled", ctx.disabledClass);
    } }, inputs: { id: "id", thumbLabelVisibilityDuration: "thumbLabelVisibilityDuration", showTicks: "showTicks", primaryTickLabels: "primaryTickLabels", secondaryTickLabels: "secondaryTickLabels", ticksOrientation: "ticksOrientation", tickLabelsOrientation: "tickLabelsOrientation", type: "type", labels: "labels", step: "step", disabled: "disabled", continuous: "continuous", minValue: "minValue", lowerBound: "lowerBound", maxValue: "maxValue", upperBound: "upperBound", value: "value", primaryTicks: "primaryTicks", secondaryTicks: "secondaryTicks" }, outputs: { onValueChange: "onValueChange", onValueChanged: "onValueChanged" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSliderComponent, multi: true }]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 13, vars: 21, consts: [[1, "igx-slider__track"], [3, "ticksOrientation", "primaryTicks", "secondaryTicks", "primaryTickLabels", "secondaryTickLabels", "tickLabelsOrientation", "labelsViewEnabled", "labels", "tickLabelTemplateRef", "minValue", "maxValue", 4, "ngIf"], [1, "igx-slider__track-fill"], ["track", ""], [1, "igx-slider__track-steps"], ["ticks", ""], [1, "igx-slider__thumbs"], [3, "type", "value", "templateRef", "continuous", "context", "deactiveState", 4, "ngIf"], [3, "type", "value", "disabled", "continuous", "onPan", "stepDistance", "step", "templateRef", "context", "deactiveState", "thumbLabelVisibilityDuration", "onChange", "onHoverChange", 4, "ngIf"], [3, "value", "type", "templateRef", "continuous", "context", "deactiveState"], [3, "type", "value", "disabled", "continuous", "onPan", "stepDistance", "step", "templateRef", "context", "deactiveState", "thumbLabelVisibilityDuration", "onChange", "onHoverChange"], ["thumbTo", ""], [3, "ticksOrientation", "primaryTicks", "secondaryTicks", "primaryTickLabels", "secondaryTickLabels", "tickLabelsOrientation", "labelsViewEnabled", "labels", "tickLabelTemplateRef", "minValue", "maxValue"], [3, "type", "value", "templateRef", "continuous", "context", "deactiveState"], ["thumbFrom", ""]], template: function IgxSliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxSliderComponent_igx_ticks_1_Template, 2, 14, "igx-ticks", 1);
        ɵngcc0.ɵɵelement(2, "div", 2, 3);
        ɵngcc0.ɵɵelement(4, "div", 4, 5);
        ɵngcc0.ɵɵtemplate(6, IgxSliderComponent_igx_ticks_6_Template, 2, 14, "igx-ticks", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "div", 6);
        ɵngcc0.ɵɵtemplate(8, IgxSliderComponent_igx_thumb_label_8_Template, 1, 6, "igx-thumb-label", 7);
        ɵngcc0.ɵɵtemplate(9, IgxSliderComponent_igx_thumb_9_Template, 2, 11, "igx-thumb", 8);
        ɵngcc0.ɵɵelement(10, "igx-thumb-label", 9);
        ɵngcc0.ɵɵelementStart(11, "igx-thumb", 10, 11);
        ɵngcc0.ɵɵlistener("onChange", function IgxSliderComponent_Template_igx_thumb_onChange_11_listener() { return ctx.onThumbChange(); })("onHoverChange", function IgxSliderComponent_Template_igx_thumb_onHoverChange_11_listener($event) { return ctx.onHoverChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showTicks && ctx.showTopTicks);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showTicks && ctx.showBottomTicks);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isRange);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isRange);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("value", ctx.upperLabel)("type", 1)("templateRef", ctx.thumbToTemplateRef)("continuous", ctx.continuous)("context", ctx.context)("deactiveState", ctx.deactivateThumbLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("type", 1)("value", ctx.upperLabel)("disabled", ctx.disabled)("continuous", ctx.continuous)("onPan", ctx.onPan)("stepDistance", ctx.stepDistance)("step", ctx.step)("templateRef", ctx.thumbToTemplateRef)("context", ctx.context)("deactiveState", ctx.deactivateThumbLabel)("thumbLabelVisibilityDuration", ctx.thumbLabelVisibilityDuration);
    } }, directives: [ɵngcc2.NgIf, IgxThumbLabelComponent, IgxSliderThumbComponent, IgxTicksComponent], pipes: [IgxTickLabelsPipe], encapsulation: 2 });
IgxSliderComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: IgxDirectionality }
];
IgxSliderComponent.propDecorators = {
    ticks: [{ type: ViewChild, args: ['ticks', { static: true },] }],
    thumbs: [{ type: ViewChildren, args: [IgxSliderThumbComponent,] }],
    labelRefs: [{ type: ViewChildren, args: [IgxThumbLabelComponent,] }],
    trackRef: [{ type: ViewChild, args: ['track', { static: true },] }],
    thumbFromTemplateRef: [{ type: ContentChild, args: [IgxThumbFromTemplateDirective, { read: TemplateRef },] }],
    thumbToTemplateRef: [{ type: ContentChild, args: [IgxThumbToTemplateDirective, { read: TemplateRef },] }],
    tickLabelTemplateRef: [{ type: ContentChild, args: [IgxTickLabelTemplateDirective, { read: TemplateRef, static: false },] }],
    role: [{ type: HostBinding, args: [`attr.role`,] }],
    valuemin: [{ type: HostBinding, args: [`attr.aria-valuemin`,] }],
    valuemax: [{ type: HostBinding, args: [`attr.aria-valuemax`,] }],
    readonly: [{ type: HostBinding, args: [`attr.aria-readonly`,] }],
    slierClass: [{ type: HostBinding, args: ['class.igx-slider',] }],
    disabledClass: [{ type: HostBinding, args: ['class.igx-slider--disabled',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    type: [{ type: Input }],
    thumbLabelVisibilityDuration: [{ type: Input }],
    labels: [{ type: Input }],
    step: [{ type: Input }],
    disabled: [{ type: Input }],
    continuous: [{ type: Input }],
    minValue: [{ type: Input }],
    maxValue: [{ type: Input }],
    lowerBound: [{ type: Input }],
    upperBound: [{ type: Input }],
    value: [{ type: Input }],
    primaryTicks: [{ type: Input }],
    secondaryTicks: [{ type: Input }],
    showTicks: [{ type: Input }],
    primaryTickLabels: [{ type: Input }],
    secondaryTickLabels: [{ type: Input }],
    ticksOrientation: [{ type: Input }],
    tickLabelsOrientation: [{ type: Input }],
    onValueChange: [{ type: Output }],
    onValueChanged: [{ type: Output }],
    onPointerDown: [{ type: HostListener, args: ['pointerdown', ['$event'],] }],
    onPointerUp: [{ type: HostListener, args: ['pointerup', ['$event'],] }],
    onFocus: [{ type: HostListener, args: ['focus',] }],
    onPanListener: [{ type: HostListener, args: ['pan', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxSliderModule {
}
IgxSliderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxSliderModule });
IgxSliderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxSliderModule_Factory(t) { return new (t || IgxSliderModule)(); }, imports: [[CommonModule, FormsModule]] });

const SwitchLabelPosition = mkenum({
    BEFORE: 'before',
    AFTER: 'after'
});
const noop$8 = () => { };
const ɵ0$a = noop$8;
let nextId$3 = 0;
/**
 *
 * The Switch component is a binary choice selection component.
 *
 * @igxModule IgxSwitchModule
 *
 * @igxTheme igx-switch-theme, igx-tooltip-theme
 *
 * @igxKeywords switch, states, tooltip
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 *
 * The Ignite UI Switch lets the user toggle between on/off or true/false states.
 *
 * @example
 * ```html
 * <igx-switch [checked]="true">
 *   Simple switch
 * </igx-switch>
 * ```
 */
class IgxSwitchComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the switch component.
         * If not set, the `id` of the first switch component will be `"igx-switch-0"`.
         *
         * @example
         * ```html
         * <igx-switch id="my-first-switch"></igx-switch>
         * ```
         */
        this.id = `igx-switch-${nextId$3++}`;
        /**
         * Sets/gets the id of the `label` element of the switch component.
         * If not set, the label of the first switch component will have value `"igx-switch-0-label"`.
         *
         * @example
         * ```html
         * <igx-switch labelId="Label1"></igx-switch>
         * ```
         */
        this.labelId = `${this.id}-label`;
        /**
         * Sets/gets the value of the `tabindex` attribute.
         *
         * @example
         * ```html
         * <igx-switch [tabindex]="1"></igx-switch>
         * ```
         */
        this.tabindex = null;
        /**
         * Sets/gets the position of the `label` in the switch component.
         * If not set, `labelPosition` will have value `"after"`.
         *
         * @example
         * ```html
         * <igx-switch labelPosition="before"></igx-switch>
         * ```
         */
        this.labelPosition = 'after';
        /**
         * Enables/Disables the ripple effect
         * If not set, `disableRipple` will have value `false`.
         *
         * @example
         * ```html
         * <igx-switch [disableRipple]="true"></igx-switch>
         * ```
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether switch is required.
         * If not set, `required` will have value `false`.
         *
         * @example
         * ```html
         * <igx-switch [required]="true"></igx-switch>
         * ```
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledBy` attribute.
         * If not set, the  value of `aria-labelledBy` will be equal to the value of `labelId` attribute.
         *
         * @example
         * ```html
         * <igx-switch aria-labelledby = "Label1"></igx-switch>
         * ```
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the value of the `aria-label` attribute.
         *
         * @example
         * ```html
         * <igx-switch aria-label="Label1"></igx-switch>
         * ```
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the switch state is changed.
         * Provides references to the `IgxSwitchComponent` and the `checked` property as event arguments.
         */
        this.change = new EventEmitter();
        /**
         * @hidden
         * @internal
         */
        this._onTouchedCallback = noop$8;
        /**
         * @hidden
         * @internal
         */
        this._onChangeCallback = noop$8;
        /**
         * Returns the class of the switch component.
         *
         * @example
         * ```typescript
         * let switchClass = this.switch.cssClass;
         * ```
         */
        this.cssClass = 'igx-switch';
        /**
         * Sets/gets whether the switch is on or off.
         * Default value is 'false'.
         *
         * @example
         * ```html
         *  <igx-switch [checked]="true"></igx-switch>
         * ```
         */
        this.checked = false;
        /**
         * Sets/gets the `disabled` attribute.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-switch [disabled]="true"><igx-switch>
         * ```
         */
        this.disabled = false;
        /**
         * Sets/gets whether the switch component is on focus.
         * Default value is `false`.
         *
         * @example
         * ```typescript
         * this.switch.focused = true;
         * ```
         */
        this.focused = false;
        /**
         * @hidden
         * @internal
         */
        this.inputId = `${this.id}-input`;
    }
    /**
     * Toggles the checked state of the switch.
     *
     * @example
     * ```typescript
     * this.switch.toggle();
     * ```
     */
    toggle() {
        if (this.disabled) {
            return;
        }
        this.checked = !this.checked;
        this.focused = false;
        this.change.emit({ checked: this.checked, switch: this });
        this._onChangeCallback(this.checked);
    }
    /**
     * @hidden
     * @internal
     */
    _onSwitchChange(event) {
        event.stopPropagation();
    }
    /**
     * @hidden
     * @internal
     */
    _onSwitchClick(event) {
        event.stopPropagation();
        this.toggle();
        if (isIE()) {
            this.nativeCheckbox.nativeElement.blur();
        }
    }
    /**
     * @hidden
     * @internal
     */
    _onLabelClick(event) {
        this.toggle();
    }
    /**
     * @hidden
     * @internal
     */
    onFocus(event) {
        this.focused = true;
    }
    /**
     * @hidden
     * @internal
     */
    onBlur(event) {
        this.focused = false;
        this._onTouchedCallback();
    }
    /**
     * @hidden
     * @internal
     */
    writeValue(value) {
        this._value = value;
        this.checked = !!this._value;
    }
    /**
     * @hidden
     * @internal
     */
    getEditElement() {
        return this.nativeCheckbox.nativeElement;
    }
    /**
     * @hidden
     * @internal
     */
    get labelClass() {
        switch (this.labelPosition) {
            case SwitchLabelPosition.BEFORE:
                return `${this.cssClass}__label--before`;
            case SwitchLabelPosition.AFTER:
            default:
                return `${this.cssClass}__label`;
        }
    }
    /**
     * @hidden
     * @internal
     */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /**
     * @hidden
     * @internal
     */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
}
IgxSwitchComponent.ɵfac = function IgxSwitchComponent_Factory(t) { return new (t || IgxSwitchComponent)(); };
IgxSwitchComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSwitchComponent, selectors: [["igx-switch"]], viewQuery: function IgxSwitchComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c12, true);
        ɵngcc0.ɵɵstaticViewQuery(_c13, true);
        ɵngcc0.ɵɵstaticViewQuery(_c11, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nativeCheckbox = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nativeLabel = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.placeholderLabel = _t.first);
    } }, hostVars: 9, hostBindings: function IgxSwitchComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-switch", ctx.cssClass)("igx-switch--checked", ctx.checked)("igx-switch--disabled", ctx.disabled)("igx-switch--focused", ctx.focused);
    } }, inputs: { id: "id", labelId: "labelId", tabindex: "tabindex", labelPosition: "labelPosition", disableRipple: "disableRipple", required: "required", ariaLabelledBy: ["aria-labelledby", "ariaLabelledBy"], ariaLabel: ["aria-label", "ariaLabel"], checked: "checked", disabled: "disabled", value: "value", name: "name" }, outputs: { change: "change" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSwitchComponent, multi: true }])], ngContentSelectors: _c2, decls: 9, vars: 17, consts: [["type", "checkbox", 1, "igx-switch__input", 3, "id", "name", "value", "tabindex", "disabled", "checked", "required", "change", "click", "focus", "blur"], ["checkbox", ""], ["igxRipple", "", "igxRippleTarget", ".igx-switch__ripple", 1, "igx-switch__composite", 3, "for", "igxRippleDisabled", "igxRippleCentered", "igxRippleDuration"], ["label", ""], [1, "igx-switch__composite-thumb"], [1, "igx-switch__ripple"], [3, "id", "click"], ["placeholderLabel", ""]], template: function IgxSwitchComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("change", function IgxSwitchComponent_Template_input_change_0_listener($event) { return ctx._onSwitchChange($event); })("click", function IgxSwitchComponent_Template_input_click_0_listener($event) { return ctx._onSwitchClick($event); })("focus", function IgxSwitchComponent_Template_input_focus_0_listener($event) { return ctx.onFocus($event); })("blur", function IgxSwitchComponent_Template_input_blur_0_listener($event) { return ctx.onBlur($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "label", 2, 3);
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵelement(5, "div", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "span", 6, 7);
        ɵngcc0.ɵɵlistener("click", function IgxSwitchComponent_Template_span_click_6_listener($event) { return ctx._onLabelClick($event); });
        ɵngcc0.ɵɵprojection(8);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.inputId)("name", ctx.name)("value", ctx.value)("tabindex", ctx.tabindex)("disabled", ctx.disabled)("checked", ctx.checked)("required", ctx.required);
        ɵngcc0.ɵɵattribute("aria-checked", ctx.checked)("aria-labelledby", ctx.ariaLabelledBy)("aria-label", ctx.ariaLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("for", ctx.inputId)("igxRippleDisabled", ctx.disableRipple)("igxRippleCentered", true)("igxRippleDuration", 300);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵclassMap(ctx.labelClass);
        ɵngcc0.ɵɵproperty("id", ctx.labelId);
    } }, directives: [IgxRippleDirective], encapsulation: 2 });
IgxSwitchComponent.propDecorators = {
    nativeCheckbox: [{ type: ViewChild, args: ['checkbox', { static: true },] }],
    nativeLabel: [{ type: ViewChild, args: ['label', { static: true },] }],
    placeholderLabel: [{ type: ViewChild, args: ['placeholderLabel', { static: true },] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    labelId: [{ type: Input }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    tabindex: [{ type: Input }],
    labelPosition: [{ type: Input }],
    disableRipple: [{ type: Input }],
    required: [{ type: Input }],
    ariaLabelledBy: [{ type: Input, args: ['aria-labelledby',] }],
    ariaLabel: [{ type: Input, args: ['aria-label',] }],
    change: [{ type: Output }],
    cssClass: [{ type: HostBinding, args: ['class.igx-switch',] }],
    checked: [{ type: HostBinding, args: ['class.igx-switch--checked',] }, { type: Input }],
    disabled: [{ type: HostBinding, args: ['class.igx-switch--disabled',] }, { type: Input }],
    focused: [{ type: HostBinding, args: ['class.igx-switch--focused',] }]
};
const IGX_SWITCH_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => IgxSwitchRequiredDirective),
    multi: true
};
/* tslint:disable directive-selector */
class IgxSwitchRequiredDirective extends CheckboxRequiredValidator {
}
IgxSwitchRequiredDirective.ɵfac = function IgxSwitchRequiredDirective_Factory(t) { return ɵIgxSwitchRequiredDirective_BaseFactory(t || IgxSwitchRequiredDirective); };
IgxSwitchRequiredDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSwitchRequiredDirective, selectors: [["igx-switch", "required", "", "formControlName", ""], ["igx-switch", "required", "", "formControl", ""], ["igx-switch", "required", "", "ngModel", ""]], features: [ɵngcc0.ɵɵProvidersFeature([IGX_SWITCH_REQUIRED_VALIDATOR]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @hidden
 */
class IgxSwitchModule {
}
IgxSwitchModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxSwitchModule });
IgxSwitchModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxSwitchModule_Factory(t) { return new (t || IgxSwitchModule)(); }, imports: [[IgxRippleModule]] });

let NEXT_ID$u = 0;
class IgxTabTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxTabTemplateDirective.ɵfac = function IgxTabTemplateDirective_Factory(t) { return new (t || IgxTabTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxTabTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTabTemplateDirective, selectors: [["", "igxTab", ""]] });
IgxTabTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * **Ignite UI for Angular Tab Bar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tabbar)
 *
 * The Ignite UI Tab Bar enables the user to navigate among a number of content panels displayed in a single view.
 *
 * Example:
 * ```html
 * <igx-bottom-nav>
 *   <igx-tab-panel label="Tab 1">Tab 1 Content</igx-tab-panel>
 *   <igx-tab-panel label="Tab 2">Tab 2 Content</igx-tab-panel>
 *   <igx-tab-panel label="Tab 3">Tab 3 Content</igx-tab-panel>
 * </igx-bottom-nav>
 * ```
 */
class IgxBottomNavComponent {
    constructor(_element) {
        this._element = _element;
        this._currentBottomNavId = NEXT_ID$u++;
        /**
         * Sets/gets the `id` of the tab bar.
         * If not set, the `id` of the first tab bar component will be `"igx-bottom-nav-0"`.
         * ```html
         * <igx-bottom-nav id = "my-first-tab-bar"></igx-bottom-nav>
         * ```
         * ```typescript
         * let tabBarId =  this.tabBar.id;
         * ```
         * @memberof IgxBottomNavComponent
         */
        this.id = `igx-bottom-nav-${this._currentBottomNavId}`;
        /**
         * Emits an event when a new tab is selected.
         * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
         * ```html
         * <igx-bottom-nav (onTableSelected) = "onTabSelected($event)"><igx-bottom-nav>
         * ```
         * @memberof IgxBottomNavComponent
         */
        this.onTabSelected = new EventEmitter();
        /**
         * Emits an event when a tab is deselected.
         * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
         * ```html
         * <igx-bottom-nav (onTabDeselected) = "onTabDeselected($event)"><igx-bottom-nav>
         * ```
         * @memberof IgxBottomNavComponent
         */
        this.onTabDeselected = new EventEmitter();
        /**
         * Gets the `index` of selected tab/panel in the respective collection.
         * ```typescript
         * let index =  this.tabBar.selectedIndex;
         * ```
         * @memberof IgxBottomNavComponent
         */
        this.selectedIndex = -1;
        /**
         * @hidden
         */
        this._itemStyle = 'igx-bottom-nav';
    }
    /**
     * Gets the `IgxTabComponent` elements for this bottom navigation component.
     * First try to get them as content children if not available get them as view children.
     * ```typescript
     * let tabs: QueryList<IgxTabComponent> =  this.tabBar.tabs;
     * ```
     * @memberof IgxBottomNavComponent
     */
    get tabs() {
        return this.hasContentTabs ? this.contentTabs : this.viewTabs;
    }
    /**
     * Gets the `itemStyle` of the tab bar.
     * ```typescript
     * let itemStyle =  this.tabBar.itemStyle;
     * ```
     * @memberof IgxBottomNavComponent
     */
    get itemStyle() {
        return this._itemStyle;
    }
    /**
     * @hidden
     */
    get hasContentTabs() {
        return (this.contentTabs && this.contentTabs.length > 0);
    }
    /**
     * Gets the selected tab in the tab bar.
     * ```typescript
     * let tab =  this.tabBar.selectedTab;
     * ```
     * @memberof IgxBottomNavComponent
     */
    get selectedTab() {
        if (this.tabs && this.selectedIndex !== undefined) {
            return this.tabs.toArray()[this.selectedIndex];
        }
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.setPanelsAttributes();
        this._panelsChanges$ = this.panels.changes.subscribe(() => {
            this.setPanelsAttributes();
        });
        // initial selection
        setTimeout(() => {
            if (this.selectedIndex === -1) {
                const selectablePanels = this.panels.filter((p) => !p.disabled);
                const panel = selectablePanels[0];
                if (panel) {
                    panel.select();
                }
            }
        }, 0);
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this._panelsChanges$) {
            this._panelsChanges$.unsubscribe();
        }
    }
    setPanelsAttributes() {
        const panelsArray = Array.from(this.panels);
        for (let index = 0; index < this.panels.length; index++) {
            const tabPanels = panelsArray[index];
            tabPanels.nativeElement.setAttribute('id', this.getTabPanelId(index));
            tabPanels.nativeElement.setAttribute('aria-labelledby', this.getTabId(index));
        }
    }
    /**
     * @hidden
     */
    _selectedPanelHandler(args) {
        if (this.hasContentTabs) {
            this.selectedIndex = args.tab.index;
            this.contentTabs.forEach((t) => {
                if (t !== args.tab) {
                    this._deselectTab(t);
                }
            });
        }
        else {
            if (args.panel) {
                this.selectedIndex = args.panel.index;
                this.panels.forEach((p) => {
                    if (p.index !== this.selectedIndex) {
                        this._deselectPanel(p);
                    }
                });
            }
        }
    }
    /**
     * @hidden
     */
    _deselectPanel(panel) {
        // Cannot deselect the selected tab - this will mean that there will be not selected tab left
        if (panel.disabled || this.selectedTab.index === panel.index) {
            return;
        }
        panel.isSelected = false;
        this.onTabDeselected.emit({ tab: this.tabs[panel.index], panel });
    }
    _deselectTab(aTab) {
        aTab.isSelected = false;
        this.onTabDeselected.emit({ tab: aTab, panel: null });
    }
    /**
     * @hidden
     */
    getTabId(index) {
        return `igx-tab-${this._currentBottomNavId}-${index}`;
    }
    /**
     * @hidden
     */
    getTabPanelId(index) {
        return `igx-tab-panel-${this._currentBottomNavId}-${index}`;
    }
}
IgxBottomNavComponent.ɵfac = function IgxBottomNavComponent_Factory(t) { return new (t || IgxBottomNavComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxBottomNavComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxBottomNavComponent, selectors: [["igx-bottom-nav"]], contentQueries: function IgxBottomNavComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabComponent, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabPanelComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTabs = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panels = _t);
    } }, viewQuery: function IgxBottomNavComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxTabComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewTabs = _t);
    } }, hostVars: 1, hostBindings: function IgxBottomNavComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("onTabSelected", function IgxBottomNavComponent_onTabSelected_HostBindingHandler($event) { return ctx._selectedPanelHandler($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { id: "id" }, outputs: { onTabSelected: "onTabSelected", onTabDeselected: "onTabDeselected" }, ngContentSelectors: _c231, decls: 5, vars: 6, consts: [[4, "ngIf"], ["role", "tablist", "aria-orientation", "horizontal"], ["tablist", ""], [3, "relatedPanel", "autoGenerated", "id", 4, "ngFor", "ngForOf"], [3, "relatedPanel", "autoGenerated", "id"]], template: function IgxBottomNavComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c230);
        ɵngcc0.ɵɵtemplate(0, IgxBottomNavComponent_div_0_Template, 2, 0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵtemplate(3, IgxBottomNavComponent_ng_container_3_Template, 2, 1, "ng-container", 0);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.hasContentTabs);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMapInterpolate2("", ctx.itemStyle, "__menu ", ctx.itemStyle, "__menu--bottom");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.hasContentTabs);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgForOf, IgxTabComponent]; }, styles: [_c80] });
IgxBottomNavComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxBottomNavComponent.propDecorators = {
    viewTabs: [{ type: ViewChildren, args: [forwardRef(() => IgxTabComponent),] }],
    contentTabs: [{ type: ContentChildren, args: [forwardRef(() => IgxTabComponent),] }],
    panels: [{ type: ContentChildren, args: [forwardRef(() => IgxTabPanelComponent),] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    onTabSelected: [{ type: Output }],
    onTabDeselected: [{ type: Output }],
    _selectedPanelHandler: [{ type: HostListener, args: ['onTabSelected', ['$event'],] }]
};
// ================================= IgxTabPanelComponent ======================================
class IgxTabPanelComponent {
    constructor(_tabBar, _element) {
        this._tabBar = _tabBar;
        this._element = _element;
        /**
         * @hidden
         */
        this._itemStyle = 'igx-tab-panel';
        /**
         * @hidden
         */
        this._isSelected = false;
        /**
         * Gets the role of the tab panel.
         * ```typescript
         * let tabPanelRole = this.tabPanel.role;
         * ```
         * @memberof IgxTabPanelComponent
         */
        this.role = 'tabpanel';
    }
    /**
     * Gets whether a tab panel will have `igx-bottom-nav__panel` class.
     * ```typescript
     * let styleClass = this.tabPanel.styleClass;
     * ```
     * @memberof IgxTabPanelComponent
     */
    get styleClass() {
        return (!this.isSelected);
    }
    /**
     * Sets/gets whether a tab panel is selected.
     * ```typescript
     * this.tabPanel.isSelected = true;
     * ```
     * ```typescript
     * let isSelected =  this.tabPanel.isSelected;
     * ```
     * @memberof IgxTabPanelComponent
     */
    get isSelected() {
        return this._isSelected;
    }
    set isSelected(newValue) {
        if (this._isSelected !== newValue) {
            if (newValue) {
                this.select();
            }
            else {
                this._isSelected = newValue;
            }
        }
    }
    /**
     * Gets the `itemStyle` of the tab panel.
     * ```typescript
     * let itemStyle = this.tabPanel.itemStyle;
     * ```
     * @memberof IgxTabPanelComponent
     */
    get itemStyle() {
        return this._itemStyle;
    }
    /**
     * Returns the native element of the tab-panel component
     * ```typescript
     *  const mytabPanelElement: HTMLElement = tabPanel.nativeElement;
     * ```
     */
    get nativeElement() {
        return this._element.nativeElement;
    }
    /**
     * Gets the tab associated with the panel.
     * ```typescript
     * let tab = this.tabPanel.relatedTab;
     * ```
     * @memberof IgxTabPanelComponent
     */
    get relatedTab() {
        if (this._tabBar.tabs) {
            return this._tabBar.tabs.toArray()[this.index];
        }
    }
    /**
     * Gets the changes and updates accordingly applied to the tab/panel.
     *
     * @memberof IgxTabComponent
     */
    get changesCount() {
        return this.relatedTab ? this.relatedTab.changesCount : 0;
    }
    /**
     * Gets the index of a panel in the panels collection.
     * ```typescript
     * let panelIndex =  this.tabPanel.index
     * ```
     * @memberof IgxTabPanelComponent
     */
    get index() {
        if (this._tabBar.panels) {
            return this._tabBar.panels.toArray().indexOf(this);
        }
    }
    /**
     * Gets the tab template.
     * ```typescript
     * let tabTemplate = this.tabPanel.customTabTemplate
     * ```
     * @memberof IgxTabPanelComponent
     */
    get customTabTemplate() {
        return this._tabTemplate;
    }
    /**
     * Sets the tab template.
     * ```typescript
     * this.tabPanel.customTabTemplate(tabTemplate);
     * ```
     * @memberof IgxTabPanelComponent
     */
    set customTabTemplate(template) {
        this._tabTemplate = template;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.tabTemplate) {
            this._tabTemplate = this.tabTemplate.template;
        }
    }
    /**
     * Selects the current tab and the tab panel.
     * ```typescript
     * this.tabPanel.select();
     * ```
     * @memberof IgxTabPanelComponent
     */
    select() {
        if (this.disabled || this._tabBar.selectedIndex === this.index) {
            return;
        }
        this._isSelected = true;
        this._tabBar.onTabSelected.emit({ tab: this._tabBar.tabs.toArray()[this.index], panel: this });
    }
}
IgxTabPanelComponent.ɵfac = function IgxTabPanelComponent_Factory(t) { return new (t || IgxTabPanelComponent)(ɵngcc0.ɵɵdirectiveInject(IgxBottomNavComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxTabPanelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTabPanelComponent, selectors: [["igx-tab-panel"]], contentQueries: function IgxTabPanelComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabTemplateDirective, true, IgxTabTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabTemplate = _t.first);
    } }, hostVars: 5, hostBindings: function IgxTabPanelComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-bottom-nav__panel", ctx.styleClass)("igx-bottom-nav__panel--selected", ctx.isSelected);
    } }, inputs: { label: "label", icon: "icon", disabled: "disabled" }, ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxTabPanelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
IgxTabPanelComponent.ctorParameters = () => [
    { type: IgxBottomNavComponent },
    { type: ElementRef }
];
IgxTabPanelComponent.propDecorators = {
    label: [{ type: Input }],
    icon: [{ type: Input }],
    disabled: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    styleClass: [{ type: HostBinding, args: ['class.igx-bottom-nav__panel',] }],
    isSelected: [{ type: HostBinding, args: ['class.igx-bottom-nav__panel--selected',] }],
    tabTemplate: [{ type: ContentChild, args: [IgxTabTemplateDirective, { read: IgxTabTemplateDirective },] }]
};
// ======================================= IgxTabComponent ==========================================
class IgxTabComponent {
    constructor(_tabBar, _element) {
        this._tabBar = _tabBar;
        this._element = _element;
        /**
         * Gets the `role` attribute.
         * ```typescript
         * let tabRole = this.tab.role;
         * ```
         * @memberof IgxTabComponent
         */
        this.role = 'tab';
        /**
         * @hidden @internal
         */
        this.ariaLabel = this.label;
        /**
         * @hidden @internal
         */
        this.ariaDisabled = this.disabled;
        /**
         * @hidden @internal
         */
        this.ariaSelected = this.isSelected;
        /**
         * @hidden
         */
        this._changesCount = 0; // changes and updates accordingly applied to the tab.
        this._disabled = false;
        this._selected = false;
    }
    /**
     * Sets/gets the `label` of the tab panel.
     * ```html
     * <igx-tab [label] = "'Tab label'"><igx-tab>
     * ```
     * ```typescript
     * let tabLabel = this.tab.label;
     * ```
     * @memberof IgxTabComponent
     */
    get label() {
        return this.relatedPanel ? this.relatedPanel.label : this._label;
    }
    set label(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.label = newValue;
        }
        this._label = newValue;
    }
    /**
     * Sets/gets  the `icon` of the tab panel.
     * ```html
     * <igx-tab [icon] = "tab_icon"><igx-tab>
     * ```
     * ```typescript
     * let tabIcon =  this.tab.icon;
     * ```
     * @memberof IgxTabComponent
     */
    get icon() {
        return this.relatedPanel ? this.relatedPanel.icon : this._icon;
    }
    set icon(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.icon = newValue;
        }
        this._icon = newValue;
    }
    /**
     * Gets the changes and updates accordingly applied to the tab.
     *
     * @memberof IgxTabComponent
     */
    get changesCount() {
        return this._changesCount;
    }
    /**
     * Gets whether the tab is disabled.
     * ```typescript
     * let isDisabled = this.tab.disabled;
     * ```
     * @memberof IgxTabComponent
     */
    get disabled() {
        return this.relatedPanel ? this.relatedPanel.disabled : this._disabled;
    }
    set disabled(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.disabled = newValue;
        }
        else {
            this._disabled = newValue;
        }
    }
    /**
     * Gets whether the tab is selected.
     * ```typescript
     * let isSelected  = this.tab.isSelected;
     * ```
     * @memberof IgxTabComponent
     */
    set isSelected(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.isSelected = newValue;
        }
        else if (this._selected !== newValue) {
            this._selected = newValue;
            if (this._selected) {
                this._tabBar.onTabSelected.emit({ tab: this, panel: null });
            }
        }
    }
    get isSelected() {
        return this.relatedPanel ? this.relatedPanel.isSelected : this._selected;
    }
    get cssClassSelected() {
        return this.isSelected;
    }
    get cssClassDisabled() {
        return this.disabled;
    }
    get cssClass() {
        return (!this.disabled && !this.isSelected);
    }
    /**
     * Gets the `index` of the tab.
     * ```typescript
     * let tabIndex = this.tab.index;
     * ```
     * @memberof IgxTabComponent
     */
    get index() {
        if (this._tabBar.tabs) {
            return this._tabBar.tabs.toArray().indexOf(this);
        }
    }
    /**
     * Returns the `template` for this IgxTabComponent.
     * ```typescript
     * let tabItemTemplate = this.tabItem.template;
     * ```
     * @memberof IgxTabComponent
     */
    get template() {
        if (this.relatedPanel && this.relatedPanel.customTabTemplate) {
            return this.relatedPanel.customTabTemplate;
        }
        if (this.customTabTemplateDir) {
            return this.customTabTemplateDir.template;
        }
        return this.defaultTabTemplate;
    }
    /**
     * Returns the `context` object for the template of this `IgxTabComponent`.
     * ```typescript
     * let tabItemContext = this.tabItem.context;
     * ```
     */
    get context() {
        return this.relatedPanel ? this.relatedPanel : this;
    }
    /**
     * Selects the current tab and the associated panel.
     * ```typescript
     * this.tab.select();
     * ```
     * @memberof IgxTabComponent
     */
    select() {
        if (this.relatedPanel) {
            this.relatedPanel.select();
        }
        else {
            this._selected = true;
            this._tabBar.onTabSelected.emit({ tab: this, panel: null });
        }
    }
    /**
     * @hidden
     */
    onClick() {
        if (this.autoGenerated) {
            this.select();
        }
    }
    elementRef() {
        return this._element;
    }
}
IgxTabComponent.ɵfac = function IgxTabComponent_Factory(t) { return new (t || IgxTabComponent)(ɵngcc0.ɵɵdirectiveInject(IgxBottomNavComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxTabComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTabComponent, selectors: [["igx-tab"]], contentQueries: function IgxTabComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabTemplateDirective, true, IgxTabTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customTabTemplateDir = _t.first);
    } }, viewQuery: function IgxTabComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c232, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultTabTemplate = _t.first);
    } }, hostVars: 10, hostBindings: function IgxTabComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxTabComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("aria-label", ctx.ariaLabel)("aria-disabled", ctx.ariaDisabled)("aria-selected", ctx.ariaSelected);
        ɵngcc0.ɵɵclassProp("igx-bottom-nav__menu-item--selected", ctx.cssClassSelected)("igx-bottom-nav__menu-item--disabled", ctx.cssClassDisabled)("igx-bottom-nav__menu-item", ctx.cssClass);
    } }, inputs: { label: "label", icon: "icon", disabled: "disabled", isSelected: "isSelected", relatedPanel: "relatedPanel", autoGenerated: "autoGenerated" }, decls: 3, vars: 4, consts: [["defaultTabTemplate", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "tab-icon", 4, "ngIf"], ["ngClass", "tab-label", 4, "ngIf"], [1, "tab-icon"], ["fontSet", "material"], [3, "value", "hidden"], ["ngClass", "tab-label"]], template: function IgxTabComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxTabComponent_ng_template_0_Template, 2, 2, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxTabComponent_ng_container_2_Template, 1, 0, "ng-container", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, ctx.context));
    } }, directives: [ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxIconComponent, IgxBadgeComponent, ɵngcc2.NgClass], encapsulation: 2 });
IgxTabComponent.ctorParameters = () => [
    { type: IgxBottomNavComponent },
    { type: ElementRef }
];
IgxTabComponent.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.role',] }],
    ariaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],
    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],
    ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
    relatedPanel: [{ type: Input }],
    label: [{ type: Input }],
    icon: [{ type: Input }],
    disabled: [{ type: Input }],
    isSelected: [{ type: Input }],
    autoGenerated: [{ type: Input }],
    cssClassSelected: [{ type: HostBinding, args: ['class.igx-bottom-nav__menu-item--selected',] }],
    cssClassDisabled: [{ type: HostBinding, args: ['class.igx-bottom-nav__menu-item--disabled',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-bottom-nav__menu-item',] }],
    defaultTabTemplate: [{ type: ViewChild, args: ['defaultTabTemplate', { read: TemplateRef, static: true },] }],
    customTabTemplateDir: [{ type: ContentChild, args: [IgxTabTemplateDirective, { read: IgxTabTemplateDirective },] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
/**
 * @hidden
 */
class IgxBottomNavModule {
}
IgxBottomNavModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxBottomNavModule });
IgxBottomNavModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxBottomNavModule_Factory(t) { return new (t || IgxBottomNavModule)(); }, imports: [[CommonModule, IgxBadgeModule, IgxIconModule]] });

/** @hidden */
class IgxTabsBase {
    scrollElement(element, scrollRight) { }
    performSelectionChange(newTab) { }
    transformContentAnimation(tab, duration) { }
    transformIndicatorAnimation(element, duration) { }
}
/** @hidden */
class IgxTabItemBase {
    get index() { return 0; }
    select() { }
    setSelectedInternal(newValue) { }
}
/** @hidden */
class IgxTabsGroupBase {
    select() { }
    setSelectedInternal(newValue) { }
}

var ButtonStyle;
(function (ButtonStyle) {
    ButtonStyle["VISIBLE"] = "visible";
    ButtonStyle["HIDDEN"] = "hidden";
    ButtonStyle["NOT_DISPLAYED"] = "not_displayed";
})(ButtonStyle || (ButtonStyle = {}));
class IgxRightButtonStyleDirective {
    constructor(tabs) {
        this.tabs = tabs;
    }
    get visibleCSS() {
        return (this.getRightButtonStyle() === ButtonStyle.VISIBLE) ? true : false;
    }
    get hiddenCSS() {
        return (this.getRightButtonStyle() === ButtonStyle.HIDDEN) ? true : false;
    }
    get notDisplayedCSS() {
        return (this.getRightButtonStyle() === ButtonStyle.NOT_DISPLAYED) ? true : false;
    }
    getRightButtonStyle() {
        const viewPortWidth = this.tabs.viewPort.nativeElement.offsetWidth;
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
        }
        const headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
        const offset = this.tabs.offset;
        const total = offset + viewPortWidth;
        // Fix for IE 11, a difference is accumulated from the widths calculations.
        if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
            return ButtonStyle.NOT_DISPLAYED;
        }
        if (itemsContainerWidth > total) {
            return ButtonStyle.VISIBLE;
        }
        else {
            return ButtonStyle.HIDDEN;
        }
    }
}
IgxRightButtonStyleDirective.ɵfac = function IgxRightButtonStyleDirective_Factory(t) { return new (t || IgxRightButtonStyleDirective)(ɵngcc0.ɵɵdirectiveInject(IgxTabsBase)); };
IgxRightButtonStyleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRightButtonStyleDirective, selectors: [["", "igxRightButtonStyle", ""]], hostVars: 6, hostBindings: function IgxRightButtonStyleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-tabs__header-button", ctx.visibleCSS)("igx-tabs__header-button--hidden", ctx.hiddenCSS)("igx-tabs__header-button--none", ctx.notDisplayedCSS);
    } } });
IgxRightButtonStyleDirective.ctorParameters = () => [
    { type: IgxTabsBase }
];
IgxRightButtonStyleDirective.propDecorators = {
    visibleCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button',] }],
    hiddenCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--hidden',] }],
    notDisplayedCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--none',] }]
};
class IgxLeftButtonStyleDirective {
    constructor(tabs) {
        this.tabs = tabs;
    }
    get visibleCSS() {
        return (this.getLeftButtonStyle() === ButtonStyle.VISIBLE) ? true : false;
    }
    get hiddenCSS() {
        return (this.getLeftButtonStyle() === ButtonStyle.HIDDEN) ? true : false;
    }
    get notDisplayedCSS() {
        return (this.getLeftButtonStyle() === ButtonStyle.NOT_DISPLAYED) ? true : false;
    }
    getLeftButtonStyle() {
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
        }
        const headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
        const offset = this.tabs.offset;
        if (offset === 0) {
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1) {
                return ButtonStyle.NOT_DISPLAYED;
            }
            return ButtonStyle.HIDDEN;
        }
        else {
            return ButtonStyle.VISIBLE;
        }
    }
}
IgxLeftButtonStyleDirective.ɵfac = function IgxLeftButtonStyleDirective_Factory(t) { return new (t || IgxLeftButtonStyleDirective)(ɵngcc0.ɵɵdirectiveInject(IgxTabsBase)); };
IgxLeftButtonStyleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxLeftButtonStyleDirective, selectors: [["", "igxLeftButtonStyle", ""]], hostVars: 6, hostBindings: function IgxLeftButtonStyleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-tabs__header-button", ctx.visibleCSS)("igx-tabs__header-button--hidden", ctx.hiddenCSS)("igx-tabs__header-button--none", ctx.notDisplayedCSS);
    } } });
IgxLeftButtonStyleDirective.ctorParameters = () => [
    { type: IgxTabsBase }
];
IgxLeftButtonStyleDirective.propDecorators = {
    visibleCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button',] }],
    hiddenCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--hidden',] }],
    notDisplayedCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--none',] }]
};
class IgxTabItemTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxTabItemTemplateDirective.ɵfac = function IgxTabItemTemplateDirective_Factory(t) { return new (t || IgxTabItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxTabItemTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTabItemTemplateDirective, selectors: [["", "igxTab", ""]] });
IgxTabItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

class IgxTabItemComponent extends IgxTabItemBase {
    constructor(_tabs, _element, _ngZone) {
        super();
        this._tabs = _tabs;
        this._element = _element;
        this._ngZone = _ngZone;
        this._changesCount = 0; // changes and updates accordingly applied to the tab.
        this._isSelected = false;
        this._disabled = false;
        /**
         * @hidden @internal
         */
        this.role = 'tab';
        /**
         * @hidden @internal
         */
        this.tabindex = -1;
        /**
         * @hidden @internal
         */
        this.ariaLabel = this.label;
        /**
         * @hidden @internal
         */
        this.ariaDisabled = this.disabled;
        /**
         * @hidden @internal
         */
        this.ariaSelected = this.isSelected;
        this._nativeTabItem = _element;
    }
    /**
     * An @Input property that sets the value of the `icon`.
     * The value should be valid icon name from {@link https://material.io/tools/icons/?style=baseline}.
     * ```html
     * <igx-tab-item label="Tab 1" icon="home">
     * ```
     */
    get icon() {
        return this.relatedGroup ? this.relatedGroup.icon : this._icon;
    }
    set icon(newValue) {
        if (this.relatedGroup) {
            this.relatedGroup.icon = newValue;
        }
        this._icon = newValue;
    }
    /**
     * An @Input property that sets the value of the `label`.
     * ```html
     * <igx-tabs-item label="Tab 2" icon="folder">
     * ```
     */
    get label() {
        return this.relatedGroup ? this.relatedGroup.label : this._label;
    }
    set label(newValue) {
        if (this.relatedGroup) {
            this.relatedGroup.label = newValue;
        }
        this._label = newValue;
    }
    get provideCssClassSelected() {
        return this.isSelected;
    }
    get provideCssClassDisabled() {
        return this.disabled;
    }
    get provideCssClass() {
        return (!this.disabled && !this.isSelected);
    }
    ngAfterViewInit() {
        this._ngZone.runOutsideAngular(() => {
            this._resizeObserver = new ResizeObserver(() => {
                this._tabs.transformIndicatorAnimation(this._nativeTabItem.nativeElement, 0);
            });
        });
    }
    ngOnDestroy() {
        this._ngZone.runOutsideAngular(() => {
            this._resizeObserver.disconnect();
        });
    }
    /**
     * @hidden
     */
    onClick(event) {
        if (this.autoGenerated) {
            this.select();
        }
    }
    /**
     * @hidden
     */
    onKeydown(event) {
        const tabsArray = this._tabs.tabs.toArray();
        const startIndex = tabsArray.indexOf(this);
        let finalIndex = -1;
        let currentIndex = startIndex;
        switch (event.key) {
            case "ArrowRight" /* RIGHT_ARROW */:
            case "Right" /* RIGHT_ARROW_IE */:
                do {
                    currentIndex++;
                    if (currentIndex === tabsArray.length) {
                        currentIndex = -1;
                        continue;
                    }
                    else if (tabsArray[currentIndex].disabled === false) {
                        finalIndex = currentIndex;
                        break;
                    }
                } while (currentIndex !== startIndex);
                break;
            case "ArrowLeft" /* LEFT_ARROW */:
            case "Left" /* LEFT_ARROW_IE */:
                do {
                    currentIndex--;
                    if (currentIndex === -1) {
                        currentIndex = tabsArray.length;
                        continue;
                    }
                    else if (tabsArray[currentIndex].disabled === false) {
                        finalIndex = currentIndex;
                        break;
                    }
                } while (currentIndex !== startIndex);
                break;
            case "Home" /* HOME */:
                event.preventDefault();
                finalIndex = tabsArray.find(t => t.disabled === false).index;
                break;
            case "End" /* END */:
                event.preventDefault();
                finalIndex = tabsArray.slice().reverse().find(t => t.disabled === false).index;
                break;
            case "Enter" /* ENTER */:
                if (!this.autoGenerated) {
                    this.nativeTabItem.nativeElement.click();
                }
                break;
            case " " /* SPACE */:
            case "Spacebar" /* SPACE_IE */:
                event.preventDefault();
                if (!this.autoGenerated) {
                    this.nativeTabItem.nativeElement.click();
                }
                break;
            default:
                break;
        }
        if (finalIndex > -1) {
            const tab = tabsArray[finalIndex];
            tab.nativeTabItem.nativeElement.focus();
            if (this.autoGenerated) {
                tab.select();
            }
        }
    }
    /**
     * @hidden
     */
    get changesCount() {
        return this._changesCount;
    }
    /**
     * @hidden
     */
    get nativeTabItem() {
        return this._nativeTabItem;
    }
    /**
     * 	Gets whether the tab is disabled.
     * ```
     * const disabledItem = this.myTabComponent.tabs.first.disabled;
     * ```
     */
    get disabled() {
        return this.relatedGroup ? this.relatedGroup.disabled : this._disabled;
    }
    set disabled(newValue) {
        if (this.relatedGroup) {
            this.relatedGroup.disabled = newValue;
        }
        else {
            this._disabled = newValue;
        }
    }
    /**
     * Gets whether the tab is selected.
     * ```typescript
     * const selectedItem = this.myTabComponent.tabs.first.isSelected;
     * ```
     */
    get isSelected() {
        return this.relatedGroup ? this.relatedGroup.isSelected : this._isSelected;
    }
    set isSelected(newValue) {
        if (!this.disabled && this.isSelected !== newValue) {
            this._tabs.performSelectionChange(newValue ? this : null);
        }
    }
    /**
     * @hidden
     */
    select() {
        if (!this.disabled && !this.isSelected) {
            this._tabs.performSelectionChange(this);
        }
    }
    /**
     * @hidden
     */
    get index() {
        if (this._tabs.tabs) {
            return this._tabs.tabs.toArray().indexOf(this);
        }
        return -1;
    }
    /**
     * @hidden
     */
    setSelectedInternal(newValue) {
        this._isSelected = newValue;
        this._ngZone.runOutsideAngular(() => {
            if (this._resizeObserver) {
                if (this._isSelected) {
                    this._resizeObserver.observe(this._element.nativeElement);
                }
                else {
                    this._resizeObserver.disconnect();
                }
            }
        });
        this.tabindex = newValue ? 0 : -1;
    }
    /**
     * @hidden
     */
    get template() {
        if (this.relatedGroup && this.relatedGroup.customTabTemplate) {
            return this.relatedGroup.customTabTemplate;
        }
        if (this.customTabTemplateDir) {
            return this.customTabTemplateDir.template;
        }
        return this.defaultTabTemplate;
    }
    /**
     * @hidden
     */
    get context() {
        return this.relatedGroup ? this.relatedGroup : this;
    }
}
IgxTabItemComponent.ɵfac = function IgxTabItemComponent_Factory(t) { return new (t || IgxTabItemComponent)(ɵngcc0.ɵɵdirectiveInject(IgxTabsBase), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxTabItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTabItemComponent, selectors: [["igx-tab-item"]], contentQueries: function IgxTabItemComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabItemTemplateDirective, true, IgxTabItemTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customTabTemplateDir = _t.first);
    } }, viewQuery: function IgxTabItemComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c232, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultTabTemplate = _t.first);
    } }, hostVars: 11, hostBindings: function IgxTabItemComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxTabItemComponent_click_HostBindingHandler($event) { return ctx.onClick($event); })("keydown", function IgxTabItemComponent_keydown_HostBindingHandler($event) { return ctx.onKeydown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("tabindex", ctx.tabindex)("aria-label", ctx.ariaLabel)("aria-disabled", ctx.ariaDisabled)("aria-selected", ctx.ariaSelected);
        ɵngcc0.ɵɵclassProp("igx-tabs__header-menu-item--selected", ctx.provideCssClassSelected)("igx-tabs__header-menu-item--disabled", ctx.provideCssClassDisabled)("igx-tabs__header-menu-item", ctx.provideCssClass);
    } }, inputs: { icon: "icon", label: "label", disabled: "disabled", isSelected: "isSelected", relatedGroup: "relatedGroup", autoGenerated: "autoGenerated" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 4, consts: [["defaultTabTemplate", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "igx-tabs__header-menu-item-icon", 4, "ngIf"], ["ngClass", "igx-tabs__item-label", 4, "ngIf"], [1, "igx-tabs__header-menu-item-icon"], ["fontSet", "material"], [3, "value", "hidden"], ["ngClass", "igx-tabs__item-label"]], template: function IgxTabItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxTabItemComponent_ng_template_0_Template, 2, 2, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxTabItemComponent_ng_container_2_Template, 1, 0, "ng-container", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c17, ctx.context));
    } }, directives: [ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxIconComponent, IgxBadgeComponent, ɵngcc2.NgClass], encapsulation: 2 });
IgxTabItemComponent.ctorParameters = () => [
    { type: IgxTabsBase },
    { type: ElementRef },
    { type: NgZone }
];
IgxTabItemComponent.propDecorators = {
    relatedGroup: [{ type: Input }],
    icon: [{ type: Input }],
    label: [{ type: Input }],
    autoGenerated: [{ type: Input }],
    defaultTabTemplate: [{ type: ViewChild, args: ['defaultTabTemplate', { read: TemplateRef, static: true },] }],
    customTabTemplateDir: [{ type: ContentChild, args: [IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective },] }],
    provideCssClassSelected: [{ type: HostBinding, args: ['class.igx-tabs__header-menu-item--selected',] }],
    provideCssClassDisabled: [{ type: HostBinding, args: ['class.igx-tabs__header-menu-item--disabled',] }],
    provideCssClass: [{ type: HostBinding, args: ['class.igx-tabs__header-menu-item',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    ariaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],
    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],
    ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    disabled: [{ type: Input }],
    isSelected: [{ type: Input }]
};

class IgxTabsGroupComponent extends IgxTabsGroupBase {
    constructor(_tabs, _element) {
        super();
        this._tabs = _tabs;
        this._element = _element;
        /**
         * An @Input property that allows you to enable/disable the `IgxTabGroupComponent`.
         * ```html
         * <igx-tabs-group label="Tab 2  Lorem ipsum dolor sit" icon="home" [disabled]="true">
         * ```
         */
        this.disabled = false;
        this._isSelected = false;
        /**
         * @hidden
         */
        this.role = 'tabpanel';
        /**
         * @hidden
         */
        this.styleClass = true;
    }
    /**
     * Sets/gets whether a tab group is selected.
     * ```typescript
     * this.tabGroup.isSelected = true;
     * ```
     * ```typescript
     * let isSelected = this.tabGroup.isSelected;
     * ```
     * @memberof IgxTabsGroupComponent
     */
    get isSelected() {
        return this._isSelected;
    }
    set isSelected(newValue) {
        if (!this.disabled && this.isSelected !== newValue) {
            this._tabs.performSelectionChange(newValue ? this.relatedTab : null);
        }
    }
    /**
     * Returns the native element of the tabs-group component
     * ```typescript
     *  const mytabsGroupElement: HTMLElement = tabsGroup.nativeElement;
     * ```
     */
    get nativeElement() {
        return this._element.nativeElement;
    }
    /**
     * An accessor that returns the `IgxTabItemComponent` component.
     * ```typescript
     * @ViewChild("MyTabsGroup")
     * public tab: IgxTabsGroupComponent;
     * ngAfterViewInIt(){
     *    let tabComponent = this.tab.relatedTab;
     * }
     * ```
     */
    get relatedTab() {
        if (this._tabs.tabs) {
            return this._tabs.tabs.toArray()[this.index];
        }
    }
    /**
     * An accessor that returns the value of the index of the `IgxTabsGroupComponent`.
     * ```typescript
     * @ViewChild("MyTabsGroup")
     * public tab: IgxTabsGroupComponent;
     * ngAfterViewInIt(){
     *    let tabIndex = this.tab.index;
     * }
     * ```
     */
    get index() {
        if (this._tabs.groups) {
            return this._tabs.groups.toArray().indexOf(this);
        }
        return -1;
    }
    /**
     * @hidden
     */
    get customTabTemplate() {
        return this._tabTemplate;
    }
    /**
     * @hidden
     */
    set customTabTemplate(template) {
        this._tabTemplate = template;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.tabTemplate) {
            this._tabTemplate = this.tabTemplate.template;
        }
    }
    /**
     * A method that sets the focus on a tab.
     * @memberof {@link IgxTabsGroupComponent}
     * ```typescript
     *  @ViewChild("MyChild")
     * public tab : IgxTabsGroupComponent;
     * ngAfterViewInit(){
     *     this.tab.select();
     * }
     * ```
     */
    select() {
        if (!this.disabled && !this.isSelected) {
            this._tabs.performSelectionChange(this.relatedTab);
        }
    }
    /**
     * @hidden
     */
    setSelectedInternal(newValue) {
        this._isSelected = newValue;
    }
}
IgxTabsGroupComponent.ɵfac = function IgxTabsGroupComponent_Factory(t) { return new (t || IgxTabsGroupComponent)(ɵngcc0.ɵɵdirectiveInject(IgxTabsBase), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxTabsGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTabsGroupComponent, selectors: [["igx-tabs-group"]], contentQueries: function IgxTabsGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabItemTemplateDirective, true, IgxTabItemTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabTemplate = _t.first);
    } }, hostVars: 3, hostBindings: function IgxTabsGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-tabs__group", ctx.styleClass);
    } }, inputs: { disabled: "disabled", icon: "icon", label: "label" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 1, vars: 1, consts: [[4, "ngIf"]], template: function IgxTabsGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, IgxTabsGroupComponent_ng_content_0_Template, 1, 0, "ng-content", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isSelected);
    } }, directives: [ɵngcc2.NgIf], encapsulation: 2 });
IgxTabsGroupComponent.ctorParameters = () => [
    { type: IgxTabsBase },
    { type: ElementRef }
];
IgxTabsGroupComponent.propDecorators = {
    disabled: [{ type: Input }],
    icon: [{ type: Input }],
    label: [{ type: Input }],
    tabTemplate: [{ type: ContentChild, args: [IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective },] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    styleClass: [{ type: HostBinding, args: ['class.igx-tabs__group',] }]
};

const IgxTabsType = mkenum({
    FIXED: 'fixed',
    CONTENTFIT: 'contentfit'
});
let NEXT_TABS_ID = 0;
class IgxTabsComponent {
    constructor(_element, _ngZone, platformUtil) {
        this._element = _element;
        this._ngZone = _ngZone;
        this.platformUtil = platformUtil;
        this._currentTabsId = NEXT_TABS_ID++;
        /**
         * @hidden
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
         * By default the header sizing mode is `contentfit`.
         * ```html
         * <igx-tabs type="fixed">
         *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
         * </igx-tabs>
         * ```
         */
        this.type = 'contentfit';
        /**
         * Sets/gets the `id` of the tabs.
         *
         * @remarks
         * If not set, the `id` will have value `"igx-tabs-0"`.
         *
         * @example
         * ```html
         * <igx-tabs id="my-first-tabs"></igx-tabs>
         * ```
         * @memberof IgxTabsComponent
         */
        this.id = `igx-tabs-${this._currentTabsId}`;
        /**
         * @hidden
         */
        this.class = '';
        /**
         * Emitted when a tab item is deselected.
         * ```html
         * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemDeselected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemDeselected = new EventEmitter();
        /**
         * Emitted when a tab item is selected.
         * ```html
         * <igx-tabs (onTabItemSelected)="itemSelected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemSelected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemSelected = new EventEmitter();
        /**
         * Enables/disables the transition animation of the tabs' content. Set to `false` by default.
         * ````html
         * <igx-tabs [disableAnimation]="true"></igx-tabs>
         */
        this.disableAnimation = false;
        /**
         * @hidden
         */
        this.offset = 0;
        this._selectedIndex = -1;
    }
    /**
     * An @Input property that sets the value of the `selectedIndex`.
     * Default value is 0.
     * ```html
     * <igx-tabs selectedIndex="1">
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-tabs [(selectedIndex)]="model.selectedIndex">
     * ```
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    set selectedIndex(index) {
        const newIndex = typeof index !== 'number' ? parseInt(index, 10) : index;
        if (this._selectedIndex !== newIndex) {
            if (this.tabs && this.tabs.length > 0) {
                const newTab = this.tabs.toArray()[newIndex];
                if (newTab) {
                    this.performSelectionChange(newTab);
                }
            }
            else {
                this._selectedIndex = newIndex;
            }
        }
    }
    /**
     * Provides an observable collection of all `IgxTabItemComponent`s.
     * First try to get them as content children if not available get them as view children.
     * ```typescript
     * const tabItems = this.myTabComponent.tabs;
     * ```
     */
    get tabs() {
        if (this.hasContentTabs) {
            return this.contentTabs;
        }
        return this.viewTabs;
    }
    /**
     * @hidden
     */
    get hasContentTabs() {
        return (this.contentTabs && this.contentTabs.length > 0);
    }
    /**
     * @hidden
     */
    get cssClass() {
        const defaultStyle = `igx-tabs`;
        const fixedStyle = `igx-tabs--fixed`;
        const iconStyle = `igx-tabs--icons`;
        const iconLabelFoundInGroups = this.groups.find((group) => group.icon != null && group.label != null);
        const iconLabelFoundInTabs = this.contentTabs.find((tab) => tab.icon != null && tab.label != null);
        let css;
        switch (IgxTabsType[this.type.toUpperCase()]) {
            case IgxTabsType.FIXED: {
                css = fixedStyle;
                break;
            }
            default: {
                css = defaultStyle;
                break;
            }
        }
        // Layout fix for items with icons
        if (iconLabelFoundInGroups !== undefined || iconLabelFoundInTabs !== undefined) {
            css = `${css} ${iconStyle}`;
        }
        return `${css} ${this.class}`;
    }
    /**
     * @hidden
     */
    scrollLeft(event) {
        this.scroll(false);
    }
    /**
     * @hidden
     */
    scrollRight(event) {
        this.scroll(true);
    }
    /**
     * @hidden
     */
    scrollElement(element, scrollRight) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollRight) ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
        this.itemsContainer.nativeElement.style.transform = `translate(${-this.offset}px)`;
    }
    /**
     * Gets the selected `IgxTabItemComponent`.
     * ```
     * const selectedItem = this.myTabComponent.selectedTabItem;
     * ```
     */
    get selectedTabItem() {
        if (this.tabs && this.selectedIndex !== undefined) {
            return this.tabs.toArray()[this.selectedIndex];
        }
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        if (this._selectedIndex === -1) {
            this.tabs.forEach((t) => {
                if (t.isSelected) {
                    this._selectedIndex = t.index;
                }
            });
        }
        if (!this.hasContentTabs && (this.selectedIndex < 0 || this.selectedIndex >= this.groups.length)) {
            this._selectedIndex = 0;
        }
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(() => {
                const newTab = this.tabs.toArray()[this._selectedIndex];
                if (newTab) {
                    this.performSelection(newTab);
                }
                else {
                    this.hideIndicator();
                }
            });
            this._ngZone.runOutsideAngular(() => {
                this._resizeObserver = new ResizeObserver(() => {
                    if (!this.hasContentTabs && this._selectedIndex >= 0 && this._selectedIndex < this.tabs.length) {
                        const newTab = this.tabs.toArray()[this._selectedIndex];
                        this.transformContentAnimation(newTab, 0);
                    }
                });
                this._resizeObserver.observe(this.tabsContainer.nativeElement);
            });
        }
        this.setGroupsAttributes();
        this._groupChanges$ = this.groups.changes.subscribe(() => {
            this.setGroupsAttributes();
            this.resetSelectionOnCollectionChanged();
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this._groupChanges$) {
            this._groupChanges$.unsubscribe();
        }
        if (this._resizeObserver) {
            this._ngZone.runOutsideAngular(() => {
                this._resizeObserver.disconnect();
            });
        }
    }
    setGroupsAttributes() {
        const groupsArray = Array.from(this.groups);
        for (let index = 0; index < this.groups.length; index++) {
            const tabsGroup = groupsArray[index];
            tabsGroup.nativeElement.setAttribute('id', this.getTabsGroupId(index));
            tabsGroup.nativeElement.setAttribute('aria-labelledby', this.getTabItemId(index));
        }
    }
    resetSelectionOnCollectionChanged() {
        requestAnimationFrame(() => {
            const currentTab = this.tabs.toArray()[this.selectedIndex];
            if (currentTab) {
                this.performSelectionChange(currentTab);
            }
            else if (this.selectedIndex >= this.tabs.length) {
                this.performSelectionChange(this.tabs.last);
            }
            else {
                this.hideIndicator();
            }
        });
    }
    scroll(scrollRight) {
        const tabsArray = this.tabs.toArray();
        for (const tab of tabsArray) {
            const element = tab.nativeTabItem.nativeElement;
            if (scrollRight) {
                if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
            else {
                if (element.offsetWidth + element.offsetLeft >= this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
        }
    }
    /**
     * @hidden
     */
    performSelectionChange(newTab) {
        const oldTab = this.selectedTabItem;
        if (oldTab) {
            this.performDeselection(oldTab);
        }
        if (newTab) {
            this.performSelection(newTab);
        }
        else {
            // if there is no new selected tab hide the selection indicator
            this.hideIndicator();
        }
        this.selectedIndexChange.emit(this._selectedIndex);
    }
    performDeselection(oldTab) {
        oldTab.setSelectedInternal(false);
        const oldTabRelatedGroup = this.groups.toArray()[oldTab.index];
        if (oldTabRelatedGroup) {
            oldTabRelatedGroup.setSelectedInternal(false);
        }
        this._selectedIndex = -1;
        this.onTabItemDeselected.emit({ tab: oldTab, group: oldTabRelatedGroup });
    }
    performSelection(newTab) {
        newTab.setSelectedInternal(true);
        this._selectedIndex = newTab.index;
        let newTabRelatedGroup = null;
        if (!this.hasContentTabs && this.groups) {
            newTabRelatedGroup = this.groups.toArray()[newTab.index];
            if (newTabRelatedGroup) {
                newTabRelatedGroup.setSelectedInternal(true);
            }
        }
        this.onTabItemSelected.emit({ tab: newTab, group: newTabRelatedGroup });
        requestAnimationFrame(() => {
            const transitionDuration = this.disableAnimation ? 0 : 0.2;
            // bring the new selected tab into view if it is not
            this.bringNewTabIntoView(newTab);
            // animate the new selection indicator
            this.transformIndicatorAnimation(newTab.nativeTabItem.nativeElement);
            // animate the new tab's group content
            if (!this.hasContentTabs) {
                this.transformContentAnimation(newTab, transitionDuration);
            }
        });
    }
    bringNewTabIntoView(newTab) {
        const tabNativeElement = newTab.nativeTabItem.nativeElement;
        // Scroll left if there is need
        if (tabNativeElement.offsetLeft < this.offset) {
            this.scrollElement(tabNativeElement, false);
        }
        // Scroll right if there is need
        const viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
        const delta = (tabNativeElement.offsetLeft + tabNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
        // Fix for IE 11, a difference is accumulated from the widths calculations
        if (delta > 1) {
            this.scrollElement(tabNativeElement, true);
        }
    }
    /**
     * @hidden
     */
    getTabItemId(index) {
        return `igx-tab-item-${this._currentTabsId}-${index}`;
    }
    /**
     * @hidden
     */
    getTabsGroupId(index) {
        return `igx-tabs-group-${this._currentTabsId}-${index}`;
    }
    /**
     * @hidden
     */
    // animation for the new panel/group (not needed for tab only mode)
    transformContentAnimation(tab, duration) {
        const contentOffset = this.tabsContainer.nativeElement.offsetWidth * tab.index;
        this.contentsContainer.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
        this.contentsContainer.nativeElement.style.transform = `translate(${-contentOffset}px)`;
    }
    /**
     * @hidden
     */
    transformIndicatorAnimation(element, duration = 0.3) {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
            this.selectedIndicator.nativeElement.style.width = `${element.offsetWidth}px`;
            this.selectedIndicator.nativeElement.style.transform = `translate(${element.offsetLeft}px)`;
        }
    }
    hideIndicator() {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    }
}
IgxTabsComponent.ɵfac = function IgxTabsComponent_Factory(t) { return new (t || IgxTabsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(PlatformUtil)); };
IgxTabsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTabsComponent, selectors: [["igx-tabs"]], contentQueries: function IgxTabsComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabsGroupComponent, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabItemComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groups = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTabs = _t);
    } }, viewQuery: function IgxTabsComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c233, true);
        ɵngcc0.ɵɵstaticViewQuery(_c234, true);
        ɵngcc0.ɵɵstaticViewQuery(_c235, true);
        ɵngcc0.ɵɵviewQuery(_c236, true);
        ɵngcc0.ɵɵstaticViewQuery(_c237, true);
        ɵngcc0.ɵɵstaticViewQuery(_c238, true);
        ɵngcc0.ɵɵviewQuery(IgxTabItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.selectedIndicator = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewPort = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewTabs = _t);
    } }, hostVars: 2, hostBindings: function IgxTabsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("class", ctx.cssClass);
    } }, inputs: { type: "type", id: "id", class: "class", disableAnimation: "disableAnimation", selectedIndex: "selectedIndex" }, outputs: { selectedIndexChange: "selectedIndexChange", onTabItemDeselected: "onTabItemDeselected", onTabItemSelected: "onTabItemSelected" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxTabsBase, useExisting: IgxTabsComponent }])], ngContentSelectors: _c240, decls: 21, vars: 2, consts: [["tabsContainer", ""], [1, "igx-tabs__header"], ["headerContainer", ""], ["igxRipple", "", "igxButton", "icon", "igxLeftButtonStyle", "", 1, "igx-tabs__header-button", 3, "click"], ["fontSet", "material"], [1, "igx-tabs__header-wrapper-fixed"], ["viewPort", ""], [1, "igx-tabs__header-wrapper-fluid"], ["itemsContainer", ""], [4, "ngIf"], ["class", "igx-tabs__header-menu-item-indicator", 4, "ngIf"], ["igxRipple", "", "igxButton", "icon", "igxRightButtonStyle", "", 1, "igx-tabs__header-button", 3, "click"], [1, "igx-tabs__content-fixed"], [1, "igx-tabs__content-fluid"], ["contentsContainer", ""], ["igxRipple", "", 3, "relatedGroup", "autoGenerated", "id", 4, "ngFor", "ngForOf"], ["igxRipple", "", 3, "relatedGroup", "autoGenerated", "id"], [1, "igx-tabs__header-menu-item-indicator"], ["selectedIndicator", ""]], template: function IgxTabsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c239);
        ɵngcc0.ɵɵelementStart(0, "div", null, 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵelementStart(4, "button", 3);
        ɵngcc0.ɵɵlistener("click", function IgxTabsComponent_Template_button_click_4_listener($event) { return ctx.scrollLeft($event); });
        ɵngcc0.ɵɵelementStart(5, "igx-icon", 4);
        ɵngcc0.ɵɵtext(6, "navigate_before");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "div", 5, 6);
        ɵngcc0.ɵɵelementStart(9, "div", 7, 8);
        ɵngcc0.ɵɵtemplate(11, IgxTabsComponent_ng_container_11_Template, 2, 1, "ng-container", 9);
        ɵngcc0.ɵɵprojection(12);
        ɵngcc0.ɵɵtemplate(13, IgxTabsComponent_div_13_Template, 2, 0, "div", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(14, "button", 11);
        ɵngcc0.ɵɵlistener("click", function IgxTabsComponent_Template_button_click_14_listener($event) { return ctx.scrollRight($event); });
        ɵngcc0.ɵɵelementStart(15, "igx-icon", 4);
        ɵngcc0.ɵɵtext(16, "navigate_next");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(17, "div", 12);
        ɵngcc0.ɵɵelementStart(18, "div", 13, 14);
        ɵngcc0.ɵɵprojection(20, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.hasContentTabs);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.groups.length > 0 || ctx.contentTabs.length > 0);
    } }, directives: [IgxRippleDirective, IgxLeftButtonStyleDirective, IgxIconComponent, ɵngcc2.NgIf, IgxRightButtonStyleDirective, ɵngcc2.NgForOf, IgxTabItemComponent], encapsulation: 2 });
IgxTabsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: PlatformUtil }
];
IgxTabsComponent.propDecorators = {
    groups: [{ type: ContentChildren, args: [forwardRef(() => IgxTabsGroupComponent),] }],
    contentTabs: [{ type: ContentChildren, args: [forwardRef(() => IgxTabItemComponent),] }],
    selectedIndex: [{ type: Input }],
    selectedIndexChange: [{ type: Output }],
    type: [{ type: Input, args: ['type',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    class: [{ type: Input }],
    onTabItemDeselected: [{ type: Output }],
    onTabItemSelected: [{ type: Output }],
    contentsContainer: [{ type: ViewChild, args: ['contentsContainer', { static: true },] }],
    headerContainer: [{ type: ViewChild, args: ['headerContainer', { static: true },] }],
    itemsContainer: [{ type: ViewChild, args: ['itemsContainer', { static: true },] }],
    selectedIndicator: [{ type: ViewChild, args: ['selectedIndicator',] }],
    tabsContainer: [{ type: ViewChild, args: ['tabsContainer', { static: true },] }],
    viewPort: [{ type: ViewChild, args: ['viewPort', { static: true },] }],
    viewTabs: [{ type: ViewChildren, args: [forwardRef(() => IgxTabItemComponent),] }],
    disableAnimation: [{ type: Input }],
    cssClass: [{ type: HostBinding, args: ['attr.class',] }]
};
/**
 * @hidden
 */
class IgxTabsModule {
}
IgxTabsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTabsModule });
IgxTabsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTabsModule_Factory(t) { return new (t || IgxTabsModule)(); }, imports: [[CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]] });

/** @hidden */
const IGX_TIME_PICKER_COMPONENT = 'IgxTimePickerComponentToken';
/** @hidden */
var TimeParts;
(function (TimeParts) {
    TimeParts["Hour"] = "hour";
    TimeParts["Minute"] = "minute";
    TimeParts["Seconds"] = "seconds";
    TimeParts["amPM"] = "ampm";
})(TimeParts || (TimeParts = {}));

/**
 * This file contains all the directives used by the @link IgxTimePickerComponent.
 * You should generally not use them directly.
 * @preferred
 */
/** @hidden */
class IgxItemListDirective {
    constructor(timePicker, elementRef) {
        this.timePicker = timePicker;
        this.elementRef = elementRef;
        this.tabindex = 0;
    }
    get defaultCSS() {
        return true;
    }
    get hourCSS() {
        return this.type === 'hourList';
    }
    get minuteCSS() {
        return this.type === 'minuteList';
    }
    get secondsCSS() {
        return this.type === 'secondsList';
    }
    get ampmCSS() {
        return this.type === 'ampmList';
    }
    onFocus() {
        this.isActive = true;
    }
    onBlur() {
        this.isActive = false;
    }
    nextItem() {
        switch (this.type) {
            case 'hourList': {
                this.timePicker.nextHour();
                break;
            }
            case 'minuteList': {
                this.timePicker.nextMinute();
                break;
            }
            case 'secondsList': {
                this.timePicker.nextSeconds();
                break;
            }
            case 'ampmList': {
                this.timePicker.nextAmPm();
                break;
            }
        }
    }
    prevItem() {
        switch (this.type) {
            case 'hourList': {
                this.timePicker.prevHour();
                break;
            }
            case 'minuteList': {
                this.timePicker.prevMinute();
                break;
            }
            case 'secondsList': {
                this.timePicker.prevSeconds();
                break;
            }
            case 'ampmList': {
                this.timePicker.prevAmPm();
                break;
            }
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowDown(event) {
        event.preventDefault();
        this.nextItem();
    }
    /**
     * @hidden
     */
    onKeydownArrowUp(event) {
        event.preventDefault();
        this.prevItem();
    }
    /**
     * @hidden
     */
    onKeydownArrowRight(event) {
        event.preventDefault();
        const listName = event.target.className;
        if (listName.indexOf('hourList') !== -1 && this.timePicker.minuteList) {
            this.timePicker.minuteList.nativeElement.focus();
        }
        else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1) && this.timePicker.secondsList) {
            this.timePicker.secondsList.nativeElement.focus();
        }
        else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1 ||
            listName.indexOf('secondsList') !== -1) && this.timePicker.ampmList) {
            this.timePicker.ampmList.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowLeft(event) {
        event.preventDefault();
        const listName = event.target.className;
        if (listName.indexOf('ampmList') !== -1 && this.timePicker.secondsList) {
            this.timePicker.secondsList.nativeElement.focus();
        }
        else if (listName.indexOf('secondsList') !== -1 && this.timePicker.secondsList
            && listName.indexOf('minutesList') && this.timePicker.minuteList) {
            this.timePicker.minuteList.nativeElement.focus();
        }
        else if (listName.indexOf('ampmList') !== -1 && this.timePicker.minuteList) {
            this.timePicker.minuteList.nativeElement.focus();
        }
        else if ((listName.indexOf('ampmList') !== -1 || listName.indexOf('secondsList') !== -1 ||
            listName.indexOf('minuteList') !== -1) && this.timePicker.hourList) {
            this.timePicker.hourList.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onKeydownEnter(event) {
        event.preventDefault();
        if (this.timePicker.mode === InteractionMode.DropDown) {
            this.timePicker.close();
            return;
        }
        this.timePicker.okButtonClick();
    }
    /**
     * @hidden
     */
    onKeydownEscape(event) {
        event.preventDefault();
        this.timePicker.cancelButtonClick();
    }
    /**
     * @hidden
     */
    onHover() {
        this.elementRef.nativeElement.focus();
    }
    /**
     * @hidden
     */
    onScroll(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.deltaY > 0) {
            this.nextItem();
        }
        else if (event.deltaY < 0) {
            this.prevItem();
        }
    }
    /**
     * @hidden
     */
    onPanMove(event) {
        if (event.deltaY < 0) {
            this.nextItem();
        }
        else if (event.deltaY > 0) {
            this.prevItem();
        }
    }
}
IgxItemListDirective.ɵfac = function IgxItemListDirective_Factory(t) { return new (t || IgxItemListDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxItemListDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxItemListDirective, selectors: [["", "igxItemList", ""]], hostVars: 11, hostBindings: function IgxItemListDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function IgxItemListDirective_focus_HostBindingHandler() { return ctx.onFocus(); })("blur", function IgxItemListDirective_blur_HostBindingHandler() { return ctx.onBlur(); })("keydown.arrowdown", function IgxItemListDirective_keydown_arrowdown_HostBindingHandler($event) { return ctx.onKeydownArrowDown($event); })("keydown.arrowup", function IgxItemListDirective_keydown_arrowup_HostBindingHandler($event) { return ctx.onKeydownArrowUp($event); })("keydown.arrowright", function IgxItemListDirective_keydown_arrowright_HostBindingHandler($event) { return ctx.onKeydownArrowRight($event); })("keydown.arrowleft", function IgxItemListDirective_keydown_arrowleft_HostBindingHandler($event) { return ctx.onKeydownArrowLeft($event); })("keydown.enter", function IgxItemListDirective_keydown_enter_HostBindingHandler($event) { return ctx.onKeydownEnter($event); })("keydown.escape", function IgxItemListDirective_keydown_escape_HostBindingHandler($event) { return ctx.onKeydownEscape($event); })("mouseover", function IgxItemListDirective_mouseover_HostBindingHandler() { return ctx.onHover(); })("wheel", function IgxItemListDirective_wheel_HostBindingHandler($event) { return ctx.onScroll($event); })("panmove", function IgxItemListDirective_panmove_HostBindingHandler($event) { return ctx.onPanMove($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵclassProp("igx-time-picker__column", ctx.defaultCSS)("igx-time-picker__hourList", ctx.hourCSS)("igx-time-picker__minuteList", ctx.minuteCSS)("igx-time-picker__secondsList", ctx.secondsCSS)("igx-time-picker__ampmList", ctx.ampmCSS);
    } }, inputs: { type: ["igxItemList", "type"] } });
IgxItemListDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: ElementRef }
];
IgxItemListDirective.propDecorators = {
    type: [{ type: Input, args: ['igxItemList',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__column',] }],
    hourCSS: [{ type: HostBinding, args: ['class.igx-time-picker__hourList',] }],
    minuteCSS: [{ type: HostBinding, args: ['class.igx-time-picker__minuteList',] }],
    secondsCSS: [{ type: HostBinding, args: ['class.igx-time-picker__secondsList',] }],
    ampmCSS: [{ type: HostBinding, args: ['class.igx-time-picker__ampmList',] }],
    onFocus: [{ type: HostListener, args: ['focus',] }],
    onBlur: [{ type: HostListener, args: ['blur',] }],
    onKeydownArrowDown: [{ type: HostListener, args: ['keydown.arrowdown', ['$event'],] }],
    onKeydownArrowUp: [{ type: HostListener, args: ['keydown.arrowup', ['$event'],] }],
    onKeydownArrowRight: [{ type: HostListener, args: ['keydown.arrowright', ['$event'],] }],
    onKeydownArrowLeft: [{ type: HostListener, args: ['keydown.arrowleft', ['$event'],] }],
    onKeydownEnter: [{ type: HostListener, args: ['keydown.enter', ['$event'],] }],
    onKeydownEscape: [{ type: HostListener, args: ['keydown.escape', ['$event'],] }],
    onHover: [{ type: HostListener, args: ['mouseover',] }],
    onScroll: [{ type: HostListener, args: ['wheel', ['$event'],] }],
    onPanMove: [{ type: HostListener, args: ['panmove', ['$event'],] }]
};
/**
 * @hidden
 */
class IgxHourItemDirective {
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    get defaultCSS() {
        return true;
    }
    get selectedCSS() {
        return this.isSelectedHour;
    }
    get activeCSS() {
        return this.isSelectedHour && this.itemList.isActive;
    }
    get isSelectedHour() {
        return this.timePicker.selectedHour === this.value;
    }
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollHourIntoView(item);
        }
    }
}
IgxHourItemDirective.ɵfac = function IgxHourItemDirective_Factory(t) { return new (t || IgxHourItemDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT), ɵngcc0.ɵɵdirectiveInject(IgxItemListDirective)); };
IgxHourItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxHourItemDirective, selectors: [["", "igxHourItem", ""]], hostVars: 6, hostBindings: function IgxHourItemDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxHourItemDirective_click_HostBindingHandler() { return ctx.onClick(ctx.value); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-time-picker__item", ctx.defaultCSS)("igx-time-picker__item--selected", ctx.selectedCSS)("igx-time-picker__item--active", ctx.activeCSS);
    } }, inputs: { value: ["igxHourItem", "value"] } });
IgxHourItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
IgxHourItemDirective.propDecorators = {
    value: [{ type: Input, args: ['igxHourItem',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item',] }],
    selectedCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--selected',] }],
    activeCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--active',] }],
    onClick: [{ type: HostListener, args: ['click', ['value'],] }]
};
/**
 * @hidden
 */
class IgxMinuteItemDirective {
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    get defaultCSS() {
        return true;
    }
    get selectedCSS() {
        return this.isSelectedMinute;
    }
    get activeCSS() {
        return this.isSelectedMinute && this.itemList.isActive;
    }
    get isSelectedMinute() {
        return this.timePicker.selectedMinute === this.value;
    }
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollMinuteIntoView(item);
        }
    }
}
IgxMinuteItemDirective.ɵfac = function IgxMinuteItemDirective_Factory(t) { return new (t || IgxMinuteItemDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT), ɵngcc0.ɵɵdirectiveInject(IgxItemListDirective)); };
IgxMinuteItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxMinuteItemDirective, selectors: [["", "igxMinuteItem", ""]], hostVars: 6, hostBindings: function IgxMinuteItemDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxMinuteItemDirective_click_HostBindingHandler() { return ctx.onClick(ctx.value); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-time-picker__item", ctx.defaultCSS)("igx-time-picker__item--selected", ctx.selectedCSS)("igx-time-picker__item--active", ctx.activeCSS);
    } }, inputs: { value: ["igxMinuteItem", "value"] } });
IgxMinuteItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
IgxMinuteItemDirective.propDecorators = {
    value: [{ type: Input, args: ['igxMinuteItem',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item',] }],
    selectedCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--selected',] }],
    activeCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--active',] }],
    onClick: [{ type: HostListener, args: ['click', ['value'],] }]
};
/**
 * @hidden
 */
class IgxSecondsItemDirective {
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    get defaultCSS() {
        return true;
    }
    get selectedCSS() {
        return this.isSelectedSeconds;
    }
    get activeCSS() {
        return this.isSelectedSeconds && this.itemList.isActive;
    }
    get isSelectedSeconds() {
        return this.timePicker.selectedSeconds === this.value;
    }
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollSecondsIntoView(item);
        }
    }
}
IgxSecondsItemDirective.ɵfac = function IgxSecondsItemDirective_Factory(t) { return new (t || IgxSecondsItemDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT), ɵngcc0.ɵɵdirectiveInject(IgxItemListDirective)); };
IgxSecondsItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSecondsItemDirective, selectors: [["", "igxSecondsItem", ""]], hostVars: 6, hostBindings: function IgxSecondsItemDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxSecondsItemDirective_click_HostBindingHandler() { return ctx.onClick(ctx.value); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-time-picker__item", ctx.defaultCSS)("igx-time-picker__item--selected", ctx.selectedCSS)("igx-time-picker__item--active", ctx.activeCSS);
    } }, inputs: { value: ["igxSecondsItem", "value"] } });
IgxSecondsItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
IgxSecondsItemDirective.propDecorators = {
    value: [{ type: Input, args: ['igxSecondsItem',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item',] }],
    selectedCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--selected',] }],
    activeCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--active',] }],
    onClick: [{ type: HostListener, args: ['click', ['value'],] }]
};
/**
 * @hidden
 */
class IgxAmPmItemDirective {
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    get defaultCSS() {
        return true;
    }
    get selectedCSS() {
        return this.isSelectedAmPm;
    }
    get activeCSS() {
        return this.isSelectedAmPm && this.itemList.isActive;
    }
    get isSelectedAmPm() {
        return this.timePicker.selectedAmPm === this.value;
    }
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollAmPmIntoView(item);
        }
    }
}
IgxAmPmItemDirective.ɵfac = function IgxAmPmItemDirective_Factory(t) { return new (t || IgxAmPmItemDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT), ɵngcc0.ɵɵdirectiveInject(IgxItemListDirective)); };
IgxAmPmItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxAmPmItemDirective, selectors: [["", "igxAmPmItem", ""]], hostVars: 6, hostBindings: function IgxAmPmItemDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxAmPmItemDirective_click_HostBindingHandler() { return ctx.onClick(ctx.value); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-time-picker__item", ctx.defaultCSS)("igx-time-picker__item--selected", ctx.selectedCSS)("igx-time-picker__item--active", ctx.activeCSS);
    } }, inputs: { value: ["igxAmPmItem", "value"] } });
IgxAmPmItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
IgxAmPmItemDirective.propDecorators = {
    value: [{ type: Input, args: ['igxAmPmItem',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item',] }],
    selectedCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--selected',] }],
    activeCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--active',] }],
    onClick: [{ type: HostListener, args: ['click', ['value'],] }]
};
/**
 * This directive should be used to mark which ng-template will be used from IgxTimePicker when re-templating its input group.
 */
class IgxTimePickerTemplateDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxTimePickerTemplateDirective.ɵfac = function IgxTimePickerTemplateDirective_Factory(t) { return new (t || IgxTimePickerTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxTimePickerTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTimePickerTemplateDirective, selectors: [["", "igxTimePickerTemplate", ""]] });
IgxTimePickerTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * This directive can be used to add custom action buttons to the dropdownb/dialog.
 */
class IgxTimePickerActionsDirective {
    constructor(template) {
        this.template = template;
    }
}
IgxTimePickerActionsDirective.ɵfac = function IgxTimePickerActionsDirective_Factory(t) { return new (t || IgxTimePickerActionsDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxTimePickerActionsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTimePickerActionsDirective, selectors: [["", "igxTimePickerActions", ""]] });
IgxTimePickerActionsDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * Formats `IgxTimePickerComponent` display value according to the `format` property,
 * when the input element loses focus.
 */
class TimeDisplayFormatPipe {
    constructor(timePicker) {
        this.timePicker = timePicker;
    }
    transform(value) {
        let hour, minutes, seconds, amPM;
        const maskAmPM = this.timePicker.parseMask();
        const mask = this.timePicker.parseMask(false);
        if (!value || value === mask || value === maskAmPM) {
            return '';
        }
        const sections = value.split(/[\s:]+/);
        if (this.timePicker.showHoursList) {
            hour = sections[0];
        }
        if (this.timePicker.showMinutesList) {
            minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
        }
        if (this.timePicker.showSecondsList) {
            seconds = sections[sections.length - (this.timePicker.showAmPmList ? 2 : 1)];
        }
        if (this.timePicker.showAmPmList) {
            amPM = sections[sections.length - 1];
        }
        const format = this.timePicker.format;
        const prompt = this.timePicker.promptChar;
        const regExp = new RegExp(this.timePicker.promptChar, 'g');
        if (format.indexOf('hh') !== -1 || format.indexOf('HH') !== -1 && hour.indexOf(prompt) !== -1) {
            hour = hour === prompt + prompt ? '00' : hour.replace(regExp, '0');
        }
        if (format.indexOf('mm') !== -1 && minutes.indexOf(prompt) !== -1) {
            minutes = minutes === prompt + prompt ? '00' : minutes.replace(regExp, '0');
        }
        if (format.indexOf('ss') !== -1 && seconds.indexOf(prompt) !== -1) {
            seconds = seconds === prompt + prompt ? '00' : seconds.replace(regExp, '0');
        }
        if (format.indexOf('hh') === -1 && format.indexOf('HH') === -1 && hour !== undefined) {
            hour = hour.indexOf(prompt) !== -1 ? hour.replace(regExp, '') : hour;
            const hourVal = parseInt(hour, 10);
            hour = !hourVal ? '0' : hourVal < 10 && hourVal !== 0 ? hour.replace('0', '') : hour;
        }
        if (format.indexOf('mm') === -1 && minutes !== undefined) {
            minutes = minutes.indexOf(prompt) !== -1 ? minutes.replace(regExp, '') : minutes;
            const minutesVal = parseInt(minutes, 10);
            minutes = !minutesVal ? '0' : minutesVal < 10 && minutesVal !== 0 ? minutes.replace('0', '') : minutes;
        }
        if (format.indexOf('ss') === -1 && seconds !== undefined) {
            seconds = seconds.indexOf(prompt) !== -1 ? seconds.replace(regExp, '') : seconds;
            const secondsVal = parseInt(seconds, 10);
            seconds = !secondsVal ? '0' : secondsVal < 10 && secondsVal !== 0 ? seconds.replace('0', '') : seconds;
        }
        if (format.indexOf('tt') !== -1 && (amPM !== 'AM' || amPM !== 'PM')) {
            amPM = amPM.indexOf('p') !== -1 || amPM.indexOf('P') !== -1 ? 'PM' : 'AM';
        }
        let result = `${hour}:${minutes}:${seconds}`;
        if (!hour) {
            // remove the hours
            result = result.slice(result.indexOf(':') + 1);
        }
        if (!minutes) {
            if (hour) {
                // get the hours and seconds and concat them
                result = result.slice(0, result.indexOf(':')) +
                    result.slice(result.lastIndexOf(':'), result.length);
            }
            else {
                // remove the minutes
                result = result.slice(result.indexOf(':') + 1);
            }
        }
        if (!seconds) {
            // remove the seconds
            result = result.slice(0, result.lastIndexOf(':'));
        }
        return amPM ? `${result} ${amPM}` : result;
    }
}
TimeDisplayFormatPipe.ɵfac = function TimeDisplayFormatPipe_Factory(t) { return new (t || TimeDisplayFormatPipe)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT)); };
TimeDisplayFormatPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "displayFormat", type: TimeDisplayFormatPipe, pure: true });
TimeDisplayFormatPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] }
];
/**
 * Formats `IgxTimePickerComponent` display value according to the `format` property,
 * when the input element gets focus.
 */
class TimeInputFormatPipe {
    constructor(timePicker) {
        this.timePicker = timePicker;
    }
    transform(value) {
        const prompt = this.timePicker.promptChar;
        const regExp = new RegExp(prompt, 'g');
        let mask, hour, minutes, seconds, amPM;
        if (this.timePicker.cleared) {
            this.timePicker.cleared = false;
            mask = this.timePicker.parseMask(false);
        }
        else {
            mask = this.timePicker.parseMask();
        }
        // TODO: Pending refactoring.
        value = this.timePicker.displayValue;
        if (!value || value === mask) {
            return mask;
        }
        const sections = value.split(/[\s:]+/);
        if (this.timePicker.showHoursList) {
            hour = sections[0];
            hour = hour.replace(regExp, '');
            const leadZeroHour = (parseInt(hour, 10) < 10 && !hour.startsWith('0')) || hour === '0';
            hour = leadZeroHour ? '0' + hour : hour;
        }
        if (this.timePicker.showMinutesList) {
            minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
            minutes = minutes.replace(regExp, '');
            const leadZeroMinutes = (parseInt(minutes, 10) < 10 && !minutes.startsWith('0')) || minutes === '0';
            minutes = leadZeroMinutes ? '0' + minutes : minutes;
        }
        if (this.timePicker.showSecondsList) {
            seconds = sections[sections.length - (this.timePicker.showAmPmList ? 2 : 1)];
            seconds = seconds.replace(regExp, '');
            const leadZeroSeconds = (parseInt(seconds, 10) < 10 && !seconds.startsWith('0')) || seconds === '0';
            seconds = leadZeroSeconds ? '0' + seconds : seconds;
        }
        if (this.timePicker.showAmPmList) {
            amPM = sections[sections.length - 1];
        }
        let result = `${hour}:${minutes}:${seconds}`;
        if (!hour) {
            // remove the hours
            result = result.slice(result.indexOf(':') + 1);
        }
        if (!minutes) {
            if (hour) {
                // get the hours and seconds and concat them
                result = result.slice(0, result.indexOf(':')) +
                    result.slice(result.lastIndexOf(':'), result.length);
            }
            else {
                // remove the minutes
                result = result.slice(result.indexOf(':') + 1);
            }
        }
        if (!seconds) {
            // remove the seconds
            result = result.slice(0, result.lastIndexOf(':'));
        }
        return amPM ? `${result} ${amPM}` : result;
    }
}
TimeInputFormatPipe.ɵfac = function TimeInputFormatPipe_Factory(t) { return new (t || TimeInputFormatPipe)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT)); };
TimeInputFormatPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "inputFormat", type: TimeInputFormatPipe, pure: true });
TimeInputFormatPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] }
];

let NEXT_ID$v = 0;
const ITEMS_COUNT = 7;
class TimePickerHammerConfig extends HammerGestureConfig {
    constructor() {
        super(...arguments);
        this.overrides = {
            pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
        };
    }
}
TimePickerHammerConfig.ɵfac = function TimePickerHammerConfig_Factory(t) { return ɵTimePickerHammerConfig_BaseFactory(t || TimePickerHammerConfig); };
TimePickerHammerConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TimePickerHammerConfig, factory: TimePickerHammerConfig.ɵfac });
const noop$9 = () => { };
const ɵ0$b = noop$9;
class IgxTimePickerComponent {
    constructor(_injector, _cdr) {
        this._injector = _injector;
        this._cdr = _cdr;
        /**
         * An @Input property that sets the value of the `id` attribute.
         * ```html
         * <igx-time-picker [id]="'igx-time-picker-5'" format="h:mm tt" ></igx-time-picker>
         * ```
         */
        this.id = `igx-time-picker-${NEXT_ID$v++}`;
        /**
         * @hidden @internal
         */
        this.timeParts = Object.assign({}, TimeParts);
        /**
         * An @Input property that allows you to disable the `igx-time-picker` component. By default `disabled` is set to false.
         * ```html
         * <igx-time-picker [disabled]="'true'" [vertical]="true" format="h:mm tt" ></igx-time-picker>
         * ```
         */
        this.disabled = false;
        /**
         * An @Input property that determines the spin behavior. By default `isSpinLoop` is set to true.
         * The seconds, minutes and hour spinning will wrap around by default.
         * ```html
         * <igx-time-picker [isSpinLoop]="false" id="time-picker"></igx-time-picker>
         * ```
         */
        this.isSpinLoop = true;
        /**
         * An @Input property that Gets/Sets the orientation of the `igxTimePicker`. By default `vertical` is set to false.
         * ```html
         * <igx-time-picker [vertical]="true" id="time-picker"></igx-time-picker>
         * ```
         */
        this.vertical = false;
        /**
         * Sets the character used to prompt the user for input.
         * Default value is "'-'".
         * ```html
         * <igx-time-picker [promptChar] = "'_'">
         * ```
         * @memberof IgxTimePickerComponent
         */
        this.promptChar = '-';
        /**
         * An @Input property that allows you to switch the interaction mode between
         * a dialog picker or dropdown with editable masked input.
         * Deafult is dialog picker.
         * ```html
         * public mode = InteractionMode.DROPDOWN;
         *  //..
         * <igx-time-picker [mode]="mode"></igx-time-picker>
         * ```
         * @memberof IgxTimePickerComponent
         */
        this.mode = InteractionMode.Dialog;
        /**
         * Emitted when selection is made. The event contains the selected value. Returns {`oldValue`: `Date`, `newValue`: `Date`}.
         * ```typescript
         *  @ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onValueChanged(timepicker){
         *     this.toast.show()
         * }
         *  //...
         *  ```
         *  ```html
         * <igx-time-picker (onValueChanged)="onValueChanged($event)"></igx-time-picker>
         * <igx-toast #toast message="The value has been changed!"></igx-toast>
         * ```
         */
        this.onValueChanged = new EventEmitter();
        /**
         * Emitted when an invalid value is being set. Returns {`timePicker`: `any`, `currentValue`: `Date`, `setThroughUI`: `boolean`}
         * ```typescript
         * public min: string = "09:00";
         * public max: string = "18:00";
         *  @ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onValidationFailed(timepicker){
         *     this.toast.show();
         * }
         *  //...
         *  ```
         *  ```html
         * <igx-time-picker [minValue]="min" [maxValue]="max" (onValidationFailed)="onValidationFailed($event)"></igx-time-picker>
         * <igx-toast #toast message="Value must be between 09:00 and 18:00!"></igx-toast>
         * ```
         */
        this.onValidationFailed = new EventEmitter();
        /**
         * Emitted when a timePicker is opened.
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted when a timePicker is closed.
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted when a timePicker is being closed.
         */
        this.onClosing = new EventEmitter();
        /**
         * @hidden
         */
        this._hourItems = [];
        /**
         * @hidden
         */
        this._minuteItems = [];
        /**
         * @hidden
         */
        this._secondsItems = [];
        /**
         * @hidden
         */
        this._ampmItems = [];
        /**
         * @hidden
         */
        this.cleared = false;
        /**
         * @hidden
         */
        this.isNotEmpty = false;
        /**
         * @hidden
         */
        this.displayFormat = new TimeDisplayFormatPipe(this);
        /**
         * @hidden
         */
        this.inputFormat = new TimeInputFormatPipe(this);
        this._resourceStrings = CurrentResourceStrings.TimePickerResStrings;
        this._okButtonLabel = null;
        this._cancelButtonLabel = null;
        this._itemsDelta = { hours: 1, minutes: 1, seconds: 1 };
        this._isHourListLoop = this.isSpinLoop;
        this._isMinuteListLoop = this.isSpinLoop;
        this._isSecondsListLoop = this.isSpinLoop;
        this._hourView = [];
        this._minuteView = [];
        this._secondsView = [];
        this._ampmView = [];
        this._destroy$ = new Subject();
        this._onOpen = new EventEmitter();
        this._onClose = new EventEmitter();
        this._hoursPos = new Set();
        this._minutesPos = new Set();
        this._secondsPos = new Set();
        this._amPmPos = new Set();
        this._ngControl = null;
        //#region ControlValueAccessor
        this._onChangeCallback = noop$9;
        this._onTouchedCallback = noop$9;
    }
    /**
     * An accessor that allows you to set a time using the `value` input.
     * ```html
     * public date: Date = new Date(Date.now());
     *  //...
     * <igx-time-picker [value]="date" format="h:mm tt"></igx-time-picker>
     * ```
     */
    set value(value) {
        if (this._isValueValid(value)) {
            const oldVal = this._value;
            this._value = value;
            this._onChangeCallback(value);
            const dispVal = this._formatTime(this.value, this.format);
            if (this.mode === InteractionMode.DropDown && this._displayValue !== dispVal) {
                this.displayValue = dispVal;
            }
            const args = {
                oldValue: oldVal,
                newValue: value
            };
            this.onValueChanged.emit(args);
        }
        else {
            const args = {
                timePicker: this,
                currentValue: value,
                setThroughUI: false
            };
            this.onValidationFailed.emit(args);
        }
    }
    /**
     * An accessor that returns the value of `igx-time-picker` component.
     * ```html
     * @ViewChild("MyPick")
     * public pick: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let pickSelect = this.pick.value;
     * }
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * An accessor that sets the resource strings.
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /**
     * An @Input property that renders OK button with custom text. By default `okButtonLabel` is set to OK.
     * ```html
     * <igx-time-picker okButtonLabel='SET' [value]="date" format="h:mm tt"></igx-time-picker>
     * ```
     */
    set okButtonLabel(value) {
        this._okButtonLabel = value;
    }
    /**
     * An accessor that returns the label of ok button.
     */
    get okButtonLabel() {
        if (this._okButtonLabel === null) {
            return this.resourceStrings.igx_time_picker_ok;
        }
        return this._okButtonLabel;
    }
    /**
     * An @Input property that renders cancel button with custom text.
     * By default `cancelButtonLabel` is set to Cancel.
     * ```html
     * <igx-time-picker cancelButtonLabel='Exit' [value]="date" format="h:mm tt"></igx-time-picker>
     * ```
     */
    set cancelButtonLabel(value) {
        this._cancelButtonLabel = value;
    }
    /**
     * An accessor that returns the label of cancel button.
     */
    get cancelButtonLabel() {
        if (this._cancelButtonLabel === null) {
            return this.resourceStrings.igx_time_picker_cancel;
        }
        return this._cancelButtonLabel;
    }
    /**
     * An @Input property that gets/sets the delta by which hour and minute items would be changed <br>
     * when the user presses the Up/Down keys.
     * By default `itemsDelta` is set to `{hours: 1, minutes: 1, seconds: 1}`
     * ```html
     * <igx-time-picker [itemsDelta]="{hours:3, minutes:5, seconds:10}" id="time-picker"></igx-time-picker>
     * ```
     */
    set itemsDelta(value) {
        this._itemsDelta = Object.assign({ hours: 1, minutes: 1, seconds: 1 }, value);
    }
    get itemsDelta() {
        return this._itemsDelta;
    }
    /**
     * An @Input property that Gets/Sets format of time while `igxTimePicker` does not have focus. <br>
     * By default `format` is set to hh:mm tt. <br>
     * List of time-flags: <br>
     * `h` : hours field in 12-hours format without leading zero <br>
     * `hh` : hours field in 12-hours format with leading zero <br>
     * `H` : hours field in 24-hours format without leading zero <br>
     * `HH` : hours field in 24-hours format with leading zero <br>
     * `m` : minutes field without leading zero <br>
     * `mm` : minutes field with leading zero <br>
     * `s` : seconds field without leading zero <br>
     * `ss` : seconds field with leading zero <br>
     * `tt` : 2 character string which represents AM/PM field <br>
     * ```html
     * <igx-time-picker format="HH:m" id="time-picker"></igx-time-picker>
     * ```
     */
    get format() {
        return this._format || 'hh:mm tt';
    }
    set format(formatValue) {
        this._format = formatValue;
        this.mask = this._format.indexOf('tt') !== -1 ? '00:00:00 LL' : '00:00:00';
        if (!this.showHoursList || !this.showMinutesList) {
            this.trimMask();
        }
        if (!this.showSecondsList) {
            this.trimMask();
        }
        if (this.displayValue) {
            this.displayValue = this._formatTime(this.value, this._format);
        }
        this.determineCursorPos();
    }
    /**
     * An @Input property that allows you to modify overlay positioning, interaction and scroll behavior.
     * ```typescript
     * const settings: OverlaySettings = {
     *      closeOnOutsideClick: true,
     *      modal: false
     *  }
     * ```
     * ---
     * ```html
     * <igx-time-picker [overlaySettings]="settings"></igx-time-picker>
     * ```
     * @memberof IgxTimePickerComponent
     */
    set overlaySettings(value) {
        this._overlaySettings = value;
    }
    get overlaySettings() {
        return this._overlaySettings ? this._overlaySettings :
            (this.mode === InteractionMode.Dialog ? this._dialogOverlaySettings : this._dropDownOverlaySettings);
    }
    /** @hidden @internal */
    writeValue(value) {
        // use this flag to make sure that min/maxValue are checked (in _convertMinMaxValue() method)
        // against the real value when initializing the component and value is bound via ngModel
        this._dateFromModel = value;
        this._value = value;
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this._formatTime(this.value, this.format);
        }
    }
    /** @hidden @internal */
    applyDisabledStyleForItem(period, value) {
        if (!this.minValue || !this.maxValue) {
            return false;
        }
        const minValueDate = this.convertMinMaxValue(this.minValue);
        const maxValueDate = this.convertMinMaxValue(this.maxValue);
        let hour = parseInt(this.selectedHour, 10);
        let minute = parseInt(this.selectedMinute, 10);
        let seconds = parseInt(this.selectedSeconds, 10);
        let amPM = this.selectedAmPm;
        const date = new Date(minValueDate);
        switch (period) {
            case TimeParts.Hour:
                hour = parseInt(value, 10);
                break;
            case TimeParts.Minute:
                minute = parseInt(value, 10);
                break;
            case TimeParts.Seconds:
                seconds = parseInt(value, 10);
                break;
            case TimeParts.amPM:
                amPM = value;
                break;
        }
        if (amPM === 'PM') {
            hour += 12;
        }
        date.setHours(hour);
        date.setMinutes(minute);
        date.setSeconds(seconds);
        return date < minValueDate || date > maxValueDate;
    }
    /** @hidden @internal */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /** @hidden @internal */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
    /** @hidden @internal */
    setDisabledState(isDisabled) { this.disabled = isDisabled; }
    //#endregion
    trimMask() {
        this.mask = this.mask.slice(this.mask.indexOf(':') + 1, this.mask.length);
    }
    /**
     * @hidden
     */
    get mask() {
        return this._mask || '00:00 LL';
    }
    set mask(val) {
        this._mask = val;
    }
    /**
     * @hidden
     */
    get displayValue() {
        if (this._displayValue === undefined) {
            return this._formatTime(this.value, this.format);
        }
        return this._displayValue;
    }
    set displayValue(value) {
        this._displayValue = value;
    }
    /**
     * Returns the current time formatted as string using the `format` option.
     * If there is no set time the return is an empty string.
     * ```typescript
     * @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let time = this.picker.displayTime;
     * }
     * ```
     */
    get displayTime() {
        if (this.value) {
            return this._formatTime(this.value, this.format);
        }
        return '';
    }
    /**
     * @hidden
     */
    get hourView() {
        return this._hourView;
    }
    /**
     * @hidden
     */
    get minuteView() {
        return this._minuteView;
    }
    /**
     * @hidden
     */
    get secondsView() {
        return this._secondsView;
    }
    /**
     * @hidden
     */
    get ampmView() {
        return this._ampmView;
    }
    /**
     * @hidden
     */
    get showClearButton() {
        return (this.displayValue && this.displayValue !== this.parseMask(false)) || this.isNotEmpty;
    }
    /**
     * @hidden
     */
    get showHoursList() {
        return this.format.indexOf('h') !== -1 || this.format.indexOf('H') !== -1;
    }
    /**
     * @hidden
     */
    get showMinutesList() {
        return this.format.indexOf('m') !== -1;
    }
    /**
     * @hidden
     */
    get showSecondsList() {
        return this.format.indexOf('s') !== -1;
    }
    /**
     * @hidden
     */
    get showAmPmList() {
        return this.format.indexOf('t') !== -1;
    }
    /**
     * @hidden
     */
    get validSecondsEntries() {
        const secondsEntries = [];
        for (let i = 0; i < 60; i++) {
            secondsEntries.push(i);
        }
        return secondsEntries;
    }
    /**
     * @hidden
     */
    get validMinuteEntries() {
        const minuteEntries = [];
        for (let i = 0; i < 60; i++) {
            minuteEntries.push(i);
        }
        return minuteEntries;
    }
    /**
     * @hidden
     */
    get validHourEntries() {
        const hourEntries = [];
        const index = this.format.indexOf('h') !== -1 ? 13 : 24;
        for (let i = 0; i < index; i++) {
            hourEntries.push(i);
        }
        return hourEntries;
    }
    /**
     * Gets the input group template.
     * ```typescript
     * let template = this.template();
     * ```
     * @memberof IgxTimePickerComponent
     */
    get template() {
        if (this.timePickerTemplateDirective) {
            return this.timePickerTemplateDirective.template;
        }
        return this.mode === InteractionMode.Dialog ? this.defaultTimePickerTemplate : this.dropdownInputTemplate;
    }
    /**
     * Gets the context passed to the input group template.
     * @memberof IgxTimePickerComponent
     */
    get context() {
        return {
            value: this.value,
            displayTime: this.displayTime,
            displayValue: this.displayValue,
            openDialog: (target) => this.openDialog(target)
        };
    }
    get required() {
        if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            const error = this._ngControl.control.validator({});
            return error && error.required;
        }
        return false;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._generateHours();
        this._generateMinutes();
        this._generateSeconds();
        if (this.format.indexOf('tt') !== -1) {
            this._generateAmPm();
        }
        this._dropDownOverlaySettings = {
            modal: false,
            closeOnOutsideClick: true,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy()
        };
        this._dialogOverlaySettings = {};
        this._ngControl = this._injector.get(NgControl, null);
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        if (this.mode === InteractionMode.DropDown && this._inputElementRef) {
            fromEvent(this._inputElementRef.nativeElement, 'keydown').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy$)).subscribe((event) => {
                if (event.key === "ArrowUp" /* UP_ARROW */ || event.key === "Up" /* UP_ARROW_IE */ ||
                    event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */) {
                    this.spinOnEdit(event);
                }
            });
        }
        if (this.toggleRef && this._inputGroup) {
            this.toggleRef.element.style.width = this._inputGroup.element.nativeElement.getBoundingClientRect().width + 'px';
        }
        if (this.toggleRef) {
            this.toggleRef.onClosed.pipe(takeUntil(this._destroy$)).subscribe(() => {
                if (this.mode === InteractionMode.DropDown) {
                    this._onDropDownClosed();
                }
                this.onClosed.emit(this);
            });
            this.toggleRef.onOpened.pipe(takeUntil(this._destroy$)).subscribe(() => {
                this.onOpened.emit(this);
            });
            this.toggleRef.onClosing.pipe(takeUntil(this._destroy$)).subscribe((event) => {
                this.onClosing.emit(event);
                // If canceled in a user onClosing handler
                if (event.cancel) {
                    return;
                }
                // Do not focus the input if clicking outside in dropdown mode
                const input = this.getEditElement();
                if (input && !(event.event && this.mode === InteractionMode.DropDown)) {
                    input.focus();
                }
                else {
                    this._updateValidityOnBlur();
                }
            });
            this.determineCursorPos();
            if (this._ngControl) {
                this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
            }
        }
    }
    ngAfterViewChecked() {
        // if one sets mode at run time this forces initialization of new igxInputGroup
        // As a result a new igxInputDirective is initialized too. In ngAfterViewInit of
        // the new directive isRequired of the igxInputGroup is set again. However
        // ngAfterViewInit of the time picker is not called again and we may finish with wrong
        // isRequired in igxInputGroup. This is why we should set it her, only when needed
        if (this._inputGroup && this._inputGroup.isRequired !== this.required) {
            this._inputGroup.isRequired = this.required;
            this._cdr.detectChanges();
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
    }
    /**
     * @hidden
     */
    onKeydownSpace(event) {
        this.openDialog(this.getInputGroupElement());
        event.preventDefault();
    }
    /**
     * @hidden
     */
    onAltArrowDown() {
        this.openDialog(this.getInputGroupElement());
    }
    determineCursorPos() {
        this.clearCursorPos();
        for (const char of this.format) {
            switch (char) {
                case 'H':
                case 'h':
                    this._hoursPos.size === 0 ? this._hoursPos.add(this.format.indexOf(char)) :
                        this._hoursPos.add(this.format.lastIndexOf(char));
                    this._hoursPos.add(this.format.lastIndexOf(char) + 1);
                    break;
                case 'M':
                case 'm':
                    this._minutesPos.size === 0 ? this._minutesPos.add(this.format.indexOf(char)) :
                        this._minutesPos.add(this.format.lastIndexOf(char));
                    this._minutesPos.add(this.format.lastIndexOf(char) + 1);
                    break;
                case 'S':
                case 's':
                    this._secondsPos.size === 0 ? this._secondsPos.add(this.format.indexOf(char)) :
                        this._secondsPos.add(this.format.lastIndexOf(char));
                    this._secondsPos.add(this.format.lastIndexOf(char) + 1);
                    break;
                case 'T':
                case 't':
                    this._amPmPos.size === 0 ? this._amPmPos.add(this.format.indexOf(char)) :
                        this._amPmPos.add(this.format.lastIndexOf(char));
                    this._amPmPos.add(this.format.lastIndexOf(char) + 1);
                    break;
            }
        }
    }
    clearCursorPos() {
        this._hoursPos.forEach(v => this._hoursPos.delete(v));
        this._minutesPos.forEach(v => this._minutesPos.delete(v));
        this._secondsPos.forEach(v => this._secondsPos.delete(v));
        this._amPmPos.forEach(v => this._amPmPos.delete(v));
    }
    _scrollItemIntoView(item, items, selectedItem, isListLoop, viewType) {
        let itemIntoView;
        if (items) {
            const index = (item === 'AM' || item === 'PM') ? items.indexOf(item) : items.indexOf(parseInt(item, 10));
            let view;
            if (index !== -1) {
                if (isListLoop) {
                    if (index > 0) {
                        selectedItem = this._itemToString(items[index - 1], viewType);
                        itemIntoView = this._nextItem(items, selectedItem, isListLoop, viewType);
                    }
                    else {
                        selectedItem = this._itemToString(items[1], viewType);
                        itemIntoView = this._prevItem(items, selectedItem, isListLoop, viewType);
                    }
                }
                else {
                    view = items.slice(index - 3, index + 4);
                    selectedItem = this._itemToString(items[index], viewType);
                    itemIntoView = { selectedItem, view };
                }
                itemIntoView.view = this._viewToString(itemIntoView.view, viewType);
            }
        }
        return itemIntoView;
    }
    _viewToString(view, viewType) {
        for (let i = 0; i < view.length; i++) {
            if (typeof (view[i]) !== 'string') {
                view[i] = this._itemToString(view[i], viewType);
            }
        }
        return view;
    }
    _itemToString(item, viewType) {
        if (item === null) {
            item = '';
        }
        else if (viewType && typeof (item) !== 'string') {
            const leadZeroHour = (item < 10 && (this.format.indexOf('hh') !== -1 || this.format.indexOf('HH') !== -1));
            const leadZeroMinute = (item < 10 && this.format.indexOf('mm') !== -1);
            const leadZeroSeconds = (item < 10 && this.format.indexOf('ss') !== -1);
            const leadZero = {
                hour: leadZeroHour,
                minute: leadZeroMinute,
                seconds: leadZeroSeconds
            }[viewType];
            item = (leadZero) ? '0' + item : `${item}`;
        }
        return item;
    }
    _prevItem(items, selectedItem, isListLoop, viewType) {
        const selectedIndex = items.indexOf(parseInt(selectedItem, 10));
        const itemsCount = items.length;
        let view;
        if (selectedIndex === -1) {
            view = items.slice(0, 7);
            selectedItem = items[3];
        }
        else if (isListLoop) {
            if (selectedIndex - 4 < 0) {
                view = items.slice(itemsCount - (4 - selectedIndex), itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 3));
            }
            else if (selectedIndex + 4 > itemsCount) {
                view = items.slice(selectedIndex - 4, itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 3 - itemsCount));
            }
            else {
                view = items.slice(selectedIndex - 4, selectedIndex + 3);
            }
            selectedItem = (selectedIndex === 0) ? items[itemsCount - 1] : items[selectedIndex - 1];
        }
        else if (selectedIndex > 3) {
            view = items.slice(selectedIndex - 4, selectedIndex + 3);
            selectedItem = items[selectedIndex - 1];
        }
        else if (selectedIndex === 3) {
            view = items.slice(0, 7);
        }
        view = this._viewToString(view, viewType);
        selectedItem = this._itemToString(selectedItem, viewType);
        return {
            selectedItem,
            view
        };
    }
    _nextItem(items, selectedItem, isListLoop, viewType) {
        const selectedIndex = items.indexOf(parseInt(selectedItem, 10));
        const itemsCount = items.length;
        let view;
        if (selectedIndex === -1) {
            view = items.slice(0, 7);
            selectedItem = items[3];
        }
        else if (isListLoop) {
            if (selectedIndex < 2) {
                view = items.slice(itemsCount - (2 - selectedIndex), itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 5));
            }
            else if (selectedIndex + 4 >= itemsCount) {
                view = items.slice(selectedIndex - 2, itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 5 - itemsCount));
            }
            else {
                view = items.slice(selectedIndex - 2, selectedIndex + 5);
            }
            selectedItem = (selectedIndex === itemsCount - 1) ? items[0] : items[selectedIndex + 1];
        }
        else if (selectedIndex + 1 < itemsCount - 3) {
            view = items.slice(selectedIndex - 2, selectedIndex + 5);
            selectedItem = items[selectedIndex + 1];
        }
        else if (selectedIndex === itemsCount - 4) {
            view = items.slice(selectedIndex - 3, itemsCount);
        }
        view = this._viewToString(view, viewType);
        selectedItem = this._itemToString(selectedItem, viewType);
        return {
            selectedItem,
            view
        };
    }
    _formatTime(value, format) {
        if (!value) {
            return '';
        }
        else {
            let hour = value.getHours();
            let formattedSeconds, formattedMinute, formattedHour;
            const minute = value.getMinutes();
            const seconds = value.getSeconds();
            const amPM = (hour > 11) ? 'PM' : 'AM';
            if (format.indexOf('h') !== -1) {
                if (hour > 12) {
                    hour -= 12;
                    formattedHour = hour < 10 && format.indexOf('hh') !== -1 ? '0' + hour : `${hour}`;
                }
                else if (hour === 0) {
                    formattedHour = '12';
                }
                else if (hour < 10 && format.indexOf('hh') !== -1) {
                    formattedHour = '0' + hour;
                }
                else {
                    formattedHour = `${hour}`;
                }
            }
            else {
                if (hour < 10 && format.indexOf('HH') !== -1) {
                    formattedHour = '0' + hour;
                }
                else {
                    formattedHour = `${hour}`;
                }
            }
            formattedMinute = minute < 10 && format.indexOf('mm') !== -1 ? '0' + minute : `${minute}`;
            formattedSeconds = seconds < 10 && format.indexOf('ss') !== -1 ? '0' + seconds : `${seconds}`;
            return format.replace('hh', formattedHour).replace('h', formattedHour)
                .replace('HH', formattedHour).replace('H', formattedHour)
                .replace('mm', formattedMinute).replace('m', formattedMinute)
                .replace('ss', formattedSeconds).replace('s', formattedSeconds)
                .replace('tt', amPM);
        }
    }
    _updateHourView(start, end) {
        this._hourView = this._viewToString(this._hourItems.slice(start, end), 'hour');
    }
    _updateMinuteView(start, end) {
        this._minuteView = this._viewToString(this._minuteItems.slice(start, end), 'minute');
    }
    _updateSecondsView(start, end) {
        this._secondsView = this._viewToString(this._secondsItems.slice(start, end), 'seconds');
    }
    _updateAmPmView(start, end) {
        this._ampmView = this._ampmItems.slice(start, end);
    }
    _addEmptyItems(items) {
        for (let i = 0; i < 3; i++) {
            items.push(null);
        }
    }
    _generateHours() {
        let hourItemsCount = 24;
        if (this.format.indexOf('h') !== -1) {
            hourItemsCount = 13;
        }
        hourItemsCount /= this.itemsDelta.hours;
        let i = this.format.indexOf('H') !== -1 ? 0 : 1;
        if (hourItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._hourItems);
            this._isHourListLoop = false;
        }
        if (hourItemsCount > 1) {
            for (i; i < hourItemsCount; i++) {
                this._hourItems.push(i * this.itemsDelta.hours);
            }
        }
        else {
            this._hourItems.push(0);
        }
        if (hourItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._hourItems);
        }
    }
    _generateMinutes() {
        const minuteItemsCount = 60 / this.itemsDelta.minutes;
        if (minuteItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._minuteItems);
            this._isMinuteListLoop = false;
        }
        for (let i = 0; i < minuteItemsCount; i++) {
            this._minuteItems.push(i * this.itemsDelta.minutes);
        }
        if (minuteItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._minuteItems);
        }
    }
    _generateSeconds() {
        const secondsItemsCount = 60 / this.itemsDelta.seconds;
        if (secondsItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._secondsItems);
            this._isSecondsListLoop = false;
        }
        for (let i = 0; i < secondsItemsCount; i++) {
            this._secondsItems.push(i * this.itemsDelta.seconds);
        }
        if (secondsItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._secondsItems);
        }
    }
    _generateAmPm() {
        this._addEmptyItems(this._ampmItems);
        this._ampmItems.push('AM');
        this._ampmItems.push('PM');
        this._addEmptyItems(this._ampmItems);
    }
    _getSelectedTime() {
        const date = this.value ? new Date(this.value) : new Date();
        if (this.selectedHour) {
            date.setHours(parseInt(this.selectedHour, 10));
        }
        if (this.selectedMinute) {
            date.setMinutes(parseInt(this.selectedMinute, 10));
        }
        if (this.selectedSeconds) {
            date.setSeconds(parseInt(this.selectedSeconds, 10));
        }
        if (((this.showHoursList && this.selectedHour !== '12') || (!this.showHoursList && this.selectedHour <= '11')) &&
            this.selectedAmPm === 'PM') {
            date.setHours(date.getHours() + 12);
        }
        if (!this.showHoursList && this.selectedAmPm === 'AM' && this.selectedHour > '11') {
            date.setHours(date.getHours() - 12);
        }
        if (this.selectedAmPm === 'AM' && this.selectedHour === '12') {
            date.setHours(0);
        }
        return date;
    }
    /** @hidden @internal */
    convertMinMaxValue(value) {
        if (!value) {
            return;
        }
        const date = this.value ? new Date(this.value) : this._dateFromModel ? new Date(this._dateFromModel) : new Date();
        const sections = value.split(/[\s:]+/);
        let hour, minutes, seconds, amPM;
        date.setSeconds(0);
        if (this.showHoursList) {
            hour = sections[0];
            date.setHours(parseInt(hour, 10));
        }
        if (this.showMinutesList) {
            minutes = this.showHoursList ? sections[1] : sections[0];
            date.setMinutes(parseInt(minutes, 10));
        }
        if (this.showSecondsList) {
            seconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
            date.setSeconds(parseInt(seconds, 10));
        }
        if (this.showAmPmList) {
            amPM = sections[sections.length - 1];
            if (((this.showHoursList && date.getHours().toString() !== '12') ||
                (!this.showHoursList && date.getHours().toString() <= '11')) && amPM === 'PM') {
                date.setHours(date.getHours() + 12);
            }
            if (!this.showHoursList && amPM === 'AM' && date.getHours().toString() > '11') {
                date.setHours(date.getHours() - 12);
            }
            if (this.showHoursList && date.getHours() === 12 && amPM === 'AM') {
                date.setHours(0);
            }
        }
        return date;
    }
    _isValueValid(value) {
        if (this.maxValue && value > this.convertMinMaxValue(this.maxValue)) {
            return false;
        }
        else if (this.minValue && value < this.convertMinMaxValue(this.minValue)) {
            return false;
        }
        else {
            return true;
        }
    }
    _isEntryValid(val) {
        let validH = true;
        let validM = true;
        let validS = true;
        const sections = val.split(/[\s:]+/);
        const re = new RegExp(this.promptChar, 'g');
        if (this.showHoursList) {
            validH = this.validHourEntries.indexOf(parseInt(sections[0].replace(re, ''), 10)) !== -1;
        }
        if (this.showMinutesList) {
            const minutes = this.showHoursList ? sections[1] : sections[0];
            validM = this.validMinuteEntries.indexOf(parseInt(minutes.replace(re, ''), 10)) !== -1;
        }
        if (this.showSecondsList) {
            const seconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
            validS = this.validSecondsEntries.indexOf(parseInt(seconds.replace(re, ''), 10)) !== -1;
        }
        return validH && validM && validS;
    }
    _getCursorPosition() {
        return this._inputElementRef.nativeElement.selectionStart;
    }
    _setCursorPosition(start, end = start) {
        this._inputElementRef.nativeElement.setSelectionRange(start, end);
    }
    _updateEditableInput() {
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this._formatTime(this._getSelectedTime(), this.format);
        }
    }
    _spinHours(currentVal, minVal, maxVal, hDelta, sign) {
        const oldVal = new Date(currentVal);
        currentVal.setMinutes(sign * hDelta);
        if (currentVal.getDate() !== oldVal.getDate() && this.isSpinLoop) {
            currentVal.setDate(oldVal.getDate());
        }
        let minutes = currentVal.getMinutes();
        if (currentVal.getTime() > maxVal.getTime()) {
            if (this.isSpinLoop) {
                minutes = minutes < minVal.getMinutes() ? 60 + minutes : minutes;
                minVal.setMinutes(sign * minutes);
                return minVal;
            }
            else {
                return oldVal;
            }
        }
        else if (currentVal.getTime() < minVal.getTime()) {
            if (this.isSpinLoop) {
                minutes = minutes <= maxVal.getMinutes() ? minutes : minutes - 60;
                maxVal.setMinutes(minutes);
                return maxVal;
            }
            else {
                return oldVal;
            }
        }
        else {
            return currentVal;
        }
    }
    _spinMinutes(currentVal, mDelta, sign) {
        let minutes = currentVal.getMinutes() + (sign * mDelta);
        if (minutes < 0 || minutes >= 60) {
            minutes = this.isSpinLoop ? minutes - (sign * 60) : currentVal.getMinutes();
        }
        currentVal.setMinutes(minutes);
        return currentVal;
    }
    _spinSeconds(currentVal, sDelta, sign) {
        let seconds = currentVal.getSeconds() + (sign * sDelta);
        if (seconds < 0 || seconds >= 60) {
            seconds = this.isSpinLoop ? seconds - (sign * 60) : currentVal.getSeconds();
        }
        currentVal.setSeconds(seconds);
        return currentVal;
    }
    _initializeContainer() {
        if (this.value) {
            const formttedTime = this._formatTime(this.value, this.format);
            const sections = formttedTime.split(/[\s:]+/);
            if (this.showHoursList) {
                this.selectedHour = sections[0];
            }
            if (this.showMinutesList) {
                this.selectedMinute = this.showHoursList ? sections[1] : sections[0];
            }
            if (this.showSecondsList) {
                this.selectedSeconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
            }
            if (this.showAmPmList && this._ampmItems !== null) {
                this.selectedAmPm = sections[sections.length - 1];
            }
        }
        if (this.selectedHour === undefined) {
            this.selectedHour = !this.showHoursList && this.value ? this.value.getHours().toString() :
                this.showHoursList ? `${this._hourItems[3]}` : '0';
        }
        if (this.selectedMinute === undefined) {
            this.selectedMinute = !this.showMinutesList && this.value ? this.value.getMinutes().toString() : '0';
        }
        if (this.selectedSeconds === undefined) {
            this.selectedSeconds = !this.showSecondsList && this.value ? this.value.getSeconds().toString() : '0';
        }
        if (this.selectedAmPm === undefined && this._ampmItems !== null) {
            this.selectedAmPm = this._ampmItems[3];
        }
        this._prevSelectedHour = this.selectedHour;
        this._prevSelectedMinute = this.selectedMinute;
        this._prevSelectedSeconds = this.selectedSeconds;
        this._prevSelectedAmPm = this.selectedAmPm;
        this._onTouchedCallback();
        this._updateHourView(0, ITEMS_COUNT);
        this._updateMinuteView(0, ITEMS_COUNT);
        this._updateSecondsView(0, ITEMS_COUNT);
        this._updateAmPmView(0, ITEMS_COUNT);
        if (this.selectedHour) {
            this.scrollHourIntoView(this.selectedHour);
        }
        if (this.selectedMinute) {
            this.scrollMinuteIntoView(this.selectedMinute);
        }
        if (this.selectedSeconds) {
            this.scrollSecondsIntoView(this.selectedSeconds);
        }
        if (this.selectedAmPm) {
            this.scrollAmPmIntoView(this.selectedAmPm);
        }
        requestAnimationFrame(() => {
            if (this.hourList) {
                this.hourList.nativeElement.focus();
            }
            else if (this.minuteList) {
                this.minuteList.nativeElement.focus();
            }
            else if (this.secondsList) {
                this.secondsList.nativeElement.focus();
            }
        });
    }
    _onDropDownClosed() {
        const oldValue = this.value;
        const newVal = this.convertMinMaxValue(this.displayValue);
        if (this.displayValue === this.parseMask(false)) {
            return;
        }
        if (this._isValueValid(newVal)) {
            if (!this.value || oldValue.getTime() !== newVal.getTime()) {
                this.value = newVal;
            }
        }
        else {
            this.displayValue = this.inputFormat.transform(this._formatTime(oldValue, this.format));
            const args = {
                timePicker: this,
                currentValue: newVal,
                setThroughUI: true
            };
            this.onValidationFailed.emit(args);
        }
    }
    onStatusChanged() {
        if ((this._ngControl.control.touched || this._ngControl.control.dirty) &&
            (this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {
            const input = this._inputDirective || this._inputDirectiveUserTemplate;
            if (this._inputGroup.isFocused) {
                input.valid = this._ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
            }
            else {
                input.valid = this._ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
            }
        }
        if (this._inputGroup && this._inputGroup.isRequired !== this.required) {
            this._inputGroup.isRequired = this.required;
        }
    }
    /**
     * @hidden
     */
    getEditElement() {
        return this._inputElementRef ? this._inputElementRef.nativeElement : null;
    }
    /**
     * @hidden
     */
    getInputGroupElement() {
        return this._inputGroup ? this._inputGroup.element.nativeElement : null;
    }
    /**
     * opens the dialog.
     * @param target HTMLElement - the target element to use for positioning the drop down container according to
     * ```html
     * <igx-time-picker [value]="date" mode="dropdown" #retemplated>
     *   <ng-template igxTimePickerTemplate let-openDialog="openDialog"
     *                let-displayTime="displayTime">
     *     <igx-input-group>
     *       <input #dropDownTarget igxInput [value]="displayTime" />
     *       <igx-suffix (click)="openDialog(dropDownTarget)">
     *         <igx-icon>alarm</igx-icon>
     *       </igx-suffix>
     *     </igx-input-group>
     *   </ng-template>
     * </igx-time-picker>
     * ```
     */
    openDialog(target) {
        if (!this.toggleRef.collapsed) {
            return this._onDropDownClosed();
        }
        const settings = this.overlaySettings;
        if (target && settings && settings.positionStrategy) {
            settings.target = target;
        }
        if (this.outlet) {
            settings.outlet = this.outlet;
        }
        this.toggleRef.open(settings);
        this._initializeContainer();
    }
    /**
     * Scrolls a hour item into view.
     * ```typescript
     * scrhintoView(picker) {
     * picker.scrollHourIntoView('2');
     * }
     *  ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrhintoView(picker)"></igx-time-picker>
     * ```
     * @param item to be scrolled in view.
     */
    scrollHourIntoView(item) {
        if (this.showHoursList) {
            const hourIntoView = this._scrollItemIntoView(item, this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
            if (hourIntoView) {
                this._hourView = hourIntoView.view;
                this.selectedHour = hourIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * Scrolls a minute item into view.
     * ```typescript
     * scrMintoView(picker) {
     * picker.scrollMinuteIntoView('3');
     * }
     *  ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrMintoView(picker)"></igx-time-picker>
     * ```
     * @param item to be scrolled in view.
     */
    scrollMinuteIntoView(item) {
        if (this.showMinutesList) {
            const minuteIntoView = this._scrollItemIntoView(item, this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
            if (minuteIntoView) {
                this._minuteView = minuteIntoView.view;
                this.selectedMinute = minuteIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * Scrolls a seconds item into view.
     * ```typescript
     * scrMintoView(picker) {
     * picker.scrollSecondsIntoView('4');
     * }
     *  ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrMintoView(picker)"></igx-time-picker>
     * ```
     * @param item to be scrolled in view.
     */
    scrollSecondsIntoView(item) {
        if (this.showSecondsList) {
            const secondsIntoView = this._scrollItemIntoView(item, this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
            if (secondsIntoView) {
                this._secondsView = secondsIntoView.view;
                this.selectedSeconds = secondsIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * Scrolls an ampm item into view.
     * ```typescript
     * scrAmPmIntoView(picker) {
     * picker.scrollAmPmIntoView('PM');
     * }
     *  ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrAmPmIntoView(picker)"></igx-time-picker>
     * ```
     * @param item to be scrolled in view.
     */
    scrollAmPmIntoView(item) {
        if (this.showAmPmList) {
            const ampmIntoView = this._scrollItemIntoView(item, this._ampmItems, this.selectedAmPm, false, null);
            if (ampmIntoView) {
                this._ampmView = ampmIntoView.view;
                this.selectedAmPm = ampmIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * @hidden
     */
    nextHour() {
        const nextHour = this._nextItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
        this._hourView = nextHour.view;
        this.selectedHour = nextHour.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    prevHour() {
        const prevHour = this._prevItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
        this._hourView = prevHour.view;
        this.selectedHour = prevHour.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    nextMinute() {
        const nextMinute = this._nextItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
        this._minuteView = nextMinute.view;
        this.selectedMinute = nextMinute.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    prevMinute() {
        const prevMinute = this._prevItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
        this._minuteView = prevMinute.view;
        this.selectedMinute = prevMinute.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    nextSeconds() {
        const nextSeconds = this._nextItem(this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
        this._secondsView = nextSeconds.view;
        this.selectedSeconds = nextSeconds.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    prevSeconds() {
        const prevSeconds = this._prevItem(this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
        this._secondsView = prevSeconds.view;
        this.selectedSeconds = prevSeconds.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    nextAmPm() {
        const selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
        if (selectedIndex + 1 < this._ampmItems.length - 3) {
            this._updateAmPmView(selectedIndex - 2, selectedIndex + 5);
            this.selectedAmPm = this._ampmItems[selectedIndex + 1];
            this._updateEditableInput();
        }
    }
    /**
     * @hidden
     */
    prevAmPm() {
        const selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
        if (selectedIndex > 3) {
            this._updateAmPmView(selectedIndex - 4, selectedIndex + 3);
            this.selectedAmPm = this._ampmItems[selectedIndex - 1];
            this._updateEditableInput();
        }
    }
    /**
     * If current value is valid selects it, closes the dialog and returns true, otherwise returns false.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [rightButtonLabel]="okButtonLabel" (onRightButtonSelect)="okButtonClick()">
     * //..
     * </igx-dialog>
     * ```
     */
    okButtonClick() {
        const time = this._getSelectedTime();
        if (this._isValueValid(time)) {
            this.close();
            this.value = time;
            return true;
        }
        else {
            const args = {
                timePicker: this,
                currentValue: time,
                setThroughUI: true
            };
            this.onValidationFailed.emit(args);
            return false;
        }
    }
    /**
     * Closes the dialog without selecting the current value.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [leftButtonLabel]="cancelButtonLabel" (onLeftButtonSelect)="cancelButtonClick()">
     * //...
     * </igx-dialog>
     * ```
     */
    cancelButtonClick() {
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this.value ? this._formatTime(this.value, this.format) : this.parseMask(false);
        }
        this.close();
        this.selectedHour = this._prevSelectedHour;
        this.selectedMinute = this._prevSelectedMinute;
        this.selectedSeconds = this._prevSelectedSeconds;
        this.selectedAmPm = this._prevSelectedAmPm;
    }
    /**
     * Returns an array of the hours currently in view.
     * ```html
     *  @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *     let hInView = this.picker.hoursInView;
     * }
     * ```
     */
    hoursInView() {
        return this._hourView.filter((hour) => hour !== '');
    }
    /**
     * Returns an array of the minutes currently in view.
     * ```html
     *  @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *     let minInView = this.picker.minutesInView;
     * }
     * ```
     */
    minutesInView() {
        return this._minuteView.filter((minute) => minute !== '');
    }
    /**
     * Returns an array of the seconds currently in view.
     * ```html
     *  @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *     let minInView = this.picker.secondsInView;
     * }
     * ```
     */
    secondsInView() {
        return this._secondsView.filter((seconds) => seconds !== '');
    }
    /**
     * Returns an array of the AM/PM currently in view.
     * ```html
     *  @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *     let ApInView = this.picker.ampmInView;
     * }
     * ```
     */
    ampmInView() {
        return this._ampmView.filter((ampm) => ampm !== '');
    }
    /**
     * Closes the dropdown/dialog.
     * ```html
     * <igx-time-picker #timePicker></igx-time-picker>
     * ```
     * ```typescript
     * @ViewChild('timePicker', { read: IgxTimePickerComponent }) picker: IgxTimePickerComponent;
     * picker.close();
     * ```
     */
    close() {
        this.toggleRef.close();
    }
    /**
     * @hidden
     */
    parseMask(preserveAmPm = true) {
        const maskWithAmPm = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace('LL', 'AM');
        const pureMask = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace(new RegExp('L', 'g'), this.promptChar);
        return preserveAmPm ? maskWithAmPm : pureMask;
    }
    /**
     * @hidden
     */
    clear() {
        var _a, _b;
        if (this.toggleRef.collapsed) {
            this.cleared = true;
            this.isNotEmpty = false;
            const oldVal = new Date(this.value);
            this.displayValue = this.parseMask(false);
            requestAnimationFrame(() => {
                this._setCursorPosition(0);
            });
            // TODO: refactoring - this.value should be null #6585
            (_a = this.value) === null || _a === void 0 ? void 0 : _a.setHours(0, 0, 0);
            if (oldVal.getTime() !== ((_b = this.value) === null || _b === void 0 ? void 0 : _b.getTime()) || this.isReset()) {
                const args = {
                    oldValue: oldVal,
                    newValue: this.value
                };
                this.onValueChanged.emit(args);
            }
        }
        else {
            this.close();
        }
    }
    /**
     * @hidden
     */
    onInput(event) {
        var _a, _b;
        const inputMask = event.target.value;
        const oldVal = new Date(this.value);
        this.isNotEmpty = inputMask !== this.parseMask(false);
        // handle cases where all empty positions (promts) are filled and we want to update
        // timepicker own value property if it is a valid Date
        if (inputMask.indexOf(this.promptChar) === -1) {
            if (this._isEntryValid(inputMask)) {
                const newVal = this.convertMinMaxValue(inputMask);
                if (oldVal.getTime() !== newVal.getTime()) {
                    this.value = newVal;
                }
            }
            else {
                const args = {
                    timePicker: this,
                    currentValue: new Date(inputMask),
                    setThroughUI: false
                };
                this.onValidationFailed.emit(args);
            }
            // handle cases where the user deletes the display value (when pressing backspace or delete)
        }
        else if (!this.value || inputMask.length === 0 || !this.isNotEmpty) {
            this.isNotEmpty = false;
            // TODO: refactoring - this.value should be null #6585
            (_a = this.value) === null || _a === void 0 ? void 0 : _a.setHours(0, 0, 0);
            this.displayValue = inputMask;
            if (oldVal.getTime() !== ((_b = this.value) === null || _b === void 0 ? void 0 : _b.getTime()) || this.isReset()) {
                // TODO: Do not emit event when the editor is empty #6482
                const args = {
                    oldValue: oldVal,
                    newValue: this.value
                };
                this.onValueChanged.emit(args);
            }
        }
    }
    /**
     * @hidden
     */
    onFocus(event) {
        this.isNotEmpty = event.target.value !== this.parseMask(false);
    }
    /**
     * @hidden
     */
    onBlur(event) {
        if (this.mode === InteractionMode.DropDown) {
            const value = event.target.value;
            this.isNotEmpty = value !== '';
            this.displayValue = value;
            if (value && (value !== this.parseMask() || value !== this.parseMask(false))) {
                if (this._isEntryValid(value)) {
                    const newVal = this.convertMinMaxValue(value);
                    if (!this.value || this.value.getTime() !== newVal.getTime()) {
                        this.value = newVal;
                    }
                }
                else {
                    const args = {
                        timePicker: this,
                        currentValue: value,
                        setThroughUI: false
                    };
                    this.onValidationFailed.emit(args);
                }
            }
        }
        if (this.toggleRef.collapsed) {
            this._updateValidityOnBlur();
        }
    }
    mouseDown(event) {
        // if the click is not on the input but in input group
        // e.g. on prefix or suffix, prevent default and this way prevent blur
        if (event.target !== this.getEditElement()) {
            event.preventDefault();
        }
    }
    /**
     * @hidden
     */
    spinOnEdit(event) {
        event.preventDefault();
        let sign;
        let displayVal;
        const currentVal = new Date(this.value);
        const min = this.minValue ? this.convertMinMaxValue(this.minValue) : this.convertMinMaxValue('00:00');
        const max = this.maxValue ? this.convertMinMaxValue(this.maxValue) : this.convertMinMaxValue('24:00');
        const cursor = this._getCursorPosition();
        if (event.key) {
            const key = event.key;
            sign = key === "ArrowDown" /* DOWN_ARROW */ || key === "Down" /* DOWN_ARROW_IE */ ? -1 : 1;
        }
        if (event.deltaY) {
            sign = event.deltaY < 0 ? 1 : -1;
        }
        if (!this.displayValue) {
            this.value = min;
            displayVal = this._formatTime(this.value, this.format);
        }
        else {
            const hDelta = this.itemsDelta.hours * 60 + (sign * this.value.getMinutes());
            const mDelta = this.itemsDelta.minutes;
            const sDelta = this.itemsDelta.seconds;
            if (this.cursorOnHours(cursor, this.showHoursList)) {
                this.value = this._spinHours(currentVal, min, max, hDelta, sign);
            }
            if (this.cursorOnMinutes(cursor, this.showHoursList, this.showMinutesList)) {
                this.value = this._spinMinutes(currentVal, mDelta, sign);
            }
            if (this.cursorOnSeconds(cursor, this.showHoursList, this.showMinutesList, this.showSecondsList)) {
                this.value = this._spinSeconds(currentVal, sDelta, sign);
            }
            if (this.cursorOnAmPm(cursor, this.showHoursList, this.showMinutesList, this.showSecondsList, this.showAmPmList)) {
                const sections = this.displayValue.split(/[\s:]+/);
                sign = sections[sections.length - 1] === 'AM' ? 1 : -1;
                currentVal.setHours(currentVal.getHours() + (sign * 12));
                this.value = currentVal;
            }
            displayVal = this._formatTime(this.value, this.format);
        }
        // minor hack for preventing cursor jumping in IE
        this._displayValue = this.inputFormat.transform(displayVal);
        this._inputElementRef.nativeElement.value = this._displayValue;
        this._setCursorPosition(cursor);
        requestAnimationFrame(() => {
            this._setCursorPosition(cursor);
        });
    }
    cursorOnHours(cursor, showHours) {
        return showHours && this._hoursPos.has(cursor);
    }
    cursorOnMinutes(cursor, showHours, showMinutes) {
        return showMinutes &&
            (showHours && this._minutesPos.has(cursor)) ||
            (!showHours && this._minutesPos.has(cursor));
    }
    cursorOnSeconds(cursor, showHours, showMinutes, showSeconds) {
        return showSeconds &&
            (showHours && showMinutes && this._secondsPos.has(cursor)) ||
            ((!showHours || !showMinutes) && this._secondsPos.has(cursor)) ||
            (!showHours && !showMinutes && this._secondsPos.has(cursor));
    }
    cursorOnAmPm(cursor, showHours, showMinutes, showSeconds, showAmPm) {
        return showAmPm &&
            (showHours && showMinutes && showSeconds && this._amPmPos.has(cursor)) ||
            ((!showHours || !showMinutes || !showSeconds) && this._amPmPos.has(cursor)) ||
            (!showHours && (!showMinutes || !showSeconds) && this._amPmPos.has(cursor));
    }
    _updateValidityOnBlur() {
        this._onTouchedCallback();
        const input = this._inputDirective || this._inputDirectiveUserTemplate;
        if (this._ngControl && !this._ngControl.valid) {
            input.valid = IgxInputState.INVALID;
        }
        else {
            input.valid = IgxInputState.INITIAL;
        }
    }
    // Workaround method for #8135
    // TODO: It must be removed in #6482
    isReset() {
        var _a, _b, _c;
        return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.getHours()) === 0
            && ((_b = this.value) === null || _b === void 0 ? void 0 : _b.getMinutes()) === 0
            && ((_c = this.value) === null || _c === void 0 ? void 0 : _c.getSeconds()) === 0;
    }
}
IgxTimePickerComponent.ɵfac = function IgxTimePickerComponent_Factory(t) { return new (t || IgxTimePickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxTimePickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTimePickerComponent, selectors: [["igx-time-picker"]], contentQueries: function IgxTimePickerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTimePickerTemplateDirective, true, IgxTimePickerTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTimePickerActionsDirective, true, IgxTimePickerActionsDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxLabelDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxInputDirective, true, IgxInputDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.timePickerTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.timePickerActionsDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.labelDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputDirectiveUserTemplate = _t.first);
    } }, viewQuery: function IgxTimePickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c241, true);
        ɵngcc0.ɵɵviewQuery(_c242, true);
        ɵngcc0.ɵɵviewQuery(_c243, true);
        ɵngcc0.ɵɵviewQuery(_c244, true);
        ɵngcc0.ɵɵstaticViewQuery(_c245, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c246, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(IgxToggleDirective, true);
        ɵngcc0.ɵɵviewQuery(IgxInputDirective, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(IgxInputDirective, true, IgxInputDirective);
        ɵngcc0.ɵɵviewQuery(IgxInputGroupComponent, true, IgxInputGroupComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hourList = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.minuteList = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.secondsList = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ampmList = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultTimePickerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdownInputTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElementRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputGroup = _t.first);
    } }, hostVars: 1, hostBindings: function IgxTimePickerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.spacebar", function IgxTimePickerComponent_keydown_spacebar_HostBindingHandler($event) { return ctx.onKeydownSpace($event); })("keydown.space", function IgxTimePickerComponent_keydown_space_HostBindingHandler($event) { return ctx.onKeydownSpace($event); })("keydown.Alt.ArrowDown", function IgxTimePickerComponent_keydown_Alt_ArrowDown_HostBindingHandler() { return ctx.onAltArrowDown(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { id: "id", disabled: "disabled", isSpinLoop: "isSpinLoop", vertical: "vertical", promptChar: "promptChar", mode: "mode", value: "value", resourceStrings: "resourceStrings", okButtonLabel: "okButtonLabel", cancelButtonLabel: "cancelButtonLabel", itemsDelta: "itemsDelta", format: "format", overlaySettings: "overlaySettings", minValue: "minValue", maxValue: "maxValue", outlet: "outlet" }, outputs: { onValueChanged: "onValueChanged", onValidationFailed: "onValidationFailed", onOpened: "onOpened", onClosed: "onClosed", onClosing: "onClosing" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxTimePickerComponent,
                multi: true
            },
            {
                provide: HAMMER_GESTURE_CONFIG,
                useClass: TimePickerHammerConfig
            },
            {
                provide: IGX_TIME_PICKER_COMPONENT,
                useExisting: IgxTimePickerComponent
            }
        ])], ngContentSelectors: _c72, decls: 18, vars: 12, consts: [["labelTemplate", ""], ["dropdownInputTemplate", ""], ["defaultTimePickerTemplate", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["defaultTimePickerActions", ""], ["igxToggle", "", 1, "igx-time-picker", 3, "ngClass"], ["class", "igx-time-picker__header", 4, "ngIf"], [1, "igx-time-picker__main"], [1, "igx-time-picker__body"], [3, "igxItemList", 4, "ngIf"], [4, "ngTemplateOutlet"], [3, "suppressInputAutofocus", "mousedown"], ["group", ""], ["igxLabel", "", 4, "ngIf"], ["ngProjectAs", "[igxLabel]", 5, ["", "igxLabel", ""], 4, "ngTemplateOutlet"], [3, "click"], ["type", "text", "igxInput", "", 3, "igxMask", "includeLiterals", "placeholder", "displayValuePipe", "focusedValuePipe", "promptChar", "value", "igxTextSelection", "disabled", "input", "blur", "focus", "wheel"], ["igxRipple", "", 3, "click", 4, "ngIf"], ["igxLabel", ""], ["ngProjectAs", "[igxLabel]", 5, ["", "igxLabel", ""]], ["igxRipple", "", 3, "click"], ["fontSet", "material"], [3, "click", "mousedown"], ["igxInput", "", "tabindex", "0", "readonly", "", 3, "value", "disabled", "blur"], ["class", "igx-time-picker__buttons", 4, "ngIf"], [1, "igx-time-picker__buttons"], ["igxButton", "flat", 3, "click", 4, "ngIf"], ["igxButton", "flat", 3, "click"], [1, "igx-time-picker__header"], [1, "igx-time-picker__header-ampm"], [1, "igx-time-picker__header-hour"], [3, "igxItemList"], ["hourList", ""], [3, "igxHourItem", "ngClass", 4, "ngFor", "ngForOf"], [3, "igxHourItem", "ngClass"], ["minuteList", ""], [3, "igxMinuteItem", "ngClass", 4, "ngFor", "ngForOf"], [3, "igxMinuteItem", "ngClass"], ["secondsList", ""], [3, "igxSecondsItem", "ngClass", 4, "ngFor", "ngForOf"], [3, "igxSecondsItem", "ngClass"], ["ampmList", ""], [3, "igxAmPmItem", "ngClass", 4, "ngFor", "ngForOf"], [3, "igxAmPmItem", "ngClass"]], template: function IgxTimePickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c71);
        ɵngcc0.ɵɵtemplate(0, IgxTimePickerComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxTimePickerComponent_ng_template_2_Template, 9, 13, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxTimePickerComponent_ng_template_4_Template, 7, 4, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxTimePickerComponent_ng_container_6_Template, 1, 0, "ng-container", 3);
        ɵngcc0.ɵɵtemplate(7, IgxTimePickerComponent_ng_template_7_Template, 1, 1, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(9, "div", 5);
        ɵngcc0.ɵɵtemplate(10, IgxTimePickerComponent_div_10_Template, 12, 4, "div", 6);
        ɵngcc0.ɵɵelementStart(11, "div", 7);
        ɵngcc0.ɵɵelementStart(12, "div", 8);
        ɵngcc0.ɵɵtemplate(13, IgxTimePickerComponent_div_13_Template, 3, 2, "div", 9);
        ɵngcc0.ɵɵtemplate(14, IgxTimePickerComponent_div_14_Template, 3, 2, "div", 9);
        ɵngcc0.ɵɵtemplate(15, IgxTimePickerComponent_div_15_Template, 3, 2, "div", 9);
        ɵngcc0.ɵɵtemplate(16, IgxTimePickerComponent_div_16_Template, 3, 2, "div", 9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(17, IgxTimePickerComponent_ng_container_17_Template, 1, 0, "ng-container", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r7 = ɵngcc0.ɵɵreference(8);
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(9, _c248, ctx.mode === "dropdown", ctx.vertical && ctx.mode === "dialog"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.mode === "dialog");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showHoursList);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMinutesList);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showSecondsList);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showAmPmList);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.timePickerActionsDirective ? ctx.timePickerActionsDirective.template : _r7);
    } }, directives: [ɵngcc2.NgTemplateOutlet, IgxToggleDirective, ɵngcc2.NgClass, ɵngcc2.NgIf, IgxInputGroupComponent, IgxPrefixDirective, IgxIconComponent, IgxInputDirective, IgxMaskDirective, IgxTextSelectionDirective, IgxLabelDirective, IgxSuffixDirective, IgxButtonDirective, IgxItemListDirective, ɵngcc2.NgForOf, IgxHourItemDirective, IgxMinuteItemDirective, IgxSecondsItemDirective, IgxAmPmItemDirective], styles: [_c80] });
IgxTimePickerComponent.ctorParameters = () => [
    { type: Injector },
    { type: ChangeDetectorRef }
];
IgxTimePickerComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    resourceStrings: [{ type: Input }],
    okButtonLabel: [{ type: Input }],
    cancelButtonLabel: [{ type: Input }],
    itemsDelta: [{ type: Input }],
    minValue: [{ type: Input }],
    maxValue: [{ type: Input }],
    isSpinLoop: [{ type: Input }],
    vertical: [{ type: Input }],
    format: [{ type: Input }],
    promptChar: [{ type: Input }],
    mode: [{ type: Input }],
    outlet: [{ type: Input }],
    overlaySettings: [{ type: Input }],
    onValueChanged: [{ type: Output }],
    onValidationFailed: [{ type: Output }],
    onOpened: [{ type: Output }],
    onClosed: [{ type: Output }],
    onClosing: [{ type: Output }],
    hourList: [{ type: ViewChild, args: ['hourList',] }],
    minuteList: [{ type: ViewChild, args: ['minuteList',] }],
    secondsList: [{ type: ViewChild, args: ['secondsList',] }],
    ampmList: [{ type: ViewChild, args: ['ampmList',] }],
    defaultTimePickerTemplate: [{ type: ViewChild, args: ['defaultTimePickerTemplate', { read: TemplateRef, static: true },] }],
    dropdownInputTemplate: [{ type: ViewChild, args: ['dropdownInputTemplate', { read: TemplateRef, static: true },] }],
    timePickerTemplateDirective: [{ type: ContentChild, args: [IgxTimePickerTemplateDirective, { read: IgxTimePickerTemplateDirective },] }],
    timePickerActionsDirective: [{ type: ContentChild, args: [IgxTimePickerActionsDirective, { read: IgxTimePickerActionsDirective },] }],
    labelDirective: [{ type: ContentChild, args: [IgxLabelDirective,] }],
    toggleRef: [{ type: ViewChild, args: [IgxToggleDirective, { static: true },] }],
    _inputElementRef: [{ type: ViewChild, args: [IgxInputDirective, { read: ElementRef },] }],
    _inputDirective: [{ type: ViewChild, args: [IgxInputDirective, { read: IgxInputDirective },] }],
    _inputDirectiveUserTemplate: [{ type: ContentChild, args: [IgxInputDirective, { read: IgxInputDirective },] }],
    _inputGroup: [{ type: ViewChild, args: [IgxInputGroupComponent, { read: IgxInputGroupComponent },] }],
    onKeydownSpace: [{ type: HostListener, args: ['keydown.spacebar', ['$event'],] }, { type: HostListener, args: ['keydown.space', ['$event'],] }],
    onAltArrowDown: [{ type: HostListener, args: ['keydown.Alt.ArrowDown',] }]
};
/**
 * @hidden
 */
class IgxTimePickerModule {
}
IgxTimePickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTimePickerModule });
IgxTimePickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTimePickerModule_Factory(t) { return new (t || IgxTimePickerModule)(); }, providers: [], imports: [[
            CommonModule,
            IgxInputGroupModule,
            IgxIconModule,
            IgxButtonModule,
            IgxMaskModule,
            IgxToggleModule,
            IgxTextSelectionModule
        ]] });

let NEXT_ID$w = 0;
/**
 * Enumeration for toast position
 * Can be:
 * Bottom
 * Middle
 * Top
 */
const IgxToastPosition = mkenum({
    Bottom: 'bottom',
    Middle: 'middle',
    Top: 'top'
});
/**
 * **Ignite UI for Angular Toast** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/toast)
 *
 * The Ignite UI Toast provides information and warning messages that are non-interactive and cannot
 * be dismissed by the user. Toasts can be displayed at the bottom, middle, or top of the page.
 *
 * Example:
 * ```html
 * <button (click)="toast.show()">Show notification</button>
 * <igx-toast #toast
 *           message="Notification displayed"
 *           displayTime="1000">
 * </igx-toast>
 * ```
 */
class IgxToastComponent extends IgxToggleDirective {
    constructor(_element, cdr, navService, overlayService) {
        super(_element, cdr, overlayService, navService);
        this._element = _element;
        this.d$ = new Subject();
        this._isVisible = false;
        /**
         * @hidden
         */
        this.cssClass = 'igx-toast';
        /**
         * Sets/gets the `id` of the toast.
         * If not set, the `id` will have value `"igx-toast-0"`.
         * ```html
         * <igx-toast id = "my-first-toast"></igx-toast>
         * ```
         * ```typescript
         * let toastId = this.toast.id;
         * ```
         */
        this.id = `igx-toast-${NEXT_ID$w++}`;
        /**
         * Emits an event prior the toast is shown.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onShowing) = "onShowing($event)"></igx-toast>
         * ```
         * @memberof IgxToastComponent
         */
        this.onShowing = new EventEmitter();
        /**
         * Emits an event when the toast is shown.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onShown)="onShown($event)"></igx-toast>
         * ```
         * @memberof IgxToastComponent
         */
        this.onShown = new EventEmitter();
        /**
         * Emits an event prior the toast is hidden.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onHiding)="onHiding($event)"></igx-toast>
         * ```
         * @memberof IgxToastComponent
         */
        this.onHiding = new EventEmitter();
        /**
         *  Emits an event when the toast is hidden.
         *  Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onHidden)="onHidden($event)"></igx-toast>
         * ```
         * @memberof IgxToastComponent
         */
        this.onHidden = new EventEmitter();
        /**
         * Sets/gets the `role` attribute.
         * If not set, `role` will have value `"alert"`.
         * ```html
         * <igx-toast [role] = "'notify'"></igx-toast>
         * ```
         * ```typescript
         * let toastRole = this.toast.role;
         * ```
         * @memberof IgxToastComponent
         */
        this.role = 'alert';
        /**
         * Sets/gets whether the toast will be hidden after the `displayTime` is over.
         * Default value is `true`.
         * ```html
         * <igx-toast [autoHide] = "false"></igx-toast>
         * ```
         * ```typescript
         * let autoHide = this.toast.autoHide;
         * ```
         * @memberof IgxToastComponent
         */
        this.autoHide = true;
        /**
         * Sets/gets the duration of time span(in milliseconds) which the toast will be visible
         * after it is being shown.
         * Default value is `4000`.
         * ```html
         * <igx-toast [displayTime] = "2500"></igx-toast>
         * ```
         * ```typescript
         * let displayTime = this.toast.displayTime;
         * ```
         * @memberof IgxToastComponent
         */
        this.displayTime = 4000;
        /**
         * @hidden
         */
        this.isVisibleChange = new EventEmitter();
        /**
         * Sets/gets the position of the toast.
         * If not set, the `position` attribute will have value `IgxToastPosition.Bottom`.
         * ```html
         * <igx-toast [position]="top"></igx-toast>
         * ```
         * ```typescript
         * let toastPosition = this.toast.position;
         * ```
         * @memberof IgxToastComponent
         */
        this.position = 'bottom';
        /**
         * @hidden
         * @internal
         */
        this.toastMessage = '';
    }
    /**
     * Enables/Disables the visibility of the toast.
     * If not set, the `isVisible` attribute will have value `false`.
     * ```html
     * <igx-toast [isVisible]="true"></igx-toast>
     * ```
     * ```typescript
     * let isVisible = this.toast.isVisible;
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-toast [(isVisible)]="model.isVisible"></igx-toast>
     * ```
     * @memberof IgxToastComponent
     */
    get isVisible() {
        return this._isVisible;
    }
    set isVisible(value) {
        this._isVisible = value;
        this.isVisibleChange.emit(this._isVisible);
    }
    /**
     * @deprecated Place your message in the toast content instead.
     * Sets/gets the message that will be shown by the toast.
     * ```html
     * <igx-toast [message] = "Notification"></igx-toast>
     * ```
     * ```typescript
     * let toastMessage = this.toast.message;
     * ```
     * @memberof IgxToastComponent
     */
    set message(value) {
        this.toastMessage = value;
    }
    get message() {
        return this.toastMessage;
    }
    /**
     * Gets the nativeElement of the toast.
     * ```typescript
     * let nativeElement = this.toast.element;
     * ```
     * @memberof IgxToastComponent
     */
    get element() {
        return this._element.nativeElement;
    }
    /**
     * Shows the toast.
     * If `autoHide` is enabled, the toast will hide after `displayTime` is over.
     * ```typescript
     * this.toast.show();
     * ```
     * @memberof IgxToastComponent
     */
    show(message) {
        clearInterval(this.timeoutId);
        const overlaySettings = {
            positionStrategy: new GlobalPositionStrategy({
                horizontalDirection: HorizontalAlignment.Center,
                verticalDirection: this.position === 'bottom'
                    ? VerticalAlignment.Bottom
                    : this.position === 'middle'
                        ? VerticalAlignment.Middle
                        : VerticalAlignment.Top,
            }),
            closeOnEscape: false,
            closeOnOutsideClick: false,
            modal: false,
            outlet: this.outlet,
        };
        if (message !== undefined) {
            this.toastMessage = message;
        }
        this.onShowing.emit(this);
        super.open(overlaySettings);
        if (this.autoHide) {
            this.timeoutId = window.setTimeout(() => {
                this.hide();
            }, this.displayTime);
        }
    }
    /**
     * Hides the toast.
     * ```typescript
     * this.toast.hide();
     * ```
     * @memberof IgxToastComponent
     */
    hide() {
        clearInterval(this.timeoutId);
        this.onHiding.emit(this);
        super.close();
    }
    /**
     * Wraps @show() method due @IToggleView interface implementation.
     * @hidden
     */
    open() {
        this.show();
    }
    /**
     * Wraps @hide() method due @IToggleView interface implementation.
     * @hidden
     */
    close() {
        this.hide();
    }
    /**
     * Toggles the visible state of the toast.
     * ```typescript
     * this.toast.toggle();
     * ```
     * @memberof IgxToastComponent
     */
    toggle() {
        super.toggle();
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.onOpened.pipe(takeUntil(this.d$)).subscribe(() => {
            this.onShown.emit(this);
            this.isVisible = true;
        });
        this.onClosed.pipe(takeUntil(this.d$)).subscribe(() => {
            this.onHidden.emit(this);
            this.isVisible = false;
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.d$.next(true);
        this.d$.complete();
    }
}
IgxToastComponent.ɵfac = function IgxToastComponent_Factory(t) { return new (t || IgxToastComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8), ɵngcc0.ɵɵdirectiveInject(IgxOverlayService)); };
IgxToastComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxToastComponent, selectors: [["igx-toast"]], hostVars: 3, hostBindings: function IgxToastComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-toast", ctx.cssClass);
    } }, inputs: { id: "id", role: "role", autoHide: "autoHide", displayTime: "displayTime", position: "position", isVisible: "isVisible", message: "message", outlet: "outlet" }, outputs: { onShowing: "onShowing", onShown: "onShown", onHiding: "onHiding", onHidden: "onHidden", isVisibleChange: "isVisibleChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 3, vars: 1, template: function IgxToastComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "span");
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.toastMessage);
    } }, encapsulation: 2 });
IgxToastComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] }
];
IgxToastComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-toast',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    onShowing: [{ type: Output }],
    onShown: [{ type: Output }],
    onHiding: [{ type: Output }],
    onHidden: [{ type: Output }],
    role: [{ type: Input }],
    autoHide: [{ type: Input }],
    displayTime: [{ type: Input }],
    outlet: [{ type: Input }],
    isVisible: [{ type: Input }],
    isVisibleChange: [{ type: Output }],
    message: [{ type: Input }],
    position: [{ type: Input }]
};
__decorate([
    DeprecateProperty(`'message' property is deprecated.
    You can use place the message in the toast content or pass it as parameter to the show method instead.`)
], IgxToastComponent.prototype, "message", null);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavigationService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavigationToggleDirective, [{
        type: Directive,
        args: [{ selector: '[igxNavToggle]' }]
    }], function () { return [{ type: IgxNavigationService }]; }, { toggleNavigationDrawer: [{
            type: HostListener,
            args: ['click']
        }], target: [{
            type: Input,
            args: ['igxNavToggle']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavigationCloseDirective, [{
        type: Directive,
        args: [{ selector: '[igxNavClose]' }]
    }], function () { return [{ type: IgxNavigationService }]; }, { closeNavigationDrawer: [{
            type: HostListener,
            args: ['click']
        }], target: [{
            type: Input,
            args: ['igxNavClose']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxNavigationModule, { declarations: [IgxNavigationCloseDirective, IgxNavigationToggleDirective], exports: [IgxNavigationCloseDirective, IgxNavigationToggleDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavigationModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                exports: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                providers: [IgxNavigationService]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PlatformUtil, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GridBaseAPIService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridFilteringPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridFiltering',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
const ɵIgxCsvExporterService_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxCsvExporterService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCsvExporterService, [{
        type: Injectable
    }], null, { onExportEnded: [{
            type: Output
        }] }); })();
const ɵIgxExcelExporterService_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxExcelExporterService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelExporterService, [{
        type: Injectable
    }], null, { onExportEnded: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxOverlayService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ApplicationRef }, { type: ɵngcc0.Injector }, { type: ɵngcc1.AnimationBuilder }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.NgZone }, { type: PlatformUtil }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBaseTransactionService, [{
        type: Injectable
    }], function () { return []; }, null); })();
const ɵIgxTransactionService_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxTransactionService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTransactionService, [{
        type: Injectable
    }], null, null); })();
const ɵIgxHierarchicalTransactionService_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxHierarchicalTransactionService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalTransactionService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxToggleDirective, [{
        type: Directive,
        args: [{
                exportAs: 'toggle',
                selector: '[igxToggle]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxOverlayService, decorators: [{
                type: Inject,
                args: [IgxOverlayService]
            }] }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }]; }, { onOpened: [{
            type: Output
        }], onOpening: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], onAppended: [{
            type: Output
        }], hiddenClass: [{
            type: HostBinding,
            args: ['class.igx-toggle--hidden']
        }, {
            type: HostBinding,
            args: ['attr.aria-hidden']
        }], defaultClass: [{
            type: HostBinding,
            args: ['class.igx-toggle']
        }], id: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxToggleActionDirective, [{
        type: Directive,
        args: [{
                exportAs: 'toggle-action',
                selector: '[igxToggleAction]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }]; }, { target: [{
            type: Input,
            args: ['igxToggleAction']
        }], 
    /**
     * @hidden
     */
    onClick: [{
            type: HostListener,
            args: ['click']
        }], overlaySettings: [{
            type: Input
        }], outlet: [{
            type: Input,
            args: ['igxToggleOutlet']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxOverlayOutletDirective, [{
        type: Directive,
        args: [{
                exportAs: 'overlay-outlet',
                selector: '[igxOverlayOutlet]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxToggleModule, { declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective], exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxToggleModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                providers: [IgxNavigationService]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectionAPIService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownGroupComponent, [{
        type: Component,
        args: [{
                selector: 'igx-drop-down-item-group',
                template: `
        <label id="{{labelId}}">{{ label }}</label>
        <ng-content select="igx-drop-down-item"></ng-content>
    `
            }]
    }], function () { return []; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }], groupClass: [{
            type: HostBinding,
            args: ['class.igx-drop-down__group']
        }], disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: [`attr.aria-disabled`]
        }, {
            type: HostBinding,
            args: ['class.igx-drop-down__group--disabled']
        }], labelledBy: [{
            type: HostBinding,
            args: [`attr.aria-labelledby`]
        }], label: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownItemBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDropDownItemBase]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_DROPDOWN_BASE]
            }] }, { type: ɵngcc0.ElementRef }, { type: IgxDropDownGroupComponent, decorators: [{
                type: Optional
            }] }, { type: IgxSelectionAPIService, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [IgxSelectionAPIService]
            }] }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], selectedChange: [{
            type: Output
        }], role: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.role']
        }], index: [{
            type: Input
        }], itemStyle: [{
            type: HostBinding,
            args: ['class.igx-drop-down__item']
        }], itemStyleCosy: [{
            type: HostBinding,
            args: ['class.igx-drop-down__item--cosy']
        }], itemStyleCompact: [{
            type: HostBinding,
            args: ['class.igx-drop-down__item--compact']
        }], selected: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-selected']
        }, {
            type: HostBinding,
            args: ['class.igx-drop-down__item--selected']
        }], focused: [{
            type: HostBinding,
            args: ['class.igx-drop-down__item--focused']
        }], headerClassCosy: [{
            type: HostBinding,
            args: ['class.igx-drop-down__header--cosy']
        }], headerClassCompact: [{
            type: HostBinding,
            args: ['class.igx-drop-down__header--compact']
        }], disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.igx-drop-down__item--disabled']
        }], 
    /**
     * @hidden
     * @internal
     */
    clicked: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], value: [{
            type: Input
        }], isHeader: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-drop-down__header']
        }] }); })();
const ɵIgxDropDownItemComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxDropDownItemComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownItemComponent, [{
        type: Component,
        args: [{
                selector: 'igx-drop-down-item',
                template: "<span class=\"igx-drop-down__inner\"><ng-content></ng-content></span>\n"
            }]
    }], null, { setTabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DisplayDensityBase, [{
        type: Directive,
        args: [{
                selector: '[igxDisplayDensityBase]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { onDensityChanged: [{
            type: Output
        }], displayDensity: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDisplayDensityModule, { declarations: [DisplayDensityBase], exports: [DisplayDensityBase] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDisplayDensityModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    DisplayDensityBase
                ],
                exports: [
                    DisplayDensityBase
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownBaseDirective, [{
        type: Directive
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { onSelection: [{
            type: Output
        }], maxHeight: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['style.maxHeight']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-drop-down']
        }], id: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DisplayContainerComponent, [{
        type: Component,
        args: [{
                selector: 'igx-display-container',
                template: `
        <ng-template
            #display_container
            igxScrollInertia
            [IgxScrollInertiaScrollContainer]="scrollContainer"
            [IgxScrollInertiaDirection]="scrollDirection">
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ViewContainerRef }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class']
        }], notVirtual: [{
            type: HostBinding,
            args: ['class.igx-display-container--inactive']
        }], _vcr: [{
            type: ViewChild,
            args: ['display_container', { read: ViewContainerRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VirtualHelperBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxVirtualHelperBase]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { onScroll: [{
            type: HostListener,
            args: ['scroll', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HVirtualHelperComponent, [{
        type: Component,
        args: [{
                selector: 'igx-horizontal-virtual-helper',
                template: '<div #horizontal_container class="igx-vhelper__placeholder-content" [style.width.px]="size"></div>'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { cssClasses: [{
            type: HostBinding,
            args: ['class']
        }], _vcr: [{
            type: ViewChild,
            args: ['horizontal_container', { read: ViewContainerRef, static: true }]
        }], width: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VirtualHelperComponent, [{
        type: Component,
        args: [{
                selector: 'igx-virtual-helper',
                template: '<div #container class="igx-vhelper__placeholder-content" [style.height.px]="size"></div>'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { cssClasses: [{
            type: HostBinding,
            args: ['class']
        }], scrollWidth: [{
            type: HostBinding,
            args: ['style.width.px']
        }], scrollTop: [{
            type: HostBinding,
            args: ['scrollTop']
        }], _vcr: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef, static: true }]
        }], itemsLength: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxScrollInertiaDirective, [{
        type: Directive,
        args: [{ selector: '[igxScrollInertia]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { wheelStep: [{
            type: Input
        }], inertiaStep: [{
            type: Input
        }], swipeToleranceX: [{
            type: Input
        }], inertiaDeltaY: [{
            type: Input
        }], inertiaDeltaX: [{
            type: Input
        }], inertiaDuration: [{
            type: Input
        }], IgxScrollInertiaDirection: [{
            type: Input
        }], IgxScrollInertiaScrollContainer: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxScrollInertiaModule, { declarations: function () { return [IgxScrollInertiaDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxScrollInertiaDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxScrollInertiaModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxScrollInertiaDirective],
                exports: [IgxScrollInertiaDirective],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxForOfSyncService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxForOfScrollSyncService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxForOfDirective, [{
        type: Directive,
        args: [{ selector: '[igxFor][igxForOf]',
                providers: [IgxForOfScrollSyncService] }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: IgxForOfScrollSyncService }]; }, { igxForScrollOrientation: [{
            type: Input
        }], onChunkLoad: [{
            type: Output
        }], onScrollbarVisibilityChanged: [{
            type: Output
        }], onContentSizeChange: [{
            type: Output
        }], onDataChanged: [{
            type: Output
        }], onBeforeViewDestroyed: [{
            type: Output
        }], onChunkPreload: [{
            type: Output
        }], igxForTotalItemCount: [{
            type: Input
        }], igxForSizePropName: [{
            type: Input
        }], igxForOf: [{
            type: Input
        }], igxForTrackBy: [{
            type: Input
        }], igxForScrollContainer: [{
            type: Input
        }], igxForContainerSize: [{
            type: Input
        }], igxForItemSize: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridForOfDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGridFor][igxGridForOf]'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: IgxForOfScrollSyncService }, { type: IgxForOfSyncService }]; }, { onDataChanging: [{
            type: Output
        }], igxGridForOf: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxForOfModule, { declarations: function () { return [IgxForOfDirective, IgxGridForOfDirective, DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent, VirtualHelperBaseDirective]; }, imports: function () { return [IgxScrollInertiaModule, CommonModule]; }, exports: function () { return [IgxForOfDirective, IgxGridForOfDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxForOfModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxForOfDirective, IgxGridForOfDirective, DisplayContainerComponent, VirtualHelperComponent,
                    HVirtualHelperComponent, VirtualHelperBaseDirective],
                entryComponents: [DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent],
                exports: [IgxForOfDirective, IgxGridForOfDirective],
                imports: [IgxScrollInertiaModule, CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownComponent, [{
        type: Component,
        args: [{
                selector: 'igx-drop-down',
                template: "<div class=\"igx-drop-down__list\" [style.width]=\"width\"\nigxToggle\n(onAppended)=\"onToggleContentAppended()\"\n(onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n(onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <div class=\"igx-drop-down__list-scroll\" #scrollContainer [attr.id]=\"this.listId\" role=\"listbox\"\n    [style.height]=\"height\"\n    [style.maxHeight]=\"maxHeight\">\n        <ng-container *ngIf=\"!collapsed\">\n            <ng-content></ng-content>\n        </ng-container>\n    </div>\n</div>\n",
                providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxDropDownComponent }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxSelectionAPIService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { onOpening: [{
            type: Output
        }], onOpened: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], allowItemsFocus: [{
            type: Input
        }], virtDir: [{
            type: ContentChild,
            args: [IgxForOfDirective, { read: IgxForOfDirective }]
        }], toggleDirective: [{
            type: ViewChild,
            args: [IgxToggleDirective, { static: true }]
        }], scrollContainerRef: [{
            type: ViewChild,
            args: ['scrollContainer', { static: true }]
        }], children: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxDropDownItemComponent), { descendants: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownItemNavigationDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDropDownItemNavigation]'
            }]
    }], function () { return [{ type: IgxDropDownBaseDirective, decorators: [{
                type: Self
            }, {
                type: Optional
            }, {
                type: Inject,
                args: [IGX_DROPDOWN_BASE]
            }] }]; }, { target: [{
            type: Input,
            args: ['igxDropDownItemNavigation']
        }], 
    /**
     * Captures keydown events and calls the appropriate handlers on the target component
     */
    handleKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDropDownModule, { declarations: function () { return [IgxDropDownComponent, IgxDropDownItemBaseDirective, IgxDropDownItemComponent, IgxDropDownGroupComponent, IgxDropDownItemNavigationDirective]; }, imports: function () { return [CommonModule, IgxToggleModule]; }, exports: function () { return [IgxDropDownComponent, IgxDropDownItemComponent, IgxDropDownGroupComponent, IgxDropDownItemNavigationDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxDropDownComponent,
                    IgxDropDownItemBaseDirective,
                    IgxDropDownItemComponent,
                    IgxDropDownGroupComponent,
                    IgxDropDownItemNavigationDirective
                ],
                exports: [
                    IgxDropDownComponent,
                    IgxDropDownItemComponent,
                    IgxDropDownGroupComponent,
                    IgxDropDownItemNavigationDirective
                ],
                imports: [
                    CommonModule,
                    IgxToggleModule
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHintDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-hint,[igxHint]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { isPositionStart: [{
            type: HostBinding,
            args: ['class.igx-input-group__hint-item--start']
        }], isPositionEnd: [{
            type: HostBinding,
            args: ['class.igx-input-group__hint-item--end']
        }], position: [{
            type: Input,
            args: ['position']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxInputDirective, [{
        type: Directive,
        args: [{
                selector: '[igxInput]',
                exportAs: 'igxInput'
            }]
    }], function () { return [{ type: IgxInputGroupBase }, { type: ɵngcc3.NgModel, decorators: [{
                type: Optional
            }, {
                type: Self
            }, {
                type: Inject,
                args: [NgModel]
            }] }, { type: ɵngcc3.FormControlName, decorators: [{
                type: Optional
            }, {
                type: Self
            }, {
                type: Inject,
                args: [FormControlName]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { isInput: [{
            type: HostBinding,
            args: ['class.igx-input-group__input']
        }], isTextArea: [{
            type: HostBinding,
            args: ['class.igx-input-group__textarea']
        }], value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], required: [{
            type: Input
        }], 
    /**
     * @hidden
     * @internal
     */
    onFocus: [{
            type: HostListener,
            args: ['focus', ['$event']]
        }], 
    /**
     * @param event The event to invoke the handler
     *
     * @hidden
     * @internal
     */
    onBlur: [{
            type: HostListener,
            args: ['blur', ['$event']]
        }], 
    /**
     * @hidden
     * @internal
     */
    onInput: [{
            type: HostListener,
            args: ['input']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxLabelDirective, [{
        type: Directive,
        args: [{
                selector: '[igxLabel]'
            }]
    }], function () { return []; }, { defaultClass: [{
            type: HostBinding,
            args: ['class.igx-input-group__label']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxPrefixDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-prefix,[igxPrefix]'
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxPrefixModule, { declarations: [IgxPrefixDirective], exports: [IgxPrefixDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxPrefixModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxPrefixDirective],
                exports: [IgxPrefixDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSuffixDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-suffix,[igxSuffix]'
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxSuffixModule, { declarations: [IgxSuffixDirective], exports: [IgxSuffixDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSuffixModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxSuffixDirective],
                exports: [IgxSuffixDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxInputGroupComponent, [{
        type: Component,
        args: [{
                selector: 'igx-input-group',
                template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n\n<div class=\"igx-input-group__hint\" (click)=\"hintClickHandler($event)\">\n    <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n</div>\n\n<ng-template #label>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #input>\n    <ng-content select=\"[igxInput]\"></ng-content>\n</ng-template>\n\n<ng-template #prefix>\n    <ng-content select=\"igx-prefix, [igxPrefix]\"></ng-content>\n</ng-template>\n\n<ng-template #suffix>\n    <ng-content select=\"igx-suffix, [igxSuffix]\"></ng-content>\n</ng-template>\n\n<ng-template #materialBundle>\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #fluentBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bootstrapBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bundle>\n    <ng-container [ngSwitch]=\"theme\">\n        <ng-container *ngSwitchCase=\"'bootstrap'\">\n            <ng-container *ngTemplateOutlet=\"bootstrapBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'fluent'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'indigo-design'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"materialBundle\"></ng-container>\n        </ng-container>\n    </ng-container>\n</ng-template>\n",
                providers: [
                    { provide: IgxInputGroupBase, useExisting: IgxInputGroupComponent }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [IGX_INPUT_GROUP_TYPE]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], defaultClass: [{
            type: HostBinding,
            args: ['class.igx-input-group']
        }], hasPlaceholder: [{
            type: HostBinding,
            args: ['class.igx-input-group--placeholder']
        }], isRequired: [{
            type: HostBinding,
            args: ['class.igx-input-group--required']
        }], isFocused: [{
            type: HostBinding,
            args: ['class.igx-input-group--focused']
        }], disabled: [{
            type: HostBinding,
            args: ['class.igx-input-group--disabled']
        }, {
            type: Input
        }], suppressInputAutofocus: [{
            type: Input
        }], hasWarning: [{
            type: HostBinding,
            args: ['class.igx-input-group--warning']
        }], validClass: [{
            type: HostBinding,
            args: ['class.igx-input-group--valid']
        }], invalidClass: [{
            type: HostBinding,
            args: ['class.igx-input-group--invalid']
        }], isFilled: [{
            type: HostBinding,
            args: ['class.igx-input-group--filled']
        }], isDisplayDensityCosy: [{
            type: HostBinding,
            args: ['class.igx-input-group--cosy']
        }], isDisplayDensityComfortable: [{
            type: HostBinding,
            args: ['class.igx-input-group--comfortable']
        }], isDisplayDensityCompact: [{
            type: HostBinding,
            args: ['class.igx-input-group--compact']
        }], 
    /** @hidden */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], 
    /** @hidden */
    onPointerDown: [{
            type: HostListener,
            args: ['pointerdown', ['$event']]
        }], type: [{
            type: Input,
            args: ['type']
        }], supressInputAutofocus: [{
            type: Input
        }], isTypeBox: [{
            type: HostBinding,
            args: ['class.igx-input-group--box']
        }], isTypeBorder: [{
            type: HostBinding,
            args: ['class.igx-input-group--border']
        }], isTypeFluent: [{
            type: HostBinding,
            args: ['class.igx-input-group--fluent']
        }], isTypeBootstrap: [{
            type: HostBinding,
            args: ['class.igx-input-group--bootstrap']
        }], isTypeIndigo: [{
            type: HostBinding,
            args: ['class.igx-input-group--indigo']
        }], isTypeSearch: [{
            type: HostBinding,
            args: ['class.igx-input-group--search']
        }], hints: [{
            type: ContentChildren,
            args: [IgxHintDirective, { read: IgxHintDirective }]
        }], input: [{
            type: ContentChild,
            args: [IgxInputDirective, { read: IgxInputDirective, static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxInputGroupModule, { declarations: function () { return [IgxInputGroupComponent, IgxHintDirective, IgxInputDirective, IgxLabelDirective]; }, imports: function () { return [CommonModule, IgxPrefixModule, IgxSuffixModule]; }, exports: function () { return [IgxInputGroupComponent, IgxHintDirective, IgxInputDirective, IgxLabelDirective, IgxPrefixModule, IgxSuffixModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxInputGroupModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxInputGroupComponent,
                    IgxHintDirective,
                    IgxInputDirective,
                    IgxLabelDirective,
                ],
                exports: [
                    IgxInputGroupComponent,
                    IgxHintDirective,
                    IgxInputDirective,
                    IgxLabelDirective,
                    IgxPrefixModule,
                    IgxSuffixModule,
                ],
                imports: [CommonModule, IgxPrefixModule, IgxSuffixModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxAutocompleteDirective, [{
        type: Directive,
        args: [{
                selector: '[igxAutocomplete]'
            }]
    }], function () { return [{ type: ɵngcc3.NgModel, decorators: [{
                type: Self
            }, {
                type: Optional
            }, {
                type: Inject,
                args: [NgModel]
            }] }, { type: ɵngcc3.FormControlName, decorators: [{
                type: Self
            }, {
                type: Optional
            }, {
                type: Inject,
                args: [FormControlName]
            }] }, { type: IgxInputGroupComponent, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { disabled: [{
            type: Input,
            args: ['igxAutocompleteDisabled']
        }], onItemSelected: [{
            type: Output
        }], autofill: [{
            type: HostBinding,
            args: ['attr.autocomplete']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], target: [{
            type: Input,
            args: ['igxAutocomplete']
        }], ariaExpanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], hasPopUp: [{
            type: HostBinding,
            args: ['attr.aria-haspopup']
        }], ariaOwns: [{
            type: HostBinding,
            args: ['attr.aria-owns']
        }], ariaActiveDescendant: [{
            type: HostBinding,
            args: ['attr.aria-activedescendant']
        }], ariaAutocomplete: [{
            type: HostBinding,
            args: ['attr.aria-autocomplete']
        }], 
    /** @hidden  @internal */
    onInput: [{
            type: HostListener,
            args: ['input']
        }], 
    /** @hidden  @internal */
    onArrowDown: [{
            type: HostListener,
            args: ['keydown.ArrowDown', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.Alt.ArrowDown', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.ArrowUp', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.Alt.ArrowUp', ['$event']]
        }], 
    /** @hidden  @internal */
    onTab: [{
            type: HostListener,
            args: ['keydown.Tab']
        }, {
            type: HostListener,
            args: ['keydown.Shift.Tab']
        }], autocompleteSettings: [{
            type: Input,
            args: ['igxAutocompleteSettings']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxAutocompleteModule, { declarations: function () { return [IgxAutocompleteDirective]; }, imports: function () { return [IgxDropDownModule, CommonModule]; }, exports: function () { return [IgxAutocompleteDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxAutocompleteModule, [{
        type: NgModule,
        args: [{
                imports: [IgxDropDownModule, CommonModule],
                declarations: [IgxAutocompleteDirective],
                exports: [IgxAutocompleteDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxButtonDirective, [{
        type: Directive,
        args: [{
                selector: '[igxButton]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { buttonClick: [{
            type: Output
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], selected: [{
            type: Input
        }], type: [{
            type: Input,
            args: ['igxButton']
        }], color: [{
            type: Input,
            args: ['igxButtonColor']
        }], background: [{
            type: Input,
            args: ['igxButtonBackground']
        }], label: [{
            type: Input,
            args: ['igxLabel']
        }], disabled: [{
            type: Input
        }], cssClassCosy: [{
            type: HostBinding,
            args: ['class.igx-button--cosy']
        }], cssClassCompact: [{
            type: HostBinding,
            args: ['class.igx-button--compact']
        }], cssClassCosyFab: [{
            type: HostBinding,
            args: ['class.igx-button--fab-cosy']
        }], cssClassCompactFab: [{
            type: HostBinding,
            args: ['class.igx-button--fab-compact']
        }], disabledAttribute: [{
            type: HostBinding,
            args: ['attr.disabled']
        }], 
    /**
     * @hidden
     * @internal
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxButtonModule, { declarations: [IgxButtonDirective], exports: [IgxButtonDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxButtonModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxButtonDirective],
                exports: [IgxButtonDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDividerDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-divider'
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], _inset: [{
            type: Input,
            args: ['inset']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }], type: [{
            type: HostBinding,
            args: ['class.igx-divider']
        }, {
            type: Input
        }], middle: [{
            type: HostBinding,
            args: ['class.igx-divider--inset']
        }, {
            type: Input
        }], vertical: [{
            type: HostBinding,
            args: ['class.igx-divider--vertical']
        }, {
            type: Input
        }], isDashed: [{
            type: HostBinding,
            args: ['class.igx-divider--dashed']
        }], inset: [{
            type: HostBinding,
            args: ['style.margin']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDividerModule, { declarations: [IgxDividerDirective], exports: [IgxDividerDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDividerModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxDividerDirective],
                exports: [IgxDividerDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDragHandleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDragHandle]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { baseClass: [{
            type: HostBinding,
            args: ['class.igx-drag__handle']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDragIgnoreDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDragIgnore]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { baseClass: [{
            type: HostBinding,
            args: ['class.igx-drag__ignore']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDragDirective, [{
        type: Directive,
        args: [{
                exportAs: 'drag',
                selector: '[igxDrag]'
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { dragTolerance: [{
            type: Input
        }], dragDirection: [{
            type: Input
        }], ghost: [{
            type: Input
        }], ghostClass: [{
            type: Input
        }], dragStart: [{
            type: Output
        }], dragMove: [{
            type: Output
        }], dragEnd: [{
            type: Output
        }], dragClick: [{
            type: Output
        }], ghostCreate: [{
            type: Output
        }], ghostDestroy: [{
            type: Output
        }], transitioned: [{
            type: Output
        }], baseClass: [{
            type: HostBinding,
            args: ['class.igx-drag']
        }], selectDisabled: [{
            type: HostBinding,
            args: ['class.igx-drag--select-disabled']
        }], ghostOffsetX: [{
            type: Input
        }], ghostOffsetY: [{
            type: Input
        }], data: [{
            type: Input,
            args: ['igxDrag']
        }], dragChannel: [{
            type: Input
        }], ghostTemplate: [{
            type: Input
        }], ghostHost: [{
            type: Input
        }], dragHandles: [{
            type: ContentChildren,
            args: [IgxDragHandleDirective, { descendants: true }]
        }], dragIgnoredElems: [{
            type: ContentChildren,
            args: [IgxDragIgnoreDirective, { descendants: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDirective, [{
        type: Directive,
        args: [{
                exportAs: 'drop',
                selector: '[igxDrop]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { enter: [{
            type: Output
        }], over: [{
            type: Output
        }], leave: [{
            type: Output
        }], dropped: [{
            type: Output
        }], droppable: [{
            type: HostBinding,
            args: ['attr.droppable']
        }], dragover: [{
            type: HostBinding,
            args: ['class.dragOver']
        }], _data: [{
            type: Input,
            args: ['igxDrop']
        }], dropStrategy: [{
            type: Input
        }], 
    /**
     * @hidden
     */
    onDragDrop: [{
            type: HostListener,
            args: ['igxDrop', ['$event']]
        }], dropChannel: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDragDropModule, { declarations: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective], exports: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDragDropModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective],
                exports: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFilterDirective, [{
        type: Directive,
        args: [{
                selector: '[igxFilter]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { filtering: [{
            type: Output
        }], filtered: [{
            type: Output
        }], filterOptions: [{
            type: Input,
            args: ['igxFilter']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFilterPipe, [{
        type: Pipe,
        args: [{
                name: 'igxFilter',
                pure: false
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxFilterModule, { declarations: function () { return [IgxFilterDirective, IgxFilterPipe]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxFilterDirective, IgxFilterPipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFilterModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxFilterDirective, IgxFilterPipe],
                exports: [IgxFilterDirective, IgxFilterPipe],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFocusDirective, [{
        type: Directive,
        args: [{
                exportAs: 'igxFocus',
                selector: '[igxFocus]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: Array, decorators: [{
                type: Inject,
                args: [NG_VALUE_ACCESSOR]
            }, {
                type: Self
            }, {
                type: Optional
            }] }]; }, { focused: [{
            type: Input,
            args: ['igxFocus']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxFocusModule, { declarations: [IgxFocusDirective], exports: [IgxFocusDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFocusModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxFocusDirective],
                exports: [IgxFocusDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxLayoutDirective, [{
        type: Directive,
        args: [{
                selector: '[igxLayout]'
            }]
    }], function () { return []; }, { dir: [{
            type: Input,
            args: ['igxLayoutDir']
        }], reverse: [{
            type: Input,
            args: ['igxLayoutReverse']
        }], wrap: [{
            type: Input,
            args: ['igxLayoutWrap']
        }], justify: [{
            type: Input,
            args: ['igxLayoutJustify']
        }], itemAlign: [{
            type: Input,
            args: ['igxLayoutItemAlign']
        }], display: [{
            type: HostBinding,
            args: ['style.display']
        }], flexwrap: [{
            type: HostBinding,
            args: ['style.flex-wrap']
        }], justifycontent: [{
            type: HostBinding,
            args: ['style.justify-content']
        }], align: [{
            type: HostBinding,
            args: ['style.align-items']
        }], direction: [{
            type: HostBinding,
            args: ['style.flex-direction']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFlexDirective, [{
        type: Directive,
        args: [{
                selector: '[igxFlex]'
            }]
    }], function () { return []; }, { grow: [{
            type: Input,
            args: ['igxFlexGrow']
        }], shrink: [{
            type: Input,
            args: ['igxFlexShrink']
        }], flex: [{
            type: Input,
            args: ['igxFlex']
        }], order: [{
            type: Input,
            args: ['igxFlexOrder']
        }], basis: [{
            type: Input,
            args: ['igxFlexBasis']
        }], style: [{
            type: HostBinding,
            args: ['style.flex']
        }], itemorder: [{
            type: HostBinding,
            args: ['style.order']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxLayoutModule, { declarations: [IgxFlexDirective, IgxLayoutDirective], exports: [IgxFlexDirective, IgxLayoutDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxLayoutModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxFlexDirective, IgxLayoutDirective],
                exports: [IgxFlexDirective, IgxLayoutDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MaskParsingService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMaskDirective, [{
        type: Directive,
        args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxMaskDirective, multi: true }],
                selector: '[igxMask]',
                exportAs: 'igxMask'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MaskParsingService }, { type: ɵngcc0.Renderer2 }]; }, { promptChar: [{
            type: Input
        }], onValueChange: [{
            type: Output
        }], 
    /** @hidden */
    onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], 
    /** @hidden */
    onInputChanged: [{
            type: HostListener,
            args: ['input']
        }], 
    /** @hidden */
    onPaste: [{
            type: HostListener,
            args: ['paste']
        }], 
    /** @hidden */
    onFocus: [{
            type: HostListener,
            args: ['focus']
        }], 
    /** @hidden */
    onBlur: [{
            type: HostListener,
            args: ['blur', ['$event.target.value']]
        }], 
    /** @hidden */
    onDragEnter: [{
            type: HostListener,
            args: ['dragenter']
        }], 
    /** @hidden */
    onDragLeave: [{
            type: HostListener,
            args: ['dragleave']
        }], 
    /** @hidden */
    onDrop: [{
            type: HostListener,
            args: ['drop', ['$event']]
        }], mask: [{
            type: Input,
            args: ['igxMask']
        }], includeLiterals: [{
            type: Input
        }], displayValuePipe: [{
            type: Input
        }], focusedValuePipe: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxMaskModule, { declarations: function () { return [IgxMaskDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxMaskDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMaskModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxMaskDirective],
                exports: [IgxMaskDirective],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRadioComponent, [{
        type: Component,
        args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxRadioComponent, multi: true }],
                selector: 'igx-radio',
                template: "<input #radio class=\"igx-radio__input\" type=\"radio\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (click)=\"_onRadioClick($event)\"\n    (change)=\"_onRadioChange($event)\"\n    (focus)=\"onFocus()\"\n    (blur)=\"onBlur()\" />\n\n<label #nativeLabel class=\"igx-radio__composite\" igxRipple\n    igxRippleTarget=\".igx-radio__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    [for]=\"inputId\">\n    <div class=\"igx-radio__ripple\"></div>\n</label>\n\n<span #placeholderLabel\n    [id]=\"labelId\"\n    [class]=\"labelClass\"\n    (click)=\"_onLabelClick()\">\n    <ng-content></ng-content>\n</span>\n"
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], labelId: [{
            type: Input
        }], labelPosition: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], disableRipple: [{
            type: Input
        }], required: [{
            type: Input
        }], ariaLabelledBy: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], change: [{
            type: Output
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-radio']
        }], checked: [{
            type: HostBinding,
            args: ['class.igx-radio--checked']
        }, {
            type: Input
        }], disabled: [{
            type: HostBinding,
            args: ['class.igx-radio--disabled']
        }, {
            type: Input
        }], focused: [{
            type: HostBinding,
            args: ['class.igx-radio--focused']
        }], nativeRadio: [{
            type: ViewChild,
            args: ['radio', { static: true }]
        }], nativeLabel: [{
            type: ViewChild,
            args: ['nativeLabel', { static: true }]
        }], placeholderLabel: [{
            type: ViewChild,
            args: ['placeholderLabel', { static: true }]
        }], value: [{
            type: Input
        }], name: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRippleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRipple]'
            }]
    }], function () { return [{ type: ɵngcc1.AnimationBuilder }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { rippleTarget: [{
            type: Input,
            args: ['igxRippleTarget']
        }], rippleDuration: [{
            type: Input,
            args: ['igxRippleDuration']
        }], rippleDisabled: [{
            type: Input,
            args: ['igxRippleDisabled']
        }], centered: [{
            type: Input,
            args: ['igxRippleCentered']
        }], 
    /**
     * @hidden
     */
    onMouseDown: [{
            type: HostListener,
            args: ['mousedown', ['$event']]
        }], rippleColor: [{
            type: Input,
            args: ['igxRipple']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxRippleModule, { declarations: [IgxRippleDirective], exports: [IgxRippleDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRippleModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxRippleDirective],
                exports: [IgxRippleDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRadioGroupDirective, [{
        type: Directive,
        args: [{
                exportAs: 'igxRadioGroup',
                selector: 'igx-radio-group, [igxRadioGroup]',
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxRadioGroupDirective, multi: true }]
            }]
    }], function () { return []; }, { change: [{
            type: Output
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-radio-group']
        }], value: [{
            type: Input
        }], name: [{
            type: Input
        }], required: [{
            type: Input
        }], disabled: [{
            type: Input
        }], labelPosition: [{
            type: Input
        }], selected: [{
            type: Input
        }], radioButtons: [{
            type: ContentChildren,
            args: [IgxRadioComponent, { descendants: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxRadioModule, { declarations: [IgxRadioGroupDirective, IgxRadioComponent], imports: [IgxRippleModule], exports: [IgxRadioGroupDirective, IgxRadioComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRadioModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxRadioGroupDirective, IgxRadioComponent],
                exports: [IgxRadioGroupDirective, IgxRadioComponent],
                imports: [IgxRippleModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTextHighlightDirective, [{
        type: Directive,
        args: [{
                selector: '[igxTextHighlight]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { groupName: [{
            type: Input,
            args: ['groupName']
        }], value: [{
            type: Input,
            args: ['value']
        }], cssClass: [{
            type: Input,
            args: ['cssClass']
        }], activeCssClass: [{
            type: Input,
            args: ['activeCssClass']
        }], containerClass: [{
            type: Input,
            args: ['containerClass']
        }], row: [{
            type: Input,
            args: ['row']
        }], column: [{
            type: Input,
            args: ['column']
        }], metadata: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTextHighlightModule, { declarations: [IgxTextHighlightDirective], exports: [IgxTextHighlightDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTextHighlightModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxTextHighlightDirective],
                exports: [IgxTextHighlightDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTextSelectionDirective, [{
        type: Directive,
        args: [{
                exportAs: 'igxTextSelection',
                selector: '[igxTextSelection]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { selected: [{
            type: Input,
            args: ['igxTextSelection']
        }], 
    /**
     * @hidden
     */
    onFocus: [{
            type: HostListener,
            args: ['focus']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTextSelectionModule, { declarations: [IgxTextSelectionDirective], exports: [IgxTextSelectionDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTextSelectionModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxTextSelectionDirective],
                exports: [IgxTextSelectionDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTooltipTargetDirective, [{
        type: Directive,
        args: [{
                exportAs: 'tooltipTarget',
                selector: '[igxTooltipTarget]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }]; }, { showDelay: [{
            type: Input,
            args: ['showDelay']
        }], hideDelay: [{
            type: Input,
            args: ['hideDelay']
        }], tooltipDisabled: [{
            type: Input,
            args: ['tooltipDisabled']
        }], onTooltipShow: [{
            type: Output
        }], onTooltipHide: [{
            type: Output
        }], target: [{
            type: Input,
            args: ['igxTooltipTarget']
        }], 
    /**
     * @hidden
     */
    onClick: [{
            type: HostListener,
            args: ['click']
        }], 
    /**
     * @hidden
     */
    onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], 
    /**
     * @hidden
     */
    onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], 
    /**
     * @hidden
     */
    onTouchStart: [{
            type: HostListener,
            args: ['touchstart', ['$event']]
        }], 
    /**
     * @hidden
     */
    onDocumentTouchStart: [{
            type: HostListener,
            args: ['document:touchstart', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTooltipDirective, [{
        type: Directive,
        args: [{
                exportAs: 'tooltip',
                selector: '[igxTooltip]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxOverlayService, decorators: [{
                type: Inject,
                args: [IgxOverlayService]
            }] }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], hiddenClass: [{
            type: HostBinding,
            args: ['class.igx-tooltip--hidden']
        }], defaultClass: [{
            type: HostBinding,
            args: ['class.igx-tooltip--desktop']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], context: [{
            type: Input,
            args: ['context']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTooltipModule, { declarations: function () { return [IgxTooltipDirective, IgxTooltipTargetDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxTooltipDirective, IgxTooltipTargetDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTooltipModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxTooltipDirective, IgxTooltipTargetDirective],
                exports: [IgxTooltipDirective, IgxTooltipTargetDirective],
                imports: [CommonModule],
                providers: [IgxOverlayService]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateTimeEditorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDateTimeEditor]',
                exportAs: 'igxDateTimeEditor',
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: IgxDateTimeEditorDirective, multi: true },
                    { provide: NG_VALIDATORS, useExisting: IgxDateTimeEditorDirective, multi: true }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: MaskParsingService }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, { isSpinLoop: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], validationFailed: [{
            type: Output
        }], locale: [{
            type: Input
        }], minValue: [{
            type: Input
        }], maxValue: [{
            type: Input
        }], inputFormat: [{
            type: Input,
            args: [`igxDateTimeEditor`]
        }], value: [{
            type: Input
        }], displayFormat: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDateTimeEditorModule, { declarations: [IgxDateTimeEditorDirective], exports: [IgxDateTimeEditorDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateTimeEditorModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxDateTimeEditorDirective],
                exports: [IgxDateTimeEditorDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridActionButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igx-grid-action-button',
                template: "<ng-container *ngIf=\"!asMenuItem\">\n\n    <ng-container *ngIf=\"!asMenuItem\">\n        <button igxButton=\"icon\" igxRipple (click)=\"handleClick($event)\" (mousedown)=\"preventEvent($event)\">\n            <igx-icon *ngIf=\"iconSet\" [fontSet]=\"iconSet\" [name]=\"iconName\">{{iconName}}</igx-icon>\n            <igx-icon *ngIf=\"!iconSet\" >{{iconName}}</igx-icon>\n        </button>\n    </ng-container>\n\n    <ng-container *ngIf=\"asMenuItem\">\n        <div #container [className]='containerClass'>\n            <igx-icon *ngIf=\"iconSet\" [fontSet]=\"iconSet\" [name]=\"iconName\">{{iconName}}</igx-icon>\n            <igx-icon *ngIf=\"!iconSet\" >{{iconName}}</igx-icon>\n            <label *ngIf='asMenuItem' igxLabel>{{labelText}}</label>\n        </div>\n    </ng-container>\n</ng-container>\n"
            }]
    }], function () { return []; }, { onActionClick: [{
            type: Output
        }], asMenuItem: [{
            type: Input
        }], container: [{
            type: ViewChild,
            args: ['container']
        }], templateRef: [{
            type: ViewChild,
            args: [TemplateRef]
        }], iconName: [{
            type: Input
        }], classNames: [{
            type: Input
        }], iconSet: [{
            type: Input
        }], labelText: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCheckboxComponent, [{
        type: Component,
        args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxCheckboxComponent, multi: true }],
                selector: 'igx-checkbox',
                preserveWhitespaces: false,
                template: "<input #checkbox class=\"igx-checkbox__input\"\n    type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [indeterminate]=\"indeterminate\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onCheckboxChange($event)\"\n    (click)=\"_onCheckboxClick($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<div\n    igxRipple\n    igxRippleTarget=\".igx-checkbox__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    class=\"igx-checkbox__composite-wrapper\"\n>\n    <label #label class=\"igx-checkbox__composite\"\n        [attr.for]=\"inputId\">\n        <svg class=\"igx-checkbox__composite-mark\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n            <path d=\"M4.1,12.7 9,17.6 20.3,6.3\" />\n        </svg>\n    </label>\n\n    <div class=\"igx-checkbox__ripple\"></div>\n</div>\n\n<span #placeholderLabel\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick($event)\">\n    <ng-content></ng-content>\n</span>\n"
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], labelId: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], labelPosition: [{
            type: Input
        }], disableRipple: [{
            type: Input
        }], required: [{
            type: Input
        }], ariaLabelledBy: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], change: [{
            type: Output
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-checkbox']
        }], focused: [{
            type: HostBinding,
            args: ['class.igx-checkbox--focused']
        }], indeterminate: [{
            type: HostBinding,
            args: ['class.igx-checkbox--indeterminate']
        }, {
            type: Input
        }], checked: [{
            type: HostBinding,
            args: ['class.igx-checkbox--checked']
        }, {
            type: Input
        }], disabled: [{
            type: HostBinding,
            args: ['class.igx-checkbox--disabled']
        }, {
            type: Input
        }], readonly: [{
            type: Input
        }], disableTransitions: [{
            type: HostBinding,
            args: ['class.igx-checkbox--plain']
        }, {
            type: Input
        }], nativeCheckbox: [{
            type: ViewChild,
            args: ['checkbox', { static: true }]
        }], nativeLabel: [{
            type: ViewChild,
            args: ['label', { static: true }]
        }], placeholderLabel: [{
            type: ViewChild,
            args: ['placeholderLabel', { static: true }]
        }], value: [{
            type: Input
        }], name: [{
            type: Input
        }] }); })();
const ɵIgxCheckboxRequiredDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxCheckboxRequiredDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCheckboxRequiredDirective, [{
        type: Directive,
        args: [{
                selector: `igx-checkbox[required][formControlName],
    igx-checkbox[required][formControl],
    igx-checkbox[required][ngModel]`,
                providers: [IGX_CHECKBOX_REQUIRED_VALIDATOR]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxCheckboxModule, { declarations: [IgxCheckboxComponent, IgxCheckboxRequiredDirective], imports: [IgxRippleModule], exports: [IgxCheckboxComponent, IgxCheckboxRequiredDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCheckboxModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                exports: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                imports: [IgxRippleModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridCRUDService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSelectionService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowBaseComponent]'
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: IgxGridCRUDService }, { type: IgxGridSelectionService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { onAnimationEnd: [{
            type: Output
        }], disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.igx-grid__tr--disabled']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], rowData: [{
            type: Input
        }], addRow: [{
            type: Input
        }], rowHeight: [{
            type: HostBinding,
            args: ['style.min-height.px']
        }], dataRowIndex: [{
            type: HostBinding,
            args: ['attr.data-rowIndex']
        }], styleClasses: [{
            type: HostBinding,
            args: ['class']
        }], selected: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-selected']
        }], 
    /**
     * @hidden
     * @internal
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], 
    /**
     * @hidden
     * @internal
     */
    showActionStrip: [{
            type: HostListener,
            args: ['mouseenter', ['$event']]
        }], index: [{
            type: Input
        }], gridID: [{
            type: Input
        }], virtDirRow: [{
            type: ViewChild,
            args: ['igxDirRef', { read: IgxGridForOfDirective }]
        }], checkboxElement: [{
            type: ViewChild,
            args: [forwardRef(() => IgxCheckboxComponent), { read: IgxCheckboxComponent }]
        }], _cells: [{
            type: ViewChildren,
            args: ['cell']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxIconService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc4.DomSanitizer }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridActionsBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGridActionsBase]'
            }]
    }], function () { return [{ type: IgxIconService }, { type: ɵngcc0.IterableDiffers }]; }, { asMenuItems: [{
            type: Input
        }], buttons: [{
            type: ViewChildren,
            args: [IgxGridActionButtonComponent]
        }] }); })();
const ɵIgxGridEditingActionsComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxGridEditingActionsComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridEditingActionsComponent, [{
        type: Component,
        args: [{
                selector: 'igx-grid-editing-actions',
                template: "\n<ng-container *ngIf=\"isRowContext\">\n    <igx-grid-action-button *ngIf=\"!disabled\" [asMenuItem]=\"asMenuItems\" iconName=\"edit\" [labelText]=\"grid.resourceStrings.igx_grid_actions_edit_label\" (onActionClick)=\"startEdit($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"addRow && isRootRow\" [asMenuItem]=\"asMenuItems\" iconName=\"add-row\" iconSet=\"imx-icons\" [labelText]=\"grid.resourceStrings.igx_grid_actions_add_label\" (onActionClick)=\"addRowHandler($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"addChild && hasChildren\" [asMenuItem]=\"asMenuItems\" iconName=\"add-child\" iconSet=\"imx-icons\" [labelText]=\"grid.resourceStrings.igx_grid_actions_add_child_label\" (onActionClick)=\"addRowHandler($event, true)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"!disabled\" class=\"igx-action-strip__delete\" classNames='igx-action-strip__menu-item--danger' [asMenuItem]=\"asMenuItems\" iconName=\"delete\" [labelText]=\"grid.resourceStrings.igx_grid_actions_delete_label\" (onActionClick)=\"deleteRow($event)\"></igx-grid-action-button>\n</ng-container>\n\n",
                providers: [{ provide: IgxGridActionsBaseDirective, useExisting: IgxGridEditingActionsComponent }]
            }]
    }], null, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-action-strip__editing-actions']
        }], addChild: [{
            type: Input
        }], addRow: [{
            type: Input
        }] }); })();
const ɵIgxGridPinningActionsComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxGridPinningActionsComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridPinningActionsComponent, [{
        type: Component,
        args: [{
                selector: 'igx-grid-pinning-actions',
                template: "<ng-container *ngIf=\"isRowContext\">\n    <igx-grid-action-button *ngIf=\"inPinnedArea && pinnedTop\" [asMenuItem]=\"asMenuItems\" iconSet=\"imx-icons\" iconName=\"jump-down\" [labelText]=\"grid.resourceStrings.igx_grid_actions_jumpDown_label\" (onActionClick)=\"scrollToRow($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"inPinnedArea && !pinnedTop\" [asMenuItem]=\"asMenuItems\" iconSet=\"imx-icons\" iconName=\"jump-up\" [labelText]=\"grid.resourceStrings.igx_grid_actions_jumpUp_label\" (onActionClick)=\"scrollToRow($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"!pinned\" [asMenuItem]=\"asMenuItems\" iconSet=\"imx-icons\" iconName=\"pin-left\" [labelText]=\"grid.resourceStrings.igx_grid_actions_pin_label\" (onActionClick)=\"pin($event)\"></igx-grid-action-button>\n    <igx-grid-action-button *ngIf=\"pinned\" [asMenuItem]=\"asMenuItems\" iconSet=\"imx-icons\" iconName=\"unpin-left\" [labelText]=\"grid.resourceStrings.igx_grid_actions_unpin_label\" (onActionClick)=\"unpin($event)\"></igx-grid-action-button>\n</ng-container>",
                providers: [{ provide: IgxGridActionsBaseDirective, useExisting: IgxGridPinningActionsComponent }]
            }]
    }], null, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-action-strip__pinning-actions']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxActionStripMenuItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxActionStripMenuItem]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxActionStripComponent, [{
        type: Component,
        args: [{
                selector: 'igx-action-strip',
                template: "<div class=\"igx-action-strip__actions\">\n    <ng-content #content></ng-content>\n    <ng-container *ngIf=\"menuItems.length > 0\">\n        <button\n            igxButton=\"icon\"\n            igxRipple\n            [igxToggleAction]=\"dropdown\"\n            [overlaySettings]=\"menuOverlaySettings\"\n            (click)=\"$event.stopPropagation()\"\n            [igxDropDownItemNavigation]=\"dropdown\"\n        >\n            <igx-icon>more_vert</igx-icon>\n        </button>\n    </ng-container>\n    <igx-drop-down #dropdown [displayDensity]=\"displayDensity\">\n        <igx-drop-down-item\n            *ngFor=\"let item of menuItems\"\n            class=\"igx-action-strip__menu-item\"\n        >\n            <div class=\"igx-drop-down__item-template\">\n                <ng-container\n                    *ngTemplateOutlet=\"\n                        item.templateRef;\n                        context: { $implicit: item }\n                    \"\n                ></ng-container>\n            </div>\n        </igx-drop-down-item>\n    </igx-drop-down>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: ɵngcc0.ChangeDetectorRef }]; }, { display: [{
            type: HostBinding,
            args: ['style.display']
        }], hidden: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['attr.class']
        }], context: [{
            type: Input
        }], hostClass: [{
            type: Input,
            args: ['class']
        }], _menuItems: [{
            type: ContentChildren,
            args: [IgxActionStripMenuItemDirective]
        }], actionButtons: [{
            type: ContentChildren,
            args: [IgxGridActionsBaseDirective]
        }], menu: [{
            type: ViewChild,
            args: ['dropdown']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxIconComponent, [{
        type: Component,
        args: [{
                selector: 'igx-icon',
                template: "<ng-template #noLigature></ng-template>\n\n<ng-template #explicitLigature>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #svgImage>\n    <svg>\n        <use [attr.href]=\"getSvgKey\"></use>\n    </svg>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: IgxIconService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-icon']
        }], ariaHidden: [{
            type: HostBinding,
            args: ['attr.aria-hidden']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], active: [{
            type: Input,
            args: ['isActive']
        }], font: [{
            type: Input,
            args: ['fontSet']
        }], getInactive: [{
            type: HostBinding,
            args: ['class.igx-icon--inactive']
        }], getIconColor: [{
            type: HostBinding,
            args: ['style.color']
        }], noLigature: [{
            type: ViewChild,
            args: ['noLigature', { read: TemplateRef, static: true }]
        }], explicitLigature: [{
            type: ViewChild,
            args: ['explicitLigature', { read: TemplateRef, static: true }]
        }], svgImage: [{
            type: ViewChild,
            args: ['svgImage', { read: TemplateRef, static: true }]
        }], iconColor: [{
            type: Input,
            args: ['color']
        }], iconName: [{
            type: Input,
            args: ['name']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxIconModule, { declarations: function () { return [IgxIconComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxIconComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxIconModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxIconComponent],
                exports: [IgxIconComponent],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxActionStripModule, { declarations: function () { return [IgxActionStripComponent, IgxActionStripMenuItemDirective, IgxGridPinningActionsComponent, IgxGridEditingActionsComponent, IgxGridActionsBaseDirective, IgxGridActionButtonComponent]; }, imports: function () { return [CommonModule, IgxDropDownModule, IgxToggleModule, IgxButtonModule, IgxIconModule, IgxRippleModule]; }, exports: function () { return [IgxActionStripComponent, IgxActionStripMenuItemDirective, IgxGridPinningActionsComponent, IgxGridEditingActionsComponent, IgxGridActionsBaseDirective, IgxGridActionButtonComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxActionStripModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxActionStripComponent,
                    IgxActionStripMenuItemDirective,
                    IgxGridPinningActionsComponent,
                    IgxGridEditingActionsComponent,
                    IgxGridActionsBaseDirective,
                    IgxGridActionButtonComponent
                ],
                entryComponents: [],
                exports: [
                    IgxActionStripComponent,
                    IgxActionStripMenuItemDirective,
                    IgxGridPinningActionsComponent,
                    IgxGridEditingActionsComponent,
                    IgxGridActionsBaseDirective,
                    IgxGridActionButtonComponent
                ],
                imports: [CommonModule, IgxDropDownModule, IgxToggleModule, IgxButtonModule, IgxIconModule, IgxRippleModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxAvatarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-avatar',
                template: "<ng-template #defaultTemplate>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #imageTemplate>\n    <div #image class=\"igx-avatar__image\" [style.backgroundImage]=\"getSrcUrl()\"></div>\n</ng-template>\n\n<ng-template #initialsTemplate>\n    <span>{{initials.substring(0, 2)}}</span>\n</ng-template>\n\n<ng-template #iconTemplate>\n     <igx-icon>{{icon}}</igx-icon>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { ariaLabel: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-avatar']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], roundShape: [{
            type: HostBinding,
            args: ['class.igx-avatar--rounded']
        }, {
            type: Input
        }], size: [{
            type: Input
        }], _isSmallSize: [{
            type: HostBinding,
            args: ['class.igx-avatar--small']
        }], _isMediumSize: [{
            type: HostBinding,
            args: ['class.igx-avatar--medium']
        }], _isLargeSize: [{
            type: HostBinding,
            args: ['class.igx-avatar--large']
        }], _isImageType: [{
            type: HostBinding,
            args: ['class.igx-avatar--image']
        }], _isIconType: [{
            type: HostBinding,
            args: ['class.igx-avatar--icon']
        }], _isInitialsType: [{
            type: HostBinding,
            args: ['class.igx-avatar--initials']
        }], roleDescription: [{
            type: HostBinding,
            args: ['attr.aria-roledescription']
        }], image: [{
            type: ViewChild,
            args: ['image']
        }], defaultTemplate: [{
            type: ViewChild,
            args: ['defaultTemplate', { read: TemplateRef, static: true }]
        }], imageTemplate: [{
            type: ViewChild,
            args: ['imageTemplate', { read: TemplateRef, static: true }]
        }], initialsTemplate: [{
            type: ViewChild,
            args: ['initialsTemplate', { read: TemplateRef, static: true }]
        }], iconTemplate: [{
            type: ViewChild,
            args: ['iconTemplate', { read: TemplateRef, static: true }]
        }], color: [{
            type: HostBinding,
            args: ['style.color']
        }, {
            type: Input
        }], bgColor: [{
            type: HostBinding,
            args: ['style.background']
        }, {
            type: Input
        }], initials: [{
            type: Input
        }], icon: [{
            type: Input
        }], src: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxAvatarModule, { declarations: function () { return [IgxAvatarComponent]; }, imports: function () { return [CommonModule, IgxIconModule]; }, exports: function () { return [IgxAvatarComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxAvatarModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxAvatarComponent],
                exports: [IgxAvatarComponent],
                imports: [CommonModule, IgxIconModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBadgeComponent, [{
        type: Component,
        args: [{
                selector: 'igx-badge',
                template: "<div class=\"igx-badge__circle\" [ngClass]=\"setClasses()\" [attr.aria-roledescription]=\"roleDescription\">\n    <span *ngIf=\"!icon\" class=\"igx-badge__circle-value\">{{value}}</span>\n    <igx-icon *ngIf=\"icon\" fontSet=\"material\">{{icon}}</igx-icon>\n</div>\n"
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], type: [{
            type: Input
        }], value: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-badge']
        }], label: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], icon: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxBadgeModule, { declarations: function () { return [IgxBadgeComponent]; }, imports: function () { return [CommonModule, IgxIconModule]; }, exports: function () { return [IgxBadgeComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBadgeModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxBadgeComponent],
                exports: [IgxBadgeComponent],
                imports: [CommonModule, IgxIconModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelBodyComponent, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-body',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_EXPANSION_PANEL_COMPONENT]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-expansion-panel__body']
        }], role: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.role']
        }], label: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-label']
        }], labelledBy: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-labelledby']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelTitleDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-title'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-expansion-panel__header-title']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelDescriptionDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-description'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-expansion-panel__header-description']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelIconDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-icon'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'igx-expansion-panel-header',
                template: "<div class=\"igx-expansion-panel__header-inner\" tabindex=\"0\" role=\"button\" [attr.id]=\"id\"\n[attr.aria-disabled]=\"disabled\" [attr.aria-expanded]=\"isExpanded\" [attr.aria-controls]=\"controls\">\n    <div class=\"igx-expansion-panel__title-wrapper\">\n        <ng-content select=\"igx-expansion-panel-title\"></ng-content>\n        <ng-content select=\"igx-expansion-panel-description\"></ng-content>\n    </div>\n    <ng-content></ng-content>\n    <div [class]=\"iconPositionClass\">\n        <ng-content *ngIf=\"iconTemplate\" select=\"igx-expansion-panel-icon\"></ng-content>\n        <igx-icon *ngIf=\"!iconTemplate\" fontSet=\"material\">\n            {{panel.collapsed? 'expand_more':'expand_less'}}\n        </igx-icon>\n    </div>\n</div>\n"
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Host
            }, {
                type: Inject,
                args: [IGX_EXPANSION_PANEL_COMPONENT]
            }] }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { lv: [{
            type: HostBinding,
            args: ['attr.aria-level']
        }, {
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }], iconPosition: [{
            type: Input
        }], onInteraction: [{
            type: Output
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-expansion-panel__header']
        }], disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-expansion-panel--disabled']
        }], iconTemplate: [{
            type: ContentChild,
            args: [IgxExpansionPanelIconDirective]
        }], isExpanded: [{
            type: HostBinding,
            args: ['class.igx-expansion-panel__header--expanded']
        }], 
    /**
     * @hidden
     */
    onAction: [{
            type: HostListener,
            args: ['keydown.Enter', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.Space', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.Spacebar', ['$event']]
        }, {
            type: HostListener,
            args: ['click', ['$event']]
        }], 
    /** @hidden @internal */
    openPanel: [{
            type: HostListener,
            args: ['keydown.Alt.ArrowDown', ['$event']]
        }], 
    /** @hidden @internal */
    closePanel: [{
            type: HostListener,
            args: ['keydown.Alt.ArrowUp', ['$event']]
        }], customIconRef: [{
            type: ContentChild,
            args: [IgxExpansionPanelIconDirective, { read: ElementRef }]
        }], defaultIconRef: [{
            type: ViewChild,
            args: [IgxIconComponent, { read: ElementRef }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelComponent, [{
        type: Component,
        args: [{
                selector: 'igx-expansion-panel',
                template: "<ng-content select=\"igx-expansion-panel-header\"></ng-content>\n<ng-content *ngIf=\"!collapsed\" select=\"igx-expansion-panel-body\"></ng-content>\n",
                providers: [{ provide: IGX_EXPANSION_PANEL_COMPONENT, useExisting: IgxExpansionPanelComponent }]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.AnimationBuilder }]; }, { animationSettings: [{
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-expansion-panel']
        }], collapsedChange: [{
            type: Output
        }], onCollapsed: [{
            type: Output
        }], onExpanded: [{
            type: Output
        }], collapsed: [{
            type: Input
        }], body: [{
            type: ContentChild,
            args: [IgxExpansionPanelBodyComponent, { read: IgxExpansionPanelBodyComponent }]
        }], header: [{
            type: ContentChild,
            args: [IgxExpansionPanelHeaderComponent, { read: IgxExpansionPanelHeaderComponent }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxExpansionPanelModule, { declarations: function () { return [IgxExpansionPanelComponent, IgxExpansionPanelHeaderComponent, IgxExpansionPanelBodyComponent, IgxExpansionPanelDescriptionDirective, IgxExpansionPanelTitleDirective, IgxExpansionPanelIconDirective]; }, imports: function () { return [CommonModule, IgxRippleModule, IgxIconModule, IgxButtonModule, IgxAvatarModule]; }, exports: function () { return [IgxExpansionPanelComponent, IgxExpansionPanelHeaderComponent, IgxExpansionPanelBodyComponent, IgxExpansionPanelDescriptionDirective, IgxExpansionPanelTitleDirective, IgxExpansionPanelIconDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxExpansionPanelComponent,
                    IgxExpansionPanelHeaderComponent,
                    IgxExpansionPanelBodyComponent,
                    IgxExpansionPanelDescriptionDirective,
                    IgxExpansionPanelTitleDirective,
                    IgxExpansionPanelIconDirective
                ],
                entryComponents: [],
                exports: [
                    IgxExpansionPanelComponent,
                    IgxExpansionPanelHeaderComponent,
                    IgxExpansionPanelBodyComponent,
                    IgxExpansionPanelDescriptionDirective,
                    IgxExpansionPanelTitleDirective,
                    IgxExpansionPanelIconDirective
                ],
                imports: [
                    CommonModule,
                    IgxRippleModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxAvatarModule
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBannerActionsDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-banner-actions'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBannerComponent, [{
        type: Component,
        args: [{
                selector: 'igx-banner',
                template: "<igx-expansion-panel #expansionPanel [animationSettings]=\"animationSettings\" (onCollapsed)=\"onExpansionPanelClose()\" (onExpanded)=\"onExpansionPanelOpen()\"\n    [collapsed]=\"collapsed\" aria-live=\"polite\" [attr.aria-hidden]=\"collapsed\">\n    <igx-expansion-panel-body>\n        <div class=\"igx-banner\">\n            <div class=\"igx-banner__message\">\n                <div *ngIf=\"bannerIcon\" class=\"igx-banner__illustration\">\n                    <ng-content select=\"igx-icon\"></ng-content>\n                </div>\n                <span class=\"igx-banner__text\">\n                    <ng-content></ng-content>\n                </span>\n            </div>\n            <div class=\"igx-banner__actions\">\n                <div class=\"igx-banner__row\">\n                    <ng-container *ngIf=\"useDefaultTemplate\">\n                        <button igxButton=\"flat\" igxRipple (click)=\"close()\">\n                            Dismiss\n                        </button>\n                    </ng-container>\n                    <ng-container *ngIf=\"!useDefaultTemplate\">\n                        <ng-content select=\"igx-banner-actions\"></ng-content>\n                    </ng-container>\n                </div>\n            </div>\n        </div>\n    </igx-expansion-panel-body>\n</igx-expansion-panel>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { onOpened: [{
            type: Output
        }], onOpening: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], animationSettings: [{
            type: Input
        }], displayStyle: [{
            type: HostBinding,
            args: ['style.display']
        }], _expansionPanel: [{
            type: ViewChild,
            args: ['expansionPanel', { static: true }]
        }], _bannerActionTemplate: [{
            type: ContentChild,
            args: [IgxBannerActionsDirective]
        }], bannerIcon: [{
            type: ContentChild,
            args: [IgxIconComponent]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxBannerModule, { declarations: function () { return [IgxBannerComponent, IgxBannerActionsDirective]; }, imports: function () { return [CommonModule, IgxExpansionPanelModule, IgxIconModule, IgxButtonModule, IgxRippleModule]; }, exports: function () { return [IgxBannerComponent, IgxBannerActionsDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBannerModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxBannerComponent, IgxBannerActionsDirective],
                exports: [IgxBannerComponent, IgxBannerActionsDirective],
                imports: [CommonModule, IgxExpansionPanelModule, IgxIconModule, IgxButtonModule, IgxRippleModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxButtonGroupComponent, [{
        type: Component,
        args: [{
                selector: 'igx-buttongroup',
                template: "<div class=\"igx-button-group\" role=\"group\" [class.igx-button-group--vertical]=\"isVertical\">\n    <button *ngFor=\"let button of values; let i = 'index'\"\n        type=\"button\"\n        igxButton=\"flat\"\n        [displayDensity]=\"displayDensity\"\n        [selected]=\"button.selected\"\n        [attr.data-togglable]=\"button.togglable\"\n        [disabled]=\"disabled || button.disabled\"\n        [igxButtonColor]=\"button.color\"\n        [igxButtonBackground]=\"button.bgcolor\"\n        [igxLabel]=\"button.label\"\n        [igxRipple]=\"button.ripple\"\n    >\n        <span class=\"igx-button-group__item-content {{ itemContentCssClass }}\">\n            <igx-icon *ngIf=\"button.icon\" fontSet=\"material\">{{button.icon}}</igx-icon>\n            <span class=\"igx-button-group__button-text\" *ngIf=\"button.label\">{{button.label}}</span>\n        </span>\n    </button>\n    <ng-content></ng-content>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], zIndex: [{
            type: HostBinding,
            args: ['style.zIndex']
        }], multiSelection: [{
            type: Input
        }], onSelect: [{
            type: Output
        }], onUnselect: [{
            type: Output
        }], itemContentCssClass: [{
            type: Input
        }], disabled: [{
            type: Input
        }], alignment: [{
            type: Input
        }], viewButtons: [{
            type: ViewChildren,
            args: [IgxButtonDirective]
        }], templateButtons: [{
            type: ContentChildren,
            args: [IgxButtonDirective]
        }], values: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxButtonGroupModule, { declarations: function () { return [IgxButtonGroupComponent]; }, imports: function () { return [IgxButtonModule, CommonModule, IgxRippleModule, IgxIconModule]; }, exports: function () { return [IgxButtonGroupComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxButtonGroupModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxButtonGroupComponent],
                exports: [IgxButtonGroupComponent],
                imports: [IgxButtonModule, CommonModule, IgxRippleModule, IgxIconModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCalendarBase]'
            }]
    }], function () { return []; }, { hideOutsideDays: [{
            type: Input
        }], onSelection: [{
            type: Output
        }], viewDateChanged: [{
            type: Output
        }], activeViewChanged: [{
            type: Output
        }], viewDate: [{
            type: Input
        }], weekStart: [{
            type: Input
        }], locale: [{
            type: Input
        }], formatOptions: [{
            type: Input
        }], formatViews: [{
            type: Input
        }], selection: [{
            type: Input
        }], value: [{
            type: Input
        }], disabledDates: [{
            type: Input
        }], specialDates: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarYearDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCalendarYear]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { onYearSelection: [{
            type: Output
        }], defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__year']
        }], currentCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__year--current']
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], value: [{
            type: Input,
            args: ['igxCalendarYear']
        }], date: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarMonthDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCalendarMonth]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { onMonthSelection: [{
            type: Output
        }], defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__month']
        }], currentCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__month--current']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], value: [{
            type: Input,
            args: ['igxCalendarMonth']
        }], date: [{
            type: Input
        }], index: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarHeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCalendarHeader]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarSubheaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCalendarSubheader]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarScrollMonthDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCalendarScrollMonth]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { 
    /**
     * @hidden
     */
    onMouseDown: [{
            type: HostListener,
            args: ['mousedown']
        }], 
    /**
     * @hidden
     */
    onMouseUp: [{
            type: HostListener,
            args: ['mouseup', ['$event']]
        }], startScroll: [{
            type: Input
        }], stopScroll: [{
            type: Input
        }] }); })();
const ɵIgxMonthPickerBaseDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxMonthPickerBaseDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMonthPickerBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxMonthPickerBase]'
            }]
    }], null, { activeView: [{
            type: Input
        }], yearsBtns: [{
            type: ViewChildren,
            args: ['yearsBtn']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMonthsViewComponent, [{
        type: Component,
        args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxMonthsViewComponent, multi: true }],
                selector: 'igx-months-view',
                template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-row--wrap\">\n        <div [igxCalendarMonth]=\"month\" [date]=\"date\" [attr.tabindex]=\"activeMonth === month.getMonth() ? 0 : -1\" (onMonthSelection)=\"selectMonth($event)\" [index]=\"i\" *ngFor=\"let month of months; index as i; trackBy: monthTracker\">\n            {{ formattedMonth(month) | titlecase }}\n        </div>\n    </div>\n</div>\n\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], formatView: [{
            type: Input
        }], onSelection: [{
            type: Output
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-calendar']
        }], date: [{
            type: Input
        }], monthFormat: [{
            type: Input
        }], locale: [{
            type: Input
        }], 
    /**
     * @hidden
     */
    onKeydownArrowUp: [{
            type: HostListener,
            args: ['keydown.arrowup', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownArrowDown: [{
            type: HostListener,
            args: ['keydown.arrowdown', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownArrowRight: [{
            type: HostListener,
            args: ['keydown.arrowright', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownArrowLeft: [{
            type: HostListener,
            args: ['keydown.arrowleft', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownHome: [{
            type: HostListener,
            args: ['keydown.home', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownEnd: [{
            type: HostListener,
            args: ['keydown.end', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownEnter: [{
            type: HostListener,
            args: ['keydown.enter', ['$event']]
        }], resetActiveMonth: [{
            type: HostListener,
            args: ['focusout', ['$event']]
        }], monthsRef: [{
            type: ViewChildren,
            args: [IgxCalendarMonthDirective, { read: IgxCalendarMonthDirective }]
        }] }); })();
const ɵCalendarHammerConfig_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(CalendarHammerConfig);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CalendarHammerConfig, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxYearsViewComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxYearsViewComponent,
                        multi: true
                    },
                    {
                        provide: HAMMER_GESTURE_CONFIG,
                        useClass: CalendarHammerConfig
                    }
                ],
                selector: 'igx-years-view',
                template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-column\" (wheel)=\"scroll($event)\" (pan)=\"pan($event)\">\n        <span [igxCalendarYear]=\"year\" [date]=\"date\" (onYearSelection)=\"selectYear($event)\" *ngFor=\"let year of decade; trackBy: yearTracker\">\n            {{ formattedYear(year) }}\n        </span>\n    </div>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], date: [{
            type: Input
        }], onSelection: [{
            type: Output
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-calendar']
        }], yearFormat: [{
            type: Input
        }], locale: [{
            type: Input
        }], 
    /**
     * @hidden
     */
    onKeydownArrowDown: [{
            type: HostListener,
            args: ['keydown.arrowdown', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownArrowUp: [{
            type: HostListener,
            args: ['keydown.arrowup', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownEnter: [{
            type: HostListener,
            args: ['keydown.enter']
        }], formatView: [{
            type: Input
        }], calendarDir: [{
            type: ViewChildren,
            args: [IgxCalendarYearDirective, { read: IgxCalendarYearDirective }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDayItemComponent, [{
        type: Component,
        args: [{
                selector: 'igx-day-item',
                template: "<span class=\"igx-calendar__date-content\">\n    <ng-content></ng-content>\n</span>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { hideOutsideDays: [{
            type: Input
        }], isLastInRange: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-calendar__date--last']
        }], isFirstInRange: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-calendar__date--first']
        }], isWithinRange: [{
            type: Input
        }], onDateSelection: [{
            type: Output
        }], selected: [{
            type: Input
        }], isSelectedCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--selected']
        }], isInactive: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--inactive']
        }], isHidden: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--hidden']
        }], isToday: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--current']
        }], isWeekend: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--weekend']
        }], isWithinRangeCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--range']
        }], isSpecial: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--special']
        }], defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__date']
        }], isDisabledCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--disabled']
        }], isSingleSelection: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--single']
        }], onSelect: [{
            type: HostListener,
            args: ['click', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.enter', ['$event']]
        }], date: [{
            type: Input
        }], selection: [{
            type: Input
        }], disabledDates: [{
            type: Input
        }], outOfRangeDates: [{
            type: Input
        }], specialDates: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDaysViewNavigationService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDaysViewComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxDaysViewComponent
                    },
                    { provide: IgxDaysViewNavigationService, useClass: IgxDaysViewNavigationService }
                ],
                selector: 'igx-days-view',
                template: "<div class=\"igx-calendar__body-row\">\n    <div *ngIf=\"showWeekNumbers\" class=\"igx-calendar__label igx-calendar__label--week-number\">\n        <span>Wk</span>\n    </div>\n    <span *ngFor=\"let dayName of generateWeekHeader()\" class=\"igx-calendar__label\">\n        {{ dayName | titlecase }}\n    </span>\n</div>\n\n<div *ngFor=\"let week of getCalendarMonth; last as isLast; index as i; trackBy: rowTracker\"\n    class=\"igx-calendar__body-row\">\n    <div class=\"igx-calendar__date igx-calendar__date--week-number\" *ngIf=\"showWeekNumbers\">\n        <span class=\"igx-calendar__date-content igx-calendar__date-content--week-number\">\n            {{getWeekNumber(week[0].date)}}\n        </span>\n    </div>\n    <!-- <igx-week-number-item *ngIf=\"showWeekNumbers\">{{getWeekNumber(week[0].date)}}</igx-week-number-item> -->\n    <igx-day-item\n        *ngFor=\"let day of week; trackBy: dateTracker\"\n        [date]=\"day\"\n        [selection]=\"selection\"\n        [selected]=\"isSelected(day)\"\n        [isLastInRange]=\"isLastInRange(day)\"\n        [isFirstInRange]=\"isFirstInRange(day)\"\n        [isWithinRange]=\"isWithinRange(day.date, true)\"\n        [disabledDates]=\"disabledDates\"\n        [specialDates]=\"specialDates\"\n        [outOfRangeDates]=\"outOfRangeDates\"\n        [hideOutsideDays]=\"hideOutsideDays\"\n        [attr.tabindex]=\"tabIndex(day)\"\n        (focus)=\"activeDate = day.date.toLocaleDateString()\"\n        (onDateSelection)=\"selectDay($event)\">\n        {{ formattedDate(day.date) }}\n    </igx-day-item>\n</div>\n"
            }]
    }], function () { return [{ type: IgxDaysViewNavigationService }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], changeDaysView: [{
            type: Input
        }], onDateSelection: [{
            type: Output
        }], onViewChanging: [{
            type: Output
        }], activeDateChange: [{
            type: Output
        }], monthsViewBlur: [{
            type: Output
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-calendar']
        }], activeDate: [{
            type: Input
        }], 
    /**
     * @hidden
     * @internal
     */
    resetActiveMonth: [{
            type: HostListener,
            args: ['focusout']
        }], 
    /**
     * @hidden
     * @internal
     */
    pointerDown: [{
            type: HostListener,
            args: ['keydown.pagedown']
        }, {
            type: HostListener,
            args: ['keydown.pageup']
        }, {
            type: HostListener,
            args: ['keydown.shift.pagedown']
        }, {
            type: HostListener,
            args: ['keydown.shift.pageup']
        }, {
            type: HostListener,
            args: ['pointerdown']
        }], 
    /**
     * @hidden
     */
    onKeydownArrow: [{
            type: HostListener,
            args: ['keydown.arrowleft', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.arrowright', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.arrowup', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.arrowdown', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownHome: [{
            type: HostListener,
            args: ['keydown.home', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownEnd: [{
            type: HostListener,
            args: ['keydown.end', ['$event']]
        }], showWeekNumbers: [{
            type: Input
        }], dates: [{
            type: ViewChildren,
            args: [IgxDayItemComponent, { read: IgxDayItemComponent }]
        }] }); })();
const ɵIgxCalendarComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxCalendarComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxCalendarComponent
                    }
                ],
                animations: [
                    trigger('animateView', [
                        transition('void => 0', useAnimation(fadeIn)),
                        transition('void => *', useAnimation(scaleInCenter, {
                            params: {
                                duration: '.2s',
                                fromScale: .9
                            }
                        }))
                    ]),
                    trigger('animateChange', [
                        transition('* => prev', useAnimation(slideInLeft, {
                            params: {
                                fromPosition: 'translateX(-30%)'
                            }
                        })),
                        transition('* => next', useAnimation(slideInRight, {
                            params: {
                                fromPosition: 'translateX(30%)'
                            }
                        }))
                    ])
                ],
                selector: 'igx-calendar',
                template: "<ng-template let-result #defaultHeader>\n    <span>{{ getFormattedDate().weekday }},&nbsp;</span>\n    <span>{{ getFormattedDate().monthday }}</span>\n</ng-template>\n\n<ng-template let-result #defaultMonth let-obj>\n    <span tabindex=\"0\" #monthsBtn (keydown)=\"onActiveViewYearKB(getViewDate(obj.index), $event, obj.index)\" (click)=\"onActiveViewYear(getViewDate(obj.index), obj.index, $event)\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedMonth(getViewDate(obj.index)) }}\n    </span>\n    <span tabindex=\"0\" #yearsBtn (keydown)=\"onActiveViewDecadeKB($event, getViewDate(obj.index), obj.index)\" (click)=\"onActiveViewDecade(getViewDate(obj.index), obj.index)\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedYear(getViewDate(obj.index)) }}\n    </span>\n</ng-template>\n\n<div *ngIf=\"selection === 'single' && hasHeader\" class=\"igx-calendar__header\">\n    <h5 class=\"igx-calendar__header-year\">{{ formattedYear(headerDate) }}</h5>\n    <h2 class=\"igx-calendar__header-date\">\n        <ng-container *ngTemplateOutlet=\"headerTemplate ? headerTemplate : defaultHeader; context: headerContext\">\n        </ng-container>\n    </h2>\n</div>\n\n<div *ngIf=\"isDefaultView\" class=\"igx-calendar__body\" [@animateView]=\"activeView\" (@animateView.done)=\"viewRendered($event)\" (swiperight)=\"previousMonth()\"\n    (swipeleft)=\"nextMonth()\" (pointerdown)=\"suppressBlur()\">\n    <div class=\"igx-calendar-picker\">\n        <div tabindex=\"0\" class=\"igx-calendar-picker__prev\" #prevMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startPrevMonthScroll\" [stopScroll]=\"stopMonthScroll\"  [ngStyle]=\"{\n                    'min-width.%': 100/(monthsViewNumber*7)\n                }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div class=\"igx-calendar-picker__dates\" *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [style.width.%]=\"100/monthsViewNumber\" [attr.data-month]=\"i | IgxGetViewDate:viewDate:false\">\n            <ng-container *ngTemplateOutlet=\"subheaderTemplate ? subheaderTemplate : defaultMonth; context: getContext(i)\">\n            </ng-container>\n        </div>\n        <div tabindex=\"0\" class=\"igx-calendar-picker__next\" #nextMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startNextMonthScroll\" [stopScroll]=\"stopMonthScroll\" [ngStyle]=\"{\n                    'min-width.%': 100/(monthsViewNumber*7)\n                }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <div style=\"display: flex\"\n        [@animateChange]=\"animationAction\"\n        (@animateChange.done)=\"animationDone($event)\">\n        <igx-days-view *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [changeDaysView]=\"true\" #days\n                [selection]=\"selection\"\n                [locale]=\"locale\"\n                [value]=\"value\"\n                [(activeDate)]=\"activeDate\"\n                [viewDate]=\"i | IgxGetViewDate:viewDate\"\n                [weekStart]=\"weekStart\"\n                [formatOptions]=\"formatOptions\"\n                [formatViews]=\"formatViews\"\n                [disabledDates]=\"disabledDates\"\n                [specialDates]=\"specialDates\"\n                [hideOutsideDays]=\"hideOutsideDays\"\n                [showWeekNumbers]=\"showWeekNumbers\"\n                (onViewChanging)=\"viewChanging($event)\"\n                (onDateSelection)=\"childClicked($event)\"\n                (monthsViewBlur)=\"resetActiveDate()\">\n        </igx-days-view>\n    </div>\n</div>\n\n<igx-months-view *ngIf=\"isYearView\" [@animateView]=\"activeView\" #months (@animateView.done)=\"viewRendered($event)\"\n                 [date]=\"viewDate\"\n                 [locale]=\"locale\"\n                 [formatView]=\"formatViews.month\"\n                 [monthFormat]=\"formatOptions.month\"\n                 (onSelection)=\"changeMonth($event)\">\n</igx-months-view>\n\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade (@animateView.done)=\"viewRendered($event)\"\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (onSelection)=\"changeYear($event)\">\n</igx-years-view>\n"
            }]
    }], null, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], hasHeader: [{
            type: Input
        }], vertical: [{
            type: Input
        }], showWeekNumbers: [{
            type: Input
        }], animationAction: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], ariaLabelledBy: [{
            type: HostBinding,
            args: ['attr.aria-labelledby']
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-calendar']
        }], monthsViewNumber: [{
            type: Input
        }], styleVerticalClass: [{
            type: HostBinding,
            args: ['class.igx-calendar--vertical']
        }], headerTemplateDirective: [{
            type: ContentChild,
            args: [forwardRef(() => IgxCalendarHeaderTemplateDirective), { read: IgxCalendarHeaderTemplateDirective, static: true }]
        }], subheaderTemplateDirective: [{
            type: ContentChild,
            args: [forwardRef(() => IgxCalendarSubheaderTemplateDirective), { read: IgxCalendarSubheaderTemplateDirective, static: true }]
        }], 
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * @internal
     */
    onKeydownPageDown: [{
            type: HostListener,
            args: ['keydown.pagedown', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.pageup', ['$event']]
        }], 
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * @internal
     */
    onKeydownShiftPageUp: [{
            type: HostListener,
            args: ['keydown.shift.pageup', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.shift.pagedown', ['$event']]
        }], 
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * @internal
     */
    onKeydownHome: [{
            type: HostListener,
            args: ['keydown.home', ['$event']]
        }], 
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * @internal
     */
    onKeydownEnd: [{
            type: HostListener,
            args: ['keydown.end', ['$event']]
        }], 
    /**
     * Stop continuous navigation on mouseup event
     * @hidden
     * @internal
     */
    onMouseUp: [{
            type: HostListener,
            args: ['document:mouseup', ['$event']]
        }], monthsView: [{
            type: ViewChild,
            args: ['months', { read: IgxMonthsViewComponent }]
        }], monthsBtns: [{
            type: ViewChildren,
            args: ['monthsBtn']
        }], dacadeView: [{
            type: ViewChild,
            args: ['decade', { read: IgxYearsViewComponent }]
        }], daysView: [{
            type: ViewChild,
            args: ['days', { read: IgxDaysViewComponent }]
        }], monthViews: [{
            type: ViewChildren,
            args: ['days', { read: IgxDaysViewComponent }]
        }], prevMonthBtn: [{
            type: ViewChild,
            args: ['prevMonthBtn']
        }], nextMonthBtn: [{
            type: ViewChild,
            args: ['nextMonthBtn']
        }] }); })();
const ɵIgxMonthPickerComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxMonthPickerComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMonthPickerComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxMonthPickerComponent
                    }
                ],
                animations: [
                    trigger('animateView', [
                        transition('void => 0', useAnimation(fadeIn)),
                        transition('void => *', useAnimation(scaleInCenter, {
                            params: {
                                duration: '.2s',
                                fromScale: .9
                            }
                        }))
                    ]),
                    trigger('animateChange', [
                        transition('* => prev', useAnimation(slideInLeft, {
                            params: {
                                fromPosition: 'translateX(-30%)'
                            }
                        })),
                        transition('* => next', useAnimation(slideInRight, {
                            params: {
                                fromPosition: 'translateX(30%)'
                            }
                        }))
                    ])
                ],
                selector: 'igx-month-picker',
                template: "<div *ngIf=\"isDefaultView\" [@animateView]=\"activeView\" (@animateView.done)=\"viewRendered($event)\" class=\"igx-calendar__body\" (swiperight)=\"previousYear()\" (swipeleft)=\"nextYear()\">\n    <div class=\"igx-calendar-picker\">\n        <div tabindex=\"0\" class=\"igx-calendar-picker__prev\" (click)=\"previousYear()\" (keydown)=\"changeYearKB($event, false)\" [ngStyle]=\"{\n            'min-width.%': 25,\n            'left': 0\n        }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div [style.width.%]=\"100\">\n            <span tabindex=\"0\" #yearsBtn (keydown)=\"activeViewDecadeKB($event)\" (click)=\"activeViewDecade()\" class=\"igx-calendar-picker__date\">\n                {{ formattedYear(viewDate) }}\n            </span>\n        </div>\n        <div tabindex=\"0\" class=\"igx-calendar-picker__next\" (click)=\"nextYear()\" (keydown)=\"changeYearKB($event)\" [ngStyle]=\"{\n            'min-width.%': 25,\n            'right': 0\n        }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <igx-months-view [@animateChange]=\"yearAction\" #months\n                     (@animateChange.done)=\"animationDone($event)\"\n                     (@animateView.done)=\"viewRendered($event)\"\n                     [date]=\"viewDate\"\n                     [locale]=\"locale\"\n                     [formatView]=\"formatViews.month\"\n                     [monthFormat]=\"formatOptions.month\"\n                     (onSelection)=\"selectMonth($event)\">\n    </igx-months-view>\n</div>\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade (@animateView.done)=\"viewRendered($event)\"\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (onSelection)=\"selectYear($event)\">\n</igx-years-view>\n"
            }]
    }], null, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-calendar']
        }], 
    /**
     * @hidden
     */
    previousYear: [{
            type: HostListener,
            args: ['keydown.pageup', ['$event']]
        }], 
    /**
     * @hidden
     */
    nextYear: [{
            type: HostListener,
            args: ['keydown.pagedown', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownHome: [{
            type: HostListener,
            args: ['keydown.home', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownEnd: [{
            type: HostListener,
            args: ['keydown.end', ['$event']]
        }], monthsView: [{
            type: ViewChild,
            args: ['months', { read: IgxMonthsViewComponent }]
        }], dacadeView: [{
            type: ViewChild,
            args: ['decade', { read: IgxYearsViewComponent }]
        }], daysView: [{
            type: ViewChild,
            args: ['days', { read: IgxDaysViewComponent }]
        }], yearsBtn: [{
            type: ViewChild,
            args: ['yearsBtn']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMonthViewSlotsCalendar, [{
        type: Pipe,
        args: [{
                name: 'IgxMonthViewSlots'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGetViewDateCalendar, [{
        type: Pipe,
        args: [{
                name: 'IgxGetViewDate'
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxCalendarModule, { declarations: function () { return [IgxCalendarBaseDirective, IgxMonthPickerBaseDirective, IgxDayItemComponent, IgxDaysViewComponent, IgxCalendarComponent, IgxCalendarHeaderTemplateDirective, IgxCalendarMonthDirective, IgxCalendarYearDirective, IgxCalendarSubheaderTemplateDirective, IgxCalendarScrollMonthDirective, IgxMonthsViewComponent, IgxYearsViewComponent, IgxMonthPickerComponent, IgxMonthViewSlotsCalendar, IgxGetViewDateCalendar]; }, imports: function () { return [CommonModule, FormsModule, IgxIconModule]; }, exports: function () { return [IgxCalendarComponent, IgxDaysViewComponent, IgxMonthsViewComponent, IgxYearsViewComponent, IgxMonthPickerComponent, IgxCalendarHeaderTemplateDirective, IgxCalendarMonthDirective, IgxCalendarYearDirective, IgxCalendarSubheaderTemplateDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxCalendarBaseDirective,
                    IgxMonthPickerBaseDirective,
                    IgxDayItemComponent,
                    IgxDaysViewComponent,
                    IgxCalendarComponent,
                    IgxCalendarHeaderTemplateDirective,
                    IgxCalendarMonthDirective,
                    IgxCalendarYearDirective,
                    IgxCalendarSubheaderTemplateDirective,
                    IgxCalendarScrollMonthDirective,
                    IgxMonthsViewComponent,
                    IgxYearsViewComponent,
                    IgxMonthPickerComponent,
                    IgxMonthViewSlotsCalendar,
                    IgxGetViewDateCalendar
                ],
                exports: [
                    IgxCalendarComponent,
                    IgxDaysViewComponent,
                    IgxMonthsViewComponent,
                    IgxYearsViewComponent,
                    IgxMonthPickerComponent,
                    IgxCalendarHeaderTemplateDirective,
                    IgxCalendarMonthDirective,
                    IgxCalendarYearDirective,
                    IgxCalendarSubheaderTemplateDirective
                ],
                imports: [CommonModule, FormsModule, IgxIconModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardMediaDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-media'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-card__media']
        }], width: [{
            type: HostBinding,
            args: ['style.width']
        }, {
            type: HostBinding,
            args: ['style.min-width']
        }, {
            type: Input
        }], height: [{
            type: HostBinding,
            args: ['style.height']
        }, {
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'igx-card-header',
                template: "<div class=\"igx-card-header__thumbnail\">\n    <ng-content select=\"igx-avatar, igx-card-media, [igxCardThumbnail]\"></ng-content>\n</div>\n\n<div class=\"igx-card-header__titles\">\n    <ng-content select=\"\n        [igxCardHeaderTitle],\n        [igxCardHeaderSubtitle],\n        .igx-card-header__title,\n        .igx-card-header__subtitle\">\n    </ng-content>\n</div>\n\n<ng-content></ng-content>\n"
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-card-header']
        }], vertical: [{
            type: HostBinding,
            args: ['class.igx-card-header--vertical']
        }, {
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardThumbnailDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCardThumbnail]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardHeaderTitleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCardHeaderTitle]'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-card-header__title']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardHeaderSubtitleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCardHeaderSubtitle]'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-card-header__subtitle']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardContentDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-content'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-card-content']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardFooterDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-footer'
            }]
    }], function () { return []; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardComponent, [{
        type: Component,
        args: [{
                selector: 'igx-card',
                template: "<ng-container select='igx-card-media'></ng-container>\n\n<ng-container select='igx-card-header'></ng-container>\n<ng-container select='igx-card-content'>\n    <ng-content></ng-content>\n</ng-container>\n\n<ng-container select='igx-card-actions'></ng-container>\n"
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }], type: [{
            type: HostBinding,
            args: ['class.igx-card']
        }, {
            type: Input
        }], horizontal: [{
            type: HostBinding,
            args: ['class.igx-card--horizontal']
        }, {
            type: Input
        }], isOutlinedCard: [{
            type: HostBinding,
            args: ['class.igx-card--outlined']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardActionsComponent, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-actions',
                template: "<div class=\"igx-card-actions__icons\">\n    <ng-content select=\"igx-icon, [igxButton='icon']\"></ng-content>\n</div>\n\n<div #buttons class=\"igx-card-actions__buttons\">\n    <ng-content select=\"[igxButton]\"></ng-content>\n</div>\n\n\n<ng-content></ng-content>\n"
            }]
    }], function () { return [{ type: IgxCardComponent, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [IgxCardComponent]
            }] }]; }, { layout: [{
            type: HostBinding,
            args: ['class.igx-card-actions']
        }, {
            type: Input
        }], reverse: [{
            type: HostBinding,
            args: ['class.igx-card-actions--reverse']
        }, {
            type: Input
        }], isJustifyLayout: [{
            type: HostBinding,
            args: ['class.igx-card-actions--justify']
        }], vertical: [{
            type: HostBinding,
            args: ['class.igx-card-actions--vertical']
        }, {
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxCardModule, { declarations: function () { return [IgxCardComponent, IgxCardHeaderComponent, IgxCardMediaDirective, IgxCardContentDirective, IgxCardActionsComponent, IgxCardFooterDirective, IgxCardHeaderTitleDirective, IgxCardHeaderSubtitleDirective, IgxCardThumbnailDirective]; }, imports: function () { return [CommonModule, IgxButtonModule]; }, exports: function () { return [IgxCardComponent, IgxCardHeaderComponent, IgxCardMediaDirective, IgxCardContentDirective, IgxCardActionsComponent, IgxCardFooterDirective, IgxCardHeaderTitleDirective, IgxCardHeaderSubtitleDirective, IgxCardThumbnailDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxCardComponent,
                    IgxCardHeaderComponent,
                    IgxCardMediaDirective,
                    IgxCardContentDirective,
                    IgxCardActionsComponent,
                    IgxCardFooterDirective,
                    IgxCardHeaderTitleDirective,
                    IgxCardHeaderSubtitleDirective,
                    IgxCardThumbnailDirective,
                ],
                exports: [
                    IgxCardComponent,
                    IgxCardHeaderComponent,
                    IgxCardMediaDirective,
                    IgxCardContentDirective,
                    IgxCardActionsComponent,
                    IgxCardFooterDirective,
                    IgxCardHeaderTitleDirective,
                    IgxCardHeaderSubtitleDirective,
                    IgxCardThumbnailDirective,
                ],
                imports: [CommonModule, IgxButtonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCarouselIndicatorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCarouselIndicator]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCarouselNextButtonDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCarouselNextButton]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCarouselPrevButtonDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCarouselPrevButton]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSlideComponent, [{
        type: Component,
        args: [{
                selector: 'igx-slide',
                template: "<ng-content></ng-content>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-slide']
        }], previous: [{
            type: HostBinding,
            args: ['class.igx-slide--previous']
        }, {
            type: Input
        }], activeChange: [{
            type: Output
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], ariaSelected: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], ariaLive: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], active: [{
            type: HostBinding,
            args: ['class.igx-slide--current']
        }, {
            type: Input
        }], index: [{
            type: Input
        }], direction: [{
            type: Input
        }] }); })();
const ɵCarouselHammerConfig_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(CarouselHammerConfig);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CarouselHammerConfig, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCarouselComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: HAMMER_GESTURE_CONFIG,
                        useClass: CarouselHammerConfig
                    }
                ],
                selector: 'igx-carousel',
                template: "<ng-template #defaultIndicator let-slide>\n    <div class=\"igx-nav-dot\"\n        [class.igx-nav-dot--active]=\"slide.active\"\n    >\n    </div>\n</ng-template>\n\n<ng-template #defaultNextButton let-disabled>\n    <a class=\"igx-nav-arrow\"\n        [class.igx-nav-arrow--disabled]=\"disabled\"\n    >\n        <igx-icon fontSet=\"material\">arrow_forward</igx-icon>\n    </a>\n</ng-template>\n\n<ng-template #defaultPrevButton let-disabled>\n    <a class=\"igx-nav-arrow\"\n        [class.igx-nav-arrow--disabled]=\"disabled\"\n    >\n        <igx-icon fontSet=\"material\">arrow_back</igx-icon>\n    </a>\n</ng-template>\n\n\n<div *ngIf=\"showIndicators\" [ngClass]=\"indicatorsOrientationClass\">\n    <div *ngFor=\"let slide of slides\"\n        class=\"igx-carousel-indicators__indicator\"\n        (click)=\"select(slide)\"\n        [attr.aria-label]=\"setAriaLabel(slide)\"\n        [attr.aria-selected]=\"slide.active\">\n        <ng-container *ngTemplateOutlet=\"getIndicatorTemplate; context: {$implicit: slide};\"></ng-container>\n    </div>\n</div>\n\n<div *ngIf=\"showIndicatorsLabel\" [ngClass]=\"indicatorsOrientationClass\">\n    <span class=\"igx-carousel__label\">{{getCarouselLabel}}</span>\n</div>\n\n<div class=\"igx-carousel__inner\" role=\"list\">\n    <ng-content></ng-content>\n</div>\n\n<div *ngIf=\"navigation && slides.length\" role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--prev\" (click)=\"prev()\">\n    <ng-container *ngTemplateOutlet=\"getPrevButtonTemplate; context: {$implicit: prevButtonDisabled};\"></ng-container>\n</div>\n\n<div *ngIf=\"navigation && slides.length\" role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--next\" (click)=\"next()\">\n    <ng-container *ngTemplateOutlet=\"getNextButtonTemplate; context: {$implicit: nextButtonDisabled};\"></ng-container>\n</div>\n\n\n\n",
                styles: [`
    :host {
        display: block;
        outline-style: none;
    }`]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc1.AnimationBuilder }, { type: PlatformUtil }]; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], ariaLabel: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-carousel']
        }], loop: [{
            type: Input
        }], pause: [{
            type: Input
        }], navigation: [{
            type: Input
        }], keyboardSupport: [{
            type: Input
        }], gesturesSupport: [{
            type: Input
        }], maximumIndicatorsCount: [{
            type: Input
        }], indicatorsOrientation: [{
            type: Input
        }], animationType: [{
            type: Input
        }], indicatorTemplate: [{
            type: ContentChild,
            args: [IgxCarouselIndicatorDirective, { read: TemplateRef, static: false }]
        }], nextButtonTemplate: [{
            type: ContentChild,
            args: [IgxCarouselNextButtonDirective, { read: TemplateRef, static: false }]
        }], prevButtonTemplate: [{
            type: ContentChild,
            args: [IgxCarouselPrevButtonDirective, { read: TemplateRef, static: false }]
        }], onSlideChanged: [{
            type: Output
        }], onSlideAdded: [{
            type: Output
        }], onSlideRemoved: [{
            type: Output
        }], onCarouselPaused: [{
            type: Output
        }], onCarouselPlaying: [{
            type: Output
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], touchAction: [{
            type: HostBinding,
            args: ['style.touch-action']
        }], interval: [{
            type: Input
        }], resourceStrings: [{
            type: Input
        }], 
    /** @hidden */
    onKeydownArrowRight: [{
            type: HostListener,
            args: ['keydown.arrowright', ['$event']]
        }], 
    /** @hidden */
    onKeydownArrowLeft: [{
            type: HostListener,
            args: ['keydown.arrowleft', ['$event']]
        }], 
    /** @hidden */
    onTap: [{
            type: HostListener,
            args: ['tap', ['$event']]
        }], 
    /** @hidden */
    onKeydownHome: [{
            type: HostListener,
            args: ['keydown.home', ['$event']]
        }], 
    /** @hidden */
    onKeydownEnd: [{
            type: HostListener,
            args: ['keydown.end', ['$event']]
        }], 
    /** @hidden */
    onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], 
    /** @hidden */
    onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], 
    /** @hidden */
    onPanLeft: [{
            type: HostListener,
            args: ['panleft', ['$event']]
        }], 
    /** @hidden */
    onPanRight: [{
            type: HostListener,
            args: ['panright', ['$event']]
        }], 
    /**
     * @hidden
     */
    onPanEnd: [{
            type: HostListener,
            args: ['panend', ['$event']]
        }], defaultIndicator: [{
            type: ViewChild,
            args: ['defaultIndicator', { read: TemplateRef, static: true }]
        }], defaultNextButton: [{
            type: ViewChild,
            args: ['defaultNextButton', { read: TemplateRef, static: true }]
        }], defaultPrevButton: [{
            type: ViewChild,
            args: ['defaultPrevButton', { read: TemplateRef, static: true }]
        }], slides: [{
            type: ContentChildren,
            args: [IgxSlideComponent]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxCarouselModule, { declarations: function () { return [IgxCarouselComponent, IgxSlideComponent, IgxCarouselIndicatorDirective, IgxCarouselNextButtonDirective, IgxCarouselPrevButtonDirective]; }, imports: function () { return [CommonModule, IgxIconModule]; }, exports: function () { return [IgxCarouselComponent, IgxSlideComponent, IgxCarouselIndicatorDirective, IgxCarouselNextButtonDirective, IgxCarouselPrevButtonDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCarouselModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxCarouselComponent,
                    IgxSlideComponent,
                    IgxCarouselIndicatorDirective,
                    IgxCarouselNextButtonDirective,
                    IgxCarouselPrevButtonDirective
                ],
                exports: [
                    IgxCarouselComponent,
                    IgxSlideComponent,
                    IgxCarouselIndicatorDirective,
                    IgxCarouselNextButtonDirective,
                    IgxCarouselPrevButtonDirective
                ],
                imports: [CommonModule, IgxIconModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxChipComponent, [{
        type: Component,
        args: [{
                selector: 'igx-chip',
                template: "<div #chipArea class=\"igx-chip__item\"\n    [igxDrag]=\"{chip: this}\"\n    [style.visibility]='hideBaseElement ? \"hidden\" : \"visible\"'\n    [ghostClass]=\"ghostClass\"\n    (dragStart)=\"onChipDragStart($event)\"\n    (ghostCreate)=\"onChipGhostCreate()\"\n    (ghostDestroy)=\"onChipGhostDestroy()\"\n    (dragEnd)=\"onChipDragEnd()\"\n    (transitioned)=\"onChipMoveEnd($event)\"\n    (dragClick)=\"onChipDragClicked($event)\"\n    igxDrop\n    (enter)=\"onChipDragEnterHandler($event)\"\n    (dropped)=\"onChipDrop($event)\">\n\n    <div #selectContainer [ngClass]=\"selectClass(selected)\">\n        <ng-container *ngTemplateOutlet=\"selectIconTemplate\"></ng-container>\n    </div>\n\n    <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n\n    <div class=\"igx-chip__content\">\n        <ng-content></ng-content>\n    </div>\n\n    <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n\n    <div class=\"igx-chip__remove\" *ngIf=\"removable\"\n        [attr.tabIndex]=\"tabIndex\"\n        (keydown)=\"onRemoveBtnKeyDown($event)\"\n        (pointerdown)=\"onRemoveMouseDown($event)\"\n        (mousedown)=\"onRemoveMouseDown($event)\"\n        (click)=\"onRemoveClick($event)\"\n        (touchmove)=\"onRemoveTouchMove()\"\n        (touchend)=\"onRemoveTouchEnd($event)\">\n        <ng-container *ngTemplateOutlet=\"removeButtonTemplate\"></ng-container>\n    </div>\n</div>\n\n<ng-template #defaultSelectIcon>\n    <igx-icon>done</igx-icon>\n</ng-template>\n\n<ng-template #defaultRemoveIcon>\n    <igx-icon>cancel</igx-icon>\n</ng-template>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], draggable: [{
            type: Input
        }], animateOnRelease: [{
            type: Input
        }], hideBaseOnDrag: [{
            type: Input
        }], removable: [{
            type: Input
        }], selectable: [{
            type: Input
        }], class: [{
            type: Input
        }], disabled: [{
            type: Input
        }], selectedChange: [{
            type: Output
        }], onMoveStart: [{
            type: Output
        }], onMoveEnd: [{
            type: Output
        }], onRemove: [{
            type: Output
        }], onClick: [{
            type: Output
        }], onSelection: [{
            type: Output
        }], onSelectionDone: [{
            type: Output
        }], onKeyDown: [{
            type: Output
        }], onDragEnter: [{
            type: Output
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabIndex']
        }, {
            type: Input
        }], selected: [{
            type: Input
        }], color: [{
            type: Input
        }], hostClass: [{
            type: HostBinding,
            args: ['attr.class']
        }], 
    /**
     * @hidden
     * @internal
     */
    keyEvent: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], data: [{
            type: Input
        }], removeIcon: [{
            type: Input
        }], selectIcon: [{
            type: Input
        }], dragDirective: [{
            type: ViewChild,
            args: ['chipArea', { read: IgxDragDirective, static: true }]
        }], chipArea: [{
            type: ViewChild,
            args: ['chipArea', { read: ElementRef, static: true }]
        }], selectContainer: [{
            type: ViewChild,
            args: ['selectContainer', { read: ElementRef, static: true }]
        }], defaultRemoveIcon: [{
            type: ViewChild,
            args: ['defaultRemoveIcon', { read: TemplateRef, static: true }]
        }], defaultSelectIcon: [{
            type: ViewChild,
            args: ['defaultSelectIcon', { read: TemplateRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxChipsAreaComponent, [{
        type: Component,
        args: [{
                selector: 'igx-chips-area',
                template: "<ng-content></ng-content>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.IterableDiffers }]; }, { class: [{
            type: Input
        }], onReorder: [{
            type: Output
        }], onSelection: [{
            type: Output
        }], onMoveStart: [{
            type: Output
        }], onMoveEnd: [{
            type: Output
        }], hostClass: [{
            type: HostBinding,
            args: ['attr.class']
        }], width: [{
            type: HostBinding,
            args: ['style.width.px']
        }, {
            type: Input
        }], height: [{
            type: HostBinding,
            args: ['style.height.px']
        }, {
            type: Input
        }], chipsList: [{
            type: ContentChildren,
            args: [IgxChipComponent, { descendants: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxChipsModule, { declarations: function () { return [IgxChipsAreaComponent, IgxChipComponent]; }, imports: function () { return [CommonModule, IgxRippleModule, IgxIconModule, IgxButtonModule, IgxAvatarModule, IgxDragDropModule, IgxPrefixModule, IgxSuffixModule]; }, exports: function () { return [IgxChipsAreaComponent, IgxChipComponent, IgxPrefixDirective, IgxSuffixDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxChipsModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxChipsAreaComponent,
                    IgxChipComponent
                ],
                exports: [
                    IgxChipsAreaComponent,
                    IgxChipComponent,
                    IgxPrefixDirective,
                    IgxSuffixDirective
                ],
                imports: [
                    CommonModule,
                    IgxRippleModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxAvatarModule,
                    IgxDragDropModule,
                    IgxPrefixModule,
                    IgxSuffixModule
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboHeaderDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboHeader]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboFooterDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboFooter]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboItem]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboEmptyDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboEmpty]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboHeaderItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboHeaderItem]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboAddItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboAddItem]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboToggleIconDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboToggleIcon]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboClearIconDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboClearIcon]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboAPIService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboItemComponent, [{
        type: Component,
        args: [{
                selector: 'igx-combo-item',
                template: "<ng-container *ngIf=\"!isHeader\">\n    <igx-checkbox [checked]=\"selected\" disableRipple=\"true\" [disableTransitions]=\"disableTransitions\" [tabindex]=\"-1\" (click)=\"disableCheck($event)\" class=\"igx-combo__checkbox\"></igx-checkbox>\n</ng-container>\n<span class=\"igx-drop-down__inner\"><ng-content></ng-content></span>\n"
            }]
    }], function () { return [{ type: IgxComboAPIService }, { type: undefined, decorators: [{
                type: Inject,
                args: [IGX_DROPDOWN_BASE]
            }] }, { type: ɵngcc0.ElementRef }, { type: IgxSelectionAPIService, decorators: [{
                type: Inject,
                args: [IgxSelectionAPIService]
            }] }]; }, { itemHeight: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['style.height.px']
        }] }); })();
const ɵIgxComboAddItemComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxComboAddItemComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboAddItemComponent, [{
        type: Component,
        args: [{
                selector: 'igx-combo-add-item',
                template: '<ng-content></ng-content>',
                providers: [{ provide: IgxComboItemComponent, useExisting: IgxComboAddItemComponent }]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboDropDownComponent, [{
        type: Component,
        args: [{
                selector: 'igx-combo-drop-down',
                template: "<div class=\"igx-drop-down__list\" [style.width]=\"width\"\nigxToggle\n(onAppended)=\"onToggleContentAppended()\"\n(onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n(onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <div class=\"igx-drop-down__list-scroll\" #scrollContainer [attr.id]=\"this.listId\" role=\"listbox\"\n    [style.height]=\"height\"\n    [style.maxHeight]=\"maxHeight\">\n        <ng-container *ngIf=\"!collapsed\">\n            <ng-content></ng-content>\n        </ng-container>\n    </div>\n</div>\n",
                providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxComboDropDownComponent }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxSelectionAPIService }, { type: undefined, decorators: [{
                type: Inject,
                args: [IGX_COMBO_COMPONENT]
            }] }, { type: IgxComboAPIService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { children: [{
            type: ContentChildren,
            args: [IgxComboItemComponent, { descendants: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboFilteringPipe, [{
        type: Pipe,
        args: [{
                name: 'comboFiltering'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboGroupingPipe, [{
        type: Pipe,
        args: [{
                name: 'comboGrouping'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_COMBO_COMPONENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboComponent, [{
        type: Component,
        args: [{
                selector: 'igx-combo',
                template: "<igx-input-group #inputGroup [displayDensity]=\"displayDensity\" [type]=\"type\" (click)=\"onInputClick($event)\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-hint, [igxHint]\">\n        <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n    </ng-container>\n    <input igxInput #comboInput name=\"comboInput\" type=\"text\" [value]=\"value\" readonly [attr.placeholder]=\"placeholder\"\n        [disabled]=\"disabled\" (blur)=\"onBlur()\" />\n    <ng-container ngProjectAs=\"igx-suffix\">\n        <ng-content select=\"igx-suffix\"></ng-content>\n    </ng-container>\n    <igx-suffix *ngIf=\"value.length\" aria-label=\"Clear Selection\" class=\"igx-combo__clear-button\"\n        (click)=\"handleClearItems($event)\">\n        <ng-container *ngIf=\"clearIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"clearIconTemplate\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!clearIconTemplate\" fontSet=\"material\">\n            clear\n        </igx-icon>\n    </igx-suffix>\n    <igx-suffix class=\"igx-combo__toggle-button\">\n        <ng-container *ngIf=\"toggleIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!toggleIconTemplate\" fontSet=\"material\">\n            {{ dropdown.collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}\n        </igx-icon>\n    </igx-suffix>\n</igx-input-group>\n<igx-combo-drop-down #igxComboDropDown class=\"igx-combo__drop-down\" [displayDensity]=\"displayDensity\"\n    [width]=\"itemsWidth || '100%'\" (onOpening)=\"handleOpening($event)\" (onClosing)=\"handleClosing($event)\"\n    (onOpened)=\"handleOpened()\" (onClosed)=\"handleClosed()\">\n    <igx-input-group *ngIf=\"displaySearchInput\" [displayDensity]=\"displayDensity\" class=\"igx-combo__search\">\n        <input class=\"igx-combo-input\" igxInput #searchInput name=\"searchInput\" autocomplete=\"off\" type=\"text\"\n            [(ngModel)]=\"searchValue\" (ngModelChange)=\"handleInputChange($event)\" (keyup)=\"handleKeyUp($event)\"\n            (keydown)=\"handleKeyDown($event)\" (focus)=\"dropdown.onBlur($event)\" [attr.placeholder]=\"searchPlaceholder\"\n            aria-autocomplete=\"both\" [attr.aria-owns]=\"dropdown.id\" [attr.aria-labelledby]=\"ariaLabelledBy\" />\n        <igx-suffix *ngIf=\"showSearchCaseIcon\">\n            <igx-icon fontSet=\"imx-icons\" name=\"case-sensitive\" [isActive]=\"filteringOptions.caseSensitive\"\n                (click)=\"toggleCaseSensitive()\">\n            </igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n    <ng-container *ngTemplateOutlet=\"headerTemplate\">\n    </ng-container>\n    <div #dropdownItemContainer class=\"igx-combo__content\" [style.overflow]=\"'hidden'\"\n        [style.maxHeight.px]=\"itemsMaxHeight\" [igxDropDownItemNavigation]=\"dropdown\" (focus)=\"dropdown.onFocus()\"\n        [tabindex]=\"dropdown.collapsed ? -1 : 0\" role=\"listbox\" [attr.id]=\"dropdown.id\">\n        <igx-combo-item role=\"option\" [itemHeight]='itemHeight' *igxFor=\"let item of data\n            | comboFiltering:filterValue:displayKey:filterable:filteringOptions\n            | comboGrouping:groupKey:valueKey;\n            index as rowIndex; containerSize: itemsMaxHeight; scrollOrientation: 'vertical'; itemSize: itemHeight\"\n            [value]=\"item\" [isHeader]=\"item.isHeader\" [index]=\"rowIndex\">\n            <ng-container *ngIf=\"item.isHeader\">\n                <ng-container\n                    *ngTemplateOutlet=\"headerItemTemplate ? headerItemTemplate : headerItemBase;\n                    context: {$implicit: item, data: data, valueKey: valueKey, groupKey: groupKey, displayKey: displayKey}\">\n                </ng-container>\n            </ng-container>\n            <ng-container *ngIf=\"!item.isHeader\">\n                <ng-container #listItem\n                    *ngTemplateOutlet=\"template; context: {$implicit: item, data: data, valueKey: valueKey, displayKey: displayKey};\">\n                </ng-container>\n            </ng-container>\n        </igx-combo-item>\n    </div>\n    <div class=\"igx-combo__add\" *ngIf=\"filteredData.length === 0 || isAddButtonVisible()\">\n        <div class=\"igx-combo__empty\" *ngIf=\"filteredData.length === 0\">\n            <ng-container *ngTemplateOutlet=\"emptyTemplate ? emptyTemplate : empty\">\n            </ng-container>\n        </div>\n        <igx-combo-add-item [itemHeight]='itemHeight' *ngIf=\"isAddButtonVisible()\"\n            [tabindex]=\"dropdown.collapsed ? -1 : customValueFlag ? 1 : -1\" class=\"igx-combo__add-item\" role=\"button\"\n            aria-label=\"Add Item\" [index]=\"virtualScrollContainer.igxForOf.length\">\n            <ng-container *ngTemplateOutlet=\"addItemTemplate ? addItemTemplate : addItemDefault\">\n            </ng-container>\n        </igx-combo-add-item>\n    </div>\n    <ng-container *ngTemplateOutlet=\"footerTemplate\">\n    </ng-container>\n</igx-combo-drop-down>\n<ng-template #complex let-display let-data=\"data\" let-key=\"displayKey\">\n    {{display[key]}}\n</ng-template>\n<ng-template #primitive let-display>\n    {{display}}\n</ng-template>\n<ng-template #empty>\n    <span>The list is empty</span>\n</ng-template>\n<ng-template #addItemDefault let-control>\n    <button igxButton=\"flat\" igxRipple>Add item</button>\n</ng-template>\n<ng-template #headerItemBase let-item let-key=\"valueKey\" let-groupKey=\"groupKey\">\n    {{ item[key] }}\n</ng-template>\n",
                providers: [
                    IgxComboAPIService,
                    { provide: IGX_COMBO_COMPONENT, useExisting: IgxComboComponent },
                    { provide: NG_VALUE_ACCESSOR, useExisting: IgxComboComponent, multi: true }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxSelectionAPIService }, { type: IgxComboAPIService }, { type: IgxIconService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [IGX_INPUT_GROUP_TYPE]
            }] }, { type: ɵngcc0.Injector, decorators: [{
                type: Optional
            }] }]; }, { overlaySettings: [{
            type: Input
        }], searchInput: [{
            type: ViewChild,
            args: ['searchInput']
        }], itemTemplate: [{
            type: ContentChild,
            args: [IgxComboItemDirective, { read: TemplateRef }]
        }], headerTemplate: [{
            type: ContentChild,
            args: [IgxComboHeaderDirective, { read: TemplateRef }]
        }], footerTemplate: [{
            type: ContentChild,
            args: [IgxComboFooterDirective, { read: TemplateRef }]
        }], headerItemTemplate: [{
            type: ContentChild,
            args: [IgxComboHeaderItemDirective, { read: TemplateRef }]
        }], addItemTemplate: [{
            type: ContentChild,
            args: [IgxComboAddItemDirective, { read: TemplateRef }]
        }], emptyTemplate: [{
            type: ContentChild,
            args: [IgxComboEmptyDirective, { read: TemplateRef }]
        }], toggleIconTemplate: [{
            type: ContentChild,
            args: [IgxComboToggleIconDirective, { read: TemplateRef }]
        }], clearIconTemplate: [{
            type: ContentChild,
            args: [IgxComboClearIconDirective, { read: TemplateRef }]
        }], dropdownContainer: [{
            type: ViewChild,
            args: ['dropdownItemContainer', { static: true }]
        }], onSelectionChange: [{
            type: Output
        }], onOpening: [{
            type: Output
        }], onOpened: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], onAddition: [{
            type: Output
        }], onSearchInput: [{
            type: Output
        }], onDataPreLoad: [{
            type: Output
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-combo']
        }], role: [{
            type: HostBinding,
            args: [`attr.role`]
        }], allowCustomValues: [{
            type: Input
        }], searchPlaceholder: [{
            type: Input
        }], showSearchCaseIcon: [{
            type: Input
        }], valueKey: [{
            type: Input
        }], filterable: [{
            type: Input
        }], disabled: [{
            type: Input
        }], autoFocusSearch: [{
            type: Input
        }], ariaExpanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], hasPopUp: [{
            type: HostBinding,
            args: ['attr.aria-haspopup']
        }], ariaOwns: [{
            type: HostBinding,
            args: ['attr.aria-owns']
        }], itemsMaxHeight: [{
            type: Input
        }], itemHeight: [{
            type: Input
        }], data: [{
            type: Input
        }], displayKey: [{
            type: Input
        }], groupKey: [{
            type: Input
        }], type: [{
            type: Input
        }], 
    /**
     * @hidden @internal
     */
    onArrowDown: [{
            type: HostListener,
            args: ['keydown.ArrowDown', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.Alt.ArrowDown', ['$event']]
        }], virtDir: [{
            type: ViewChild,
            args: [IgxForOfDirective, { read: IgxForOfDirective, static: true }]
        }], inputGroup: [{
            type: ViewChild,
            args: ['inputGroup', { read: IgxInputGroupComponent, static: true }]
        }], comboInput: [{
            type: ViewChild,
            args: ['comboInput', { read: IgxInputDirective, static: true }]
        }], dropdown: [{
            type: ViewChild,
            args: [IgxComboDropDownComponent, { read: IgxComboDropDownComponent, static: true }]
        }], primitiveTemplate: [{
            type: ViewChild,
            args: ['primitive', { read: TemplateRef, static: true }]
        }], complexTemplate: [{
            type: ViewChild,
            args: ['complex', { read: TemplateRef, static: true }]
        }], virtualScrollContainer: [{
            type: ViewChild,
            args: [IgxForOfDirective, { static: true }]
        }], width: [{
            type: HostBinding,
            args: ['style.width']
        }, {
            type: Input
        }], itemsWidth: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], ariaLabelledBy: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-labelledby']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxComboModule, { declarations: function () { return [IgxComboComponent, IgxComboItemComponent, IgxComboGroupingPipe, IgxComboFilteringPipe, IgxComboDropDownComponent, IgxComboAddItemComponent, IgxComboItemDirective, IgxComboEmptyDirective, IgxComboHeaderItemDirective, IgxComboHeaderDirective, IgxComboFooterDirective, IgxComboAddItemDirective, IgxComboToggleIconDirective, IgxComboClearIconDirective]; }, imports: function () { return [IgxRippleModule, CommonModule, IgxInputGroupModule, FormsModule, ReactiveFormsModule, IgxForOfModule, IgxToggleModule, IgxCheckboxModule, IgxDropDownModule, IgxButtonModule, IgxIconModule]; }, exports: function () { return [IgxComboComponent, IgxComboItemComponent, IgxComboDropDownComponent, IgxComboAddItemComponent, IgxComboItemDirective, IgxComboEmptyDirective, IgxComboHeaderItemDirective, IgxComboHeaderDirective, IgxComboFooterDirective, IgxComboAddItemDirective, IgxComboToggleIconDirective, IgxComboClearIconDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxComboComponent, IgxComboItemComponent, IgxComboGroupingPipe,
                    IgxComboFilteringPipe, IgxComboDropDownComponent, IgxComboAddItemComponent,
                    IgxComboItemDirective,
                    IgxComboEmptyDirective,
                    IgxComboHeaderItemDirective,
                    IgxComboHeaderDirective,
                    IgxComboFooterDirective,
                    IgxComboAddItemDirective,
                    IgxComboToggleIconDirective,
                    IgxComboClearIconDirective],
                exports: [IgxComboComponent, IgxComboItemComponent, IgxComboDropDownComponent, IgxComboAddItemComponent,
                    IgxComboItemDirective,
                    IgxComboEmptyDirective,
                    IgxComboHeaderItemDirective,
                    IgxComboHeaderDirective,
                    IgxComboFooterDirective,
                    IgxComboAddItemDirective,
                    IgxComboToggleIconDirective,
                    IgxComboClearIconDirective],
                imports: [IgxRippleModule, CommonModule, IgxInputGroupModule, FormsModule, ReactiveFormsModule,
                    IgxForOfModule, IgxToggleModule, IgxCheckboxModule, IgxDropDownModule, IgxButtonModule, IgxIconModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatePickerDisplayValuePipe, [{
        type: Pipe,
        args: [{
                name: 'displayValue'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_DATE_PICKER_COMPONENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatePickerInputValuePipe, [{
        type: Pipe,
        args: [{
                name: 'inputValue'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_DATE_PICKER_COMPONENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDatePickerTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDatePickerTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDatePickerActionsDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDatePickerActions]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarContainerComponent, [{
        type: Component,
        args: [{
                selector: 'igx-calendar-container',
                template: "<ng-template #defaultDatePickerActions>\n    <div *ngIf=\"cancelButtonLabel || todayButtonLabel\" class=\"igx-date-picker__buttons\">\n        <button #closeButton *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"closeCalendar()\">\n            {{ cancelButtonLabel }}\n        </button>\n        <button #todayButton *ngIf=\"todayButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"triggerTodaySelection()\">\n            {{ todayButtonLabel }}\n        </button>\n    </div>\n</ng-template>\n<igx-calendar #calendar></igx-calendar>\n<ng-container *ngTemplateOutlet=\"datePickerActions ? datePickerActions.template : defaultDatePickerActions\"></ng-container>\n",
                styles: [':host {display: block;}']
            }]
    }], function () { return []; }, { mode: [{
            type: Input
        }], vertical: [{
            type: Input
        }], onClose: [{
            type: Output
        }], onTodaySelection: [{
            type: Output
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-date-picker']
        }], dropdownCSS: [{
            type: HostBinding,
            args: ['class.igx-date-picker--dropdown']
        }], verticalCSS: [{
            type: HostBinding,
            args: ['class.igx-date-picker--vertical']
        }], onEscape: [{
            type: HostListener,
            args: ['keydown.esc', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.alt.arrowup', ['$event']]
        }], calendar: [{
            type: ViewChild,
            args: ['calendar', { static: true }]
        }], cancelButtonLabel: [{
            type: Input
        }], todayButtonLabel: [{
            type: Input
        }], datePickerActions: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDatePickerComponent, [{
        type: Component,
        args: [{
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxDatePickerComponent,
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: IgxDatePickerComponent,
                        multi: true
                    }],
                // tslint:disable-next-line:component-selector
                selector: 'igx-date-picker',
                template: "<ng-template #labelTemplate>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #readOnlyDatePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\">\n        <ng-container ngProjectAs=\"[igxLabel]\" *ngTemplateOutlet=\"labelTemplate\"></ng-container>\n        <igx-prefix>\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility&&!_labelDirectiveUserTemplate\" igxLabel>{{label}}</label>\n        <input\n            class=\"igx-date-picker__input-date\"\n            igxInput\n            [value]=\"displayData || ''\"\n            [disabled]=\"disabled\"\n            (blur)=\"onBlur($event)\"\n            [tabindex]='editorTabIndex'\n            readonly\n        />\n    </igx-input-group>\n</ng-template>\n\n<ng-template #editableDatePickerTemplate>\n    <igx-input-group #editableInputGroup>\n        <ng-container ngProjectAs=\"[igxLabel]\" *ngTemplateOutlet=\"labelTemplate\"></ng-container>\n        <igx-prefix (click)=\"onOpenClick($event)\">\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility&&!_labelDirectiveUserTemplate\" igxLabel>{{label}}</label>\n        <input\n            class=\"igx-date-picker__input-date\"\n            igxInput\n            type=\"text\"\n            [value]=\"transformedDate\"\n            [igxMask]=\"inputMask\"\n            [placeholder]=\"mask\"\n            [igxTextSelection]=\"true\"\n            [disabled]=\"disabled\"\n            [displayValuePipe]=\"displayValuePipe\"\n            [focusedValuePipe]=\"inputValuePipe\"\n            (blur)=\"onBlur($event)\"\n            (wheel)=\"onWheel($event)\"\n            (input)=\"onInput($event)\"\n            (focus)=\"onFocus()\"\n            [tabindex]='editorTabIndex'\n        />\n        <igx-suffix *ngIf=\"!isEmpty\" (click)=\"clear()\">\n            <igx-icon>clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }]
    }], function () { return [{ type: IgxOverlayService, decorators: [{
                type: Inject,
                args: [IgxOverlayService]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgModuleRef }, { type: ɵngcc0.Injector }, { type: ɵngcc0.Renderer2 }]; }, { label: [{
            type: Input
        }], labelVisibility: [{
            type: Input
        }], weekStart: [{
            type: Input
        }], monthsViewNumber: [{
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], vertical: [{
            type: Input
        }], mode: [{
            type: Input
        }], isSpinLoop: [{
            type: Input
        }], onOpened: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], onSelection: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], onDisabledDate: [{
            type: Output
        }], onValidationFailed: [{
            type: Output
        }], formatOptions: [{
            type: Input
        }], format: [{
            type: Input
        }], formatViews: [{
            type: Input
        }], disabledDates: [{
            type: Input
        }], specialDates: [{
            type: Input
        }], modalOverlaySettings: [{
            type: Input
        }], dropDownOverlaySettings: [{
            type: Input
        }], value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], 
    //#endregion
    /**
     * @hidden
     */
    onSpaceClick: [{
            type: HostListener,
            args: ['keydown.spacebar', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.space', ['$event']]
        }], mask: [{
            type: Input
        }], locale: [{
            type: Input
        }], editorTabIndex: [{
            type: Input
        }], hideOutsideDays: [{
            type: Input
        }], showWeekNumbers: [{
            type: Input
        }], formatter: [{
            type: Input
        }], todayButtonLabel: [{
            type: Input
        }], cancelButtonLabel: [{
            type: Input
        }], outlet: [{
            type: Input
        }], readOnlyDatePickerTemplate: [{
            type: ViewChild,
            args: ['readOnlyDatePickerTemplate', { read: TemplateRef, static: true }]
        }], editableDatePickerTemplate: [{
            type: ViewChild,
            args: ['editableDatePickerTemplate', { read: TemplateRef, static: true }]
        }], _inputGroup: [{
            type: ViewChild,
            args: [IgxInputGroupComponent]
        }], _inputGroupUserTemplate: [{
            type: ContentChild,
            args: [IgxInputGroupComponent]
        }], _inputElementRef: [{
            type: ViewChild,
            args: [IgxInputDirective, { read: ElementRef }]
        }], _inputUserTemplateElementRef: [{
            type: ContentChild,
            args: [IgxInputDirective, { read: ElementRef }]
        }], _inputDirective: [{
            type: ViewChild,
            args: [IgxInputDirective]
        }], _inputDirectiveUserTemplates: [{
            type: ContentChildren,
            args: [IgxInputDirective, { descendants: true }]
        }], _labelDirective: [{
            type: ViewChild,
            args: [IgxLabelDirective]
        }], _labelDirectiveUserTemplate: [{
            type: ContentChild,
            args: [IgxLabelDirective]
        }], datePickerTemplateDirective: [{
            type: ContentChild,
            args: [IgxDatePickerTemplateDirective, { read: IgxDatePickerTemplateDirective }]
        }], headerTemplate: [{
            type: ContentChild,
            args: [IgxCalendarHeaderTemplateDirective, { read: IgxCalendarHeaderTemplateDirective }]
        }], subheaderTemplate: [{
            type: ContentChild,
            args: [IgxCalendarSubheaderTemplateDirective, { read: IgxCalendarSubheaderTemplateDirective }]
        }], datePickerActionsDirective: [{
            type: ContentChild,
            args: [IgxDatePickerActionsDirective, { read: IgxDatePickerActionsDirective }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDatePickerModule, { declarations: function () { return [IgxDatePickerComponent, IgxCalendarContainerComponent, IgxDatePickerActionsDirective, IgxDatePickerTemplateDirective, DatePickerDisplayValuePipe, DatePickerInputValuePipe]; }, imports: function () { return [CommonModule, IgxIconModule, IgxInputGroupModule, IgxCalendarModule, IgxButtonModule, IgxRippleModule, IgxMaskModule, IgxTextSelectionModule]; }, exports: function () { return [IgxDatePickerComponent, IgxDatePickerTemplateDirective, IgxDatePickerActionsDirective, DatePickerDisplayValuePipe, DatePickerInputValuePipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDatePickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxDatePickerComponent,
                    IgxCalendarContainerComponent,
                    IgxDatePickerActionsDirective,
                    IgxDatePickerTemplateDirective,
                    DatePickerDisplayValuePipe,
                    DatePickerInputValuePipe
                ],
                entryComponents: [
                    IgxCalendarContainerComponent
                ],
                exports: [
                    IgxDatePickerComponent,
                    IgxDatePickerTemplateDirective,
                    IgxDatePickerActionsDirective,
                    DatePickerDisplayValuePipe,
                    DatePickerInputValuePipe
                ],
                imports: [
                    CommonModule,
                    IgxIconModule,
                    IgxInputGroupModule,
                    IgxCalendarModule,
                    IgxButtonModule,
                    IgxRippleModule,
                    IgxMaskModule,
                    IgxTextSelectionModule
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDialogTitleDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-dialog-title,[igxDialogTitle]'
            }]
    }], function () { return []; }, { defaultStyle: [{
            type: HostBinding,
            args: ['class.igx-dialog__window-title']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDialogActionsDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-dialog-actions,[igxDialogActions]'
            }]
    }], function () { return []; }, { defaultClass: [{
            type: HostBinding,
            args: ['class.igx-dialog__window-actions']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDialogComponent, [{
        type: Component,
        args: [{
                selector: 'igx-dialog',
                template: "<div tabindex=\"0\" #dialog class=\"igx-dialog\" igxToggle (click)=\"onDialogSelected($event)\">\n    <div #dialogWindow class=\"igx-dialog__window\"  [attr.role]=\"role\" [attr.aria-labelledby]=\"titleId\">\n\n        <div *ngIf=\"title\" [attr.id]=\"titleId\" class=\"igx-dialog__window-title\">\n            {{ title }}\n        </div>\n        <ng-content *ngIf=\"!title\" select=\"igx-dialog-title,[igxDialogTitle]\"></ng-content>\n\n        <div class=\"igx-dialog__window-content\" *ngIf=\"message\">{{ message }}</div>\n        <ng-content *ngIf=\"!message\"></ng-content>\n\n        <div *ngIf=\"leftButtonLabel || rightButtonLabel\" class=\"igx-dialog__window-actions\">\n            <button *ngIf=\"leftButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ leftButtonType }}\" igxButtonColor=\"{{ leftButtonColor }}\" igxButtonBackground=\"{{ leftButtonBackgroundColor }}\"\n                igxRipple=\"{{ leftButtonRipple }}\" (click)=\"onInternalLeftButtonSelect($event)\">\n                {{ leftButtonLabel }}\n            </button>\n            <button *ngIf=\"rightButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ rightButtonType }}\" igxButtonColor=\"{{ rightButtonColor }}\" igxButtonBackground=\"{{ rightButtonBackgroundColor }}\"\n                igxRipple=\"{{ rightButtonRipple }}\" (click)=\"onInternalRightButtonSelect($event)\">\n                {{ rightButtonLabel }}\n            </button>\n        </div>\n        <ng-content *ngIf=\"!leftButtonLabel && !rightButtonLabel\" select=\"igx-dialog-actions,[igxDialogActions]\"></ng-content>\n\n    </div>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], title: [{
            type: Input
        }], message: [{
            type: Input
        }], leftButtonLabel: [{
            type: Input
        }], leftButtonType: [{
            type: Input
        }], leftButtonColor: [{
            type: Input
        }], leftButtonBackgroundColor: [{
            type: Input
        }], leftButtonRipple: [{
            type: Input
        }], rightButtonLabel: [{
            type: Input
        }], rightButtonType: [{
            type: Input
        }], rightButtonColor: [{
            type: Input
        }], rightButtonBackgroundColor: [{
            type: Input
        }], rightButtonRipple: [{
            type: Input
        }], onOpen: [{
            type: Output
        }], onClose: [{
            type: Output
        }], onLeftButtonSelect: [{
            type: Output
        }], onRightButtonSelect: [{
            type: Output
        }], isOpenChange: [{
            type: Output
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], isModal: [{
            type: Input
        }], closeOnEscape: [{
            type: Input
        }], closeOnOutsideSelect: [{
            type: Input
        }], positionSettings: [{
            type: Input
        }], isOpen: [{
            type: Input
        }], isCollapsed: [{
            type: HostBinding,
            args: ['class.igx-dialog--hidden']
        }], role: [{
            type: Input
        }], titleId: [{
            type: Input
        }], toggleRef: [{
            type: ViewChild,
            args: [IgxToggleDirective, { static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDialogModule, { declarations: function () { return [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective]; }, imports: function () { return [CommonModule, IgxToggleModule, IgxButtonModule, IgxRippleModule, IgxFocusModule]; }, exports: function () { return [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDialogModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                exports: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                imports: [CommonModule, IgxToggleModule, IgxButtonModule, IgxRippleModule, IgxFocusModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTemplateOutletDirective, [{
        type: Directive,
        args: [{ selector: '[igxTemplateOutlet]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }]; }, { onViewCreated: [{
            type: Output
        }], onViewMoved: [{
            type: Output
        }], onCachedViewLoaded: [{
            type: Output
        }], onBeforeViewDetach: [{
            type: Output
        }], igxTemplateOutletContext: [{
            type: Input
        }], igxTemplateOutlet: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTemplateOutletModule, { declarations: function () { return [IgxTemplateOutletDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxTemplateOutletDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTemplateOutletModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxTemplateOutletDirective],
                entryComponents: [],
                exports: [IgxTemplateOutletDirective],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxProcessBarTextTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxProcessBarText]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxProgressBarGradientDirective, [{
        type: Directive,
        args: [{
                selector: '[igxProgressBarGradient]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDirectionality, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DIR_DOCUMENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BaseProgressDirective, [{
        type: Directive
    }], function () { return []; }, { onProgressChanged: [{
            type: Output
        }], step: [{
            type: Input
        }], animate: [{
            type: Input
        }], max: [{
            type: HostBinding,
            args: ['attr.aria-valuemax']
        }, {
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxLinearProgressBarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-linear-bar',
                template: "<div class=\"igx-linear-bar__base\">\n    <div class=\"igx-linear-bar__indicator\" [style.width.%]=\"valueInPercent\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n"
            }]
    }], function () { return []; }, { valueMin: [{
            type: HostBinding,
            args: ['attr.aria-valuemin']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-linear-bar']
        }], striped: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--striped']
        }, {
            type: Input
        }], indeterminate: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--indeterminate']
        }, {
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], textAlign: [{
            type: Input
        }], textVisibility: [{
            type: Input
        }], textTop: [{
            type: Input
        }], type: [{
            type: Input
        }], value: [{
            type: HostBinding,
            args: ['attr.aria-valuenow']
        }, {
            type: Input
        }], error: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--danger']
        }], info: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--info']
        }], warning: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--warning']
        }], success: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--success']
        }], text: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCircularProgressBarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-circular-bar',
                template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:text *ngIf=\"textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n        </ng-container>\n    </svg:text>\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultTextTemplate>\n        <svg:tspan class=\"igx-circular-bar__text\">\n            {{textContent ? textContent: valueInPercent + '%'}}\n        </svg:tspan>\n    </ng-template>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n"
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: IgxDirectionality }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-circular-bar']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], indeterminate: [{
            type: HostBinding,
            args: ['class.igx-circular-bar--indeterminate']
        }, {
            type: Input
        }], textVisibility: [{
            type: Input
        }], value: [{
            type: Input
        }], text: [{
            type: Input
        }], textTemplate: [{
            type: ContentChild,
            args: [IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective }]
        }], gradientTemplate: [{
            type: ContentChild,
            args: [IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective }]
        }], _svgCircle: [{
            type: ViewChild,
            args: ['circle', { static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxProgressBarModule, { declarations: function () { return [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective, IgxProgressBarGradientDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective, IgxProgressBarGradientDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxProgressBarModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxLinearProgressBarComponent,
                    IgxCircularProgressBarComponent,
                    IgxProcessBarTextTemplateDirective,
                    IgxProgressBarGradientDirective,
                ],
                exports: [
                    IgxLinearProgressBarComponent,
                    IgxCircularProgressBarComponent,
                    IgxProcessBarTextTemplateDirective,
                    IgxProgressBarGradientDirective,
                ],
                imports: [CommonModule]
            }]
    }], null, null); })();
const ɵIgxSelectItemComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxSelectItemComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectItemComponent, [{
        type: Component,
        args: [{
                selector: 'igx-select-item',
                template: '<span class="igx-drop-down__inner"><ng-content></ng-content></span>'
            }]
    }], null, { text: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectToggleIconDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSelectToggleIcon]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectHeaderDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSelectHeader]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectFooterDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSelectFooter]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectComponent, [{
        type: Component,
        args: [{
                selector: 'igx-select',
                template: "<igx-input-group #inputGroup class=\"input-group\" (click)=\"inputGroupClick($event)\" [type]=\"type\" [displayDensity]=\"displayDensity\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n    </ng-container>\n    <input #input class=\"input\" type=\"text\" igxInput [igxSelectItemNavigation]=\"this\"\n        [disabled]=\"disabled\"\n        readonly=\"true\"\n        [attr.placeholder]=\"this.placeholder\"\n        [value]=\"this.selectionValue\"\n        role=\"combobox\"\n        aria-haspopup=\"listbox\"\n        [attr.aria-labelledby]=\"this.label?.id\"\n        [attr.aria-expanded]=\"!this.collapsed\"\n        [attr.aria-owns]=\"this.listId\"\n        [attr.aria-activedescendant]=\"!this.collapsed ? this.focusedItem?.id : null\"\n        (blur)=\"onBlur()\"\n        (focus)=\"onFocus()\"\n    />\n    <ng-container ngProjectAs=\"igx-suffix\">\n            <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n    </ng-container>\n    <igx-suffix>\n        <ng-container *ngIf=\"toggleIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n            </ng-container>\n        <igx-icon *ngIf=\"!toggleIconTemplate\" fontSet=\"material\">{{ collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}</igx-icon>\n    </igx-suffix>\n    <ng-container ngProjectAs=\"igx-hint, [igxHint]\" >\n        <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n    </ng-container>\n</igx-input-group>\n<div igxToggle class=\"igx-drop-down__list\" (mousedown)=\"mousedownHandler($event);\" (onOpening)=\"handleOpening($event)\"\n    (onOpened)=\"handleOpened()\" (onClosing)=\"handleClosing($event)\" (onClosed)=\"handleClosed()\">\n\n    <div *ngIf=\"headerTemplate\" class=\"igx-drop-down__select-header\">\n        <ng-content *ngTemplateOutlet=\"headerTemplate\"></ng-content>\n    </div>\n\n    <!-- #7436 LMB scrolling closes items container - unselectable attribute is IE specific  -->\n    <div #scrollContainer class=\"igx-drop-down__list-scroll\" unselectable=\"on\" [style.maxHeight]=\"maxHeight\"\n        [attr.id]=\"this.listId\" role=\"listbox\" [attr.aria-labelledby]=\"this.label?.id\">\n        <ng-content select=\"igx-select-item, igx-select-item-group\"></ng-content>\n    </div>\n\n    <div *ngIf=\"footerTemplate\" class=\"igx-drop-down__select-footer\">\n        <ng-container *ngTemplateOutlet=\"footerTemplate\"></ng-container>\n    </div>\n</div>\n",
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: IgxSelectComponent, multi: true },
                    { provide: IGX_DROPDOWN_BASE, useExisting: IgxSelectComponent }
                ],
                styles: [`
        :host {
            display: block;
        }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxSelectionAPIService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [IGX_INPUT_GROUP_TYPE]
            }] }, { type: ɵngcc0.Injector }]; }, { disabled: [{
            type: Input
        }], maxHeight: [{
            type: HostBinding,
            args: ['style.maxHeight']
        }], onOpening: [{
            type: Output
        }], onOpened: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], toggleIconTemplate: [{
            type: ContentChild,
            args: [IgxSelectToggleIconDirective, { read: TemplateRef }]
        }], headerTemplate: [{
            type: ContentChild,
            args: [IgxSelectHeaderDirective, { read: TemplateRef, static: false }]
        }], footerTemplate: [{
            type: ContentChild,
            args: [IgxSelectFooterDirective, { read: TemplateRef, static: false }]
        }], value: [{
            type: Input
        }], type: [{
            type: Input
        }], inputGroup: [{
            type: ViewChild,
            args: ['inputGroup', { read: IgxInputGroupComponent, static: true }]
        }], input: [{
            type: ViewChild,
            args: ['input', { read: IgxInputDirective, static: true }]
        }], hintElement: [{
            type: ContentChild,
            args: [IgxHintDirective, { read: ElementRef }]
        }], children: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxSelectItemComponent), { descendants: true }]
        }], label: [{
            type: ContentChild,
            args: [forwardRef(() => IgxLabelDirective), { static: true }]
        }], placeholder: [{
            type: Input
        }], overlaySettings: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectItemNavigationDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSelectItemNavigation]'
            }]
    }], function () { return []; }, { target: [{
            type: Input,
            args: ['igxSelectItemNavigation']
        }], 
    /** Handle continuous letter typing navigation */
    captureKey: [{
            type: HostListener,
            args: ['keyup', ['$event']]
        }] }); })();
const ɵIgxSelectGroupComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxSelectGroupComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectGroupComponent, [{
        type: Component,
        args: [{
                selector: 'igx-select-item-group',
                template: `
        <label id="{{labelId}}">{{ label }}</label>
        <ng-content select="igx-select-item"></ng-content>
    `
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxSelectModule, { declarations: function () { return [IgxSelectComponent, IgxSelectFooterDirective, IgxSelectGroupComponent, IgxSelectHeaderDirective, IgxSelectItemComponent, IgxSelectItemNavigationDirective, IgxSelectToggleIconDirective]; }, imports: function () { return [CommonModule,
        FormsModule, IgxButtonModule, IgxDropDownModule, IgxIconModule, IgxInputGroupModule, IgxRippleModule, IgxToggleModule, ReactiveFormsModule]; }, exports: function () { return [IgxSelectComponent, IgxSelectFooterDirective, IgxSelectGroupComponent, IgxSelectHeaderDirective, IgxSelectItemComponent, IgxSelectItemNavigationDirective, IgxSelectToggleIconDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxSelectComponent,
                    IgxSelectFooterDirective,
                    IgxSelectGroupComponent,
                    IgxSelectHeaderDirective,
                    IgxSelectItemComponent,
                    IgxSelectItemNavigationDirective,
                    IgxSelectToggleIconDirective
                ],
                exports: [
                    IgxSelectComponent,
                    IgxSelectFooterDirective,
                    IgxSelectGroupComponent,
                    IgxSelectHeaderDirective,
                    IgxSelectItemComponent,
                    IgxSelectItemNavigationDirective,
                    IgxSelectToggleIconDirective
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    IgxButtonModule,
                    IgxDropDownModule,
                    IgxIconModule,
                    IgxInputGroupModule,
                    IgxRippleModule,
                    IgxToggleModule,
                    ReactiveFormsModule
                ],
                providers: []
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFilterCellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxFilterCellTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCell]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCellHeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxHeader]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCellFooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxFooter]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCellEditorTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCellEditor]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCollapsibleIndicatorTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCollapsibleIndicator]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnMovingService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-column',
                template: ``
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { header: [{
            type: Input
        }], title: [{
            type: Input
        }], sortable: [{
            type: Input
        }], groupable: [{
            type: Input
        }], filterable: [{
            type: Input
        }], resizable: [{
            type: Input
        }], hiddenChange: [{
            type: Output
        }], expandedChange: [{
            type: Output
        }], collapsibleChange: [{
            type: Output
        }], visibleWhenCollapsedChange: [{
            type: Output
        }], onColumnChange: [{
            type: Output
        }], disableHiding: [{
            type: Input
        }], disablePinning: [{
            type: Input
        }], movable: [{
            type: Input
        }], widthChange: [{
            type: Output
        }], headerClasses: [{
            type: Input
        }], headerGroupClasses: [{
            type: Input
        }], cellStyles: [{
            type: Input
        }], filteringIgnoreCase: [{
            type: Input
        }], sortingIgnoreCase: [{
            type: Input
        }], dataType: [{
            type: Input
        }], pinnedChange: [{
            type: Output
        }], searchable: [{
            type: Input
        }], selectable: [{
            type: Input
        }], editable: [{
            type: Input
        }], hasSummary: [{
            type: Input
        }], hidden: [{
            type: Input
        }], width: [{
            type: Input
        }], minWidth: [{
            type: Input
        }], pinned: [{
            type: Input
        }], summaries: [{
            type: Input
        }], filters: [{
            type: Input
        }], sortStrategy: [{
            type: Input
        }], groupingComparer: [{
            type: Input
        }], bodyTemplate: [{
            type: Input,
            args: ['cellTemplate']
        }], headerTemplate: [{
            type: Input
        }], inlineEditorTemplate: [{
            type: Input,
            args: ['cellEditorTemplate']
        }], filterCellTemplate: [{
            type: Input,
            args: ['filterCellTemplate']
        }], visibleWhenCollapsed: [{
            type: Input
        }], pipeArgs: [{
            type: Input
        }], field: [{
            type: Input
        }], maxWidth: [{
            type: Input
        }], cellClasses: [{
            type: Input
        }], formatter: [{
            type: Input
        }], collapsibleIndicatorTemplate: [{
            type: Input
        }], rowEnd: [{
            type: Input
        }], colEnd: [{
            type: Input
        }], rowStart: [{
            type: Input
        }], colStart: [{
            type: Input
        }], cellTemplate: [{
            type: ContentChild,
            args: [IgxCellTemplateDirective, { read: IgxCellTemplateDirective }]
        }], headTemplate: [{
            type: ContentChildren,
            args: [IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective, descendants: false }]
        }], editorTemplate: [{
            type: ContentChild,
            args: [IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective }]
        }], filterCellTemplateDirective: [{
            type: ContentChild,
            args: [IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective }]
        }], collapseIndicatorTemplate: [{
            type: ContentChild,
            args: [IgxCollapsibleIndicatorTemplateDirective, { read: IgxCollapsibleIndicatorTemplateDirective, static: false }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridBodyDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGridBody]',
                providers: [IgxForOfSyncService]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnActionsComponent, [{
        type: Component,
        args: [{
                selector: 'igx-column-actions',
                template: "<div class=\"igx-column-actions__header\">\n    <h4 [attr.id]='titleID' class=\"igx-column-actions__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-actions__header-input\" *ngIf=\"!hideFilter\">\n        <input igxInput\n            type=\"text\"\n            [attr.aria-describedby]='titleID'\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-actions__columns\" tabindex=\"0\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox\n        *ngFor=\"let column of columns\n            | columnActionEnabled:actionsDirective.actionEnabledColumnsFilter:pipeTrigger\n            | filterActionColumns:filterCriteria:pipeTrigger\n            | sortActionColumns:columnDisplayOrder:pipeTrigger;\"\n        class=\"igx-column-actions__columns-item\"\n\n        (change)=\"toggleColumn($event, column)\"\n        [checked]=\"actionsDirective.columnChecked(column)\"\n        [style.margin-left.px]=\"column.level * indentation\">\n        {{ column.header || column.field }}\n    </igx-checkbox>\n</div>\n\n<div class=\"igx-column-actions__buttons\">\n    <button igxButton igxRipple (click)=\"uncheckAllColumns()\" [disabled]=\"uncheckAllDisabled\">{{ uncheckAllText }}</button>\n    <button igxButton igxRipple (click)=\"checkAllColumns()\" [disabled]=\"checkAllDisabled\">{{ checkAllText }}</button>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.IterableDiffers }]; }, { title: [{
            type: Input
        }], hideFilter: [{
            type: Input
        }], columnsAreaMaxHeight: [{
            type: Input
        }], indentation: [{
            type: Input
        }], onColumnToggled: [{
            type: Output
        }], cssClass: [{
            type: HostBinding,
            args: ['attr.class']
        }], columns: [{
            type: Input
        }], grid: [{
            type: Input
        }], filterColumnsPrompt: [{
            type: Input
        }], filterCriteria: [{
            type: Input
        }], columnDisplayOrder: [{
            type: Input
        }], uncheckAllText: [{
            type: Input
        }], checkAllText: [{
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], columnItems: [{
            type: ViewChildren,
            args: [IgxCheckboxComponent]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnActionsBaseDirective, [{
        type: Directive
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnHidingDirective, [{
        type: Directive,
        args: [{
                selector: '[igxColumnHiding]'
            }]
    }], function () { return [{ type: IgxColumnActionsComponent, decorators: [{
                type: Inject,
                args: [IgxColumnActionsComponent]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnPinningDirective, [{
        type: Directive,
        args: [{
                selector: '[igxColumnPinning]'
            }]
    }], function () { return [{ type: IgxColumnActionsComponent, decorators: [{
                type: Inject,
                args: [IgxColumnActionsComponent]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridToolbarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-grid-toolbar',
                template: "<span class=\"igx-grid-toolbar__title\" *ngIf=\"getTitle()\">\n    {{ getTitle() }}\n</span>\n\n<div class=\"igx-grid-toolbar__custom-content\" *ngIf=\"customContentTemplate != null\">\n    <ng-container *ngTemplateOutlet=\"customContentTemplate; context: context\">\n    </ng-container>\n</div>\n\n<div class=\"igx-grid-toolbar__actions\">\n    <div *ngIf=\"grid.allowAdvancedFiltering\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #advancedFilteringButton name=\"btnAdvancedFiltering\" igxRipple\n            (click)=\"showAdvancedFilteringUI()\"\n                [ngClass]=\"grid.advancedFilteringExpressionsTree ? 'igx-grid-toolbar__adv-filter--filtered' : 'igx-grid-toolbar__adv-filter'\">\n            <div class=\"igx-grid-toolbar__button-space\">\n                <igx-icon>\n                    filter_list\n                </igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_title}}</span>\n            </div>\n        </button>\n    </div>\n\n    <div *ngIf=\"grid.columnHiding\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #columnHidingButton name=\"btnColumnHiding\" igxRipple\n            (click)=\"toggleColumnHidingUI()\">\n            <div class=\"igx-grid-toolbar__button-space\">\n                <igx-icon *ngIf=\"grid.hiddenColumnsCount > 0\">visibility_off</igx-icon>\n                <igx-icon *ngIf=\"grid.hiddenColumnsCount === 0\">visibility</igx-icon>\n                <span>{{ grid.hiddenColumnsCount }}</span>\n                <span>{{ grid.hiddenColumnsText }}</span>\n            </div>\n        </button>\n        <igx-drop-down #columnHidingDropdown (onClosing)=\"onClosingColumnHiding($event)\">\n            <igx-column-actions\n                igxColumnHiding\n                [grid]=\"grid\"\n                [title]=\"grid.columnHidingTitle\"\n                [filterColumnsPrompt]=\"filterColumnsPrompt\"\n                [columnsAreaMaxHeight]=\"defaultDropDownsMaxHeight\">\n            </igx-column-actions>\n        </igx-drop-down>\n    </div>\n\n    <div *ngIf=\"grid.columnPinning\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #columnPinningButton name=\"btnColumnPinning\" igxRipple\n            (click)=\"toggleColumnPinningUI()\">\n            <div  class=\"igx-grid-toolbar__button-space\">\n                <igx-icon *ngIf=\"pinnedColumnsCount > 0\" fontSet=\"imx-icons\" name=\"pin-left\"></igx-icon>\n                <igx-icon *ngIf=\"pinnedColumnsCount === 0\" fontSet=\"imx-icons\" name=\"unpin-left\"></igx-icon>\n                <span>{{ pinnedColumnsCount }}</span>\n                <span>{{ grid.pinnedColumnsText }}</span>\n                <span></span>\n            </div>\n        </button>\n        <igx-drop-down #columnPinningDropdown (onClosing)=\"onClosingColumnPinning($event)\">\n            <igx-column-actions\n                igxColumnPinning\n                [grid]=\"grid\"\n                [title]=\"grid.columnPinningTitle\"\n                [filterColumnsPrompt]=\"filterColumnsPrompt\"\n                [columnsAreaMaxHeight]=\"defaultDropDownsMaxHeight\">\n            </igx-column-actions>\n        </igx-drop-down>\n    </div>\n\n    <div class=\"igx-grid-toolbar__dropdown\" *ngIf=\"shouldShowExportButton\" id=\"btnExport\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" igxRipple #btnExport\n                (click)=\"exportClicked()\" [disabled]=\"isExporting\">\n            <span class=\"igx-grid-toolbar__button-space\">\n                <igx-icon fontSet=\"material\">import_export</igx-icon>\n                <span>{{ getExportText() }}</span>\n                <igx-icon fontSet=\"material\">arrow_drop_down</igx-icon>\n            </span>\n        </button>\n\n        <igx-drop-down #exportDropdown>\n            <ul class=\"igx-grid-toolbar__dd-list\">\n                <li class=\"igx-grid-toolbar__dd-list-items\" igxRipple *ngIf=\"shouldShowExportExcelButton\" id=\"btnExportExcel\"\n                (click)=\"exportToExcelClicked()\">{{ getExportExcelText() }}</li>\n                <li class=\"igx-grid-toolbar__dd-list-items\" igxRipple *ngIf=\"shouldShowExportCsvButton\" id=\"btnExportCsv\"\n                (click)=\"exportToCsvClicked()\">{{ getExportCsvText() }}</li>\n            </ul>\n        </igx-drop-down>\n    </div>\n</div>\n\n<div class=\"igx-grid-toolbar__progress-bar\" *ngIf=\"isExporting\">\n    <igx-linear-bar [indeterminate]=\"true\"></igx-linear-bar>\n</div>\n"
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxExcelExporterService, decorators: [{
                type: Optional
            }] }, { type: IgxCsvExporterService, decorators: [{
                type: Optional
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: IgxIconService }]; }, { class: [{
            type: Input
        }], filterColumnsPrompt: [{
            type: Input
        }], defaultDropDownsMaxHeight: [{
            type: Input
        }], hostClass: [{
            type: HostBinding,
            args: ['attr.class']
        }], gridID: [{
            type: HostBinding,
            args: ['class.igx-grid-toolbar']
        }, {
            type: Input
        }], columnHidingDropdown: [{
            type: ViewChild,
            args: ['columnHidingDropdown', { read: IgxDropDownComponent }]
        }], columnHidingUI: [{
            type: ViewChild,
            args: [IgxColumnHidingDirective, { read: IgxColumnActionsComponent }]
        }], columnHidingButton: [{
            type: ViewChild,
            args: ['columnHidingButton', { read: IgxButtonDirective }]
        }], exportDropdown: [{
            type: ViewChild,
            args: ['exportDropdown', { read: IgxDropDownComponent }]
        }], exportButton: [{
            type: ViewChild,
            args: ['btnExport', { read: IgxButtonDirective }]
        }], columnPinningDropdown: [{
            type: ViewChild,
            args: ['columnPinningDropdown', { read: IgxDropDownComponent }]
        }], columnPinningUI: [{
            type: ViewChild,
            args: [IgxColumnPinningDirective, { read: IgxColumnActionsComponent }]
        }], columnPinningButton: [{
            type: ViewChild,
            args: ['columnPinningButton', { read: IgxButtonDirective }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowEditTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowEdit]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowEditTextDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowEditText]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowEditActionsDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowEditActions]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowEditTabStopDirective, [{
        type: Directive,
        args: [{
                selector: `[igxRowEditTabStop]`
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: ɵngcc0.ElementRef }]; }, { handleTab: [{
            type: HostListener,
            args: ['keydown.Tab', [`$event`]]
        }, {
            type: HostListener,
            args: ['keydown.Shift.Tab', [`$event`]]
        }], handleEscape: [{
            type: HostListener,
            args: ['keydown.Escape', [`$event`]]
        }], handleEnter: [{
            type: HostListener,
            args: ['keydown.Enter', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleColumnOperationsTemplateDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-excel-style-column-operations,[igxExcelStyleColumnOperations]'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleFilterOperationsTemplateDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-excel-style-filter-operations,[igxExcelStyleFilterOperations]'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridExcelStyleFilteringComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-excel-style-filtering',
                template: "<ng-template #defaultExcelColumnOperations>\n    <igx-excel-style-header\n        [showHiding]=\"displayDensity !== 'comfortable' && !column?.disableHiding\"\n        [showPinning]=\"displayDensity !== 'comfortable' && !column?.disablePinning\"\n        [showSelecting]=\"displayDensity !== 'comfortable' && columnSelectable()\"\n    >\n    </igx-excel-style-header>\n\n    <igx-excel-style-sorting *ngIf=\"column?.sortable\">\n    </igx-excel-style-sorting>\n\n    <igx-excel-style-moving *ngIf=\"column?.movable\">\n    </igx-excel-style-moving>\n\n    <igx-excel-style-pinning *ngIf=\"!column?.disablePinning && displayDensity==='comfortable'\">\n    </igx-excel-style-pinning>\n\n    <igx-excel-style-hiding *ngIf=\"!column?.disableHiding && displayDensity==='comfortable'\">\n    </igx-excel-style-hiding>\n\n    <igx-excel-style-selecting *ngIf=\"columnSelectable() && displayDensity==='comfortable'\">\n    </igx-excel-style-selecting>\n</ng-template>\n\n<ng-template #defaultExcelFilterOperations>\n    <igx-excel-style-clear-filters>\n    </igx-excel-style-clear-filters>\n\n    <igx-excel-style-conditional-filter>\n    </igx-excel-style-conditional-filter>\n\n    <igx-excel-style-search>\n    </igx-excel-style-search>\n</ng-template>\n\n<article #mainDropdown\n    class=\"igx-excel-filter__menu\"\n    [ngClass]=\"{\n        'igx-excel-filter__menu--cosy': displayDensity === 'cosy',\n        'igx-excel-filter__menu--compact': displayDensity === 'compact'\n    }\"\n    [id]=\"overlayComponentId\"\n    (keydown)=\"onKeyDown($event)\"\n    [style.min-height]=\"minHeight\"\n    [style.max-height]=\"maxHeight\">\n\n    <ng-container *ngIf=\"this.excelColumnOperationsDirective; else defaultExcelColumnOperations\">\n        <ng-content select=\"igx-excel-style-column-operations,[igxExcelStyleColumnOperations]\">\n        </ng-content>\n    </ng-container>\n\n    <ng-container *ngIf=\"this.excelFilterOperationsDirective; else defaultExcelFilterOperations\">\n        <ng-content select=\"igx-excel-style-filter-operations,[igxExcelStyleFilterOperations]\">\n        </ng-content>\n    </ng-container>\n</article>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: GridBaseAPIService, decorators: [{
                type: Host
            }, {
                type: Optional
            }] }]; }, { className: [{
            type: HostBinding,
            args: ['class.igx-excel-filter']
        }], inline: [{
            type: HostBinding,
            args: ['class.igx-excel-filter--inline']
        }], loadingStart: [{
            type: Output
        }], loadingEnd: [{
            type: Output
        }], initialized: [{
            type: Output
        }], sortingChanged: [{
            type: Output
        }], columnChange: [{
            type: Output
        }], listDataLoaded: [{
            type: Output
        }], column: [{
            type: Input
        }], minHeight: [{
            type: Input
        }], maxHeight: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['style.max-height']
        }], defaultExcelColumnOperations: [{
            type: ViewChild,
            args: ['defaultExcelColumnOperations', { read: TemplateRef, static: true }]
        }], defaultExcelFilterOperations: [{
            type: ViewChild,
            args: ['defaultExcelFilterOperations', { read: TemplateRef, static: true }]
        }], mainDropdown: [{
            type: ViewChild,
            args: ['mainDropdown', { read: ElementRef }]
        }], excelColumnOperationsDirective: [{
            type: ContentChild,
            args: [IgxExcelStyleColumnOperationsTemplateDirective, { read: IgxExcelStyleColumnOperationsTemplateDirective }]
        }], excelFilterOperationsDirective: [{
            type: ContentChild,
            args: [IgxExcelStyleFilterOperationsTemplateDirective, { read: IgxExcelStyleFilterOperationsTemplateDirective }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridNavigationService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFilteringService, [{
        type: Injectable
    }], function () { return [{ type: GridBaseAPIService }, { type: ɵngcc0.NgModuleRef }, { type: IgxIconService }, { type: IgxOverlayService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnResizingService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridHeaderComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-header',
                template: "<ng-template #defaultColumn>\n    <span [title]=\"columnTitle\">{{ column.header || column.field }}</span>\n</ng-template>\n\n<span class=\"igx-grid__th-title\">\n    <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n    </ng-container>\n</span>\n<div class=\"igx-grid__th-icons\" *ngIf=\"!column.columnGroup\">\n    <igx-icon\n        [attr.draggable]=\"false\"\n        [attr.data-sortIndex]=\"column.field | sortingIndex:grid.sortingExpressions\"\n        class=\"sort-icon\"\n        *ngIf=\"column.sortable\"\n        (click)=\"onSortingIconClick($event)\">\n        {{sortingIcon}}\n    </igx-icon>\n\n    <igx-icon [ngClass]=\"filterIconClassName\" [attr.draggable]=\"false\" (click)=\"onFilteringIconClick($event)\"\n        *ngIf=\"grid.allowFiltering == true && column.filterable && grid.filterMode == 'excelStyleFilter'\">\n        more_vert\n    </igx-icon>\n</div>\n"
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: IgxColumnResizingService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { hostRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], ariaSelected: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], styleClasses: [{
            type: HostBinding,
            args: ['class']
        }], height: [{
            type: HostBinding,
            args: ['style.height.rem']
        }], headerID: [{
            type: HostBinding,
            args: ['attr.id']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], 
    /**
     * @hidden
     */
    onPinterEnter: [{
            type: HostListener,
            args: ['pointerenter']
        }], 
    /**
     * @hidden
     */
    onPointerLeave: [{
            type: HostListener,
            args: ['pointerleave']
        }], column: [{
            type: Input
        }], gridID: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridFilteringCellComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-filtering-cell',
                template: "<ng-template #emptyFilter>\n    <igx-chips-area [attr.draggable]=\"false\" class=\"igx-filtering-chips\">\n        <igx-chip #ghostChip [attr.draggable]=\"false\" (click)=\"onChipClicked()\" [displayDensity]=\"displayDensity\" tabIndex=\"-1\">\n            <igx-icon [attr.draggable]=\"false\" igxPrefix>filter_list</igx-icon>\n            <span [attr.draggable]=\"false\">{{filteringService.grid.resourceStrings.igx_grid_filter}}</span>\n        </igx-chip>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #defaultFilter>\n    <igx-chips-area #chipsArea class=\"igx-filtering-chips\">\n        <ng-container *ngFor=\"let item of expressionsList; let last = last; let index = index;\" >\n            <igx-chip *ngIf=\"isChipVisible(index)\"\n                [removable]=\"true\"\n                tabIndex=\"-1\"\n                [displayDensity]=\"displayDensity\"\n                (click)=\"onChipClicked(item.expression)\"\n                (onRemove)=\"onChipRemoved($event, item)\">\n                <igx-icon igxPrefix\n                    fontSet=\"imx-icons\"\n                    [name]=\"item.expression.condition.iconName\">\n                </igx-icon>\n                <span #label>\n                    {{filteringService.getChipLabel(item.expression)}}\n                </span>\n            </igx-chip>\n            <span class=\"igx-filtering-chips__connector\" *ngIf=\"!last && isChipVisible(index + 1)\">{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n        </ng-container>\n        <div #moreIcon [ngClass]=\"filteringIndicatorClass()\" (click)=\"onChipClicked()\">\n            <igx-icon>filter_list</igx-icon>\n            <igx-badge [value]=\"moreFiltersCount\"></igx-badge>\n        </div>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #complexFilter>\n    <igx-chip #complexChip [removable]=\"true\" [displayDensity]=\"displayDensity\" (onRemove)=\"clearFiltering()\" tabIndex=\"-1\">\n        <igx-icon igxPrefix>filter_list</igx-icon>\n        <span>{{filteringService.grid.resourceStrings.igx_grid_complex_filter}}</span>\n    </igx-chip>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: IgxFilteringService }]; }, { styleClasses: [{
            type: HostBinding,
            args: ['class']
        }], column: [{
            type: Input
        }], emptyFilter: [{
            type: ViewChild,
            args: ['emptyFilter', { read: TemplateRef, static: true }]
        }], defaultFilter: [{
            type: ViewChild,
            args: ['defaultFilter', { read: TemplateRef, static: true }]
        }], complexFilter: [{
            type: ViewChild,
            args: ['complexFilter', { read: TemplateRef, static: true }]
        }], chipsArea: [{
            type: ViewChild,
            args: ['chipsArea', { read: IgxChipsAreaComponent }]
        }], moreIcon: [{
            type: ViewChild,
            args: ['moreIcon', { read: ElementRef }]
        }], ghostChip: [{
            type: ViewChild,
            args: ['ghostChip', { read: IgxChipComponent }]
        }], complexChip: [{
            type: ViewChild,
            args: ['complexChip', { read: IgxChipComponent }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridHeaderGroupComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-header-group',
                template: "<ng-container *ngIf=\"grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-group igx-grid__mrl-block\"\n     [ngClass]=\"{\n         'igx-grid__th--pinned-last': hasLastPinnedChildColumn,\n         'igx-grid__th--pinned-first': hasFirstPinnedChildColumn\n        }\"\n     [ngStyle]=\"{'grid-template-rows':column.getGridTemplate(true, false),\n     'grid-template-columns':column.getGridTemplate(false, false),\n     '-ms-grid-rows':column.getGridTemplate(true, true),\n     '-ms-grid-columns':column.getGridTemplate(false, true)}\">\n        <ng-container *ngFor=\"let child of column.children\" >\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                [column]=\"child\"\n                [gridID]=\"child.grid.id\"\n                [igxColumnMovingDrag]=\"child\"\n                [ghostHost]=\"grid.outlet.nativeElement\"\n                [attr.droppable]=\"true\"\n                [igxColumnMovingDrop]=\"child\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n\n<ng-template #defaultColumn>\n    <span class=\"igx-grid__th-group-title\" [title]=\"columnTitle\">{{column.header}}</span>\n</ng-template>\n\n<ng-template #defaultCollapseIndicator>\n    <igx-icon [attr.draggable]=\"false\" >\n            {{column.expanded ? 'expand_more' : 'chevron_right'}} </igx-icon>\n</ng-template>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-title\"\n        role=\"columnheader\"\n        [attr.aria-label]=\"column.header || column.field\"\n        [attr.aria-expanded]=\"column.expanded\"\n        [attr.aria-selected]=\"column.selected\"\n        [ngClass]=\"{\n            'igx-grid__th--pinned-last': hasLastPinnedChildColumn,\n            'igx-grid__th--pinned-first': hasFirstPinnedChildColumn,\n            'igx-grid__th--collapsible': column.collapsible,\n            'igx-grid__th--selectable': selectable,\n            'igx-grid__th--selected': selected,\n            'igx-grid__th--active': activeGroup}\"\n        [igxColumnMovingDrag]=\"column\"\n        [ghostHost]=\"grid.outlet.nativeElement\"\n        [attr.droppable]=\"true\"\n        [igxColumnMovingDrop]=\"column\"\n        (pointerdown)=\"pointerdown($event)\"\n        (click)=\"groupClicked($event)\"\n        (pointerenter)=\"onPinterEnter()\"\n        (pointerleave)=\"onPointerLeave()\"\n        >\n        <ng-container *ngIf=\"column.collapsible\">\n            <div class=\"igx-grid__th-expander\" (click)=\"toggleExpandState($event)\">\n                <ng-container\n                    *ngTemplateOutlet=\"column.collapsibleIndicatorTemplate ? column.collapsibleIndicatorTemplate : defaultCollapseIndicator; context: {$implicit: column, column: column}\">\n                </ng-container>\n            </div>\n        </ng-container>\n        <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n        </ng-container>\n    </div>\n    <div class=\"igx-grid__thead-group\">\n        <ng-container *ngFor=\"let child of column.children\">\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                                [column]=\"child\"\n                                [gridID]=\"child.grid.id\"\n                                [style.min-width]=\"grid.getHeaderGroupWidth(child)\"\n                                [style.flex-basis]=\"grid.getHeaderGroupWidth(child)\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n<ng-container *ngIf=\"!column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <igx-grid-header [igxColumnMovingDrag]=\"column\" [ghostHost]=\"grid.outlet.nativeElement\" [attr.droppable]=\"true\" (pointerdown)=\"activate()\" [igxColumnMovingDrop]=\"column\" [gridID]=\"column.grid.id\" [column]=\"column\"></igx-grid-header>\n    <igx-grid-filtering-cell *ngIf=\"grid.allowFiltering && grid.filterMode == 'quickFilter'\" [column]=\"column\" [attr.draggable]=\"false\"></igx-grid-filtering-cell>\n    <span *ngIf=\"!column.columnGroup && column.resizable\" class=\"igx-grid__th-resize-handle\"\n        [igxResizeHandle]=\"column\"\n        [attr.draggable]=\"false\"\n        [style.cursor]=\"colResizingService.resizeCursor\">\n    </span>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: GridBaseAPIService }, { type: ɵngcc0.ElementRef }, { type: IgxColumnResizingService }, { type: IgxFilteringService }]; }, { gridRowSpan: [{
            type: HostBinding,
            args: ['style.-ms-grid-row-span']
        }], gridColumnSpan: [{
            type: HostBinding,
            args: ['style.-ms-grid-column-span']
        }], rowEnd: [{
            type: HostBinding,
            args: ['style.grid-row-end']
        }], colEnd: [{
            type: HostBinding,
            args: ['style.grid-column-end']
        }], rowStart: [{
            type: HostBinding,
            args: ['style.-ms-grid-row']
        }, {
            type: HostBinding,
            args: ['style.grid-row-start']
        }], colStart: [{
            type: HostBinding,
            args: ['style.-ms-grid-column']
        }, {
            type: HostBinding,
            args: ['style.grid-column-start']
        }], active: [{
            type: HostBinding,
            args: ['class.igx-grid__th--active']
        }], styleClasses: [{
            type: HostBinding,
            args: ['class']
        }], zIndex: [{
            type: HostBinding,
            args: ['style.z-index']
        }], groupDisplayStyle: [{
            type: HostBinding,
            args: ['style.display']
        }], 
    /**
     * @hidden
     */
    onMouseDown: [{
            type: HostListener,
            args: ['mousedown', ['$event']]
        }], column: [{
            type: Input
        }], gridID: [{
            type: Input
        }], headerCell: [{
            type: ViewChild,
            args: [IgxGridHeaderComponent]
        }], filterCell: [{
            type: ViewChild,
            args: [IgxGridFilteringCellComponent]
        }], children: [{
            type: ViewChildren,
            args: [forwardRef(() => IgxGridHeaderGroupComponent), { read: IgxGridHeaderGroupComponent }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSummaryService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSummaryCellComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-summary-cell',
                template: "<ng-container *ngIf=\"hasSummary\">\n    <ng-container *ngFor=\"let summary of summaryResults\">\n            <div class=\"igx-grid-summary__item\" [style.height.px]=\"itemHeight\">\n\n                <ng-container *ngIf=\"visibleColumnIndex === 0 && firstCellIndentation >= 0\">\n                    <div class=\"igx-grid__tree-cell--padding-level-{{firstCellIndentation}}\"></div>\n\n                    <div #indicator class=\"igx-grid__tree-grouping-indicator\" style=\"visibility: hidden\">\n                        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n                    </div>\n                </ng-container>\n\n                <span class=\"igx-grid-summary__label\" [title]=\"summary.label\">{{ translateSummary(summary) }}</span>\n                <span class=\"igx-grid-summary__result\" [title]=\"summary.summaryResult\">\n                    {{ summary.summaryResult }}\n                </span>\n            </div>\n    </ng-container>\n</ng-container>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { firstCellIndentation: [{
            type: Input
        }], hasSummary: [{
            type: Input
        }], visibleColumnIndex: [{
            type: HostBinding,
            args: ['attr.data-visibleIndex']
        }], attrCellID: [{
            type: HostBinding,
            args: ['attr.id']
        }], activate: [{
            type: HostListener,
            args: ['pointerdown']
        }], summaryResults: [{
            type: Input
        }], column: [{
            type: Input
        }], density: [{
            type: Input
        }], active: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-grid-summary--active']
        }], rowIndex: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.data-rowIndex']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSummaryRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-summary-row',
                template: "<ng-container *ngIf=\"summaries.size\">\n    <ng-container *ngIf=\"grid.summariesMargin\">\n        <div\n        class=\"igx-grid__summaries-patch\"\n        [style.min-width.px]=\"grid.summariesMargin\"\n        [style.flex-basis.px]=\"grid.summariesMargin\"\n        (pointerdown)=\"$event.preventDefault()\"\n        ></div>\n    </ng-container>\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n        <ng-container *ngTemplateOutlet=\"summaryCellTemplate; context: getContext(this)\"></ng-container>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\" [igxForSizePropName]='\"calcPixelWidth\"' #igxDirRef>\n        <igx-grid-summary-cell\n            class=\"igx-grid-summary igx-grid-summary--fw\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            role=\"cell\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [class.igx-grid-summary--pinned-last]=\"col.isLastPinned\"\n            [column]=\"col\"\n            [rowIndex]=\"index\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\"\n            [style.min-width]=\"col.getCellWidth()\"\n            [style.max-width]=\"col.getCellWidth()\"\n            [style.flex-basis]=\"col.getCellWidth()\">\n        </igx-grid-summary-cell>\n    </ng-template>\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n        <ng-container *ngTemplateOutlet=\"summaryCellTemplate; context: getContext(this)\"></ng-container>\n    </ng-container>\n</ng-container>\n\n<ng-template #summaryCellTemplate let-col>\n    <igx-grid-summary-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            role=\"cell\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            class=\"igx-grid-summary igx-grid-summary--fw igx-grid-summary--pinned\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [class.igx-grid-summary--pinned-first]=\"col.isFirstPinned\"\n            [class.igx-grid-summary--pinned-last]=\"col.isLastPinned\"\n            [column]=\"col\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [rowIndex]=\"index\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\"\n            [style.min-width]=\"col.getCellWidth()\"\n            [style.max-width]=\"col.getCellWidth()\"\n            [style.flex-basis]=\"col.getCellWidth()\"\n            [style.left]=\"col.rightPinnedOffset\">\n        </igx-grid-summary-cell>\n</ng-template>\n",
                providers: [IgxForOfSyncService]
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { firstCellIndentation: [{
            type: Input
        }], dataRowIndex: [{
            type: HostBinding,
            args: ['attr.data-rowIndex']
        }], summaries: [{
            type: Input
        }], gridID: [{
            type: Input
        }], index: [{
            type: Input
        }], _summaryCells: [{
            type: ViewChildren,
            args: [IgxSummaryCellComponent, { read: IgxSummaryCellComponent }]
        }], virtDirRow: [{
            type: ViewChild,
            args: ['igxDirRef', { read: IgxGridForOfDirective }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridDragSelectDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGridDragSelect]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { onDragStop: [{
            type: Output
        }], onDragScroll: [{
            type: Output
        }], activeDrag: [{
            type: Input,
            args: ['igxGridDragSelect']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxListBase]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxEmptyListTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxEmptyList]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDataLoadingTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDataLoading]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListItemLeftPanningTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxListItemLeftPanning]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListItemRightPanningTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxListItemRightPanning]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HammerGesturesManager, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: PlatformUtil }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListItemComponent, [{
        type: Component,
        args: [{
                providers: [HammerGesturesManager],
                selector: 'igx-list-item',
                template: "   \n<div *ngIf=\"!isHeader && list.listItemLeftPanningTemplate != null\" #leftPanningTmpl class=\"igx-list__item-right\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemLeftPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<div *ngIf=\"!isHeader && list.listItemRightPanningTemplate != null\" #rightPanningTmpl class=\"igx-list__item-left\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemRightPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<ng-template #itemsContent>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #itemThumbnails>\n    <div class=\"igx-list__item-thumbnail\">\n        <ng-content select=\"[igxListThumbnail], igx-list__item-thumbnail, igx-avatar\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemLines>\n    <div class=\"igx-list__item-lines\">\n        <ng-content select=\"[igxListLine], .igx-list__item-lines, [igxListLineTitle], [igxListLineSubTitle], .igx-list__item-line-title, .igx-list__item-line-subtitle\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemActions>\n    <div class=\"igx-list__item-actions\">\n        <ng-content select=\"[igxListAction], .igx-list__item-actions\"></ng-content>\n    </div>\n</ng-template>\n\n    \n<ng-container *ngIf=\"isHeader\">\n    <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n</ng-container>\n\n<ng-container *ngIf=\"!isHeader\">\n    <div class=\"igx-list__item-content\">\n        <ng-container *ngTemplateOutlet=\"itemThumbnails\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemLines\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemActions\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n    </div>\n</ng-container>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: IgxListBaseDirective }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { hidden: [{
            type: Input
        }], touchAction: [{
            type: HostBinding,
            args: ['style.touch-action']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], headerStyle: [{
            type: HostBinding,
            args: ['class.igx-list__header']
        }], innerStyle: [{
            type: HostBinding,
            args: ['class.igx-list__item-base']
        }], display: [{
            type: HostBinding,
            args: ['style.display']
        }], 
    /**
     * @hidden
     */
    clicked: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], 
    /**
     * @hidden
     */
    panStart: [{
            type: HostListener,
            args: ['panstart', ['$event']]
        }], 
    /**
     * @hidden
     */
    panMove: [{
            type: HostListener,
            args: ['panmove', ['$event']]
        }], 
    /**
     * @hidden
     */
    panEnd: [{
            type: HostListener,
            args: ['panend', ['$event']]
        }], index: [{
            type: Input
        }], leftPanningTemplateElement: [{
            type: ViewChild,
            args: ['leftPanningTmpl']
        }], rightPanningTemplateElement: [{
            type: ViewChild,
            args: ['rightPanningTmpl']
        }], isHeader: [{
            type: Input
        }], ariaLabel: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListThumbnailDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListThumbnail]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListActionDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListAction]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListLineDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListLine]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListLineTitleDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListLineTitle]'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-list__item-line-title']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListLineSubTitleDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListLineSubTitle]'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-list__item-line-subtitle']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListComponent, [{
        type: Component,
        args: [{
                selector: 'igx-list',
                template: "<ng-content></ng-content>\n\n<ng-template #defaultEmptyList>\n    <article class=\"message\">\n        {{resourceStrings.igx_list_no_items}}\n    </article>\n</ng-template>\n\n<ng-template #defaultDataLoading>\n    <article class=\"message\">\n        {{resourceStrings.igx_list_loading}}\n    </article>\n</ng-template>\n\n<ng-container *ngIf=\"!children || children.length === 0 || isLoading\">\n    <ng-container *ngTemplateOutlet=\"template; context: context\">\n    </ng-container>\n</ng-container>\n",
                providers: [{ provide: IgxListBaseDirective, useExisting: IgxListComponent }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { panEndTriggeringThreshold: [{
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], allowLeftPanning: [{
            type: Input
        }], allowRightPanning: [{
            type: Input
        }], isLoading: [{
            type: Input
        }], onLeftPan: [{
            type: Output
        }], onRightPan: [{
            type: Output
        }], onPanStateChange: [{
            type: Output
        }], onItemClicked: [{
            type: Output
        }], resourceStrings: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], isListEmpty: [{
            type: HostBinding,
            args: ['class.igx-list-empty']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-list']
        }], cssClassCompact: [{
            type: HostBinding,
            args: ['class.igx-list--compact']
        }], cssClassCosy: [{
            type: HostBinding,
            args: ['class.igx-list--cosy']
        }], children: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxListItemComponent), { descendants: true }]
        }], emptyListTemplate: [{
            type: ContentChild,
            args: [IgxEmptyListTemplateDirective, { read: IgxEmptyListTemplateDirective }]
        }], dataLoadingTemplate: [{
            type: ContentChild,
            args: [IgxDataLoadingTemplateDirective, { read: IgxDataLoadingTemplateDirective }]
        }], listItemLeftPanningTemplate: [{
            type: ContentChild,
            args: [IgxListItemLeftPanningTemplateDirective, { read: IgxListItemLeftPanningTemplateDirective }]
        }], listItemRightPanningTemplate: [{
            type: ContentChild,
            args: [IgxListItemRightPanningTemplateDirective, { read: IgxListItemRightPanningTemplateDirective }]
        }], defaultEmptyListTemplate: [{
            type: ViewChild,
            args: ['defaultEmptyList', { read: TemplateRef, static: true }]
        }], defaultDataLoadingTemplate: [{
            type: ViewChild,
            args: ['defaultDataLoading', { read: TemplateRef, static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxListModule, { declarations: function () { return [IgxListBaseDirective, IgxListComponent, IgxListItemComponent, IgxListThumbnailDirective, IgxListActionDirective, IgxListLineDirective, IgxListLineTitleDirective, IgxListLineSubTitleDirective, IgxDataLoadingTemplateDirective, IgxEmptyListTemplateDirective, IgxListItemLeftPanningTemplateDirective, IgxListItemRightPanningTemplateDirective]; }, imports: function () { return [CommonModule, IgxRippleModule]; }, exports: function () { return [IgxListComponent, IgxListItemComponent, IgxListThumbnailDirective, IgxListActionDirective, IgxListLineDirective, IgxListLineTitleDirective, IgxListLineSubTitleDirective, IgxDataLoadingTemplateDirective, IgxEmptyListTemplateDirective, IgxListItemLeftPanningTemplateDirective, IgxListItemRightPanningTemplateDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxListBaseDirective,
                    IgxListComponent,
                    IgxListItemComponent,
                    IgxListThumbnailDirective,
                    IgxListActionDirective,
                    IgxListLineDirective,
                    IgxListLineTitleDirective,
                    IgxListLineSubTitleDirective,
                    IgxDataLoadingTemplateDirective,
                    IgxEmptyListTemplateDirective,
                    IgxListItemLeftPanningTemplateDirective,
                    IgxListItemRightPanningTemplateDirective
                ],
                exports: [
                    IgxListComponent,
                    IgxListItemComponent,
                    IgxListThumbnailDirective,
                    IgxListActionDirective,
                    IgxListLineDirective,
                    IgxListLineTitleDirective,
                    IgxListLineSubTitleDirective,
                    IgxDataLoadingTemplateDirective,
                    IgxEmptyListTemplateDirective,
                    IgxListItemLeftPanningTemplateDirective,
                    IgxListItemRightPanningTemplateDirective
                ],
                imports: [
                    CommonModule,
                    IgxRippleModule
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleLoadingValuesTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxExcelStyleLoading]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleSearchComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-search',
                template: "<igx-input-group\n            type=\"box\"\n            [displayDensity]=\"esf.displayDensity\">\n    <igx-icon igxPrefix>search</igx-icon>\n    <input\n        #input\n        igxInput\n        tabindex=\"0\"\n        [(ngModel)]=\"searchValue\"\n        (ngModelChange)=\"filterListData()\"\n        (keydown)=\"onInputKeyDown($event)\"\n        [placeholder]=\"esf.column?.grid.resourceStrings.igx_grid_excel_search_placeholder\"\n        autocomplete=\"off\"/>\n    <igx-icon\n        igxSuffix\n        *ngIf=\"searchValue || searchValue === 0\"\n        (click)=\"clearInput()\"\n        tabindex=\"0\">\n        clear\n    </igx-icon>\n</igx-input-group>\n\n<igx-list #list [displayDensity]=\"esf.displayDensity\" [isLoading]=\"isLoading\">\n    <div [style.overflow]=\"'hidden'\" [style.position]=\"'relative'\">\n        <igx-list-item\n        *igxFor=\"let item of displayedListData scrollOrientation : 'vertical'; containerSize: containerSize; itemSize: itemSize\">\n            <igx-checkbox\n            [value]=\"item\"\n            tabindex=\"-1\"\n            [checked]=\"item.isSelected\"\n            [disableRipple]=\"true\"\n            [indeterminate]=\"item.indeterminate\"\n            [disableTransitions]=\"true\"\n            (change)=\"onCheckboxChange($event)\">\n                {{ item.label }}\n            </igx-checkbox>\n        </igx-list-item>\n    </div>\n\n    <ng-template igxDataLoading>\n        <div class=\"igx-excel-filter__loading\">\n            <ng-container *ngTemplateOutlet=\"valuesLoadingTemplate\">\n            </ng-container>\n        </div>\n    </ng-template>\n</igx-list>\n\n<ng-template #defaultExcelStyleLoadingValuesTemplate>\n    <igx-circular-bar [indeterminate]=\"true\">\n    </igx-circular-bar>\n</ng-template>\n\n<footer class=\"igx-excel-filter__menu-footer\">\n    <button igxButton [displayDensity]=\"esf.displayDensity\" (click)=\"esf.cancel()\">{{ esf.grid?.resourceStrings.igx_grid_excel_cancel }}</button>\n    <button igxButton=\"raised\" [displayDensity]=\"esf.displayDensity\" [disabled]=\"applyButtonDisabled\" (click)=\"applyFilter()\">{{ esf.grid?.resourceStrings.igx_grid_excel_apply }}</button>\n</footer>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: IgxGridExcelStyleFilteringComponent }]; }, { class: [{
            type: HostBinding,
            args: ['class']
        }], searchInput: [{
            type: ViewChild,
            args: ['input', { read: IgxInputDirective, static: true }]
        }], list: [{
            type: ViewChild,
            args: ['list', { read: IgxListComponent, static: true }]
        }], virtDir: [{
            type: ViewChild,
            args: [IgxForOfDirective, { static: true }]
        }], defaultExcelStyleLoadingValuesTemplate: [{
            type: ViewChild,
            args: ['defaultExcelStyleLoadingValuesTemplate', { read: TemplateRef }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnResizerDirective, [{
        type: Directive,
        args: [{
                selector: '[igxResizer]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.NgZone }]; }, { restrictHResizeMin: [{
            type: Input
        }], restrictHResizeMax: [{
            type: Input
        }], resizeEnd: [{
            type: Output
        }], resizeStart: [{
            type: Output
        }], resize: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridColumnResizerComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-column-resizer',
                template: "<div class=\"igx-grid__th-resize-line\"\n    [style.left.px]=\"-99999\" igxResizer\n    [style.height.px]=\"colResizingService.resizerHeight\"\n    [restrictHResizeMax]=\"colResizingService.restrictResizeMax\"\n    [restrictHResizeMin]=\"colResizingService.restrictResizeMin\"\n    (resizeEnd)=\"colResizingService.resizeColumn($event)\">\n</div>\n"
            }]
    }], function () { return [{ type: IgxColumnResizingService }]; }, { resizer: [{
            type: ViewChild,
            args: [IgxColumnResizerDirective, { static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridFilteringRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-filtering-row',
                template: "<!-- Have to apply styles inline because of the overlay outlet ... -->\n<igx-drop-down #inputGroupConditions [displayDensity]=\"displayDensity\" [height]=\"'200px'\" (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\"\n        [value]=\"condition\"\n        [selected]=\"isConditionSelected(condition)\">\n        <div class=\"igx-grid__filtering-dropdown-items\">\n            <igx-icon fontSet=\"imx-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n            <span class=\"igx-grid__filtering-dropdown-text\">{{ translateCondition(condition) }}</span>\n        </div>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<ng-template #defaultFilterUI>\n    <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"displayDensity\" (focusout)=\"onInputGroupFocusout()\">\n        <igx-prefix #inputGroupPrefix\n                    (click)=\"inputGroupPrefixClick($event)\"\n                    (keydown)=\"onPrefixKeyDown($event)\"\n                    tabindex=\"0\"\n                    [igxDropDownItemNavigation]=\"inputGroupConditions\">\n            <igx-icon fontSet=\"imx-icons\" [name]=\"getIconName()\"></igx-icon>\n        </igx-prefix>\n        <input\n            #input\n            igxInput\n            tabindex=\"0\"\n            [placeholder]=\"placeholder\"\n            autocomplete=\"off\"\n            [value]=\"value\"\n            (input)=\"onInput($event)\"\n            [type]=\"type\"\n            [readonly]=\"isUnaryCondition\"\n            (click)=\"onInputClick()\"\n            (compositionstart)=\"onCompositionStart()\"\n            (compositionend)=\"onCompositionEnd()\"\n            (keydown)=\"onInputKeyDown($event)\"\n            (keyup)=\"onInputKeyUp($event)\"/>\n            <igx-suffix *ngIf=\"value || value === 0\" >\n                <igx-icon (keydown)=\"onCommitKeyDown($event)\" (click)=\"onCommitClick()\" tabindex=\"0\">done</igx-icon>\n                <igx-icon (keydown)=\"onClearKeyDown($event)\" (click)=\"onClearClick()\" tabindex=\"0\">clear</igx-icon>\n            </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-template #defaultDateUI>\n    <igx-date-picker\n        tabindex=\"0\"\n        mode=\"dropdown\"\n        [value]=\"value\"\n        [outlet]=\"filteringService.grid.outlet\"\n        [locale]=\"filteringService.grid.locale\"\n        (onSelection)=\"onDateSelected($event)\"\n        (onClosed)=\"datePickerClose()\">\n        <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\">\n            <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"displayDensity\" (focusout)=\"onInputGroupFocusout()\">\n                <igx-prefix #inputGroupPrefix\n                            tabindex=\"0\"\n                            (click)=\"inputGroupPrefixClick($event)\"\n                            (keydown)=\"onPrefixKeyDown($event)\"\n                            [igxDropDownItemNavigation]=\"inputGroupConditions\">\n                    <igx-icon fontSet=\"imx-icons\" [name]=\"expression.condition.iconName\"></igx-icon>\n                </igx-prefix>\n                <input #input\n                       igxInput\n                       tabindex=\"0\"\n                       (click)=\"expression.condition.isUnary ? noop() : openDialog(inputGroup.element.nativeElement)\"\n                       [placeholder]=\"placeholder\"\n                       autocomplete=\"off\"\n                       [value]=\"value | date:column.pipeArgs.format:undefined:filteringService.grid.locale\"\n                       [readonly]=\"true\"\n                       (keydown)=\"onInputKeyDown($event)\"/>\n                <igx-suffix *ngIf=\"value\">\n                    <igx-icon (keydown)=\"onCommitKeyDown($event)\" (click)=\"onCommitClick()\" tabindex=\"0\">done</igx-icon>\n                    <igx-icon (keydown)=\"onClearKeyDown($event)\" (click)=\"clearInput()\" tabindex=\"0\">clear</igx-icon>\n                </igx-suffix>\n            </igx-input-group>\n            </ng-template>\n    </igx-date-picker>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this }\"></ng-container>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-start\" *ngIf=\"showArrows\" (keydown)=\"onLeftArrowKeyDown($event)\" (click)=\"scrollChipsOnArrowPress('left')\">\n    <igx-icon>navigate_before</igx-icon>\n</button>\n\n<div #container class=\"igx-grid__filtering-row-main\">\n    <div>\n         <igx-chips-area #chipsArea>\n            <ng-container *ngFor=\"let item of expressionsList; index as i; let last = last;\" tabindex=\"0\">\n                <igx-chip #chip id='chip'\n                    (pointerdown)=\"onChipPointerdown($event, chip)\"\n                    (click)=\"onChipClick($event, item)\"\n                    (keydown)=\"onChipKeyDown($event, item)\"\n                    (onRemove)=\"onChipRemoved($event, item)\"\n                    [selectable]=\"false\"\n                    [selected]=\"item.isSelected\"\n                    [displayDensity]=\"displayDensity\"\n                    [removable]=\"true\">\n                    <igx-icon\n                        igxPrefix\n                        fontSet=\"imx-icons\"\n                        [name]=\"item.expression.condition.iconName\">\n                    </igx-icon>\n                    <span>{{filteringService.getChipLabel(item.expression)}}</span>\n                </igx-chip>\n\n                <span id='operand' *ngIf=\"!last\">\n                    <button igxButton (click)=\"toggleOperatorsDropDown($event, i)\" [igxDropDownItemNavigation]=\"operators\" [displayDensity]=\"column.grid.displayDensity\">\n                        <igx-icon>expand_more</igx-icon>\n                        <span>{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n                    </button>\n                    <igx-drop-down [displayDensity]=\"column.grid.displayDensity\" #operators (onSelection)=\"onLogicOperatorChanged($event, item)\">\n                            <igx-drop-down-item [value]=\"0\" [selected]=\"item.afterOperator === 0\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_and}}</igx-drop-down-item>\n                            <igx-drop-down-item [value]=\"1\" [selected]=\"item.afterOperator === 1\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_or}}</igx-drop-down-item>\n                    </igx-drop-down>\n                </span>\n            </ng-container>\n        </igx-chips-area>\n    </div>\n</div>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-end\" *ngIf=\"showArrows\" (click)=\"scrollChipsOnArrowPress('right')\">\n    <igx-icon>navigate_next</igx-icon>\n</button>\n\n<div #buttonsContainer [ngClass]=\"isNarrowWidth ? 'igx-grid__filtering-row-editing-buttons--small' : 'igx-grid__filtering-row-editing-buttons'\">\n    <button [displayDensity]=\"column.grid.displayDensity\" [igxButton]=\"isNarrowWidth ? 'icon' : 'flat'\" igxRipple (click)=\"clearFiltering()\" [disabled]=\"disabled\" [tabindex]=\"disabled\">\n        <igx-icon>refresh</igx-icon>\n        {{isNarrowWidth ? '' : filteringService.grid.resourceStrings.igx_grid_filter_row_reset}}\n    </button>\n    <button #closeButton [displayDensity]=\"column.grid.displayDensity\" [igxButton]=\"isNarrowWidth ? 'icon' : 'flat'\"  igxRipple (click)=\"close()\">\n        <igx-icon>close</igx-icon>\n        {{isNarrowWidth ? '' : filteringService.grid.resourceStrings.igx_grid_filter_row_close}}\n    </button>\n</div>\n"
            }]
    }], function () { return [{ type: IgxFilteringService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { column: [{
            type: Input
        }], value: [{
            type: Input
        }], styleClasses: [{
            type: HostBinding,
            args: ['class']
        }], onKeydownHandler: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], defaultFilterUI: [{
            type: ViewChild,
            args: ['defaultFilterUI', { read: TemplateRef, static: true }]
        }], defaultDateUI: [{
            type: ViewChild,
            args: ['defaultDateUI', { read: TemplateRef, static: true }]
        }], input: [{
            type: ViewChild,
            args: ['input', { read: ElementRef }]
        }], dropDownConditions: [{
            type: ViewChild,
            args: ['inputGroupConditions', { read: IgxDropDownComponent, static: true }]
        }], chipsArea: [{
            type: ViewChild,
            args: ['chipsArea', { read: IgxChipsAreaComponent, static: true }]
        }], dropDownOperators: [{
            type: ViewChildren,
            args: ['operators', { read: IgxDropDownComponent }]
        }], inputGroup: [{
            type: ViewChild,
            args: ['inputGroup', { read: ElementRef }]
        }], inputGroupPrefix: [{
            type: ViewChild,
            args: ['inputGroupPrefix', { read: ElementRef }]
        }], container: [{
            type: ViewChild,
            args: ['container', { static: true }]
        }], operand: [{
            type: ViewChild,
            args: ['operand']
        }], closeButton: [{
            type: ViewChild,
            args: ['closeButton', { static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnMovingDragDirective, [{
        type: Directive,
        args: [{
                selector: '[igxColumnMovingDrag]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxColumnMovingService }]; }, { data: [{
            type: Input,
            args: ['igxColumnMovingDrag']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGroupByRowTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGroupByRow]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridDetailTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGridDetail]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowExpandedIndicatorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowExpandedIndicator]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowCollapsedIndicatorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowCollapsedIndicator]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHeaderExpandIndicatorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxHeaderExpandedIndicator]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHeaderCollapseIndicatorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxHeaderCollapsedIndicator]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGroupAreaDropDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGroupAreaDrop]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { hovered: [{
            type: HostBinding,
            args: ['class.igx-drop-area--hover']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxAdvancedFilteringDialogComponent, [{
        type: Component,
        args: [{
                selector: 'igx-advanced-filtering-dialog',
                template: "<article\n    *ngIf=\"grid\"\n    class=\"igx-advanced-filter\"\n    igxDrag\n    [ghost]=\"false\"\n    [dragTolerance]=\"0\"\n    (dragStart)=\"dragStart($event)\"\n    (dragEnd)=\"dragEnd($event)\"\n    (dragMove)=\"onDragMove($event)\"\n    (keydown)=\"onKeyDown($event)\"\n    [ngClass]=\"{\n        'igx-advanced-filter--cosy': grid.displayDensity === 'cosy',\n        'igx-advanced-filter--compact': grid.displayDensity === 'compact',\n        'igx-advanced-filter--inline': inline\n    }\"\n>\n    <header class=\"igx-advanced-filter__header\" igxDragHandle>\n        <h4 class=\"igx-typography__h6\" style=\"pointer-events: none;\">\n            {{ grid.resourceStrings.igx_grid_advanced_filter_title }}\n        </h4>\n        <div class=\"igx-filter-legend\">\n            <div class=\"igx-filter-legend__item--and\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_and_label }}</span>\n            </div>\n            <div class=\"igx-filter-legend__item--or\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_or_label }}</span>\n            </div>\n        </div>\n    </header>\n\n    <article #expressionsContainer\n             class=\"igx-advanced-filter__main\"\n             (scroll)=\"onExpressionsScrolled()\">\n        <ng-container *ngIf=\"!rootGroup\">\n\n            <button #addRootAndGroupButton\n                igxButton=\"outlined\"\n                [displayDensity]=\"displayDensity\"\n                (click)=\"addAndGroup()\"\n            >\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\" [displayDensity]=\"displayDensity\" (click)=\"addOrGroup()\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n            <div class=\"igx-filter-empty\">\n                <h6 class=\"igx-filter-empty__title\">\n                    {{grid.resourceStrings.igx_grid_advanced_filter_initial_text}}\n                </h6>\n            </div>\n        </ng-container>\n\n        <ng-template #addExpressionsTemplate let-expressionItem let-afterExpression=\"afterExpression\">\n            <button #addConditionButton\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addCondition(expressionItem, afterExpression)\"\n            >\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_add_condition}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addAndGroup(expressionItem, afterExpression)\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addOrGroup(expressionItem, afterExpression)\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n        </ng-template>\n\n        <ng-template #filterOperandTemplate let-expressionItem>\n            <div *ngIf=\"!expressionItem.inEditMode\"\n                class=\"igx-filter-tree__expression-item\"\n                (mouseenter)=\"expressionItem.hovered = true\"\n                (mouseleave)=\"expressionItem.hovered = false\"\n                >\n                <igx-chip [data]=\"expressionItem\"\n                          [displayDensity]=\"displayDensity === 'compact' ? 'cosy' : displayDensity\"\n                          [removable]=\"true\"\n                          [selected]=\"expressionItem.selected\"\n                          (keydown)=\"invokeClick($event)\"\n                          (click)=\"onChipClick(expressionItem)\"\n                          (dblclick)=\"onChipDblClick(expressionItem)\"\n                          (onRemove)=\"onChipRemove(expressionItem)\"\n                          (onSelectionDone)=\"onChipSelectionEnd()\"\n                    >\n                    <span igxPrefix class=\"igx-filter-tree__expression-column\">{{ expressionItem.columnHeader || expressionItem.expression.fieldName }}</span>\n                    <igx-prefix>\n                        <igx-icon fontSet=\"imx-icons\" [name]=\"expressionItem.expression.condition.iconName\">\n                    </igx-icon>\n                    </igx-prefix>\n                    <span class=\"igx-filter-tree__expression-condition\">\n                        {{ getConditionFriendlyName(expressionItem.expression.condition.name) }}\n                    </span>\n                    <span igxSuffix *ngIf=\"!expressionItem.expression.condition.isUnary\">\n                        {{ isDate(expressionItem.expression.searchVal) ? (expressionItem.expression.searchVal | date:getFormat(expressionItem.expression.fieldName):undefined:grid.locale) : expressionItem.expression.searchVal }}\n                    </span>\n                </igx-chip>\n                <div class=\"igx-filter-tree__expression-actions\"\n                *ngIf=\"(expressionItem.selected && selectedExpressions.length === 1) || expressionItem.hovered\">\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionEdit(expressionItem)\">\n                        edit\n                    </igx-icon>\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionAdd(expressionItem)\"\n                        *ngIf=\"!expressionItem.inAddMode && (expressionItem.parent !== currentGroup || expressionItem !== currentGroup.children[currentGroup.children.length - 1])\"\n                    >\n                        add\n                    </igx-icon>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inEditMode\"\n                #editingInputsContainer\n                class=\"igx-filter-tree__inputs\"\n            >\n                <igx-select #columnSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"columnSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_column_placeholder\"\n                            [(ngModel)]=\"selectedColumn\">\n                    <igx-select-item *ngFor=\"let column of filterableColumns\" [value]=\"column\">\n                        {{column.header || column.field}}\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-select #conditionSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"conditionSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_filter_condition_placeholder\"\n                            [(ngModel)]=\"selectedCondition\"\n                            [disabled]=\"!selectedColumn\">\n                    <igx-prefix *ngIf=\"selectedColumn && conditionSelect.value && selectedColumn.filters.condition(conditionSelect.value)\">\n                        <igx-icon fontSet=\"imx-icons\" [name]=\"selectedColumn.filters.condition(conditionSelect.value).iconName\">\n                        </igx-icon>\n                    </igx-prefix>\n                    <igx-select-item *ngFor=\"let condition of getConditionList()\" [value]=\"condition\">\n                        <div class=\"igx-grid__filtering-dropdown-items\">\n                            <igx-icon fontSet=\"imx-icons\"\n                                      [name]=\"selectedColumn.filters.condition(condition).iconName\">\n                            </igx-icon>\n                            <span class=\"igx-grid__filtering-dropdown-text\">{{getConditionFriendlyName(condition)}}</span>\n                        </div>\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-input-group *ngIf=\"!selectedColumn || selectedColumn.dataType !== 'date'\"\n                                 type=\"box\"\n                                 [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"\n                                 [displayDensity]=\"'compact'\">\n                    <input #searchValueInput\n                           igxInput\n                           [type]=\"selectedColumn && selectedColumn.dataType === 'number' ? 'number' : 'text'\"\n                           [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_value_placeholder\"\n                           [(ngModel)]=\"searchValue\"/>\n                </igx-input-group>\n\n                <igx-date-picker *ngIf=\"selectedColumn && selectedColumn.dataType === 'date'\"\n                                 mode=\"dropdown\"\n                                 [(ngModel)]=\"searchValue\"\n                                 [locale]=\"grid.locale\"\n                                 [outlet]=\"grid.outlet\">\n                    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n                        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"'compact'\">\n                            <input #searchValueInput\n                                    igxInput\n                                    tabindex=\"0\"\n                                    (keydown)=\"invokeClick($event)\"\n                                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                                    [placeholder]=\"grid.resourceStrings.igx_grid_filter_row_date_placeholder\"\n                                    autocomplete=\"off\"\n                                    [value]=\"value | date:selectedColumn.pipeArgs.format:undefined:grid.locale\"\n                                    [readonly]=\"true\"\n                                    [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"/>\n                        </igx-input-group>\n                    </ng-template>\n                </igx-date-picker>\n\n                <div class=\"igx-filter-tree__inputs-actions\">\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            [disabled]=\"!operandCanBeCommitted()\"\n                            (click)=\"commitOperandEdit()\">\n                        <igx-icon fontSet=\"material\">check</igx-icon>\n                    </button>\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            (click)=\"cancelOperandEdit()\">\n                        <igx-icon fontSet=\"material\">close</igx-icon>\n                    </button>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inAddMode\"\n                #addModeContainer\n                class=\"igx-filter-tree__buttons\"\n            >\n                <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem.parent, expressionItem)\"></ng-container>\n                <button igxButton=\"icon\"\n                        [displayDensity]=\"displayDensity\"\n                        (click)=\"cancelOperandAdd()\">\n                    <igx-icon fontSet=\"material\">close</igx-icon>\n                </button>\n            </div>\n\n        </ng-template>\n\n        <ng-template #expressionTreeTemplate let-expressionItem>\n            <div class=\"igx-filter-tree\">\n                <div tabindex=\"0\"\n                     class=\"igx-filter-tree__line\"\n                     [ngClass]=\"{\n                         'igx-filter-tree__line--and': expressionItem.operator === 0,\n                         'igx-filter-tree__line--or': expressionItem.operator === 1,\n                         'igx-filter-tree__line--selected': expressionItem.selected\n                     }\"\n                     (keydown)=\"invokeClick($event)\"\n                     (click)=\"onGroupClick(expressionItem)\"\n                ></div>\n\n                <div class=\"igx-filter-tree__expression\">\n                    <ng-container *ngFor=\"let expr of expressionItem.children\">\n                        <ng-container *ngTemplateOutlet=\"isExpressionGroup(expr) ? expressionTreeTemplate : filterOperandTemplate; context: context(expr)\"></ng-container>\n                    </ng-container>\n                    <div *ngIf=\"currentGroup === expressionItem\"\n                        #currentGroupButtonsContainer\n                        class=\"igx-filter-tree__buttons\">\n                        <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem)\"></ng-container>\n                        <button igxButton=\"outlined\"\n                                *ngIf=\"expressionItem !== rootGroup\"\n                                [displayDensity]=\"displayDensity\"\n                                [disabled]=\"editedExpression || expressionItem.children.length < 2\"\n                                (click)=\"endGroup(expressionItem)\">\n                            <span>{{grid.resourceStrings.igx_grid_advanced_filter_end_group}}</span>\n                        </button>\n                    </div>\n                </div>\n            </div>\n\n        </ng-template>\n\n        <ng-container *ngIf=\"rootGroup\">\n            <ng-container *ngTemplateOutlet=\"expressionTreeTemplate; context: context(rootGroup)\"></ng-container>\n        </ng-container>\n\n        <div igxToggle\n            class=\"igx-filter-contextual-menu\"\n            (keydown)=\"onKeyDown($event)\"\n            (onClosed)=\"contextMenuClosed()\"\n            [ngClass]=\"{\n                'igx-filter-contextual-menu--cosy': displayDensity === 'cosy',\n                'igx-filter-contextual-menu--compact': displayDensity === 'compact'\n            }\"\n        >\n            <button igxButton=\"icon\"\n                    class=\"igx-filter-contextual-menu__close-btn\"\n                    (click)=\"clearSelection()\"\n            >\n                <igx-icon>close</igx-icon>\n            </button>\n\n            <ng-container *ngIf=\"contextualGroup\">\n                <igx-buttongroup [displayDensity]=\"displayDensity\"\n                                 [multiSelection]=\"false\"\n                                 [values]=\"filteringLogics\"\n                                 type=\"outline\"\n                                 (onSelect)=\"selectFilteringLogic($event)\">\n                </igx-buttongroup>\n\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"!contextualGroup.parent\"\n                    (click)=\"ungroup()\"\n                >\n                    <igx-icon fontSet=\"imx-icons\" name=\"ungroup\"></igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_ungroup}}</span>\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteGroup()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    <igx-icon>delete</igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_delete}}</span>\n                </button>\n            </ng-container>\n            <ng-container *ngIf=\"!contextualGroup\">\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createAndGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_and_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createOrGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_or_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteFilters()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_delete_filters}}\n                </button>\n            </ng-container>\n        </div>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick()\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"cancelChanges()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick()\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n<div #overlayOutlet\n     igxOverlayOutlet\n     class=\"igx-advanced-filter__outlet\"\n     (pointerdown)=\"onOutletPointerDown($event)\">\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { display: [{
            type: HostBinding,
            args: ['style.display']
        }], editingInputsContainer: [{
            type: ViewChild,
            args: ['editingInputsContainer', { read: ElementRef }]
        }], addModeContainer: [{
            type: ViewChild,
            args: ['addModeContainer', { read: ElementRef }]
        }], currentGroupButtonsContainer: [{
            type: ViewChild,
            args: ['currentGroupButtonsContainer', { read: ElementRef }]
        }], grid: [{
            type: Input
        }], columnSelect: [{
            type: ViewChild,
            args: ['columnSelect', { read: IgxSelectComponent }]
        }], conditionSelect: [{
            type: ViewChild,
            args: ['conditionSelect', { read: IgxSelectComponent }]
        }], searchValueInput: [{
            type: ViewChild,
            args: ['searchValueInput', { read: ElementRef }]
        }], addRootAndGroupButton: [{
            type: ViewChild,
            args: ['addRootAndGroupButton', { read: ElementRef }]
        }], addConditionButton: [{
            type: ViewChild,
            args: ['addConditionButton', { read: ElementRef }]
        }], contextMenuToggle: [{
            type: ViewChild,
            args: [IgxToggleDirective]
        }], chips: [{
            type: ViewChildren,
            args: [IgxChipComponent]
        }], expressionsContainer: [{
            type: ViewChild,
            args: ['expressionsContainer']
        }], overlayOutlet: [{
            type: ViewChild,
            args: ['overlayOutlet', { read: IgxOverlayOutletDirective, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowSelectorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowSelector]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHeadSelectorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxHeadSelector]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridToolbarCustomContentDirective, [{
        type: Directive,
        args: [{
                selector: '[igxToolbarCustomContent]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
const ɵIgxColumnGroupComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxColumnGroupComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnGroupComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: IgxColumnComponent, useExisting: forwardRef(() => IgxColumnGroupComponent) }],
                selector: 'igx-column-group',
                template: ``
            }]
    }], null, { children: [{
            type: ContentChildren,
            args: [IgxColumnComponent, { read: IgxColumnComponent }]
        }], searchable: [{
            type: Input
        }], hiddenChange: [{
            type: Output
        }], collapsible: [{
            type: Input
        }], expanded: [{
            type: Input
        }], summaries: [{
            type: Input
        }], filters: [{
            type: Input
        }], hidden: [{
            type: Input
        }], collapsibleIndicatorTemplate: [{
            type: Input
        }] }); })();
const ɵIgxRowDragDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxRowDragDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowDragDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowDrag]'
            }]
    }], null, { data: [{
            type: Input,
            args: ['igxRowDrag']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDragIndicatorIconDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDragIndicatorIcon]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowDragGhostDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowDragGhost]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxRowDragModule, { declarations: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective], exports: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowDragModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective],
                entryComponents: [],
                exports: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective],
                imports: []
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSnackbarComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('slideInOut', [
                        transition('void => *', [
                            useAnimation(slideInBottom, {
                                params: {
                                    duration: '.35s',
                                    easing: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
                                    fromPosition: 'translateY(100%)',
                                    toPosition: 'translateY(0)'
                                }
                            })
                        ]),
                        transition('* => void', [
                            useAnimation(slideOutBottom, {
                                params: {
                                    duration: '.2s',
                                    easing: 'cubic-bezier(0.4, 0.0, 1, 1)',
                                    fromPosition: 'translateY(0)',
                                    toOpacity: 1,
                                    toPosition: 'translateY(100%)'
                                }
                            })
                        ])
                    ]),
                    trigger('fadeInOut', [
                        transition('void => *', [
                            useAnimation(fadeIn, {
                                params: {
                                    duration: '.35s',
                                    easing: 'ease-out'
                                }
                            })
                        ]),
                        transition('* => void', [
                            useAnimation(fadeOut, {
                                params: {
                                    duration: '.2s',
                                    easing: 'ease-out'
                                }
                            })
                        ])
                    ])
                ],
                selector: 'igx-snackbar',
                template: "<div class=\"igx-snackbar\" *ngIf=\"isVisible\" (@slideInOut.start)=\"snackbarAnimationStarted($event)\" (@slideInOut.done)=\"snackbarAnimationDone($event)\"\n    [@slideInOut]=\"isVisible\">\n    <div class=\"igx-snackbar__message\" [@fadeInOut]=\"isVisible\">\n        {{ snackbarMessage }}\n        <ng-content></ng-content>\n    </div>\n    <button class=\"igx-snackbar__button\" igxRipple=\"white\" *ngIf=\"actionText\" [@fadeInOut] (click)=\"triggerAction()\">\n        {{ actionText }}\n    </button>\n</div>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], isVisible: [{
            type: Input
        }], autoHide: [{
            type: Input
        }], displayTime: [{
            type: Input
        }], onAction: [{
            type: Output
        }], animationStarted: [{
            type: Output
        }], animationDone: [{
            type: Output
        }], message: [{
            type: Input
        }], actionText: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxSnackbarModule, { declarations: function () { return [IgxSnackbarComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxSnackbarComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSnackbarModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxSnackbarComponent],
                exports: [IgxSnackbarComponent],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridBaseDirective, [{
        type: Directive
    }], function () { return [{ type: IgxGridSelectionService }, { type: IgxGridCRUDService }, { type: IgxColumnResizingService }, { type: GridBaseAPIService }, { type: undefined, decorators: [{
                type: Inject,
                args: [IgxGridTransaction]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ViewContainerRef }, { type: IgxGridNavigationService }, { type: IgxFilteringService }, { type: IgxOverlayService, decorators: [{
                type: Inject,
                args: [IgxOverlayService]
            }] }, { type: IgxGridSummaryService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, { snackbarDisplayTime: [{
            type: Input
        }], autoGenerate: [{
            type: Input
        }], filteringExpressionsTreeChange: [{
            type: Output
        }], advancedFilteringExpressionsTreeChange: [{
            type: Output
        }], onScroll: [{
            type: Output
        }], pageChange: [{
            type: Output
        }], perPageChange: [{
            type: Output
        }], class: [{
            type: Input
        }], evenRowCSS: [{
            type: Input
        }], oddRowCSS: [{
            type: Input
        }], columnHidingTitle: [{
            type: Input
        }], columnPinningTitle: [{
            type: Input
        }], onCellClick: [{
            type: Output
        }], onSelection: [{
            type: Output
        }], onRowSelectionChange: [{
            type: Output
        }], onColumnSelectionChange: [{
            type: Output
        }], onColumnPinning: [{
            type: Output
        }], cellEditEnter: [{
            type: Output
        }], cellEditExit: [{
            type: Output
        }], cellEdit: [{
            type: Output
        }], cellEditDone: [{
            type: Output
        }], rowEditEnter: [{
            type: Output
        }], rowEdit: [{
            type: Output
        }], rowEditDone: [{
            type: Output
        }], rowEditExit: [{
            type: Output
        }], onColumnInit: [{
            type: Output
        }], onSortingDone: [{
            type: Output
        }], onFilteringDone: [{
            type: Output
        }], onPagingDone: [{
            type: Output
        }], onRowAdded: [{
            type: Output
        }], onRowDeleted: [{
            type: Output
        }], onColumnResized: [{
            type: Output
        }], onContextMenu: [{
            type: Output
        }], onDoubleClick: [{
            type: Output
        }], onColumnVisibilityChanged: [{
            type: Output
        }], onColumnMovingStart: [{
            type: Output
        }], onColumnMoving: [{
            type: Output
        }], onColumnMovingEnd: [{
            type: Output
        }], onGridKeydown: [{
            type: Output
        }], onRowDragStart: [{
            type: Output
        }], onRowDragEnd: [{
            type: Output
        }], onGridCopy: [{
            type: Output
        }], expansionStatesChange: [{
            type: Output
        }], onRowToggle: [{
            type: Output
        }], onRowPinning: [{
            type: Output
        }], activeNodeChange: [{
            type: Output
        }], columnList: [{
            type: ContentChildren,
            args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: true }]
        }], tmpOutlets: [{
            type: ViewChildren,
            args: [IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective }]
        }], rowExpandedIndicatorTemplate: [{
            type: ContentChild,
            args: [IgxRowExpandedIndicatorDirective, { read: TemplateRef }]
        }], rowCollapsedIndicatorTemplate: [{
            type: ContentChild,
            args: [IgxRowCollapsedIndicatorDirective, { read: TemplateRef }]
        }], headerExpandIndicatorTemplate: [{
            type: ContentChild,
            args: [IgxHeaderExpandIndicatorDirective, { read: TemplateRef }]
        }], headerCollapseIndicatorTemplate: [{
            type: ContentChild,
            args: [IgxHeaderCollapseIndicatorDirective, { read: TemplateRef }]
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], hostRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], sortingExpressionsChange: [{
            type: Output
        }], toolbar: [{
            type: ViewChild,
            args: ['toolbar', { read: IgxGridToolbarComponent }]
        }], toolbarHtml: [{
            type: ViewChild,
            args: ['toolbar', { read: ElementRef }]
        }], clipboardOptions: [{
            type: Input
        }], onToolbarExporting: [{
            type: Output
        }], onRangeSelection: [{
            type: Output
        }], locale: [{
            type: Input
        }], resourceStrings: [{
            type: Input
        }], filteringLogic: [{
            type: Input
        }], filteringExpressionsTree: [{
            type: Input
        }], advancedFilteringExpressionsTree: [{
            type: Input
        }], pagingMode: [{
            type: Input
        }], paging: [{
            type: Input
        }], page: [{
            type: Input
        }], perPage: [{
            type: Input
        }], columnHiding: [{
            type: Input
        }], hideRowSelectors: [{
            type: Input
        }], rowDraggable: [{
            type: Input
        }], rowEditable: [{
            type: Input
        }], height: [{
            type: HostBinding,
            args: ['style.height']
        }, {
            type: Input
        }], hostWidth: [{
            type: HostBinding,
            args: ['style.width']
        }], width: [{
            type: Input
        }], rowHeight: [{
            type: Input
        }], columnWidth: [{
            type: Input
        }], emptyGridMessage: [{
            type: Input
        }], isLoading: [{
            type: Input
        }], emptyFilteredGridMessage: [{
            type: Input
        }], pinning: [{
            type: Input
        }], columnPinning: [{
            type: Input
        }], allowFiltering: [{
            type: Input
        }], allowAdvancedFiltering: [{
            type: Input
        }], filterMode: [{
            type: Input
        }], summaryPosition: [{
            type: Input
        }], summaryCalculationMode: [{
            type: Input
        }], showSummaryOnCollapse: [{
            type: Input
        }], filterStrategy: [{
            type: Input
        }], sortStrategy: [{
            type: Input
        }], selectedRows: [{
            type: Input
        }], hostClass: [{
            type: HostBinding,
            args: ['attr.class']
        }], sortingExpressions: [{
            type: Input
        }], hiddenColumnsText: [{
            type: Input
        }], pinnedColumnsText: [{
            type: Input
        }], showToolbar: [{
            type: Input
        }], toolbarTitle: [{
            type: Input
        }], exportExcel: [{
            type: Input
        }], exportCsv: [{
            type: Input
        }], exportText: [{
            type: Input
        }], exportExcelText: [{
            type: Input
        }], exportCsvText: [{
            type: Input
        }], cellSelection: [{
            type: Input
        }], rowSelection: [{
            type: Input
        }], columnSelection: [{
            type: Input
        }], 
    /**
     * @hidden
     * @internal
     */
    hideActionStrip: [{
            type: HostListener,
            args: ['mouseleave', ['$event']]
        }], expansionStates: [{
            type: Input
        }], outlet: [{
            type: Input
        }], totalRecords: [{
            type: Input
        }], defaultExpandedTemplate: [{
            type: ViewChild,
            args: ['defaultExpandedTemplate', { read: TemplateRef, static: true }]
        }], defaultCollapsedTemplate: [{
            type: ViewChild,
            args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true }]
        }], emptyGridTemplate: [{
            type: Input
        }], addRowEmptyTemplate: [{
            type: Input
        }], loadingGridTemplate: [{
            type: Input
        }], paginationTemplate: [{
            type: Input
        }], primaryKey: [{
            type: Input
        }], uniqueColumnValuesStrategy: [{
            type: Input
        }], addRowSnackbar: [{
            type: ViewChild,
            args: [IgxSnackbarComponent]
        }], resizeLine: [{
            type: ViewChild,
            args: [IgxGridColumnResizerComponent]
        }], loadingOverlay: [{
            type: ViewChild,
            args: ['loadingOverlay', { static: true }]
        }], loadingOutlet: [{
            type: ViewChild,
            args: ['igxLoadingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true }]
        }], actionStrip: [{
            type: ContentChild,
            args: [IgxActionStripComponent]
        }], excelStyleLoadingValuesTemplateDirective: [{
            type: ContentChild,
            args: [IgxExcelStyleLoadingValuesTemplateDirective, { read: IgxExcelStyleLoadingValuesTemplateDirective, static: true }]
        }], excelStyleFilteringComponents: [{
            type: ContentChildren,
            args: [IgxGridExcelStyleFilteringComponent, { read: IgxGridExcelStyleFilteringComponent, descendants: false }]
        }], headerGroups: [{
            type: ViewChildren,
            args: [IgxGridHeaderGroupComponent, { read: IgxGridHeaderGroupComponent }]
        }], _rowList: [{
            type: ViewChildren,
            args: ['row']
        }], _pinnedRowList: [{
            type: ViewChildren,
            args: ['pinnedRow']
        }], _summaryRowList: [{
            type: ViewChildren,
            args: ['summaryRow', { read: IgxSummaryRowComponent }]
        }], _dataRowList: [{
            type: ViewChildren,
            args: [IgxRowDirective, { read: IgxRowDirective }]
        }], emptyFilteredGridTemplate: [{
            type: ViewChild,
            args: ['emptyFilteredGrid', { read: TemplateRef, static: true }]
        }], emptyGridDefaultTemplate: [{
            type: ViewChild,
            args: ['defaultEmptyGrid', { read: TemplateRef, static: true }]
        }], loadingGridDefaultTemplate: [{
            type: ViewChild,
            args: ['defaultLoadingGrid', { read: TemplateRef, static: true }]
        }], parentVirtDir: [{
            type: ViewChild,
            args: ['scrollContainer', { read: IgxGridForOfDirective, static: true }]
        }], toolbarCustomContentTemplates: [{
            type: ContentChildren,
            args: [IgxGridToolbarCustomContentDirective, { read: IgxGridToolbarCustomContentDirective, descendants: false }]
        }], headSelectorsTemplates: [{
            type: ContentChildren,
            args: [IgxHeadSelectorDirective, { read: IgxHeadSelectorDirective, descendants: false }]
        }], rowSelectorsTemplates: [{
            type: ContentChildren,
            args: [IgxRowSelectorDirective, { read: IgxRowSelectorDirective, descendants: false }]
        }], dragGhostCustomTemplates: [{
            type: ContentChildren,
            args: [IgxRowDragGhostDirective, { read: TemplateRef, descendants: false }]
        }], verticalScrollContainer: [{
            type: ViewChild,
            args: ['verticalScrollContainer', { read: IgxGridForOfDirective, static: true }]
        }], verticalScroll: [{
            type: ViewChild,
            args: ['verticalScrollHolder', { read: IgxGridForOfDirective, static: true }]
        }], scr: [{
            type: ViewChild,
            args: ['scr', { read: ElementRef, static: true }]
        }], footer: [{
            type: ViewChild,
            args: ['footer', { read: ElementRef }]
        }], headerContainer: [{
            type: ViewChild,
            args: ['hContainer', { read: IgxGridForOfDirective, static: true }]
        }], headerSelectorContainer: [{
            type: ViewChild,
            args: ['headerSelectorContainer']
        }], headerDragContainer: [{
            type: ViewChild,
            args: ['headerDragContainer']
        }], headerGroupContainer: [{
            type: ViewChild,
            args: ['headerGroupContainer']
        }], filteringRow: [{
            type: ViewChild,
            args: ['filteringRow', { read: IgxGridFilteringRowComponent }]
        }], theadRow: [{
            type: ViewChild,
            args: ['theadRow', { static: true }]
        }], tbody: [{
            type: ViewChild,
            args: ['tbody', { static: true }]
        }], pinContainer: [{
            type: ViewChild,
            args: ['pinContainer', { read: ElementRef }]
        }], tfoot: [{
            type: ViewChild,
            args: ['tfoot', { static: true }]
        }], _outletDirective: [{
            type: ViewChild,
            args: ['igxFilteringOverlayOutlet', { read: IgxOverlayOutletDirective, static: true }]
        }], rowEditingOutletDirective: [{
            type: ViewChild,
            args: ['igxRowEditingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true }]
        }], dragIndicatorIconBase: [{
            type: ViewChild,
            args: ['dragIndicatorIconBase', { read: TemplateRef, static: true }]
        }], defaultRowEditTemplate: [{
            type: ViewChild,
            args: ['defaultRowEditTemplate', { read: TemplateRef, static: true }]
        }], rowEditCustom: [{
            type: ContentChild,
            args: [IgxRowEditTemplateDirective, { read: TemplateRef }]
        }], rowEditText: [{
            type: ContentChild,
            args: [IgxRowEditTextDirective, { read: TemplateRef }]
        }], rowEditActions: [{
            type: ContentChild,
            args: [IgxRowEditActionsDirective, { read: TemplateRef }]
        }], dragIndicatorIconTemplates: [{
            type: ContentChildren,
            args: [IgxDragIndicatorIconDirective, { read: TemplateRef, descendants: false }]
        }], rowEditTabsDEFAULT: [{
            type: ViewChildren,
            args: [IgxRowEditTabStopDirective]
        }], rowEditTabsCUSTOM: [{
            type: ContentChildren,
            args: [IgxRowEditTabStopDirective, { descendants: true }]
        }], rowEditingOverlay: [{
            type: ViewChild,
            args: [IgxToggleDirective]
        }] }); })();
const ɵIgxGridAPIService_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxGridAPIService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridAPIService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridGroupByRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-groupby-row',
                template: "<ng-container #defaultGroupRow>\n    <div (click)=\"toggle()\" class=\"igx-grid__grouping-indicator\">\n            <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n            </ng-container>\n    </div>\n\n    <div class=\"igx-grid__group-content\" #groupContent>\n        <ng-container *ngTemplateOutlet=\"grid.groupRowTemplate ? grid.groupRowTemplate : defaultGroupByTemplate; context: { $implicit: groupRow }\">\n        </ng-container>\n    </div>\n\n    <ng-template #defaultGroupByExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n    </ng-template>\n\n    <ng-template #defaultGroupByCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </ng-template>\n\n\n    <ng-template #defaultGroupByTemplate>\n        <div class=\"igx-group-label\">\n            <igx-icon fontSet=\"material\" class=\"igx-group-label__icon\">group_work</igx-icon>\n            <span class=\"igx-group-label__column-name\">\n            {{ groupRow.column && groupRow.column.header ?\n                groupRow.column.header :\n                (groupRow.expression ? groupRow.expression.fieldName : '') }}:\n            </span>\n\n            <ng-container *ngIf=\"dataType === 'boolean' || dataType === 'string'; else default\" >\n                <span class=\"igx-group-label__text\">{{ groupRow.value }}</span>\n            </ng-container>\n            <ng-template #default>\n                <ng-container *ngIf=\"dataType === 'number'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | number }}</span>\n                </ng-container>\n                <ng-container *ngIf=\"dataType === 'date'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | date }}</span>\n                </ng-container>\n            </ng-template>\n\n            <igx-badge [value]=\"groupRow.records ? groupRow.records.length : 0\" class='igx-group-label__count-badge'></igx-badge>\n        </div>\n    </ng-template>\n</ng-container>\n"
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: IgxGridSelectionService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { isFocused: [{
            type: Input
        }], expanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], describedBy: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }], dataRowIndex: [{
            type: HostBinding,
            args: ['attr.data-rowIndex']
        }], attrCellID: [{
            type: HostBinding,
            args: ['attr.id']
        }], styleClasses: [{
            type: HostBinding,
            args: ['class']
        }], activate: [{
            type: HostListener,
            args: ['pointerdown']
        }], defaultGroupByExpandedTemplate: [{
            type: ViewChild,
            args: ['defaultGroupByExpandedTemplate', { read: TemplateRef, static: true }]
        }], defaultGroupByCollapsedTemplate: [{
            type: ViewChild,
            args: ['defaultGroupByCollapsedTemplate', { read: TemplateRef, static: true }]
        }], index: [{
            type: Input
        }], gridID: [{
            type: Input
        }], groupRow: [{
            type: Input
        }], groupContent: [{
            type: ViewChild,
            args: ['groupContent', { static: true }]
        }] }); })();
const ɵIgxGridMRLNavigationService_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxGridMRLNavigationService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridMRLNavigationService, [{
        type: Injectable
    }], null, null); })();
const ɵIgxGridComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxGridComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                providers: [
                    IgxGridNavigationService,
                    IgxGridSummaryService,
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    { provide: GridBaseAPIService, useClass: IgxGridAPIService },
                    { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxGridComponent) },
                    IgxFilteringService,
                    IgxColumnResizingService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService
                ],
                selector: 'igx-grid',
                template: "<igx-grid-toolbar [style.max-width.px]='outerWidth' [style.flex-basis.px]=\"outerWidth\" role=\"toolbar\" *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div [style.flex-basis.px]='outerWidth' class=\"igx-grid__grouparea\"\n    *ngIf=\"showGroupArea && (groupingExpressions.length > 0 || hasGroupableColumns)\" #groupArea>\n    <igx-chips-area (onReorder)=\"chipsOrderChanged($event)\" (onMoveEnd)=\"chipsMovingEnded()\">\n        <ng-container *ngFor=\"let expr of chipsGoupingExpressions; let last = last;\">\n            <igx-chip [id]=\"expr.fieldName\" [title]=\"getGroupByChipTitle(expr)\"\n                [removable]=\"getColumnGroupable(expr.fieldName)\"\n                [draggable]=\"getColumnGroupable(expr.fieldName)\" [displayDensity]=\"displayDensity\"\n                (onKeyDown)=\"onChipKeyDown($event)\" (onRemove)=\"onChipRemoved($event)\"\n                (onClick)=\"getColumnGroupable(expr.fieldName) ? onChipClicked($event): null\"\n                [disabled]='!getColumnGroupable(expr.fieldName)'>\n                <span>{{ getGroupByChipTitle(expr) }}</span>\n                <igx-icon igxSuffix>{{ expr.dir == 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n            </igx-chip>\n            <span class=\"igx-grid__grouparea-connector\">\n                <igx-icon [style.visibility]=\"(!last || dropAreaVisible) ? 'visible' : 'hidden'\">arrow_forward\n                </igx-icon>\n            </span>\n        </ng-container>\n        <div igxGroupAreaDrop [style.visibility]=\"dropAreaVisible ? 'visible' : 'hidden'\" [class]=\"groupAreaHostClass\"\n            [attr.gridId]='this.id'>\n            <ng-container *ngTemplateOutlet=\"dropAreaTemplateResolved\"></ng-container>\n        </div>\n    </igx-chips-area>\n</div>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" [class.igx-grid__tr--mrl]='hasColumnLayouts' role=\"rowgroup\" (focus)=\"navigation.focusFirstCell()\"\n    [style.width.px]='calcWidth' tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\" (keydown)=\"navigation.headerNavigation($event)\" (scroll)=\"preventHeaderScroll($event)\" #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"pinnedWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"groupingExpressions.length > 0\">\n                <div class=\"igx-grid__header-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"\n                    [ngClass]=\"{\n                    'igx-grid__header-indentation--no-border': isRowSelectable || rowDraggable\n                }\" #headerGroupContainer  (click)=\"toggleAllGroupRows()\" (pointerdown)=\"$event.preventDefault()\">\n\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                    'igx-grid__drag-indicator--header': !isRowSelectable\n                }\" (pointerdown)=\"$event.preventDefault()\"  #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                }\" (pointerdown)=\"$event.preventDefault()\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\" [style.left]=\"col.rightPinnedOffset\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollSize\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\" (keydown)=\"navigation.handleNavigation($event)\" (focus)=\"navigation.focusTbody($event)\"\n        role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\" (scroll)='preventContainerScroll($event)'\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth || null' #tbody>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n    <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\">\n    </ng-container>\n    <ng-template #pinnedRecordsTemplate>\n        <ng-container *ngIf='data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridRowPinning:id:true:pipeTrigger\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger:true\n        | gridAddRow:true:pipeTrigger as pinnedData'>\n            <div #pinContainer *ngIf='pinnedData.length > 0'\n                [ngClass]=\"{\n                    'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                    'igx-grid__tr--pinned-top': isRowPinningToTop\n                }\"\n                class='igx-grid__tr--pinned' [style.width.px]='calcWidth'>\n                <ng-container *ngFor=\"let rowData of pinnedData; let rowIndex = index\">\n                    <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                    </ng-container>\n                </ng-container>\n            </div>\n        </ng-container>\n    </ng-template>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger\n        | gridGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:groupsRecords:pipeTrigger\n        | gridPaging:page:perPage:id:pipeTrigger\n        | gridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:showSummaryOnCollapse:pipeTrigger:summaryPipeTrigger\n        | gridDetails:hasDetails:expansionStates:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\n        | gridAddRow:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight'\n            [igxForItemSize]=\"hasColumnLayouts ? rowHeight * multiRowLayoutRowSize + 1 : renderedRowHeight\"\n            [igxForTrackBy]='trackChanges'\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template\n                [igxTemplateOutlet]='getRowTemplate(rowData)'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'\n                (onViewCreated)='viewCreatedHandler($event)'\n                (onViewMoved)='viewMovedHandler($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-rowData let-disabledRow=\"disabled\" let-isAddRow=\"addRow\">\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" [disabled]=\"disabledRow\" [addRow]=\"isAddRow\" #row>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData let-isAddRow=\"addRow\">\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" [addRow]=\"isAddRow\" #row #pinnedRow>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #group_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" #row>\n            </igx-grid-groupby-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-template #detail_template_container let-rowIndex=\"index\" let-rowData>\n            <div detail='true' style=\"overflow:auto;width: 100%;\" id=\"{{id}}_{{rowIndex}}\" (pointerdown)='detailsViewFocused(detailsContainer, rowIndex)' #detailsContainer [attr.data-rowindex]='rowIndex'\n                [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr-container--active': isDetailActive(rowIndex)\n            }\">\n                <div class=\"igx-grid__hierarchical-indent\" style='display:flex;'>\n                        <ng-container *ngIf=\"this.groupingExpressions.length > 0\">\n                                <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"></div>\n                        </ng-container>\n                        <ng-template\n                    [ngTemplateOutlet]='detailTemplate'\n                    [ngTemplateOutletContext]='getDetailsContext(rowData, rowIndex)'>\n                    </ng-template>\n                </div>\n            </div>\n        </ng-template>\n\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <div #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\" (pointerdown)=\"$event.preventDefault()\">\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [actionText]=\"snackbarActionText\" [displayTime]='snackbarDisplayTime'>{{snackbarLabel}}</igx-snackbar>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\"\n(focus)=\"navigation.focusFirstCell(false)\" (keydown)=\"navigation.summaryNav($event)\" #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth'  [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollSize\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\" (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [overlaySettings]=\"paginatorSettings\" [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button igxButton=\"raised\" igxRipple (click)='beginAddRowByIndex(null, -1)'>\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultDropArea>\n    <igx-icon fontSet=\"material\" class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{dropAreaMessage}}</span>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n   [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_less</igx-icon>\n</ng-template>\n\n <ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n    [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_more</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\" *ngIf=\"!this.crudService.row?.isAddRow\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n"
            }]
    }], null, { onDataPreLoad: [{
            type: Output
        }], groupingExpressionsChange: [{
            type: Output
        }], groupingExpansionStateChange: [{
            type: Output
        }], groupsExpanded: [{
            type: Input
        }], onGroupingDone: [{
            type: Output
        }], detailTemplate: [{
            type: ContentChild,
            args: [IgxGridDetailTemplateDirective, { read: TemplateRef, static: false }]
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], data: [{
            type: Input
        }], groupingExpressions: [{
            type: Input
        }], groupingExpansionState: [{
            type: Input
        }], hideGroupedColumns: [{
            type: Input
        }], dropAreaMessage: [{
            type: Input
        }], showGroupArea: [{
            type: Input
        }], dropAreaTemplate: [{
            type: Input
        }], groupTemplate: [{
            type: ContentChild,
            args: [IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective }]
        }], gridDetailsTemplate: [{
            type: ContentChild,
            args: [IgxGridDetailTemplateDirective, { read: IgxGridDetailTemplateDirective, static: false }]
        }], _groupsRowList: [{
            type: ViewChildren,
            args: [IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent }]
        }], defaultDropAreaTemplate: [{
            type: ViewChild,
            args: ['defaultDropArea', { read: TemplateRef, static: true }]
        }], groupArea: [{
            type: ViewChild,
            args: ['groupArea']
        }], recordTemplate: [{
            type: ViewChild,
            args: ['record_template', { read: TemplateRef, static: true }]
        }], detailTemplateContainer: [{
            type: ViewChild,
            args: ['detail_template_container', { read: TemplateRef, static: true }]
        }], defaultGroupTemplate: [{
            type: ViewChild,
            args: ['group_template', { read: TemplateRef, static: true }]
        }], summaryTemplate: [{
            type: ViewChild,
            args: ['summary_template', { read: TemplateRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridStateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGridState]'
            }]
    }], function () { return [{ type: IgxGridBaseDirective, decorators: [{
                type: Host
            }, {
                type: Optional
            }] }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ViewContainerRef }]; }, { options: [{
            type: Input,
            args: ['igxGridState']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridStateModule, { declarations: [IgxGridStateDirective], exports: [IgxGridStateDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridStateModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxGridStateDirective],
                exports: [IgxGridStateDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridSharedModules, { imports: function () { return [CommonModule,
        FormsModule, IgxButtonModule, IgxDatePickerModule, IgxIconModule, IgxRippleModule, IgxInputGroupModule, IgxFocusModule, IgxToggleModule, IgxForOfModule, IgxTemplateOutletModule, IgxTextHighlightModule, IgxTextSelectionModule, IgxCheckboxModule, IgxBadgeModule, IgxChipsModule, IgxDragDropModule, IgxDropDownModule, IgxButtonGroupModule, IgxProgressBarModule, IgxSelectModule, IgxGridStateModule, IgxSnackbarModule]; }, exports: function () { return [CommonModule,
        FormsModule, IgxButtonModule, IgxDatePickerModule, IgxIconModule, IgxRippleModule, IgxInputGroupModule, IgxFocusModule, IgxToggleModule, IgxForOfModule, IgxTemplateOutletModule, IgxTextHighlightModule, IgxGridStateModule, IgxTextSelectionModule, IgxCheckboxModule, IgxBadgeModule, IgxChipsModule, IgxDragDropModule, IgxDropDownModule, IgxButtonGroupModule, IgxProgressBarModule, IgxSelectModule, IgxSnackbarModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSharedModules, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    IgxButtonModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxFocusModule,
                    IgxToggleModule,
                    IgxForOfModule,
                    IgxTemplateOutletModule,
                    IgxTextHighlightModule,
                    IgxTextSelectionModule,
                    IgxCheckboxModule,
                    IgxBadgeModule,
                    IgxChipsModule,
                    IgxDragDropModule,
                    IgxDropDownModule,
                    IgxButtonGroupModule,
                    IgxProgressBarModule,
                    IgxSelectModule,
                    IgxGridStateModule,
                    IgxSnackbarModule
                ],
                exports: [
                    CommonModule,
                    FormsModule,
                    IgxButtonModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxFocusModule,
                    IgxToggleModule,
                    IgxForOfModule,
                    IgxTemplateOutletModule,
                    IgxTextHighlightModule,
                    IgxGridStateModule,
                    IgxTextSelectionModule,
                    IgxCheckboxModule,
                    IgxBadgeModule,
                    IgxChipsModule,
                    IgxDragDropModule,
                    IgxDropDownModule,
                    IgxButtonGroupModule,
                    IgxProgressBarModule,
                    IgxSelectModule,
                    IgxSnackbarModule
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ItemPropertyValueChangedDirective, [{
        type: Directive
    }], function () { return [{ type: String }]; }, { valueChanged: [{
            type: Output
        }], value: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnChooserItemBaseDirective, [{
        type: Directive
    }], function () { return [{ type: String }]; }, { indentation: [{
            type: Input
        }], column: [{
            type: Input
        }], container: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnHidingItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxColumnHidingItem]'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnChooserBaseDirective, [{
        type: Directive
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { disableFilter: [{
            type: Input
        }], columnsAreaMaxHeight: [{
            type: Input
        }], cssClass: [{
            type: HostBinding,
            args: ['attr.class']
        }], columns: [{
            type: Input
        }], title: [{
            type: Input
        }], filterColumnsPrompt: [{
            type: Input
        }], columnItems: [{
            type: Input
        }], filterCriteria: [{
            type: Input
        }], columnDisplayOrder: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnHidingComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-column-hiding',
                template: "<div class=\"igx-column-actions__header\">\n    <h4 class=\"igx-column-actions__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-actions__header-input\" *ngIf=\"!disableFilter\">\n        <input igxInput\n            type=\"text\"\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-actions__columns\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox\n        *ngFor=\"let columnItem of hidableColumns\"\n        class=\"igx-column-actions__columns-item\"\n        (onColumnVisibilityChanged)=\"onVisibilityChanged($event)\"\n        (change)=\"columnItem.value = !columnItem.value\"\n        [checked]=\"columnItem.value\"\n        [disabled]=\"columnItem.disabled\"\n        [style.margin-left.px]=\"columnItem.calcIndent\">\n        {{ columnItem.name }}\n    </igx-checkbox>\n</div>\n\n<div class=\"igx-column-actions__buttons\">\n    <button igxButton igxRipple (click)=\"showAllColumns()\" [disabled]=\"disableShowAll\">{{ showAllText }}</button>\n    <button igxButton igxRipple (click)=\"hideAllColumns()\" [disabled]=\"disableHideAll\">{{ hideAllText }}</button>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { showAllText: [{
            type: Input
        }], hideAllText: [{
            type: Input
        }], onColumnVisibilityChanged: [{
            type: Output
        }], disableHideAll: [{
            type: Input
        }], disableShowAll: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxColumnHidingModule, { declarations: [IgxColumnHidingComponent, IgxColumnHidingItemDirective], imports: [IgxGridSharedModules], exports: [IgxColumnHidingComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnHidingModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxColumnHidingComponent,
                    IgxColumnHidingItemDirective
                ],
                imports: [
                    IgxGridSharedModules
                ],
                exports: [
                    IgxColumnHidingComponent
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleClearFiltersComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-clear-filters',
                template: "<div *ngIf=\"esf.column\"\n    tabindex=\"0\"\n    [ngClass]=\"clearFilterClass()\"\n    (keydown)=\"onClearFilterKeyDown($event)\"\n    (click)=\"clearFilter()\">\n    <span>{{ esf.grid.resourceStrings.igx_grid_excel_filter_clear }}</span>\n    <igx-icon>clear</igx-icon>\n</div>\n"
            }]
    }], function () { return [{ type: IgxGridExcelStyleFilteringComponent }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleDefaultExpressionComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-default-expression',
                template: "<igx-select #dropdownConditions\n        type=\"box\"\n        [displayDensity]=\"displayDensity\"\n        [placeholder]=\"conditionsPlaceholder\"\n        (onSelection)=\"onConditionsChanged($event)\"\n        [overlaySettings]=\"dropDownOverlaySettings\">\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" fontSet=\"imx-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n    <igx-select-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <div class=\"igx-grid__filtering-dropdown-items\">\n            <igx-icon fontSet=\"imx-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n            <span class=\"igx-grid__filtering-dropdown-text\">{{translateCondition(condition)}}</span>\n        </div>\n    </igx-select-item>\n</igx-select>\n\n<igx-input-group #inputGroupValues type=\"box\" [displayDensity]=\"displayDensity\">\n    <input\n        #inputValues\n        igxInput\n        [type]=\"type\"\n        tabindex=\"0\"\n        [placeholder]=\"inputValuePlaceholder\"\n        [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"\n        autocomplete=\"off\"\n        [value]=\"expressionUI.expression.searchVal\"\n        (input)=\"onValuesInput($event)\"\n    />\n</igx-input-group>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\">\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #orButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n\n<div #overlayOutlet\n     igxOverlayOutlet\n     (pointerdown)=\"onOutletPointerDown($event)\">\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { onExpressionRemoved: [{
            type: Output
        }], onLogicOperatorChanged: [{
            type: Output
        }], column: [{
            type: Input
        }], expressionUI: [{
            type: Input
        }], expressionsList: [{
            type: Input
        }], grid: [{
            type: Input
        }], displayDensity: [{
            type: Input
        }], overlayOutlet: [{
            type: ViewChild,
            args: ['overlayOutlet', { read: IgxOverlayOutletDirective, static: true }]
        }], dropdownConditions: [{
            type: ViewChild,
            args: ['dropdownConditions', { read: IgxSelectComponent, static: true }]
        }], logicOperatorButtonGroup: [{
            type: ViewChild,
            args: ['logicOperatorButtonGroup', { read: IgxButtonGroupComponent }]
        }], inputValuesDirective: [{
            type: ViewChild,
            args: ['inputValues', { read: IgxInputDirective, static: true }]
        }] }); })();
const ɵIgxExcelStyleDateExpressionComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxExcelStyleDateExpressionComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleDateExpressionComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-date-expression',
                template: "<igx-select #dropdownConditions\n        type=\"box\"\n        [displayDensity]=\"displayDensity\"\n        [placeholder]=\"conditionsPlaceholder\"\n        (onSelection)=\"onConditionsChanged($event)\"\n        [overlaySettings]=\"dropDownOverlaySettings\">\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" fontSet=\"imx-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n    <igx-select-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"imx-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span>{{translateCondition(condition)}}</span>\n    </igx-select-item>\n</igx-select>\n\n<igx-date-picker #datePicker mode=\"dropdown\" [(ngModel)]=\"expressionUI.expression.searchVal\" [locale]=\"grid.locale\" [outlet]=\"grid.outlet\">\n    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"displayDensity\">\n            <input #input\n                    igxInput\n                    tabindex=\"0\"\n                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                    [placeholder]=\"inputDatePlaceholder\"\n                    autocomplete=\"off\"\n                    [value]=\"value | date:column.pipeArgs.format:undefined:grid.locale\"\n                    [readonly]=\"true\"\n                    [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"/>\n        </igx-input-group>\n    </ng-template>\n</igx-date-picker>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\" >\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        tabindex=\"0\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #orButton\n        tabindex=\"0\"\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n\n<div #overlayOutlet\n     igxOverlayOutlet\n     (pointerdown)=\"onOutletPointerDown($event)\">\n</div>\n"
            }]
    }], null, { datePicker: [{
            type: ViewChild,
            args: ['datePicker', { read: IgxDatePickerComponent, static: true }]
        }], displayDensity: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleCustomDialogComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-custom-dialog',
                template: "<article #toggle igxToggle\n    class=\"igx-excel-filter__secondary\"\n    [ngClass]=\"{\n        'igx-excel-filter__secondary--cosy': grid.displayDensity === 'cosy',\n        'igx-excel-filter__secondary--compact': grid.displayDensity === 'compact'\n    }\"\n    (keydown)=\"onKeyDown($event)\"\n    (onOpening)=\"onCustomDialogOpening()\"\n    (onOpened)=\"onCustomDialogOpened()\">\n    <header class=\"igx-excel-filter__secondary-header\">\n        <h4 class=\"igx-typography__h6\">\n            {{ grid.resourceStrings.igx_grid_excel_custom_dialog_header }}{{ column.header || column.field }}\n        </h4>\n    </header>\n\n    <article #expressionsContainer class=\"igx-excel-filter__secondary-main\">\n        <ng-container *ngIf=\"column.dataType === 'date'\">\n            <igx-excel-style-date-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (onExpressionRemoved)=\"onExpressionRemoved($event)\"\n                (onLogicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-date-expression>\n        </ng-container>\n\n        <ng-container *ngIf=\"column.dataType !== 'date'\">\n            <igx-excel-style-default-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (onExpressionRemoved)=\"onExpressionRemoved($event)\"\n                (onLogicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-default-expression>\n        </ng-container>\n\n        <button igxButton [displayDensity]=\"displayDensity\"\n            class=\"igx-excel-filter__add-filter\"\n            (click)=\"onAddButtonClick()\">\n            <igx-icon>add</igx-icon>\n            <span>{{ grid.resourceStrings.igx_grid_excel_custom_dialog_add }}</span>\n        </button>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick()\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"closeDialog()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick()\" (keydown)=\"onApplyButtonKeyDown($event)\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { expressionsList: [{
            type: Input
        }], column: [{
            type: Input
        }], selectedOperator: [{
            type: Input
        }], filteringService: [{
            type: Input
        }], overlayComponentId: [{
            type: Input
        }], overlayService: [{
            type: Input
        }], displayDensity: [{
            type: Input
        }], expressionComponents: [{
            type: ViewChildren,
            args: [IgxExcelStyleDefaultExpressionComponent]
        }], expressionDateComponents: [{
            type: ViewChildren,
            args: [IgxExcelStyleDateExpressionComponent]
        }], toggle: [{
            type: ViewChild,
            args: ['toggle', { read: IgxToggleDirective, static: true }]
        }], defaultExpressionTemplate: [{
            type: ViewChild,
            args: ['defaultExpressionTemplate', { read: TemplateRef }]
        }], dateExpressionTemplate: [{
            type: ViewChild,
            args: ['dateExpressionTemplate', { read: TemplateRef }]
        }], expressionsContainer: [{
            type: ViewChild,
            args: ['expressionsContainer', { static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleConditionalFilterComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-conditional-filter',
                template: "<ng-container *ngIf=\"esf.column\">\n    <div tabindex=\"0\"\n        class=\"igx-excel-filter__actions-filter\"\n        (keydown)=\"onTextFilterKeyDown($event)\"\n        (click)=\"onTextFilterClick($event)\"\n        [igxDropDownItemNavigation]=\"subMenu\">\n        <span>{{ subMenuText }}</span>\n        <igx-icon>keyboard_arrow_right</igx-icon>\n    </div>\n\n    <igx-drop-down\n        #subMenu\n        [maxHeight]=\"'397px'\"\n        [displayDensity]=\"esf.grid.displayDensity\"\n        (onSelection)=\"onSubMenuSelection($event)\"\n        (onClosed)=\"onSubMenuClosed()\">\n        <div>\n            <igx-drop-down-item\n            *ngFor=\"let condition of conditions\"\n            [value]=\"condition\">\n                <div class=\"igx-grid__filtering-dropdown-items\">\n                    <igx-icon fontSet=\"imx-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n                    <span class=\"igx-grid__filtering-dropdown-text\">{{ translateCondition(condition) }}</span>\n                </div>\n            </igx-drop-down-item>\n            <igx-drop-down-item *ngIf=\"showCustomFilterItem()\">\n                <div class=\"igx-grid__filtering-dropdown-items\">\n                    <igx-icon>filter_list</igx-icon>\n                    <span class=\"igx-grid__filtering-dropdown-text\">{{ esf.grid.resourceStrings.igx_grid_excel_custom_filter }}</span>\n                </div>\n            </igx-drop-down-item>\n        </div>\n    </igx-drop-down>\n\n    <igx-excel-style-custom-dialog\n        #customDialog\n        [column]=\"esf.column\"\n        [filteringService]=\"esf.grid.filteringService\"\n        [overlayComponentId]=\"esf.overlayComponentId\"\n        [overlayService]=\"esf.overlayService\"\n        [displayDensity]=\"esf.grid.displayDensity\">\n    </igx-excel-style-custom-dialog>\n</ng-container>\n"
            }]
    }], function () { return [{ type: IgxGridExcelStyleFilteringComponent }]; }, { customDialog: [{
            type: ViewChild,
            args: ['customDialog', { read: IgxExcelStyleCustomDialogComponent }]
        }], subMenu: [{
            type: ViewChild,
            args: ['subMenu', { read: IgxDropDownComponent }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleHeaderComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-header',
                template: "<header *ngIf=\"esf.column\"\r\n        class=\"igx-excel-filter__menu-header\">\r\n    <h4>{{ esf.column.header || esf.column.field }}</h4>\r\n    <div class=\"igx-excel-filter__menu-header-actions\">\r\n        <button *ngIf=\"showSelecting\"\r\n            igxButton=\"icon\"\r\n            (click)=\"esf.onSelect()\"\r\n            [ngClass]=\"esf.selectedClass()\"\r\n        >\r\n            <igx-icon fontSet=\"material\">done</igx-icon>\r\n        </button>\r\n        <button *ngIf=\"showPinning\"\r\n            igxButton=\"icon\"\r\n            (click)=\"esf.onPin()\"\r\n        >\r\n            <igx-icon fontSet=\"imx-icons\" [name]=\"esf.column.pinned ? 'unpin-left' : 'pin-left'\"></igx-icon>\r\n        </button>\r\n        <button *ngIf=\"showHiding\"\r\n            igxButton=\"icon\"\r\n            (click)=\"esf.onHideToggle()\"\r\n        >\r\n            <igx-icon>{{ esf.column.hidden ? 'visibility' : 'visibility_off' }}</igx-icon>\r\n        </button>\r\n    </div>\r\n</header>\r\n"
            }]
    }], function () { return [{ type: IgxGridExcelStyleFilteringComponent }]; }, { showPinning: [{
            type: Input
        }], showSelecting: [{
            type: Input
        }], showHiding: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleHidingComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-hiding',
                template: "<div *ngIf=\"esf.column\"\n    class=\"igx-excel-filter__actions-hide\"\n    tabindex=\"0\"\n    (click)=\"esf.onHideToggle()\">\n    <span>{{ esf.column.hidden ? esf.grid.resourceStrings.igx_grid_excel_show : esf.grid.resourceStrings.igx_grid_excel_hide }}</span>\n    <igx-icon>{{ esf.column.hidden ? 'visibility' : 'visibility_off' }}</igx-icon>\n</div>\n"
            }]
    }], function () { return [{ type: IgxGridExcelStyleFilteringComponent }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleMovingComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-moving',
                template: "<ng-container *ngIf=\"esf.column\">\n<header>\n    {{ esf.grid.resourceStrings.igx_grid_excel_filter_moving_header }}\n</header>\n<section class=\"igx-excel-filter__move-buttons\">\n    <button [displayDensity]=\"esf.grid.displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveLeft\"\n        (click)=\"onMoveButtonClicked(0)\">\n        <igx-icon>arrow_back</igx-icon>\n        <span>\n            {{ esf.grid.displayDensity==='compact'?\n            esf.grid.resourceStrings.igx_grid_excel_filter_moving_left_short:\n            esf.grid.resourceStrings.igx_grid_excel_filter_moving_left }}\n        </span>\n    </button>\n    <button [displayDensity]=\"esf.grid.displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveRight\"\n        (click)=\"onMoveButtonClicked(1)\">\n        <span>\n            {{ esf.grid.displayDensity==='compact'?\n            esf.grid.resourceStrings.igx_grid_excel_filter_moving_right_short:\n            esf.grid.resourceStrings.igx_grid_excel_filter_moving_right }}\n        </span>\n        <igx-icon>arrow_forwards</igx-icon>\n    </button>\n</section>\n</ng-container>\n"
            }]
    }], function () { return [{ type: IgxGridExcelStyleFilteringComponent }]; }, { class: [{
            type: HostBinding,
            args: ['class']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStylePinningComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-pinning',
                template: "<div *ngIf=\"esf.column\"\n    [ngClass]=\"esf.column.pinned ? 'igx-excel-filter__actions-unpin' : 'igx-excel-filter__actions-pin'\"\n    (click)=\"esf.onPin()\"\n    tabindex=\"0\">\n    <span>{{ esf.column.pinned ? esf.grid.resourceStrings.igx_grid_excel_unpin : esf.grid.resourceStrings.igx_grid_excel_pin }}</span>\n    <igx-icon fontSet=\"imx-icons\" name=\"{{ esf.column.pinned ? 'unpin-left' : 'pin-left' }}\"></igx-icon>\n</div>\n"
            }]
    }], function () { return [{ type: IgxGridExcelStyleFilteringComponent }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleSelectingComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-selecting',
                template: "<div *ngIf=\"esf.column\"\n    [ngClass]=\"esf.selectedClass()\"\n    tabindex=\"0\"\n    (click)=\"esf.onSelect()\">\n    <span>{{esf.grid.resourceStrings.igx_grid_excel_select }}</span>\n    <igx-icon fontSet=\"material\">done</igx-icon>\n</div>\n"
            }]
    }], function () { return [{ type: IgxGridExcelStyleFilteringComponent }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleSortingComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-excel-style-sorting',
                template: "<ng-container *ngIf=\"esf.column\">\n<header>\n    {{ esf.grid.resourceStrings.igx_grid_excel_filter_sorting_header }}\n</header>\n<igx-buttongroup #sortButtonGroup [multiSelection]=\"false\">\n    <button igxButton\n        [displayDensity]=\"esf.grid.displayDensity\"\n        [attr.data-togglable]=\"true\"\n        (click)=\"onSortButtonClicked(1)\"\n        >\n        <igx-icon>arrow_upwards</igx-icon>\n        <span>\n            {{ esf.grid.displayDensity==='compact'?\n            esf.grid.resourceStrings.igx_grid_excel_filter_sorting_asc_short:\n            esf.grid.resourceStrings.igx_grid_excel_filter_sorting_asc  }}\n        </span>\n    </button>\n\n    <button igxButton\n        [displayDensity]=\"esf.grid.displayDensity\"\n        [attr.data-togglable]=\"true\"\n        (click)=\"onSortButtonClicked(2)\"\n        >\n        <igx-icon>arrow_downwards</igx-icon>\n        <span>\n            {{ esf.grid.displayDensity==='compact'?\n            esf.grid.resourceStrings.igx_grid_excel_filter_sorting_desc_short:\n            esf.grid.resourceStrings.igx_grid_excel_filter_sorting_desc\n        }}\n        </span>\n    </button>\n</igx-buttongroup>\n</ng-container>\n"
            }]
    }], function () { return [{ type: IgxGridExcelStyleFilteringComponent }, { type: ɵngcc0.ChangeDetectorRef }]; }, { class: [{
            type: HostBinding,
            args: ['class']
        }], sortButtonGroup: [{
            type: ViewChild,
            args: ['sortButtonGroup', { read: IgxButtonGroupComponent }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridCellComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-grid-cell',
                template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip\n        *ngIf=\"displayPinnedChip\"\n        class=\"igx-grid__td--pinned-chip\"\n        [disabled]=\"true\"\n        [displayDensity]=\"'compact'\"\n        >{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip\n    >\n</ng-template>\n<ng-template #defaultCell>\n    <div *ngIf=\"column.dataType !== 'boolean'\"\n        igxTextHighlight\n        class=\"igx-grid__td-text\"\n        style=\"pointer-events: none;\"\n        [cssClass]=\"highlightClass\"\n        [activeCssClass]=\"activeHighlightClass\"\n        [groupName]=\"gridID\"\n        [value]=\"\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === 'number'\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'date'\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : value\n        \"\n        [row]=\"rowData\"\n        [column]=\"this.column.field\"\n        [containerClass]=\"'igx-grid__td-text'\"\n        [metadata]=\"searchMetadata\"\n    >{{\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === \"number\"\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === \"date\"\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : value\n        }}</div>\n    <igx-icon\n        *ngIf=\"column.dataType === 'boolean'\"\n        [ngClass]=\"{ 'igx-icon--success': value, 'igx-icon--error': !value }\"\n        >{{ value ? \"check\" : \"close\" }}</igx-icon\n    >\n</ng-template>\n<ng-template #addRowCell let-cell=\"cell\">\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n    [cssClass]=\"highlightClass\"\n    [activeCssClass]=\"activeHighlightClass\"\n    [groupName]=\"gridID\"\n    [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ? (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : value\"\n    [row]=\"rowData\"\n    [column]=\"this.column.field\"\n    [containerClass]=\"'igx-grid__td-text'\"\n    [metadata]=\"searchMetadata\">{{\n        !isEmptyAddRowCell ? value : (column.header || column.field)\n    }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                type=\"number\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox\n            (change)=\"editValue = $event.checked\"\n            [value]=\"editValue\"\n            [checked]=\"editValue\"\n            [igxFocus]=\"true\"\n            [disableRipple]=\"true\"\n        ></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker\n            [style.width.%]=\"100\"\n            [outlet]=\"grid.outlet\"\n            mode=\"dropdown\"\n            [locale]=\"grid.locale\"\n            [(value)]=\"editValue\"\n            [igxFocus]=\"true\"\n            [labelVisibility]=\"false\"\n        >\n        </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n",
                providers: [HammerGesturesManager]
            }]
    }], function () { return [{ type: IgxGridSelectionService }, { type: IgxGridCRUDService }, { type: GridBaseAPIService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: HammerGesturesManager }, { type: PlatformUtil }]; }, { lastPinned: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-grid__td--pinned-last']
        }], firstPinned: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-grid__td--pinned-first']
        }], editMode: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-grid__td--editing']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], width: [{
            type: Input
        }], active: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-grid__td--active']
        }], displayPinnedChip: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-grid__td--row-pinned-first']
        }], onDoubleClick: [{
            type: HostListener,
            args: ['dblclick', ['$event']]
        }], isEmptyAddRowCell: [{
            type: HostBinding,
            args: ['class.igx-grid__td--new']
        }], rowIndex: [{
            type: HostBinding,
            args: ['attr.data-rowIndex']
        }], visibleColumnIndex: [{
            type: HostBinding,
            args: ['attr.data-visibleIndex']
        }, {
            type: Input
        }], attrCellID: [{
            type: HostBinding,
            args: ['attr.id']
        }], title: [{
            type: HostBinding,
            args: ['attr.title']
        }], booleanClass: [{
            type: HostBinding,
            args: ['class.igx-grid__td--bool-true']
        }], cellSelectionMode: [{
            type: Input
        }], lastSearchInfo: [{
            type: Input
        }], readonly: [{
            type: HostBinding,
            args: ['attr.aria-readonly']
        }], ariaSelected: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], selected: [{
            type: HostBinding,
            args: ['class.igx-grid__td--selected']
        }], columnSelected: [{
            type: HostBinding,
            args: ['class.igx-grid__td--column-selected']
        }], highlight: [{
            type: ViewChild,
            args: [IgxTextHighlightDirective, { read: IgxTextHighlightDirective }]
        }], 
    /**
     * @hidden
     * @internal
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], 
    /**
     * @hidden
     * @internal
     */
    onContextMenu: [{
            type: HostListener,
            args: ['contextmenu', ['$event']]
        }], column: [{
            type: Input
        }], row: [{
            type: Input
        }], rowData: [{
            type: Input
        }], cellTemplate: [{
            type: Input
        }], pinnedIndicator: [{
            type: Input
        }], value: [{
            type: Input
        }], formatter: [{
            type: Input
        }], defaultCellTemplate: [{
            type: ViewChild,
            args: ['defaultCell', { read: TemplateRef, static: true }]
        }], defaultPinnedIndicator: [{
            type: ViewChild,
            args: ['defaultPinnedIndicator', { read: TemplateRef, static: true }]
        }], inlineEditorTemplate: [{
            type: ViewChild,
            args: ['inlineEditor', { read: TemplateRef, static: true }]
        }], addRowCellTemplate: [{
            type: ViewChild,
            args: ['addRowCell', { read: TemplateRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridFooterComponent, [{
        type: Component,
        args: [{
                selector: 'igx-grid-footer',
                template: '<ng-content></ng-content>'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxPaginatorComponent, [{
        type: Component,
        args: [{
                selector: 'igx-paginator',
                template: "<div class=\"igx-paginator__select\" [hidden]=\"dropdownHidden\">\n    <label class=\"igx-paginator__label\">{{ resourceStrings.igx_paginator_label }}</label>\n    <div class=\"igx-paginator__select-input\">\n        <igx-select [overlaySettings]=\"overlaySettings\" [(ngModel)]=\"perPage\" [displayDensity]=\"paginatorSelectDisplayDensity()\" type=\"border\"\n            [disabled]=\"!dropdownEnabled\">\n            <label igxLabel [hidden]=\"true\">{{ resourceStrings.igx_paginator_label }}</label>\n            <igx-select-item [value]=\"val\" *ngFor=\"let val of selectOptions\">\n                {{val}}\n            </igx-select-item>\n        </igx-select>\n    </div>\n</div>\n<div class=\"igx-paginator__pager\" [hidden]=\"pagerHidden\" role=\"navigation\">\n    <button [title]=\"resourceStrings.igx_paginator_first_page_button_text\" [disabled]=\"isFirstPageDisabled\" [attr.aria-disabled]=\"isFirstPageDisabled\" (click)=\"paginate(0)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">first_page</igx-icon>\n    </button>\n    <button [title]=\"resourceStrings.igx_paginator_previous_page_button_text\" [disabled]=\"isFirstPageDisabled\" [attr.aria-disabled]=\"isFirstPageDisabled\" (click)=\"previousPage()\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">chevron_left</igx-icon>\n    </button>\n    <div class='igx-paginator__pager-text' aria-current=\"page\">\n        <span>{{ page + 1 }}</span>\n        <span>&nbsp;{{ resourceStrings.igx_paginator_pager_text }}&nbsp;</span>\n        <span>{{ totalPages }}</span>\n    </div>\n    <button [title]=\"resourceStrings.igx_paginator_next_page_button_text\" [disabled]=\"isLastPageDisabled\" [attr.aria-disabled]=\"isLastPageDisabled\" (click)=\"nextPage()\" igxRipple igxRippleCentered=\"true\" igxButton=\"icon\">\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </button>\n    <button [title]=\"resourceStrings.igx_paginator_last_page_button_text\" [disabled]=\"isLastPageDisabled\" [attr.aria-disabled]=\"isLastPageDisabled\" (click)=\"paginate(totalPages - 1)\" igxButton=\"icon\" igxRipple\n        igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">last_page</igx-icon>\n    </button>\n</div>\n"
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { pagerEnabled: [{
            type: Input
        }], pagerHidden: [{
            type: Input
        }], dropdownEnabled: [{
            type: Input
        }], dropdownHidden: [{
            type: Input
        }], selectLabel: [{
            type: Input
        }], prepositionPage: [{
            type: Input
        }], perPageChange: [{
            type: Output
        }], pageChange: [{
            type: Output
        }], classCosy: [{
            type: HostBinding,
            args: ['class.igx-paginator--cosy']
        }], classCompact: [{
            type: HostBinding,
            args: ['class.igx-paginator--compact']
        }], classComfortable: [{
            type: HostBinding,
            args: ['class.igx-paginator']
        }], page: [{
            type: Input
        }], perPage: [{
            type: Input
        }], totalRecords: [{
            type: Input
        }], selectOptions: [{
            type: Input
        }], overlaySettings: [{
            type: Input
        }], resourceStrings: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxPaginatorModule, { declarations: function () { return [IgxPaginatorComponent]; }, imports: function () { return [CommonModule, IgxSelectModule, FormsModule, IgxIconModule, IgxButtonModule, IgxRippleModule, IgxInputGroupModule]; }, exports: function () { return [IgxPaginatorComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxPaginatorModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxPaginatorComponent],
                exports: [IgxPaginatorComponent],
                imports: [CommonModule, IgxSelectModule, FormsModule, IgxIconModule, IgxButtonModule, IgxRippleModule, IgxInputGroupModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridCellStyleClassesPipe, [{
        type: Pipe,
        args: [{
                name: 'igxCellStyleClasses'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridCellStylesPipe, [{
        type: Pipe,
        args: [{
                name: 'igxCellStyles'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridNotGroupedPipe, [{
        type: Pipe,
        args: [{
                name: 'igxNotGrouped'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridTopLevelColumns, [{
        type: Pipe,
        args: [{
                name: 'igxTopLevel'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridFilterConditionPipe, [{
        type: Pipe,
        args: [{
                name: 'filterCondition',
                pure: true
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridTransactionPipe, [{
        type: Pipe,
        args: [{
                name: 'gridTransaction',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridPaginatorOptionsPipe, [{
        type: Pipe,
        args: [{
                name: 'paginatorOptions',
                pure: true
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHasVisibleColumnsPipe, [{
        type: Pipe,
        args: [{
                name: 'visibleColumns',
                pure: true
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridRowPinningPipe, [{
        type: Pipe,
        args: [{
                name: 'gridRowPinning',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnActionEnabledPipe, [{
        type: Pipe,
        args: [{
                name: 'columnActionEnabled',
                pure: true
            }]
    }], function () { return [{ type: IgxColumnActionsComponent, decorators: [{
                type: Inject,
                args: [IgxColumnActionsComponent]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFilterActionColumnsPipe, [{
        type: Pipe,
        args: [{
                name: 'filterActionColumns',
                pure: true
            }]
    }], function () { return [{ type: IgxColumnActionsComponent, decorators: [{
                type: Inject,
                args: [IgxColumnActionsComponent]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSortActionColumnsPipe, [{
        type: Pipe,
        args: [{
                name: 'sortActionColumns',
                pure: true
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridDataMapperPipe, [{
        type: Pipe,
        args: [{ name: 'dataMapper' }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxStringReplacePipe, [{
        type: Pipe,
        args: [{ name: 'igxStringReplace' }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridTransactionStatePipe, [{
        type: Pipe,
        args: [{ name: 'transactionState' }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnFormatterPipe, [{
        type: Pipe,
        args: [{ name: 'columnFormatter' }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridAddRowPipe, [{
        type: Pipe,
        args: [{
                name: 'gridAddRow',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridPipesModule, { declarations: function () { return [IgxGridFilterConditionPipe, IgxGridTransactionPipe, IgxGridNotGroupedPipe, IgxGridTopLevelColumns, IgxGridCellStylesPipe, IgxGridCellStyleClassesPipe, IgxGridPaginatorOptionsPipe, IgxHasVisibleColumnsPipe, IgxGridRowPinningPipe, IgxColumnActionEnabledPipe, IgxFilterActionColumnsPipe, IgxSortActionColumnsPipe, IgxGridDataMapperPipe, IgxStringReplacePipe, IgxGridTransactionStatePipe, IgxGridAddRowPipe, IgxColumnFormatterPipe]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxGridFilterConditionPipe, IgxGridTransactionPipe, IgxGridNotGroupedPipe, IgxGridTopLevelColumns, IgxGridCellStylesPipe, IgxGridCellStyleClassesPipe, IgxGridPaginatorOptionsPipe, IgxHasVisibleColumnsPipe, IgxGridRowPinningPipe, IgxColumnActionEnabledPipe, IgxFilterActionColumnsPipe, IgxSortActionColumnsPipe, IgxGridDataMapperPipe, IgxStringReplacePipe, IgxGridTransactionStatePipe, IgxGridAddRowPipe, IgxColumnFormatterPipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridPipesModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridFilterConditionPipe,
                    IgxGridTransactionPipe,
                    IgxGridNotGroupedPipe,
                    IgxGridTopLevelColumns,
                    IgxGridCellStylesPipe,
                    IgxGridCellStyleClassesPipe,
                    IgxGridPaginatorOptionsPipe,
                    IgxHasVisibleColumnsPipe,
                    IgxGridRowPinningPipe,
                    IgxColumnActionEnabledPipe,
                    IgxFilterActionColumnsPipe,
                    IgxSortActionColumnsPipe,
                    IgxGridDataMapperPipe,
                    IgxStringReplacePipe,
                    IgxGridTransactionStatePipe,
                    IgxGridAddRowPipe,
                    IgxColumnFormatterPipe
                ],
                exports: [
                    IgxGridFilterConditionPipe,
                    IgxGridTransactionPipe,
                    IgxGridNotGroupedPipe,
                    IgxGridTopLevelColumns,
                    IgxGridCellStylesPipe,
                    IgxGridCellStyleClassesPipe,
                    IgxGridPaginatorOptionsPipe,
                    IgxHasVisibleColumnsPipe,
                    IgxGridRowPinningPipe,
                    IgxColumnActionEnabledPipe,
                    IgxFilterActionColumnsPipe,
                    IgxSortActionColumnsPipe,
                    IgxGridDataMapperPipe,
                    IgxStringReplacePipe,
                    IgxGridTransactionStatePipe,
                    IgxGridAddRowPipe,
                    IgxColumnFormatterPipe
                ],
                imports: [
                    CommonModule
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridExcelStyleFilteringModule, { declarations: function () { return [IgxGridExcelStyleFilteringComponent, IgxExcelStyleHeaderComponent, IgxExcelStyleSortingComponent, IgxExcelStylePinningComponent, IgxExcelStyleHidingComponent, IgxExcelStyleSelectingComponent, IgxExcelStyleClearFiltersComponent, IgxExcelStyleConditionalFilterComponent, IgxExcelStyleMovingComponent, IgxExcelStyleSearchComponent, IgxExcelStyleCustomDialogComponent, IgxExcelStyleDefaultExpressionComponent, IgxExcelStyleDateExpressionComponent, IgxExcelStyleColumnOperationsTemplateDirective, IgxExcelStyleFilterOperationsTemplateDirective, IgxExcelStyleLoadingValuesTemplateDirective]; }, imports: function () { return [CommonModule,
        FormsModule, IgxGridPipesModule, IgxButtonModule, IgxButtonGroupModule, IgxDatePickerModule, IgxIconModule, IgxRippleModule, IgxInputGroupModule, IgxDropDownModule, IgxForOfModule, IgxCheckboxModule, IgxFilterModule, IgxToggleModule, IgxListModule, IgxProgressBarModule, IgxSelectModule]; }, exports: function () { return [IgxGridExcelStyleFilteringComponent, IgxExcelStyleColumnOperationsTemplateDirective, IgxExcelStyleFilterOperationsTemplateDirective, IgxExcelStyleLoadingValuesTemplateDirective, IgxExcelStyleDateExpressionComponent, IgxExcelStyleHeaderComponent, IgxExcelStyleSortingComponent, IgxExcelStylePinningComponent, IgxExcelStyleHidingComponent, IgxExcelStyleSelectingComponent, IgxExcelStyleClearFiltersComponent, IgxExcelStyleConditionalFilterComponent, IgxExcelStyleMovingComponent, IgxExcelStyleSearchComponent, IgxExcelStyleHeaderComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridExcelStyleFilteringModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridExcelStyleFilteringComponent,
                    IgxExcelStyleHeaderComponent,
                    IgxExcelStyleSortingComponent,
                    IgxExcelStylePinningComponent,
                    IgxExcelStyleHidingComponent,
                    IgxExcelStyleSelectingComponent,
                    IgxExcelStyleClearFiltersComponent,
                    IgxExcelStyleConditionalFilterComponent,
                    IgxExcelStyleMovingComponent,
                    IgxExcelStyleSearchComponent,
                    IgxExcelStyleCustomDialogComponent,
                    IgxExcelStyleDefaultExpressionComponent,
                    IgxExcelStyleDateExpressionComponent,
                    IgxExcelStyleColumnOperationsTemplateDirective,
                    IgxExcelStyleFilterOperationsTemplateDirective,
                    IgxExcelStyleLoadingValuesTemplateDirective
                ],
                exports: [
                    IgxGridExcelStyleFilteringComponent,
                    IgxExcelStyleColumnOperationsTemplateDirective,
                    IgxExcelStyleFilterOperationsTemplateDirective,
                    IgxExcelStyleLoadingValuesTemplateDirective,
                    IgxExcelStyleDateExpressionComponent,
                    IgxExcelStyleHeaderComponent,
                    IgxExcelStyleSortingComponent,
                    IgxExcelStylePinningComponent,
                    IgxExcelStyleHidingComponent,
                    IgxExcelStyleSelectingComponent,
                    IgxExcelStyleClearFiltersComponent,
                    IgxExcelStyleConditionalFilterComponent,
                    IgxExcelStyleMovingComponent,
                    IgxExcelStyleSearchComponent,
                    IgxExcelStyleHeaderComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    IgxGridPipesModule,
                    IgxButtonModule,
                    IgxButtonGroupModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxDropDownModule,
                    IgxForOfModule,
                    IgxCheckboxModule,
                    IgxFilterModule,
                    IgxToggleModule,
                    IgxListModule,
                    IgxProgressBarModule,
                    IgxSelectModule,
                ],
                entryComponents: [
                    IgxGridExcelStyleFilteringComponent
                ],
                providers: [
                    IgxSelectionAPIService
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridSelectionModule, { declarations: [IgxRowSelectorDirective, IgxHeadSelectorDirective, IgxGridDragSelectDirective], exports: [IgxRowSelectorDirective, IgxHeadSelectorDirective, IgxGridDragSelectDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSelectionModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxRowSelectorDirective,
                    IgxHeadSelectorDirective,
                    IgxGridDragSelectDirective
                ],
                exports: [
                    IgxRowSelectorDirective,
                    IgxHeadSelectorDirective,
                    IgxGridDragSelectDirective
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxResizeHandleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxResizeHandle]'
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: IgxColumnResizingService }]; }, { 
    /**
     * @hidden
     */
    onMouseOver: [{
            type: HostListener,
            args: ['mouseover']
        }], 
    /**
     * @hidden
     */
    onDoubleClick: [{
            type: HostListener,
            args: ['dblclick']
        }], column: [{
            type: Input,
            args: ['igxResizeHandle']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridResizingModule, { declarations: function () { return [IgxGridColumnResizerComponent, IgxResizeHandleDirective, IgxColumnResizerDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxGridColumnResizerComponent, IgxResizeHandleDirective, IgxColumnResizerDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridResizingModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridColumnResizerComponent,
                    IgxResizeHandleDirective,
                    IgxColumnResizerDirective
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    IgxGridColumnResizerComponent,
                    IgxResizeHandleDirective,
                    IgxColumnResizerDirective
                ],
                providers: [
                    IgxColumnResizingService
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnMovingDropDirective, [{
        type: Directive,
        args: [{
                selector: '[igxColumnMovingDrop]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: IgxColumnMovingService }]; }, { data: [{
            type: Input,
            args: ['igxColumnMovingDrop']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxColumnMovingModule, { declarations: [IgxColumnMovingDropDirective, IgxColumnMovingDragDirective], exports: [IgxColumnMovingDropDirective, IgxColumnMovingDragDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnMovingModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxColumnMovingDropDirective,
                    IgxColumnMovingDragDirective
                ],
                exports: [
                    IgxColumnMovingDropDirective,
                    IgxColumnMovingDragDirective
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSummaryDataPipe, [{
        type: Pipe,
        args: [{
                name: 'igxGridSummaryDataPipe',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridSummaryModule, { declarations: [IgxSummaryCellComponent, IgxSummaryRowComponent, IgxSummaryDataPipe], imports: [IgxGridPipesModule, IgxGridSharedModules], exports: [IgxSummaryCellComponent, IgxSummaryRowComponent, IgxSummaryDataPipe] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSummaryModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxSummaryCellComponent,
                    IgxSummaryRowComponent,
                    IgxSummaryDataPipe
                ],
                imports: [
                    IgxGridPipesModule,
                    IgxGridSharedModules
                ],
                exports: [
                    IgxSummaryCellComponent,
                    IgxSummaryRowComponent,
                    IgxSummaryDataPipe
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnPinningItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxColumnPinningItem]'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnPinningComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-column-pinning',
                template: "\n<div class=\"igx-column-actions__header\">\n    <h4 class=\"igx-column-actions__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-actions__header-input\" *ngIf=\"!disableFilter\">\n        <input igxInput\n            type=\"text\"\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-actions__columns\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox igxColumnPinningItem\n        *ngFor=\"let columnItem of pinnableColumns\"\n        class=\"igx-column-actions__columns-item\"\n        (change)=\"checkboxValueChange($event, columnItem)\"\n        [checked]=\"columnItem.value\">\n        {{ columnItem.name }}\n    </igx-checkbox>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxColumnPinningModule, { declarations: [IgxColumnPinningItemDirective, IgxColumnPinningComponent], imports: [IgxGridSharedModules], exports: [IgxColumnPinningComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnPinningModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxColumnPinningItemDirective,
                    IgxColumnPinningComponent
                ],
                imports: [
                    IgxGridSharedModules
                ],
                exports: [
                    IgxColumnPinningComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxColumnActionsModule, { declarations: [IgxColumnHidingDirective, IgxColumnPinningDirective, IgxColumnActionsComponent], imports: [IgxGridSharedModules, IgxGridPipesModule], exports: [IgxColumnHidingDirective, IgxColumnPinningDirective, IgxColumnActionsComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnActionsModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxColumnHidingDirective,
                    IgxColumnPinningDirective,
                    IgxColumnActionsComponent,
                ],
                imports: [
                    IgxGridSharedModules,
                    IgxGridPipesModule
                ],
                exports: [
                    IgxColumnHidingDirective,
                    IgxColumnPinningDirective,
                    IgxColumnActionsComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridToolbarModule, { declarations: [IgxGridToolbarComponent, IgxGridToolbarCustomContentDirective], imports: [IgxGridSharedModules, IgxColumnHidingModule, IgxColumnPinningModule, IgxColumnActionsModule], exports: [IgxGridToolbarComponent, IgxGridToolbarCustomContentDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridToolbarModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridToolbarComponent,
                    IgxGridToolbarCustomContentDirective
                ],
                imports: [
                    IgxGridSharedModules,
                    IgxColumnHidingModule,
                    IgxColumnPinningModule,
                    IgxColumnActionsModule
                ],
                exports: [
                    IgxGridToolbarComponent,
                    IgxGridToolbarCustomContentDirective
                ]
            }]
    }], null, null); })();
const ɵIgxColumnLayoutComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxColumnLayoutComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnLayoutComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: IgxColumnComponent, useExisting: forwardRef(() => IgxColumnLayoutComponent) }],
                selector: 'igx-column-layout',
                template: ``
            }]
    }], null, { hidden: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridColumnModule, { declarations: [IgxFilterCellTemplateDirective, IgxCellTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellFooterTemplateDirective, IgxCellEditorTemplateDirective, IgxCollapsibleIndicatorTemplateDirective, IgxColumnComponent, IgxColumnGroupComponent, IgxColumnLayoutComponent], exports: [IgxFilterCellTemplateDirective, IgxCellTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellFooterTemplateDirective, IgxCellEditorTemplateDirective, IgxCollapsibleIndicatorTemplateDirective, IgxColumnComponent, IgxColumnGroupComponent, IgxColumnLayoutComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridColumnModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxFilterCellTemplateDirective,
                    IgxCellTemplateDirective,
                    IgxCellHeaderTemplateDirective,
                    IgxCellFooterTemplateDirective,
                    IgxCellEditorTemplateDirective,
                    IgxCollapsibleIndicatorTemplateDirective,
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent
                ],
                entryComponents: [
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent
                ],
                exports: [
                    IgxFilterCellTemplateDirective,
                    IgxCellTemplateDirective,
                    IgxCellHeaderTemplateDirective,
                    IgxCellFooterTemplateDirective,
                    IgxCellEditorTemplateDirective,
                    IgxCollapsibleIndicatorTemplateDirective,
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridFilteringModule, { declarations: [IgxGridFilteringCellComponent, IgxGridFilteringRowComponent], imports: [IgxGridSharedModules, IgxGridPipesModule], exports: [IgxGridFilteringCellComponent, IgxGridFilteringRowComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridFilteringModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridFilteringCellComponent,
                    IgxGridFilteringRowComponent
                ],
                imports: [
                    IgxGridSharedModules,
                    IgxGridPipesModule
                ],
                exports: [
                    IgxGridFilteringCellComponent,
                    IgxGridFilteringRowComponent
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SortingIndexPipe, [{
        type: Pipe,
        args: [{
                name: 'sortingIndex',
                pure: true
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridHeadersModule, { declarations: [IgxGridHeaderComponent, IgxGridHeaderGroupComponent, SortingIndexPipe], imports: [IgxGridSharedModules, IgxGridFilteringModule, IgxColumnMovingModule, IgxGridResizingModule], exports: [IgxGridHeaderComponent, IgxGridHeaderGroupComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridHeadersModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridHeaderComponent,
                    IgxGridHeaderGroupComponent,
                    SortingIndexPipe
                ],
                imports: [
                    IgxGridSharedModules,
                    IgxGridFilteringModule,
                    IgxColumnMovingModule,
                    IgxGridResizingModule
                ],
                exports: [
                    IgxGridHeaderComponent,
                    IgxGridHeaderGroupComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridCommonModule, { declarations: [IgxRowDirective, IgxGridCellComponent, IgxRowEditTemplateDirective, IgxRowEditActionsDirective, IgxRowEditTextDirective, IgxRowEditTabStopDirective, IgxGridBodyDirective, IgxGridFooterComponent, IgxAdvancedFilteringDialogComponent], imports: [IgxGridColumnModule, IgxGridHeadersModule, IgxColumnMovingModule, IgxGridResizingModule, IgxColumnPinningModule, IgxGridSelectionModule, IgxGridSummaryModule, IgxGridToolbarModule, IgxColumnHidingModule, IgxColumnActionsModule, IgxGridPipesModule, IgxGridFilteringModule, IgxGridExcelStyleFilteringModule, IgxRowDragModule, IgxPaginatorModule, IgxGridSharedModules], exports: [IgxGridCellComponent, IgxRowEditTemplateDirective, IgxRowEditActionsDirective, IgxRowEditTextDirective, IgxRowEditTabStopDirective, IgxGridBodyDirective, IgxColumnHidingModule, IgxColumnPinningModule, IgxColumnActionsModule, IgxGridColumnModule, IgxGridHeadersModule, IgxGridPipesModule, IgxGridFilteringModule, IgxGridExcelStyleFilteringModule, IgxRowDragModule, IgxPaginatorModule, IgxGridFooterComponent, IgxGridResizingModule, IgxColumnMovingModule, IgxGridSelectionModule, IgxGridSummaryModule, IgxGridToolbarModule, IgxAdvancedFilteringDialogComponent, IgxGridSharedModules] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridCommonModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxRowDirective,
                    IgxGridCellComponent,
                    IgxRowEditTemplateDirective,
                    IgxRowEditActionsDirective,
                    IgxRowEditTextDirective,
                    IgxRowEditTabStopDirective,
                    IgxGridBodyDirective,
                    IgxGridFooterComponent,
                    IgxAdvancedFilteringDialogComponent
                ],
                entryComponents: [
                    IgxAdvancedFilteringDialogComponent
                ],
                exports: [
                    IgxGridCellComponent,
                    IgxRowEditTemplateDirective,
                    IgxRowEditActionsDirective,
                    IgxRowEditTextDirective,
                    IgxRowEditTabStopDirective,
                    IgxGridBodyDirective,
                    IgxColumnHidingModule,
                    IgxColumnPinningModule,
                    IgxColumnActionsModule,
                    IgxGridColumnModule,
                    IgxGridHeadersModule,
                    IgxGridPipesModule,
                    IgxGridFilteringModule,
                    IgxGridExcelStyleFilteringModule,
                    IgxRowDragModule,
                    IgxPaginatorModule,
                    IgxGridFooterComponent,
                    IgxGridResizingModule,
                    IgxColumnMovingModule,
                    IgxGridSelectionModule,
                    IgxGridSummaryModule,
                    IgxGridToolbarModule,
                    IgxAdvancedFilteringDialogComponent,
                    IgxGridSharedModules
                ],
                imports: [
                    IgxGridColumnModule,
                    IgxGridHeadersModule,
                    IgxColumnMovingModule,
                    IgxGridResizingModule,
                    IgxColumnPinningModule,
                    IgxGridSelectionModule,
                    IgxGridSummaryModule,
                    IgxGridToolbarModule,
                    IgxColumnHidingModule,
                    IgxColumnActionsModule,
                    IgxGridPipesModule,
                    IgxGridFilteringModule,
                    IgxGridExcelStyleFilteringModule,
                    IgxRowDragModule,
                    IgxPaginatorModule,
                    IgxGridSharedModules
                ],
                providers: [
                    { provide: IgxGridTransaction, useClass: IgxBaseTransactionService }
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSortingPipe, [{
        type: Pipe,
        args: [{
                name: 'gridSort',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridGroupingPipe, [{
        type: Pipe,
        args: [{
                name: 'gridGroupBy',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridPagingPipe, [{
        type: Pipe,
        args: [{
                name: 'gridPaging',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridFilteringPipe, [{
        type: Pipe,
        args: [{
                name: 'gridFiltering',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
const ɵIgxGridRowComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxGridRowComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-row',
                template: "\n <ng-container *ngTemplateOutlet='addRow ? addTemp : defaultTemp'></ng-container>\n\n<ng-template #addTemp>\n    <div class='igx-grid__tr--inner' [class.igx-grid__tr--add-animate]='animateAdd' (animationend)='animationEndHandler()'>\n        <ng-container *ngTemplateOutlet='defaultTemp'></ng-container>\n    </div>\n</ng-template>\n<ng-template #defaultTemp>\n<ng-container *ngIf=\"grid.groupingExpressions.length > 0\">\n    <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{grid.groupingExpressions.length}}\" (pointerdown)=\"$event.preventDefault()\" (click)=\"$event.stopPropagation()\"></div>\n</ng-container>\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"this.showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (pointerdown)=\"$event.preventDefault()\" (click)=\"onRowSelectorClick($event)\">\n         <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n        </ng-template>\n    </div>\n</ng-container>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n        <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n                <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n        </ng-template>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n    </ng-template>\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n        <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n                <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n        </ng-template>\n    </ng-container>\n</ng-container>\n\n<ng-container *ngIf=\"grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n        <ng-container *ngTemplateOutlet=\"mrlPinnedTemplate; context: getContextMRL(pinnedColumns, this)\"></ng-container>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <div class=\"igx-grid__mrl-block\" [ngStyle]=\"{\n            'grid-template-rows':col.getGridTemplate(true, false),\n            'grid-template-columns':col.getGridTemplate(false, false),\n            '-ms-grid-rows':col.getGridTemplate(true, true),\n            '-ms-grid-columns':col.getGridTemplate(false, true)\n        }\">\n            <ng-template ngFor let-col [ngForOf]=\"col.children\">\n                    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? mrlExpandableCellTemplate : mrlCellTemplate; context: getContext(col, this)\"></ng-container>\n            </ng-template>\n        </div>\n    </ng-template>\n\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n        <ng-container *ngTemplateOutlet=\"mrlPinnedTemplate; context: getContextMRL(pinnedColumns, this)\"></ng-container>\n    </ng-container>\n</ng-container>\n</ng-template>\n\n<ng-template #mrlPinnedTemplate let-pinnedColumns>\n    <div *ngFor=\"let col of pinnedColumns | igxTopLevel\" class=\"igx-grid__mrl-block\"\n    [class.igx-grid__td--pinned-last]=\"col.hasLastPinnedChildColumn\"\n    [class.igx-grid__td--pinned-first]=\"col.hasFirstPinnedChildColumn\"\n    [style.left]=\"mrlRightPinnedOffset\"\n    [ngStyle]=\"{\n        'grid-template-rows':col.getGridTemplate(true, false),\n        'grid-template-columns':col.getGridTemplate(false, false),\n        'z-index': col.pinned ? 1 : null,\n        '-ms-grid-rows':col.getGridTemplate(true, true),\n        '-ms-grid-columns':col.getGridTemplate(false, true)\n    }\">\n        <ng-template ngFor let-col [ngForOf]=\"col.children\">\n                <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails? mrlExpandableCellTemplate : mrlCellTemplate; context: getContext(col, this)\"></ng-container>\n        </ng-template>\n    </div>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [checked]=\"selected\"\n            [readonly]=\"true\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<ng-template #cellTemplate let-col>\n        <igx-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [firstPinned]=\"col.columnLayoutChild ? null : col.isFirstPinned\"\n        [style.min-height.px]=\"cellHeight\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [style.left]=\"col.rightPinnedOffset\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #expandableCellTemplate let-col>\n    <igx-expandable-grid-cell\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n        [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [expanded]=\"expanded\"\n        [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [style.min-height.px]=\"cellHeight\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-expandable-grid-cell>\n</ng-template>\n\n<ng-template #mrlCellTemplate let-col>\n    <igx-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n        [column]=\"col\"\n        [style.-ms-grid-row-span]=\"col.gridRowSpan\"\n        [style.-ms-grid-column-span]=\"col.gridColumnSpan\"\n        [style.grid-row-end]=\"col.rowEnd\"\n        [style.grid-column-end]=\"col.colEnd\"\n        [style.-ms-grid-row]=\"col.rowStart\"\n        [style.grid-row-start]=\"col.rowStart\"\n        [style.-ms-grid-column]=\"col.colStart\"\n        [style.grid-column-start]=\"col.colStart\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [firstPinned]=\"col.columnLayoutChild ? null : col.isFirstPinned\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"cellHeight\"\n        [rowData]=\"rowData\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #mrlExpandableCellTemplate let-col>\n    <igx-expandable-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n        [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n        [expanded]=\"expanded\"\n        [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n        [column]=\"col\"\n        [style.-ms-grid-row-span]=\"col.gridRowSpan\"\n        [style.-ms-grid-column-span]=\"col.gridColumnSpan\"\n        [style.grid-row-end]=\"col.rowEnd\"\n        [style.grid-column-end]=\"col.colEnd\"\n        [style.-ms-grid-row]=\"col.rowStart\"\n        [style.grid-row-start]=\"col.rowStart\"\n        [style.-ms-grid-column]=\"col.colStart\"\n        [style.grid-column-start]=\"col.colStart\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"cellHeight\"\n        [rowData]=\"rowData\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-expandable-grid-cell>\n</ng-template>\n",
                providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxGridRowComponent) }]
            }]
    }], null, { hasColumnLayouts: [{
            type: HostBinding,
            args: ['class.igx-grid__tr--mrl']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSummaryPipe, [{
        type: Pipe,
        args: [{
                name: 'gridSummary',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridDetailsPipe, [{
        type: Pipe,
        args: [{
                name: 'gridDetails',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridExpandableCellComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-expandable-grid-cell',
                template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip *ngIf=\"displayPinnedChip\" class=\"igx-grid__td--pinned-chip\" [disabled]=\"true\" [displayDensity]=\"'compact'\">{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip>\n</ng-template>\n<ng-template #defaultCell>\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n        [cssClass]=\"highlightClass\"\n        [activeCssClass]=\"activeHighlightClass\"\n        [groupName]=\"gridID\"\n        [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ? (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : value\"\n        [row]=\"rowData\"\n        [column]=\"this.column.field\"\n        [containerClass]=\"'igx-grid__td-text'\"\n        [metadata]=\"searchMetadata\">{{ formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ? (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : value }}</div>\n</ng-template>\n<ng-template #addRowCell let-cell=\"cell\">\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n    [cssClass]=\"highlightClass\"\n    [activeCssClass]=\"activeHighlightClass\"\n    [groupName]=\"gridID\"\n    [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ? (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : value\"\n    [row]=\"rowData\"\n    [column]=\"this.column.field\"\n    [containerClass]=\"'igx-grid__td-text'\"\n    [metadata]=\"searchMetadata\">{{\n        value ? value : (column.header || column.field)\n    }}</div>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"true\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"true\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outlet\" mode=\"dropdown\"\n        [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"true\" [labelVisibility]=\"false\">\n    </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"showExpanderIndicator\">\n    <div #indicator\n         class=\"igx-grid__tree-grouping-indicator\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus()\">\n         <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n    </div>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n</ng-template>\n",
                providers: [HammerGesturesManager]
            }]
    }], function () { return [{ type: IgxGridSelectionService }, { type: IgxGridCRUDService }, { type: GridBaseAPIService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: HammerGesturesManager }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: PlatformUtil }]; }, { expanded: [{
            type: Input
        }], indicator: [{
            type: ViewChild,
            args: ['indicator', { read: ElementRef }]
        }], indentationDiv: [{
            type: ViewChild,
            args: ['indentationDiv', { read: ElementRef }]
        }], defaultExpandedTemplate: [{
            type: ViewChild,
            args: ['defaultExpandedTemplate', { read: TemplateRef, static: true }]
        }], defaultCollapsedTemplate: [{
            type: ViewChild,
            args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridModule, { declarations: [IgxGridComponent, IgxGridRowComponent, IgxGridGroupByRowComponent, IgxGroupByRowTemplateDirective, IgxGridDetailTemplateDirective, IgxRowExpandedIndicatorDirective, IgxRowCollapsedIndicatorDirective, IgxHeaderExpandIndicatorDirective, IgxHeaderCollapseIndicatorDirective, IgxGroupAreaDropDirective, IgxGridGroupingPipe, IgxGridPagingPipe, IgxGridSortingPipe, IgxGridFilteringPipe, IgxGridSummaryPipe, IgxGridDetailsPipe, IgxGridExpandableCellComponent], imports: [IgxGridCommonModule], exports: [IgxGridComponent, IgxGridExpandableCellComponent, IgxGridGroupByRowComponent, IgxGridRowComponent, IgxGroupByRowTemplateDirective, IgxGridDetailTemplateDirective, IgxRowExpandedIndicatorDirective, IgxRowCollapsedIndicatorDirective, IgxHeaderExpandIndicatorDirective, IgxHeaderCollapseIndicatorDirective, IgxGroupAreaDropDirective, IgxGridGroupingPipe, IgxGridPagingPipe, IgxGridSortingPipe, IgxGridFilteringPipe, IgxGridSummaryPipe, IgxGridDetailsPipe, IgxGridCommonModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridComponent,
                    IgxGridRowComponent,
                    IgxGridGroupByRowComponent,
                    IgxGroupByRowTemplateDirective,
                    IgxGridDetailTemplateDirective,
                    IgxRowExpandedIndicatorDirective,
                    IgxRowCollapsedIndicatorDirective,
                    IgxHeaderExpandIndicatorDirective,
                    IgxHeaderCollapseIndicatorDirective,
                    IgxGroupAreaDropDirective,
                    IgxGridGroupingPipe,
                    IgxGridPagingPipe,
                    IgxGridSortingPipe,
                    IgxGridFilteringPipe,
                    IgxGridSummaryPipe,
                    IgxGridDetailsPipe,
                    IgxGridExpandableCellComponent
                ],
                exports: [
                    IgxGridComponent,
                    IgxGridExpandableCellComponent,
                    IgxGridGroupByRowComponent,
                    IgxGridRowComponent,
                    IgxGroupByRowTemplateDirective,
                    IgxGridDetailTemplateDirective,
                    IgxRowExpandedIndicatorDirective,
                    IgxRowCollapsedIndicatorDirective,
                    IgxHeaderExpandIndicatorDirective,
                    IgxHeaderCollapseIndicatorDirective,
                    IgxGroupAreaDropDirective,
                    IgxGridGroupingPipe,
                    IgxGridPagingPipe,
                    IgxGridSortingPipe,
                    IgxGridFilteringPipe,
                    IgxGridSummaryPipe,
                    IgxGridDetailsPipe,
                    IgxGridCommonModule
                ],
                imports: [
                    IgxGridCommonModule,
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            }]
    }], null, null); })();
const ɵIgxTreeGridAPIService_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxTreeGridAPIService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridAPIService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowLoadingIndicatorTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowLoadingIndicator]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
const ɵIgxTreeGridComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxTreeGridComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-tree-grid',
                template: "<igx-grid-toolbar role=\"toolbar\" [style.max-width.px]='outerWidth' [style.flex-basis.px]='outerWidth' *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" role=\"rowgroup\" [style.width.px]='calcWidth' tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\" (focus)=\"navigation.focusFirstCell()\" (keydown)=\"navigation.headerNavigation($event)\" #theadRow>\n        <div class=\"igx-grid__tr\" [style.width.px]='calcWidth' role=\"row\">\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" (pointerdown)=\"$event.preventDefault()\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible }\" (pointerdown)=\"$event.preventDefault()\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]=\"'calcPixelWidth'\" #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\" [style.left]=\"col.rightPinnedOffset\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollSize\"></div>\n    <div #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\"  tabindex=\"0\" (focus)=\"navigation.focusTbody($event)\" [attr.aria-activedescendant]=\"activeDescendant\" (keydown)=\"navigation.handleNavigation($event)\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth' #tbody (scroll)='preventContainerScroll($event)'>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template #pinnedRecordsTemplate>\n            <ng-container *ngIf='data\n            | treeGridTransaction:id:pipeTrigger\n            | visibleColumns:hasVisibleColumns\n            | treeGridNormalizeRecord:pipeTrigger\n            | gridRowPinning:id:true:pipeTrigger\n            | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n            | treeGridSorting:sortingExpressions:sortStrategy:id:pipeTrigger:true\n            | gridAddRow:true:pipeTrigger as pinnedData'>\n                <div #pinContainer *ngIf='pinnedData.length > 0'\n                    [ngClass]=\"{\n                        'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                        'igx-grid__tr--pinned-top': isRowPinningToTop\n                    }\"\n                    class='igx-grid__tr--pinned' [style.width.px]='calcWidth'>\n                    <ng-container *ngFor=\"let rowData of pinnedData;let rowIndex = index;\">\n                        <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                        </ng-container>\n                    </ng-container>\n                </div>\n            </ng-container>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | treeGridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:id:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | treeGridSorting:sortingExpressions:sortStrategy:id:pipeTrigger\n        | treeGridFlattening:id:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:page:perPage:id:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:showSummaryOnCollapse:id:pipeTrigger:summaryPipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\n        | gridAddRow:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" #verticalScrollContainer>\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex, false)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-disabledRow=\"disabled\" let-rowData let-isAddRow=\"addRow\">\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" [disabled]=\"disabledRow\" [addRow]=\"isAddRow\" #row>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData let-isAddRow=\"addRow\">\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" [addRow]=\"isAddRow\" #row #pinnedRow>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\"\n                [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\"  (pointerdown)=\"$event.preventDefault()\"\n            [style.height.px]='calcHeight'>\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [actionText]=\"snackbarActionText\" [displayTime]='snackbarDisplayTime'>{{snackbarLabel}}</igx-snackbar>\n    </div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\" (focus)=\"navigation.focusFirstCell(false)\" (keydown)=\"navigation.summaryNav($event)\" #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollSize\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\" (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [overlaySettings]=\"paginatorSettings\" [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\"\n        [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button igxButton=\"raised\" igxRipple (click)='beginAddRowByIndex(null, -1)'>\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\" *ngIf=\"!this.crudService.row?.isAddRow\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [readonly]=\"true\"\n            disableRipple=\"true\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n",
                providers: [
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    IgxGridSummaryService,
                    IgxGridNavigationService,
                    { provide: GridBaseAPIService, useClass: IgxTreeGridAPIService },
                    { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxTreeGridComponent) },
                    IgxFilteringService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService
                ]
            }]
    }], null, { cascadeOnDelete: [{
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], data: [{
            type: Input
        }], expansionDepth: [{
            type: Input
        }], rowLoadingIndicatorTemplate: [{
            type: Input
        }], childDataKey: [{
            type: Input
        }], foreignKey: [{
            type: Input
        }], hasChildrenKey: [{
            type: Input
        }], rowLoadingTemplate: [{
            type: ContentChild,
            args: [IgxRowLoadingIndicatorTemplateDirective, { read: IgxRowLoadingIndicatorTemplateDirective }]
        }], loadChildrenOnDemand: [{
            type: Input
        }], dragIndicatorIconBase: [{
            type: ViewChild,
            args: ['dragIndicatorIconBase', { read: TemplateRef, static: true }]
        }], recordTemplate: [{
            type: ViewChild,
            args: ['record_template', { read: TemplateRef, static: true }]
        }], summaryTemplate: [{
            type: ViewChild,
            args: ['summary_template', { read: TemplateRef, static: true }]
        }] }); })();
const ɵIgxTreeGridRowComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxTreeGridRowComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-tree-grid-row',
                template: "<ng-container *ngTemplateOutlet='addRow ? addTemp : defaultTemp'></ng-container>\n\n<ng-template #addTemp>\n    <div class='igx-grid__tr--inner' [class.igx-grid__tr--add-animate]='animateAdd' (animationend)='animationEndHandler()'>\n        <ng-container *ngTemplateOutlet='defaultTemp'></ng-container>\n    </div>\n</ng-template>\n<ng-template #defaultTemp>\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\" (pointerdown)=\"$event.preventDefault()\">\n        <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n        </ng-template>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n    <ng-container *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-container>\n</ng-container>\n<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]=\"'calcPixelWidth'\" [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <ng-template #cellTemplate>\n        <igx-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"cellHeight\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n            #treeCell>\n        </igx-grid-cell>\n    </ng-template>\n    <ng-template #treeCellTemplate>\n        <igx-tree-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n            [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [level]=\"treeRow.level\"\n            [expanded]=\"treeRow.expanded\"\n            [showIndicator]=\"showIndicator\"\n            [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"cellHeight\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger\"\n            [isLoading]=\"isLoading\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n            #treeCell>\n        </igx-tree-grid-cell>\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n</ng-template>\n<ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n    <ng-container *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-container>\n</ng-container>\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"selected\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<ng-template #pinnedCellsTemplate let-col>\n    <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n        <ng-template #cellTemplate>\n            <igx-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n                [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n                [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n                [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [firstPinned]=\"col.isFirstPinned\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"cellHeight\"\n                [rowData]=\"rowData\"\n                [style.min-width]=\"col.width\"\n                [style.max-width]=\"col.width\"\n                [style.flex-basis]=\"col.width\"\n                [style.left]=\"col.rightPinnedOffset\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [lastSearchInfo]=\"grid.lastSearchInfo\"\n                [active]=\"isCellActive(col.visibleIndex)\"\n                [cellSelectionMode]=\"grid.cellSelection\"\n                [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n                #treeCell>\n            </igx-grid-cell>\n            </ng-template>\n        <ng-template #treeCellTemplate>\n            <igx-tree-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell igx-grid__td--pinned\"\n                [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n                [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n                [level]=\"treeRow.level\"\n                [expanded]=\"treeRow.expanded\"\n                [showIndicator]=\"showIndicator\"\n                [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"cellHeight\"\n                [rowData]=\"rowData\"\n                [style.min-width]=\"col.width\"\n                [style.max-width]=\"col.width\"\n                [style.flex-basis]=\"col.width\"\n                [style.left]=\"col.rightPinnedOffset\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger\"\n                [isLoading]=\"isLoading\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [lastSearchInfo]=\"grid.lastSearchInfo\"\n                [active]=\"isCellActive(col.visibleIndex)\"\n                [cellSelectionMode]=\"grid.cellSelection\"\n                [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n                #treeCell>\n            </igx-tree-grid-cell>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n    </ng-template>\n</ng-template>\n</ng-template>",
                providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxTreeGridRowComponent) }]
            }]
    }], null, { treeRow: [{
            type: Input
        }], expanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], _cells: [{
            type: ViewChildren,
            args: ['treeCell']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridHierarchizingPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridHierarchizing',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridFlatteningPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridFlattening',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridSortingPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridSorting',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridPagingPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridPaging',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridTransactionPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridTransaction',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridNormalizeRecordsPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridNormalizeRecord',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
const ɵIgxTreeGridCellComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxTreeGridCellComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridCellComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-tree-grid-cell',
                template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip\n        *ngIf=\"displayPinnedChip\"\n        class=\"igx-grid__td--pinned-chip\"\n        [disabled]=\"true\"\n        [displayDensity]=\"'compact'\"\n        >{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip\n    >\n</ng-template>\n<ng-template #defaultCell>\n    <div *ngIf=\"column.dataType !== 'boolean'\"\n        igxTextHighlight\n        class=\"igx-grid__td-text\"\n        style=\"pointer-events: none;\"\n        [cssClass]=\"highlightClass\"\n        [activeCssClass]=\"activeHighlightClass\"\n        [groupName]=\"gridID\"\n        [value]=\"\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === 'number'\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'date'\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : value\n        \"\n        [row]=\"rowData\"\n        [column]=\"this.column.field\"\n        [containerClass]=\"'igx-grid__td-text'\"\n        [metadata]=\"searchMetadata\"\n    >{{\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === \"number\"\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === \"date\"\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : value\n        }}</div>\n    <igx-icon\n        *ngIf=\"column.dataType === 'boolean'\"\n        [ngClass]=\"{ 'igx-icon--success': value, 'igx-icon--error': !value }\"\n        >{{ value ? \"check\" : \"close\" }}</igx-icon\n    >\n</ng-template>\n<ng-template #addRowCell let-cell=\"cell\">\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n    [cssClass]=\"highlightClass\"\n    [activeCssClass]=\"activeHighlightClass\"\n    [groupName]=\"gridID\"\n    [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ? (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : value\"\n    [row]=\"rowData\"\n    [column]=\"this.column.field\"\n    [containerClass]=\"'igx-grid__td-text'\"\n    [metadata]=\"searchMetadata\">{{\n        !isEmptyAddRowCell ? value : (column.header || column.field)\n    }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"true\" />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [(ngModel)]=\"editValue\"\n                [igxFocus]=\"true\"\n                type=\"number\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox\n            (change)=\"editValue = $event.checked\"\n            [value]=\"editValue\"\n            [checked]=\"editValue\"\n            [disableRipple]=\"true\"\n        ></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker\n            [style.width.%]=\"100\"\n            [outlet]=\"grid.outlet\"\n            mode=\"dropdown\"\n            [locale]=\"grid.locale\"\n            [(value)]=\"editValue\"\n            [igxFocus]=\"true\"\n            [labelVisibility]=\"false\"\n        >\n        </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"!editMode\">\n    <ng-container *ngIf=\"level > 0\">\n        <div\n            #indentationDiv\n            class=\"igx-grid__tree-cell--padding-level-{{ level }}\"\n        ></div>\n    </ng-container>\n    <div\n        #indicator\n        *ngIf=\"!isLoading\"\n        class=\"igx-grid__tree-grouping-indicator\"\n        [ngStyle]=\"{ visibility: showIndicator ? 'visible' : 'hidden' }\"\n        (click)=\"toggle($event)\"\n        (focus)=\"onIndicatorFocus()\"\n    >\n        <ng-container\n            *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\"\n        >\n        </ng-container>\n        <ng-container\n            *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\"\n        >\n        </ng-container>\n    </div>\n    <div\n        *ngIf=\"isLoading\"\n        (dblclick)=\"onLoadingDblClick($event)\"\n        class=\"igx-grid__tree-loading-indicator\"\n    >\n        <ng-container\n            *ngTemplateOutlet=\"\n                grid.rowLoadingIndicatorTemplate\n                    ? grid.rowLoadingIndicatorTemplate\n                    : defaultLoadingIndicatorTemplate\n            \"\n        >\n        </ng-container>\n    </div>\n    <ng-template #defaultLoadingIndicatorTemplate>\n        <igx-circular-bar [indeterminate]=\"true\"> </igx-circular-bar>\n    </ng-template>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\"> </ng-container>\n<ng-template #defaultExpandedTemplate>\n    <igx-icon fontSet=\"material\">expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n    <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n</ng-template>\n",
                providers: [HammerGesturesManager]
            }]
    }], null, { level: [{
            type: Input
        }], showIndicator: [{
            type: Input
        }], isLoading: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridSummaryPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridSummary',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTreeGridModule, { declarations: [IgxTreeGridComponent, IgxTreeGridRowComponent, IgxTreeGridCellComponent, IgxTreeGridHierarchizingPipe, IgxTreeGridFlatteningPipe, IgxTreeGridSortingPipe, IgxTreeGridFilteringPipe, IgxTreeGridPagingPipe, IgxTreeGridTransactionPipe, IgxTreeGridSummaryPipe, IgxRowLoadingIndicatorTemplateDirective, IgxTreeGridNormalizeRecordsPipe], imports: [IgxGridCommonModule], exports: [IgxTreeGridComponent, IgxTreeGridRowComponent, IgxTreeGridCellComponent, IgxRowLoadingIndicatorTemplateDirective, IgxGridCommonModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxTreeGridComponent,
                    IgxTreeGridRowComponent,
                    IgxTreeGridCellComponent,
                    IgxTreeGridHierarchizingPipe,
                    IgxTreeGridFlatteningPipe,
                    IgxTreeGridSortingPipe,
                    IgxTreeGridFilteringPipe,
                    IgxTreeGridPagingPipe,
                    IgxTreeGridTransactionPipe,
                    IgxTreeGridSummaryPipe,
                    IgxRowLoadingIndicatorTemplateDirective,
                    IgxTreeGridNormalizeRecordsPipe
                ],
                exports: [
                    IgxTreeGridComponent,
                    IgxTreeGridRowComponent,
                    IgxTreeGridCellComponent,
                    IgxRowLoadingIndicatorTemplateDirective,
                    IgxGridCommonModule
                ],
                imports: [
                    IgxGridCommonModule,
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxChildGridRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-child-grid-row',
                template: "<div class=\"igx-grid__hierarchical-indent\" [ngClass]=\"{'igx-grid__hierarchical-indent--scroll': parentHasScroll}\">\n    <igx-hierarchical-grid #hgrid [data]='rowData.childGridsData[layout.key]'></igx-hierarchical-grid>\n</div>\n"
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ChangeDetectorRef }]; }, { rowData: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], level: [{
            type: HostBinding,
            args: ['attr.data-level']
        }], layout: [{
            type: Input
        }], parentGridID: [{
            type: Input
        }], index: [{
            type: Input
        }], hGrid: [{
            type: ViewChild,
            args: ['hgrid', { static: true }]
        }] }); })();
const ɵIgxHierarchicalGridNavigationService_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxHierarchicalGridNavigationService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalGridNavigationService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalGridBaseDirective, [{
        type: Directive
    }], function () { return [{ type: IgxGridSelectionService }, { type: IgxGridCRUDService }, { type: IgxColumnResizingService }, { type: GridBaseAPIService }, { type: undefined, decorators: [{
                type: Inject,
                args: [IgxGridTransaction]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ViewContainerRef }, { type: IgxHierarchicalGridNavigationService }, { type: IgxFilteringService }, { type: IgxOverlayService, decorators: [{
                type: Inject,
                args: [IgxOverlayService]
            }] }, { type: IgxGridSummaryService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, { showExpandAll: [{
            type: Input
        }], onDataPreLoad: [{
            type: Output
        }], hasChildrenKey: [{
            type: Input
        }], dragIndicatorIconBase: [{
            type: ViewChild,
            args: ['dragIndicatorIconBase', { read: TemplateRef, static: true }]
        }] }); })();
const ɵIgxHierarchicalGridAPIService_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxHierarchicalGridAPIService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalGridAPIService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowIslandAPIService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowIslandComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-row-island',
                template: ``,
                providers: [IgxRowIslandAPIService,
                    IgxGridSelectionService]
            }]
    }], function () { return [{ type: IgxGridSelectionService }, { type: IgxGridCRUDService }, { type: IgxColumnResizingService }, { type: GridBaseAPIService }, { type: undefined, decorators: [{
                type: Inject,
                args: [IgxGridTransaction]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ViewContainerRef }, { type: IgxHierarchicalGridNavigationService }, { type: IgxFilteringService }, { type: IgxOverlayService, decorators: [{
                type: Inject,
                args: [IgxOverlayService]
            }] }, { type: IgxGridSummaryService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: IgxRowIslandAPIService }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, { children: [{
            type: ContentChildren,
            args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false }]
        }], childColumns: [{
            type: ContentChildren,
            args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: false }]
        }], onLayoutChange: [{
            type: Output
        }], onGridCreated: [{
            type: Output
        }], onGridInitialized: [{
            type: Output
        }], expandChildren: [{
            type: Input
        }], key: [{
            type: Input
        }], actionStrips: [{
            type: ContentChildren,
            args: [IgxActionStripComponent, { read: IgxActionStripComponent, descendants: false }]
        }] }); })();
const ɵIgxHierarchicalGridComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxHierarchicalGridComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalGridComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-hierarchical-grid',
                template: "<igx-grid-toolbar role=\"toolbar\" [style.max-width.px]='outerWidth' [style.flex-basis.px]=\"outerWidth\" *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\"  tabindex=\"0\" (focus)=\"navigation.focusFirstCell()\" [attr.aria-activedescendant]=\"activeDescendant\"\n     (keydown)=\"navigation.headerNavigation($event)\" role=\"rowgroup\" [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <div #headerHierarchyExpander (click)=\"toggleAll()\" (mousedown)='$event.preventDefault()' [hidden]='!hasExpandableChildren || !hasVisibleColumns' [ngClass]=\"{\n                'igx-grid__hierarchical-expander igx-grid__hierarchical-expander--header': hasExpandableChildren,\n                'igx-grid__hierarchical-expander--push': filteringService.isFilterRowVisible,\n                'igx-grid__hierarchical-expander--no-border': isRowSelectable || rowDraggable\n            }\">\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n            </div>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                        'igx-grid__drag-indicator--header': !isRowSelectable\n                    }\" (pointerdown)='$event.preventDefault()' #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                        'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                    }\"  (pointerdown)='$event.preventDefault()'>\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter,\n                                        selectAll: selectAllRows.bind(this),\n                                        deselectAll: deselectAllRows.bind(this) }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group\n                        [column]=\"col\"\n                        [gridID]=\"id\"\n                        [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"\n                        [style.left]=\"col.rightPinnedOffset\">\n                    </igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollSize\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\"  tabindex=\"0\" (focus)=\"navigation.focusTbody($event)\" [attr.aria-activedescendant]=\"activeDescendant\"\n     (keydown)=\"navigation.handleNavigation($event)\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\" role=\"rowgroup\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth' #tbody (scroll)='preventContainerScroll($event)'>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template #pinnedRecordsTemplate>\n            <ng-container *ngIf=\"data\n            | gridTransaction:id:pipeTrigger\n            | visibleColumns:hasVisibleColumns\n            | gridRowPinning:id:true:pipeTrigger\n            | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n            | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger:true\n            | gridAddRow:true:pipeTrigger as pinnedData\">\n                <div #pinContainer *ngIf='pinnedData.length > 0' class='igx-grid__tr--pinned'\n                    [ngClass]=\"{ 'igx-grid__tr--pinned-bottom':  !isRowPinningToTop, 'igx-grid__tr--pinned-top': isRowPinningToTop }\"\n                    [style.width.px]='calcWidth'>\n                    <ng-container *ngFor=\"let rowData of pinnedData; let rowIndex = index\">\n                        <ng-container *ngTemplateOutlet=\"pinned_hierarchical_record_template; context: getContext(rowData, rowIndex, true)\">\n                        </ng-container>\n                    </ng-container>\n                </div>\n            </ng-container>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-template igxGridFor let-rowData let-rowIndex=\"index\" [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger\n        | gridHierarchicalPaging:page:perPage:id:pipeTrigger\n        | gridHierarchical:expansionStates:id:primaryKey:childLayoutKeys:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\n        | gridAddRow:false:pipeTrigger\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" [igxForTrackBy]='trackChanges'\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template\n                [igxTemplateOutlet]='(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template))'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex, false)' (onViewCreated)='viewCreatedHandler($event)'\n                (onViewMoved)='viewMovedHandler($event)' (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n            <!-- <ng-container *igxTemplateOutlet=\"(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template)); context: getContext(rowData)\"></ng-container> -->\n        </ng-template>\n        <ng-template #hierarchical_record_template let-rowIndex=\"index\" let-disabledRow=\"disabled\" let-rowData let-isAddRow=\"addRow\">\n            <igx-hierarchical-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [disabled]=\"disabledRow\" [rowData]=\"rowData\" [addRow]=\"isAddRow\" #row>\n            </igx-hierarchical-grid-row>\n        </ng-template>\n\n        <ng-template #pinned_hierarchical_record_template let-rowIndex=\"index\" let-rowData let-isAddRow=\"addRow\">\n            <igx-hierarchical-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" [addRow]=\"isAddRow\" #row #pinnedRow>\n            </igx-hierarchical-grid-row>\n        </ng-template>\n        <ng-template #child_record_template let-rowIndex=\"index\" let-rowData>\n            <div style=\"overflow:auto;width: 100%;\" [attr.data-rowindex]='rowIndex' (scroll)='onContainerScroll()'\n                [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr--highlighted':isRowHighlighted(rowData)\n            }\">\n                <igx-child-grid-row *ngFor=\"let layout of childLayoutList\" [parentGridID]=\"id\" [index]=\"rowIndex\"\n                    [rowData]=\"rowData\" [layout]='layout' #row>\n                </igx-child-grid-row>\n            </div>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n            id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark *ngIf=\"!this.parent\"></igc-trial-watermark>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\" (pointerdown)=\"$event.preventDefault()\">\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [actionText]=\"snackbarActionText\" [displayTime]='snackbarDisplayTime'>{{snackbarLabel}}</igx-snackbar>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\" [attr.aria-activedescendant]=\"activeDescendant\"\n (keydown)=\"navigation.summaryNav($event)\"  role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollSize\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\"  (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [overlaySettings]=\"paginatorSettings\" [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button igxButton=\"raised\" igxRipple (click)='beginAddRowByIndex(null, -1)'>\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" fontSet=\"material\">unfold_more</igx-icon>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" [isActive]='hasExpandedRecords() && hasExpandableChildren' fontSet=\"material\">unfold_less</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\" *ngIf=\"!this.crudService.row?.isAddRow\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n",
                providers: [
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    { provide: GridBaseAPIService, useClass: IgxHierarchicalGridAPIService },
                    { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxHierarchicalGridComponent) },
                    IgxGridSummaryService,
                    IgxFilteringService,
                    IgxHierarchicalGridNavigationService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService,
                    IgxRowIslandAPIService
                ]
            }]
    }], null, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], data: [{
            type: Input
        }], expandChildren: [{
            type: Input
        }], childLayoutList: [{
            type: ContentChildren,
            args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false }]
        }], allLayoutList: [{
            type: ContentChildren,
            args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: true }]
        }], hierarchicalRecordTemplate: [{
            type: ViewChild,
            args: ['hierarchical_record_template', { read: TemplateRef, static: true }]
        }], childTemplate: [{
            type: ViewChild,
            args: ['child_record_template', { read: TemplateRef, static: true }]
        }], headerHierarchyExpander: [{
            type: ViewChild,
            args: ['headerHierarchyExpander', { read: ElementRef, static: true }]
        }], templateOutlets: [{
            type: ViewChildren,
            args: [IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective }]
        }], hierarchicalRows: [{
            type: ViewChildren,
            args: [IgxChildGridRowComponent, { read: IgxChildGridRowComponent }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalGridCellComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-hierarchical-grid-cell',
                template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip\n        *ngIf=\"displayPinnedChip\"\n        class=\"igx-grid__td--pinned-chip\"\n        [disabled]=\"true\"\n        [displayDensity]=\"'compact'\"\n        >{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip\n    >\n</ng-template>\n<ng-template #defaultCell>\n    <div *ngIf=\"column.dataType !== 'boolean'\"\n        igxTextHighlight\n        class=\"igx-grid__td-text\"\n        style=\"pointer-events: none;\"\n        [cssClass]=\"highlightClass\"\n        [activeCssClass]=\"activeHighlightClass\"\n        [groupName]=\"gridID\"\n        [value]=\"\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === 'number'\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === 'date'\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : value\n        \"\n        [row]=\"rowData\"\n        [column]=\"this.column.field\"\n        [containerClass]=\"'igx-grid__td-text'\"\n        [metadata]=\"searchMetadata\"\n    >{{\n            formatter\n                ? (value | columnFormatter: formatter)\n                : column.dataType === \"number\"\n                ? (value | number:column.pipeArgs.digitsInfo:grid.locale)\n                : column.dataType === \"date\"\n                ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale)\n                : value\n        }}</div>\n    <igx-icon\n        *ngIf=\"column.dataType === 'boolean'\"\n        [ngClass]=\"{ 'igx-icon--success': value, 'igx-icon--error': !value }\"\n        >{{ value ? \"check\" : \"close\" }}</igx-icon\n    >\n</ng-template>\n<ng-template #addRowCell let-cell=\"cell\">\n    <div igxTextHighlight class=\"igx-grid__td-text\" style=\"pointer-events: none\"\n    [cssClass]=\"highlightClass\"\n    [activeCssClass]=\"activeHighlightClass\"\n    [groupName]=\"gridID\"\n    [value]=\"formatter ? (value | columnFormatter:formatter) : column.dataType === 'number' ? (value | number:column.pipeArgs.digitsInfo:grid.locale) : column.dataType === 'date' ? (value | date:column.pipeArgs.format:column.pipeArgs.timezone:grid.locale) : value\"\n    [row]=\"rowData\"\n    [column]=\"this.column.field\"\n    [containerClass]=\"'igx-grid__td-text'\"\n    [metadata]=\"searchMetadata\">{{\n        !isEmptyAddRowCell ? value : (column.header || column.field)\n    }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input\n                igxInput\n                [value]=\"editValue\"\n                (input)=\"editValue = $event.target.value\"\n                [igxFocus]=\"true\"\n                type=\"number\"\n            />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox\n            (change)=\"editValue = $event.checked\"\n            [value]=\"editValue\"\n            [checked]=\"editValue\"\n            [igxFocus]=\"true\"\n            [disableRipple]=\"true\"\n        ></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker\n            [style.width.%]=\"100\"\n            [outlet]=\"grid.outlet\"\n            mode=\"dropdown\"\n            [locale]=\"grid.locale\"\n            [(value)]=\"editValue\"\n            [igxFocus]=\"true\"\n            [labelVisibility]=\"false\"\n        >\n        </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n",
                providers: [HammerGesturesManager]
            }]
    }], function () { return [{ type: IgxGridSelectionService }, { type: IgxGridCRUDService }, { type: GridBaseAPIService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: HammerGesturesManager }, { type: PlatformUtil }]; }, null); })();
const ɵIgxHierarchicalRowComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxHierarchicalRowComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-hierarchical-grid-row',
                template: "\n<ng-container *ngTemplateOutlet='addRow ? addTemp : defaultTemp'></ng-container>\n<ng-template #defaultExpandedTemplate>\n    <igx-icon [isActive]='!added' fontSet=\"material\">expand_more</igx-icon>\n</ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n    <igx-icon [isActive]='!added' fontSet=\"material\">chevron_right</igx-icon>\n</ng-template>\n\n<ng-template #defaultEmptyTemplate>\n    <igx-icon fontSet=\"material\"></igx-icon>\n</ng-template>\n\n<ng-template #addTemp>\n    <div class='igx-grid__tr--inner' [class.igx-grid__tr--add-animate]='animateAdd' (animationend)='animationEndHandler()'>\n        <ng-container *ngTemplateOutlet='defaultTemp'></ng-container>\n    </div>\n</ng-template>\n<ng-template #defaultTemp>\n    <div (click)=\"expanderClick($event)\" (mousedown)='$event.preventDefault()' [ngClass]=\"expanderClassResolved\" *ngIf=\"hasChildren\" #expander>\n            <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n            </ng-container>\n    </div>\n\n    <ng-container *ngIf=\"rowDraggable\">\n        <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\" (pointerdown)=\"$event.preventDefault()\">\n                <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n        </div>\n    </ng-container>\n    <ng-container *ngIf=\"showRowSelectors\">\n        <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\" (pointerdown)=\"$event.preventDefault()\">\n            <ng-template *ngTemplateOutlet=\"\n                this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n                context: { $implicit: {\n                                index: viewIndex,\n                                rowID: rowID,\n                                selected: selected,\n                                select: select,\n                                deselect: deselect }}\">\n            </ng-template>\n        </div>\n    </ng-container>\n\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n        <ng-template *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-template>\n    </ng-container>\n\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"' [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <igx-hierarchical-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [style.min-height.px]=\"cellHeight\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\">\n        </igx-hierarchical-grid-cell>\n    </ng-template>\n\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n        <ng-template *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-template>\n    </ng-container>\n\n    <ng-template #rowSelectorBaseTemplate>\n        <div class=\"igx-grid__cbx-padding\">\n            <igx-checkbox\n                [tabindex]=\"-1\"\n                [readonly]=\"true\"\n                [checked]=\"selected\"\n                disableRipple=\"true\"\n                [disabled]=\"deleted\"\n                [disableTransitions]=\"grid.disableTransitions\"\n                [aria-label]=\"rowCheckboxAriaLabel\">\n            </igx-checkbox>\n        </div>\n    </ng-template>\n\n    <ng-template #pinnedCellsTemplate let-col>\n        <igx-hierarchical-grid-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n            [class.igx-grid__td--edited]=\"rowID | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.crudService.cell:grid.crudService.row\"\n            [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex:grid.pipeTrigger\"\n            [editMode]=\"col.editable && crudService.targetInEdit(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [firstPinned]=\"col.isFirstPinned\"\n            [lastPinned]=\"col.isLastPinned\"\n            [style.min-height.px]=\"cellHeight\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [style.left]=\"col.rightPinnedOffset\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData | dataMapper:col.field:grid.pipeTrigger\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\">\n        </igx-hierarchical-grid-cell>\n    </ng-template>\n</ng-template>",
                providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxHierarchicalRowComponent) }]
            }]
    }], null, { expandedClass: [{
            type: HostBinding,
            args: ['class.igx-grid__tr--expanded']
        }], highlighted: [{
            type: HostBinding,
            args: ['class.igx-grid__tr--highlighted']
        }], _cells: [{
            type: ViewChildren,
            args: [forwardRef(() => IgxHierarchicalGridCellComponent), { read: IgxHierarchicalGridCellComponent }]
        }], expander: [{
            type: ViewChild,
            args: ['expander', { read: ElementRef }]
        }], defaultExpandedTemplate: [{
            type: ViewChild,
            args: ['defaultExpandedTemplate', { read: TemplateRef, static: true }]
        }], defaultEmptyTemplate: [{
            type: ViewChild,
            args: ['defaultEmptyTemplate', { read: TemplateRef, static: true }]
        }], defaultCollapsedTemplate: [{
            type: ViewChild,
            args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridHierarchicalPipe, [{
        type: Pipe,
        args: [{
                name: 'gridHierarchical',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridHierarchicalPagingPipe, [{
        type: Pipe,
        args: [{
                name: 'gridHierarchicalPaging',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxHierarchicalGridModule, { declarations: [IgxHierarchicalGridComponent, IgxHierarchicalRowComponent, IgxRowIslandComponent, IgxChildGridRowComponent, IgxHierarchicalGridCellComponent, IgxGridHierarchicalPipe, IgxGridHierarchicalPagingPipe], imports: [IgxGridModule], exports: [IgxGridModule, IgxHierarchicalGridComponent, IgxHierarchicalRowComponent, IgxHierarchicalGridCellComponent, IgxRowIslandComponent, IgxChildGridRowComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalGridModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxHierarchicalGridComponent,
                    IgxHierarchicalRowComponent,
                    IgxRowIslandComponent,
                    IgxChildGridRowComponent,
                    IgxHierarchicalGridCellComponent,
                    IgxGridHierarchicalPipe,
                    IgxGridHierarchicalPagingPipe
                ],
                exports: [
                    IgxGridModule,
                    IgxHierarchicalGridComponent,
                    IgxHierarchicalRowComponent,
                    IgxHierarchicalGridCellComponent,
                    IgxRowIslandComponent,
                    IgxChildGridRowComponent
                ],
                imports: [
                    IgxGridModule,
                ],
                entryComponents: [
                    IgxGridComponent
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavbarActionDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-navbar-action,[igxNavbarAction]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavbarTitleDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-navbar-title,[igxNavbarTitle]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavbarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-navbar',
                template: "<nav class=\"igx-navbar\" role=\"navigation\" [attr.aria-labelledby]=\"titleId\">\n    <div class=\"igx-navbar__left\">\n        <igx-icon\n            (click)=\"_triggerAction()\"\n            fontSet=\"material\"\n            *ngIf=\"isActionButtonVisible\">\n            {{actionButtonIcon}}\n        </igx-icon>\n        <ng-content select=\"igx-navbar-action, [igxNavbarAction]\"></ng-content>\n        <h1\n            *ngIf=\"!isTitleContentVisible\"\n            class=\"igx-navbar__title\"\n            [attr.id]=\"titleId\">\n            {{ title }}\n        </h1>\n        <ng-content select=\"igx-navbar-title, [igxNavbarTitle]\"></ng-content>\n    </div>\n    <div class=\"igx-navbar__right\">\n        <ng-content></ng-content>\n    </div>\n</nav>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], onAction: [{
            type: Output
        }], titleId: [{
            type: Input
        }], isActionButtonVisible: [{
            type: Input
        }], actionButtonIcon: [{
            type: Input
        }], title: [{
            type: Input
        }], actionIconTemplate: [{
            type: ContentChild,
            args: [IgxNavbarActionDirective, { read: IgxNavbarActionDirective }]
        }], titleContent: [{
            type: ContentChild,
            args: [IgxNavbarTitleDirective, { read: IgxNavbarTitleDirective }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxNavbarModule, { declarations: function () { return [IgxNavbarComponent, IgxNavbarActionDirective, IgxNavbarTitleDirective]; }, imports: function () { return [IgxButtonModule, IgxIconModule, CommonModule]; }, exports: function () { return [IgxNavbarComponent, IgxNavbarActionDirective, IgxNavbarTitleDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavbarModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxNavbarComponent, IgxNavbarActionDirective, IgxNavbarTitleDirective],
                exports: [IgxNavbarComponent, IgxNavbarActionDirective, IgxNavbarTitleDirective],
                imports: [IgxButtonModule, IgxIconModule, CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavDrawerItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDrawerItem]',
                exportAs: 'igxDrawerItem'
            }]
    }], function () { return []; }, { active: [{
            type: Input,
            args: ['active']
        }], isHeader: [{
            type: Input,
            args: ['isHeader']
        }], defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-nav-drawer__item']
        }], currentCSS: [{
            type: HostBinding,
            args: ['class.igx-nav-drawer__item--active']
        }], headerCSS: [{
            type: HostBinding,
            args: ['class.igx-nav-drawer__item--header']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavDrawerTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDrawer]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavDrawerMiniTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDrawerMini]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavigationDrawerComponent, [{
        type: Component,
        args: [{
                providers: [HammerGesturesManager],
                selector: 'igx-nav-drawer',
                template: "<ng-template #defaultItemsTemplate>\n    <div igxDrawerItem [isHeader]=\"true\">Navigation Drawer</div>\n    <div igxDrawerItem> Start by adding</div>\n    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>\n    <div igxDrawerItem> And some items inside </div>\n    <div igxDrawerItem> Style with igxDrawerItem </div>\n    <div igxDrawerItem> and igxRipple directives</div>\n</ng-template>\n\n<div [hidden]=\"pin\"\n    class=\"igx-nav-drawer__overlay\"\n    [class.igx-nav-drawer__overlay--hidden]=\"!isOpen\"\n    [class.igx-nav-drawer--disable-animation]=\"disableAnimation\"\n    (click)=\"close()\" #overlay>\n</div>\n<aside role=\"navigation\"\n    class=\"igx-nav-drawer__aside\"\n    [class.igx-nav-drawer__aside--collapsed]=\"!miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--mini]=\"miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--normal]=\"!miniTemplate || isOpen\"\n    [class.igx-nav-drawer__aside--pinned]=\"pin\"\n    [class.igx-nav-drawer__aside--right]=\"position == 'right'\" #aside\n    [class.igx-nav-drawer--disable-animation]=\"disableAnimation\">\n\n    <ng-container *ngTemplateOutlet=\"template || defaultItemsTemplate\"></ng-container>\n</aside>\n<div class=\"igx-nav-drawer__style-dummy\" #dummy></div>\n",
                styles: [`
        :host {
            display: block;
            height: 100%;
        }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef, decorators: [{
                type: Inject,
                args: [ElementRef]
            }] }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: HammerGesturesManager }, { type: PlatformUtil }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-nav-drawer']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], position: [{
            type: Input
        }], enableGestures: [{
            type: Input
        }], isOpenChange: [{
            type: Output
        }], pin: [{
            type: Input
        }], pinThreshold: [{
            type: Input
        }], width: [{
            type: Input
        }], disableAnimation: [{
            type: HostBinding,
            args: ['class.igx-nav-drawer--disable-animation']
        }, {
            type: Input
        }], miniWidth: [{
            type: Input
        }], pinChange: [{
            type: Output
        }], opening: [{
            type: Output
        }], opened: [{
            type: Output
        }], closing: [{
            type: Output
        }], closed: [{
            type: Output
        }], isOpen: [{
            type: Input
        }], miniTemplate: [{
            type: ContentChild,
            args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective }]
        }], flexWidth: [{
            type: HostBinding,
            args: ['style.flexBasis']
        }], isPinnedRight: [{
            type: HostBinding,
            args: ['style.order']
        }], contentTemplate: [{
            type: ContentChild,
            args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective }]
        }], _drawer: [{
            type: ViewChild,
            args: ['aside', { static: true }]
        }], _overlay: [{
            type: ViewChild,
            args: ['overlay', { static: true }]
        }], _styleDummy: [{
            type: ViewChild,
            args: ['dummy', { static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxNavigationDrawerModule, { declarations: function () { return [IgxNavigationDrawerComponent, IgxNavDrawerItemDirective, IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxNavigationDrawerComponent, IgxNavDrawerItemDirective, IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavigationDrawerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxNavigationDrawerComponent,
                    IgxNavDrawerItemDirective,
                    IgxNavDrawerMiniTemplateDirective,
                    IgxNavDrawerTemplateDirective
                ],
                exports: [
                    IgxNavigationDrawerComponent,
                    IgxNavDrawerItemDirective,
                    IgxNavDrawerMiniTemplateDirective,
                    IgxNavDrawerTemplateDirective
                ],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxThumbFromTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSliderThumbFrom]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxThumbToTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSliderThumbTo]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTickLabelTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSliderTickLabel]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSliderThumbComponent, [{
        type: Component,
        args: [{
                selector: 'igx-thumb',
                template: "<div class=\"dot\"></div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: IgxDirectionality }]; }, { onThumbValueChange: [{
            type: Output
        }], onChange: [{
            type: Output
        }], onHoverChange: [{
            type: Output
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], zIndex: [{
            type: HostBinding,
            args: ['attr.z-index']
        }], thumbFromClass: [{
            type: HostBinding,
            args: ['class.igx-slider__thumb-from']
        }], thumbToClass: [{
            type: HostBinding,
            args: ['class.igx-slider__thumb-to']
        }], thumbFromActiveClass: [{
            type: HostBinding,
            args: ['class.igx-slider__thumb-from--active']
        }], thumbToActiveClass: [{
            type: HostBinding,
            args: ['class.igx-slider__thumb-to--active']
        }], thumbPressedClass: [{
            type: HostBinding,
            args: ['class.igx-slider__thumb--pressed']
        }], onPinterEnter: [{
            type: HostListener,
            args: ['pointerenter']
        }], onPointerLeave: [{
            type: HostListener,
            args: ['pointerleave']
        }], onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }], onFocusListener: [{
            type: HostListener,
            args: ['focus']
        }], value: [{
            type: Input
        }], continuous: [{
            type: Input
        }], thumbLabelVisibilityDuration: [{
            type: Input
        }], disabled: [{
            type: Input
        }], onPan: [{
            type: Input
        }], stepDistance: [{
            type: Input
        }], step: [{
            type: Input
        }], templateRef: [{
            type: Input
        }], context: [{
            type: Input
        }], type: [{
            type: Input
        }], deactiveState: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxThumbLabelComponent, [{
        type: Component,
        args: [{
                selector: 'igx-thumb-label',
                template: "<div class=\"label\">\n    <ng-container *ngTemplateOutlet=\"templateRef ? templateRef : thumbFromDefaultTemplate; context: context\"></ng-container>\n</div>\n\n<ng-template #thumbFromDefaultTemplate>\n    {{ value }}\n</ng-template>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { thumbFromClass: [{
            type: HostBinding,
            args: ['class.igx-slider__label-from']
        }], thumbToClass: [{
            type: HostBinding,
            args: ['class.igx-slider__label-to']
        }], thumbFromActiveClass: [{
            type: HostBinding,
            args: ['class.igx-slider__label-from--active']
        }], thumbToActiveClass: [{
            type: HostBinding,
            args: ['class.igx-slider__label-to--active']
        }], value: [{
            type: Input
        }], templateRef: [{
            type: Input
        }], context: [{
            type: Input
        }], type: [{
            type: Input
        }], continuous: [{
            type: Input
        }], deactiveState: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTicksComponent, [{
        type: Component,
        args: [{
                selector: 'igx-ticks',
                template: "<div class=\"igx-slider__ticks-group\" *ngFor=\"let n of [].constructor(ticksLength); let idx=index\" [ngClass]=\"{ 'igx-slider__ticks-group--tall': isPrimary(idx)}\">\n    <div class=\"igx-slider__ticks-tick\">\n        <span class=\"igx-slider__ticks-label\" [ngClass]=\"{ 'igx-slider__tick-label--hidden': !hiddenTickLabels(idx)}\">\n            <ng-container *ngTemplateOutlet=\"tickLabelTemplateRef ? tickLabelTemplateRef : tickLabelDefaultTemplate; context: context(idx)\"></ng-container>\n        </span>\n    </div>\n</div>\n\n<ng-template #tickLabelDefaultTemplate let-value>\n    {{ value }}\n</ng-template>\n"
            }]
    }], function () { return []; }, { ticksClass: [{
            type: HostBinding,
            args: ['class.igx-slider__ticks']
        }], ticksTopClass: [{
            type: HostBinding,
            args: ['class.igx-slider__ticks--top']
        }], hasPrimaryClass: [{
            type: HostBinding,
            args: ['class.igx-slider__ticks--tall']
        }], labelsTopToBottomClass: [{
            type: HostBinding,
            args: ['class.igx-slider__tick-labels--top-bottom']
        }], labelsBottomToTopClass: [{
            type: HostBinding,
            args: ['class.igx-slider__tick-labels--bottom-top']
        }], primaryTicks: [{
            type: Input
        }], secondaryTicks: [{
            type: Input
        }], primaryTickLabels: [{
            type: Input
        }], secondaryTickLabels: [{
            type: Input
        }], ticksOrientation: [{
            type: Input
        }], tickLabelsOrientation: [{
            type: Input
        }], maxValue: [{
            type: Input
        }], minValue: [{
            type: Input
        }], labelsViewEnabled: [{
            type: Input
        }], labels: [{
            type: Input
        }], tickLabelTemplateRef: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTickLabelsPipe, [{
        type: Pipe,
        args: [{
                name: 'spreadTickLabels'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSliderComponent, [{
        type: Component,
        args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSliderComponent, multi: true }],
                selector: 'igx-slider',
                template: "<div class=\"igx-slider__track\">\n    <igx-ticks\n        *ngIf=\"showTicks && showTopTicks\"\n        [ticksOrientation]=\"0\"\n        [primaryTicks]=\"primaryTicks\"\n        [secondaryTicks]=\"secondaryTicks\"\n        [primaryTickLabels]=\"primaryTickLabels\"\n        [secondaryTickLabels]=\"secondaryTickLabels\"\n        [tickLabelsOrientation]=\"tickLabelsOrientation\"\n        [labelsViewEnabled]=\"labelsViewEnabled\"\n        [labels]=\"labels | spreadTickLabels:secondaryTicks\"\n        [tickLabelTemplateRef]=\"tickLabelTemplateRef\"\n        [minValue]=\"minValue\"\n        [maxValue]=\"maxValue\"></igx-ticks>\n\n    <div #track class=\"igx-slider__track-fill\"></div>\n    <div #ticks class=\"igx-slider__track-steps\"></div>\n\n    <igx-ticks\n        *ngIf=\"showTicks && showBottomTicks\"\n        [ticksOrientation]=\"1\"\n        [primaryTicks]=\"primaryTicks\"\n        [secondaryTicks]=\"secondaryTicks\"\n        [primaryTickLabels]=\"primaryTickLabels\"\n        [secondaryTickLabels]=\"secondaryTickLabels\"\n        [tickLabelsOrientation]=\"tickLabelsOrientation\"\n        [labelsViewEnabled]=\"labelsViewEnabled\"\n        [labels]=\"labels | spreadTickLabels:secondaryTicks\"\n        [tickLabelTemplateRef]=\"tickLabelTemplateRef\"\n        [minValue]=\"minValue\"\n        [maxValue]=\"maxValue\"></igx-ticks>\n</div>\n<div class=\"igx-slider__thumbs\">\n    <igx-thumb-label\n        *ngIf=\"isRange\"\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"\n        [deactiveState]=\"deactivateThumbLabel\"></igx-thumb-label>\n\n    <igx-thumb\n        *ngIf=\"isRange\"\n        #thumbFrom\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n\n    <igx-thumb-label\n        [value]=\"upperLabel\"\n        [type]=\"1\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"\n        [deactiveState]=\"deactivateThumbLabel\"></igx-thumb-label>\n\n    <igx-thumb\n        #thumbTo\n        [type]=\"1\"\n        [value]=\"upperLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: IgxDirectionality }]; }, { thumbs: [{
            type: ViewChildren,
            args: [IgxSliderThumbComponent]
        }], labelRefs: [{
            type: ViewChildren,
            args: [IgxThumbLabelComponent]
        }], role: [{
            type: HostBinding,
            args: [`attr.role`]
        }], slierClass: [{
            type: HostBinding,
            args: ['class.igx-slider']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], thumbLabelVisibilityDuration: [{
            type: Input
        }], showTicks: [{
            type: Input
        }], primaryTickLabels: [{
            type: Input
        }], secondaryTickLabels: [{
            type: Input
        }], ticksOrientation: [{
            type: Input
        }], tickLabelsOrientation: [{
            type: Input
        }], onValueChange: [{
            type: Output
        }], onValueChanged: [{
            type: Output
        }], valuemin: [{
            type: HostBinding,
            args: [`attr.aria-valuemin`]
        }], valuemax: [{
            type: HostBinding,
            args: [`attr.aria-valuemax`]
        }], readonly: [{
            type: HostBinding,
            args: [`attr.aria-readonly`]
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.igx-slider--disabled']
        }], type: [{
            type: Input
        }], labels: [{
            type: Input
        }], step: [{
            type: Input
        }], disabled: [{
            type: Input
        }], continuous: [{
            type: Input
        }], minValue: [{
            type: Input
        }], lowerBound: [{
            type: Input
        }], maxValue: [{
            type: Input
        }], upperBound: [{
            type: Input
        }], value: [{
            type: Input
        }], primaryTicks: [{
            type: Input
        }], secondaryTicks: [{
            type: Input
        }], 
    /**
     * @hidden
     */
    onPointerDown: [{
            type: HostListener,
            args: ['pointerdown', ['$event']]
        }], 
    /**
     * @hidden
     */
    onPointerUp: [{
            type: HostListener,
            args: ['pointerup', ['$event']]
        }], 
    /**
     * @hidden
     */
    onFocus: [{
            type: HostListener,
            args: ['focus']
        }], 
    /**
     * @hidden
     */
    onPanListener: [{
            type: HostListener,
            args: ['pan', ['$event']]
        }], ticks: [{
            type: ViewChild,
            args: ['ticks', { static: true }]
        }], trackRef: [{
            type: ViewChild,
            args: ['track', { static: true }]
        }], thumbFromTemplateRef: [{
            type: ContentChild,
            args: [IgxThumbFromTemplateDirective, { read: TemplateRef }]
        }], thumbToTemplateRef: [{
            type: ContentChild,
            args: [IgxThumbToTemplateDirective, { read: TemplateRef }]
        }], tickLabelTemplateRef: [{
            type: ContentChild,
            args: [IgxTickLabelTemplateDirective, { read: TemplateRef, static: false }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxSliderModule, { declarations: function () { return [IgxSliderComponent, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, IgxTickLabelTemplateDirective, IgxSliderThumbComponent, IgxThumbLabelComponent, IgxTicksComponent, IgxTickLabelsPipe]; }, imports: function () { return [CommonModule, FormsModule]; }, exports: function () { return [IgxSliderComponent, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, IgxTickLabelTemplateDirective, IgxSliderThumbComponent, IgxThumbLabelComponent, IgxTicksComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSliderModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxSliderComponent,
                    IgxThumbFromTemplateDirective,
                    IgxThumbToTemplateDirective,
                    IgxTickLabelTemplateDirective,
                    IgxSliderThumbComponent,
                    IgxThumbLabelComponent,
                    IgxTicksComponent,
                    IgxTickLabelsPipe
                ],
                exports: [
                    IgxSliderComponent,
                    IgxThumbFromTemplateDirective,
                    IgxThumbToTemplateDirective,
                    IgxTickLabelTemplateDirective,
                    IgxSliderThumbComponent,
                    IgxThumbLabelComponent,
                    IgxTicksComponent
                ],
                imports: [CommonModule, FormsModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSwitchComponent, [{
        type: Component,
        args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSwitchComponent, multi: true }],
                selector: 'igx-switch',
                template: "<input #checkbox class=\"igx-switch__input\" type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onSwitchChange($event)\"\n    (click)=\"_onSwitchClick($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<label #label class =\"igx-switch__composite\" [for]=\"inputId\"\n    igxRipple\n    igxRippleTarget=\".igx-switch__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\">\n    <div class=\"igx-switch__composite-thumb\">\n        <div class=\"igx-switch__ripple\"></div>\n    </div>\n</label>\n\n<span #placeholderLabel\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick($event)\">\n    <ng-content></ng-content>\n</span>\n"
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], labelId: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], labelPosition: [{
            type: Input
        }], disableRipple: [{
            type: Input
        }], required: [{
            type: Input
        }], ariaLabelledBy: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], change: [{
            type: Output
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-switch']
        }], checked: [{
            type: HostBinding,
            args: ['class.igx-switch--checked']
        }, {
            type: Input
        }], disabled: [{
            type: HostBinding,
            args: ['class.igx-switch--disabled']
        }, {
            type: Input
        }], focused: [{
            type: HostBinding,
            args: ['class.igx-switch--focused']
        }], nativeCheckbox: [{
            type: ViewChild,
            args: ['checkbox', { static: true }]
        }], nativeLabel: [{
            type: ViewChild,
            args: ['label', { static: true }]
        }], placeholderLabel: [{
            type: ViewChild,
            args: ['placeholderLabel', { static: true }]
        }], value: [{
            type: Input
        }], name: [{
            type: Input
        }] }); })();
const ɵIgxSwitchRequiredDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxSwitchRequiredDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSwitchRequiredDirective, [{
        type: Directive,
        args: [{
                selector: `igx-switch[required][formControlName],
    igx-switch[required][formControl],
    igx-switch[required][ngModel]`,
                providers: [IGX_SWITCH_REQUIRED_VALIDATOR]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxSwitchModule, { declarations: [IgxSwitchComponent, IgxSwitchRequiredDirective], imports: [IgxRippleModule], exports: [IgxSwitchComponent, IgxSwitchRequiredDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSwitchModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                exports: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                imports: [IgxRippleModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxTab]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBottomNavComponent, [{
        type: Component,
        args: [{
                selector: 'igx-bottom-nav',
                template: "<div *ngIf=\"!hasContentTabs\">\n    <ng-content></ng-content>\n</div>\n<div #tablist class=\"{{itemStyle}}__menu {{itemStyle}}__menu--bottom\" role=\"tablist\" aria-orientation=\"horizontal\">\n    <ng-container *ngIf=\"!hasContentTabs\">\n        <igx-tab *ngFor=\"let panel of panels; let i = index\"\n            [relatedPanel]=\"panel\"\n            [autoGenerated]=\"true\"\n            [id]=\"getTabId(i)\"\n            [attr.aria-controls]=\"getTabPanelId(i)\">>\n        </igx-tab>\n    </ng-container>\n    <ng-content select=\"igx-tab\"></ng-content>\n</div>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], onTabSelected: [{
            type: Output
        }], onTabDeselected: [{
            type: Output
        }], 
    /**
     * @hidden
     */
    _selectedPanelHandler: [{
            type: HostListener,
            args: ['onTabSelected', ['$event']]
        }], viewTabs: [{
            type: ViewChildren,
            args: [forwardRef(() => IgxTabComponent)]
        }], contentTabs: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxTabComponent)]
        }], panels: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxTabPanelComponent)]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabPanelComponent, [{
        type: Component,
        args: [{
                selector: 'igx-tab-panel',
                template: "<ng-content></ng-content>\n"
            }]
    }], function () { return [{ type: IgxBottomNavComponent }, { type: ɵngcc0.ElementRef }]; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-bottom-nav__panel']
        }], isSelected: [{
            type: HostBinding,
            args: ['class.igx-bottom-nav__panel--selected']
        }], label: [{
            type: Input
        }], icon: [{
            type: Input
        }], disabled: [{
            type: Input
        }], tabTemplate: [{
            type: ContentChild,
            args: [IgxTabTemplateDirective, { read: IgxTabTemplateDirective }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabComponent, [{
        type: Component,
        args: [{
                selector: 'igx-tab',
                template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"tab-icon\">\n        <igx-icon fontSet=\"material\">{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"context.changesCount\" [hidden]=\"context.changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"tab-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>"
            }]
    }], function () { return [{ type: IgxBottomNavComponent }, { type: ɵngcc0.ElementRef }]; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }], ariaLabel: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], ariaDisabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], ariaSelected: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], label: [{
            type: Input
        }], icon: [{
            type: Input
        }], disabled: [{
            type: Input
        }], isSelected: [{
            type: Input
        }], cssClassSelected: [{
            type: HostBinding,
            args: ['class.igx-bottom-nav__menu-item--selected']
        }], cssClassDisabled: [{
            type: HostBinding,
            args: ['class.igx-bottom-nav__menu-item--disabled']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-bottom-nav__menu-item']
        }], 
    /**
     * @hidden
     */
    onClick: [{
            type: HostListener,
            args: ['click']
        }], relatedPanel: [{
            type: Input
        }], autoGenerated: [{
            type: Input
        }], defaultTabTemplate: [{
            type: ViewChild,
            args: ['defaultTabTemplate', { read: TemplateRef, static: true }]
        }], customTabTemplateDir: [{
            type: ContentChild,
            args: [IgxTabTemplateDirective, { read: IgxTabTemplateDirective }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxBottomNavModule, { declarations: function () { return [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective]; }, imports: function () { return [CommonModule, IgxBadgeModule, IgxIconModule]; }, exports: function () { return [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBottomNavModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                exports: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                imports: [CommonModule, IgxBadgeModule, IgxIconModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRightButtonStyleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRightButtonStyle]'
            }]
    }], function () { return [{ type: IgxTabsBase }]; }, { visibleCSS: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-button']
        }], hiddenCSS: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-button--hidden']
        }], notDisplayedCSS: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-button--none']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxLeftButtonStyleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxLeftButtonStyle]'
            }]
    }], function () { return [{ type: IgxTabsBase }]; }, { visibleCSS: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-button']
        }], hiddenCSS: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-button--hidden']
        }], notDisplayedCSS: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-button--none']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabItemTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxTab]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabItemComponent, [{
        type: Component,
        args: [{
                selector: 'igx-tab-item',
                template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"igx-tabs__header-menu-item-icon\">\n        <igx-icon fontSet=\"material\">{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"changesCount\" [hidden]=\"changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"igx-tabs__item-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>"
            }]
    }], function () { return [{ type: IgxTabsBase }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], ariaLabel: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], ariaDisabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], ariaSelected: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], icon: [{
            type: Input
        }], label: [{
            type: Input
        }], provideCssClassSelected: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-menu-item--selected']
        }], provideCssClassDisabled: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-menu-item--disabled']
        }], provideCssClass: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-menu-item']
        }], 
    /**
     * @hidden
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], disabled: [{
            type: Input
        }], isSelected: [{
            type: Input
        }], relatedGroup: [{
            type: Input
        }], autoGenerated: [{
            type: Input
        }], defaultTabTemplate: [{
            type: ViewChild,
            args: ['defaultTabTemplate', { read: TemplateRef, static: true }]
        }], customTabTemplateDir: [{
            type: ContentChild,
            args: [IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabsGroupComponent, [{
        type: Component,
        args: [{
                selector: 'igx-tabs-group',
                template: "<ng-content *ngIf=\"isSelected\"></ng-content>\n"
            }]
    }], function () { return [{ type: IgxTabsBase }, { type: ɵngcc0.ElementRef }]; }, { disabled: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-tabs__group']
        }], icon: [{
            type: Input
        }], label: [{
            type: Input
        }], tabTemplate: [{
            type: ContentChild,
            args: [IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabsComponent, [{
        type: Component,
        args: [{
                selector: 'igx-tabs',
                template: "<!-- TODO Remove tab container from here -->\n<div #tabsContainer>\n    <div class=\"igx-tabs__header\" #headerContainer>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollLeft($event)\" igxLeftButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_before</igx-icon>\n        </button>\n        <div class=\"igx-tabs__header-wrapper-fixed\" #viewPort>\n            <div #itemsContainer class=\"igx-tabs__header-wrapper-fluid\">\n                <ng-container *ngIf=\"!hasContentTabs\">\n                    <igx-tab-item igxRipple\n                        *ngFor=\"let group of groups; let i = index\"\n                        [relatedGroup]=\"group\"\n                        [autoGenerated]=\"true\"\n                        [id]=\"getTabItemId(i)\"\n                        [attr.aria-controls]=\"getTabsGroupId(i)\">\n                    </igx-tab-item>\n                </ng-container>\n                <ng-content select=\"igx-tab-item\"></ng-content>\n                <div #selectedIndicator *ngIf=\"groups.length > 0 || contentTabs.length > 0\" class=\"igx-tabs__header-menu-item-indicator\"></div>\n            </div>\n        </div>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollRight($event)\" igxRightButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_next</igx-icon>\n        </button>\n    </div>\n    <div class=\"igx-tabs__content-fixed\">\n        <div #contentsContainer class=\"igx-tabs__content-fluid\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</div>\n",
                providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: PlatformUtil }]; }, { selectedIndexChange: [{
            type: Output
        }], type: [{
            type: Input,
            args: ['type']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], class: [{
            type: Input
        }], onTabItemDeselected: [{
            type: Output
        }], onTabItemSelected: [{
            type: Output
        }], disableAnimation: [{
            type: Input
        }], selectedIndex: [{
            type: Input
        }], cssClass: [{
            type: HostBinding,
            args: ['attr.class']
        }], groups: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxTabsGroupComponent)]
        }], contentTabs: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxTabItemComponent)]
        }], contentsContainer: [{
            type: ViewChild,
            args: ['contentsContainer', { static: true }]
        }], headerContainer: [{
            type: ViewChild,
            args: ['headerContainer', { static: true }]
        }], itemsContainer: [{
            type: ViewChild,
            args: ['itemsContainer', { static: true }]
        }], selectedIndicator: [{
            type: ViewChild,
            args: ['selectedIndicator']
        }], tabsContainer: [{
            type: ViewChild,
            args: ['tabsContainer', { static: true }]
        }], viewPort: [{
            type: ViewChild,
            args: ['viewPort', { static: true }]
        }], viewTabs: [{
            type: ViewChildren,
            args: [forwardRef(() => IgxTabItemComponent)]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTabsModule, { declarations: function () { return [IgxTabsComponent, IgxTabsGroupComponent, IgxTabItemComponent, IgxTabItemTemplateDirective, IgxRightButtonStyleDirective, IgxLeftButtonStyleDirective]; }, imports: function () { return [CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]; }, exports: function () { return [IgxTabsComponent, IgxTabsGroupComponent, IgxTabItemComponent, IgxTabItemTemplateDirective, IgxRightButtonStyleDirective, IgxLeftButtonStyleDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabsModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                exports: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                imports: [CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxItemListDirective, [{
        type: Directive,
        args: [{
                selector: '[igxItemList]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }, { type: ɵngcc0.ElementRef }]; }, { tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__column']
        }], hourCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__hourList']
        }], minuteCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__minuteList']
        }], secondsCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__secondsList']
        }], ampmCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__ampmList']
        }], onFocus: [{
            type: HostListener,
            args: ['focus']
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }], 
    /**
     * @hidden
     */
    onKeydownArrowDown: [{
            type: HostListener,
            args: ['keydown.arrowdown', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownArrowUp: [{
            type: HostListener,
            args: ['keydown.arrowup', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownArrowRight: [{
            type: HostListener,
            args: ['keydown.arrowright', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownArrowLeft: [{
            type: HostListener,
            args: ['keydown.arrowleft', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownEnter: [{
            type: HostListener,
            args: ['keydown.enter', ['$event']]
        }], 
    /**
     * @hidden
     */
    onKeydownEscape: [{
            type: HostListener,
            args: ['keydown.escape', ['$event']]
        }], 
    /**
     * @hidden
     */
    onHover: [{
            type: HostListener,
            args: ['mouseover']
        }], 
    /**
     * @hidden
     */
    onScroll: [{
            type: HostListener,
            args: ['wheel', ['$event']]
        }], 
    /**
     * @hidden
     */
    onPanMove: [{
            type: HostListener,
            args: ['panmove', ['$event']]
        }], type: [{
            type: Input,
            args: ['igxItemList']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHourItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxHourItem]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }, { type: IgxItemListDirective }]; }, { defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item']
        }], selectedCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--selected']
        }], activeCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--active']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['value']]
        }], value: [{
            type: Input,
            args: ['igxHourItem']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMinuteItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxMinuteItem]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }, { type: IgxItemListDirective }]; }, { defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item']
        }], selectedCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--selected']
        }], activeCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--active']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['value']]
        }], value: [{
            type: Input,
            args: ['igxMinuteItem']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSecondsItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSecondsItem]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }, { type: IgxItemListDirective }]; }, { defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item']
        }], selectedCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--selected']
        }], activeCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--active']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['value']]
        }], value: [{
            type: Input,
            args: ['igxSecondsItem']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxAmPmItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxAmPmItem]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }, { type: IgxItemListDirective }]; }, { defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item']
        }], selectedCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--selected']
        }], activeCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--active']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['value']]
        }], value: [{
            type: Input,
            args: ['igxAmPmItem']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTimePickerTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxTimePickerTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTimePickerActionsDirective, [{
        type: Directive,
        args: [{
                selector: '[igxTimePickerActions]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimeDisplayFormatPipe, [{
        type: Pipe,
        args: [{ name: 'displayFormat' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimeInputFormatPipe, [{
        type: Pipe,
        args: [{ name: 'inputFormat' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }]; }, null); })();
const ɵTimePickerHammerConfig_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(TimePickerHammerConfig);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimePickerHammerConfig, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTimePickerComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxTimePickerComponent,
                        multi: true
                    },
                    {
                        provide: HAMMER_GESTURE_CONFIG,
                        useClass: TimePickerHammerConfig
                    },
                    {
                        provide: IGX_TIME_PICKER_COMPONENT,
                        useExisting: IgxTimePickerComponent
                    }
                ],
                selector: 'igx-time-picker',
                template: "<ng-template #labelTemplate>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #dropdownInputTemplate>\n    <igx-input-group #group (mousedown)=\"mouseDown($event)\" [suppressInputAutofocus]=\"true\">\n        <label igxLabel *ngIf=\"!labelDirective\">Time</label>\n        <ng-container ngProjectAs=\"[igxLabel]\" *ngTemplateOutlet=\"labelTemplate\"></ng-container>\n        <igx-prefix (click)=\"openDialog(group.element.nativeElement)\">\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <input\n            type=\"text\"\n            [igxMask]=\"mask\"\n            igxInput\n            [includeLiterals]=\"true\"\n            [placeholder]=\"format\"\n            [displayValuePipe]=\"displayFormat\"\n            [focusedValuePipe]=\"inputFormat\"\n            [promptChar]=\"promptChar\"\n            [value]=\"displayValue\"\n            [igxTextSelection]=\"true\"\n            (input)=\"onInput($event)\"\n            (blur)=\"onBlur($event)\"\n            (focus)=\"onFocus($event)\"\n            (wheel)=\"spinOnEdit($event)\"\n            [disabled]=\"disabled\" />\n        <igx-suffix *ngIf=\"showClearButton\" igxRipple (click)=\"clear()\">\n            <igx-icon fontSet=\"material\">clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n<ng-template #defaultTimePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\" (mousedown)=\"mouseDown($event)\">\n        <igx-prefix>\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <label igxLabel *ngIf=\"!labelDirective\">Time</label>\n        <ng-container ngProjectAs=\"[igxLabel]\" *ngTemplateOutlet=\"labelTemplate\"></ng-container>\n        <input\n            igxInput\n            [value]=\"displayTime || ''\"\n            [disabled]=\"disabled\"\n            tabindex=\"0\" readonly\n            (blur)=\"onBlur($event)\" />\n    </igx-input-group>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n\n<ng-template #defaultTimePickerActions>\n    <div *ngIf=\"cancelButtonLabel || okButtonLabel\" class=\"igx-time-picker__buttons\">\n        <button *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" (click)=\"cancelButtonClick()\">\n            {{cancelButtonLabel}}\n        </button>\n        <button *ngIf=\"okButtonLabel\" igxButton=\"flat\" (click)=\"okButtonClick()\">\n            {{okButtonLabel}}\n        </button>\n    </div>\n</ng-template>\n<div igxToggle class=\"igx-time-picker\"\n    [ngClass]=\"{'igx-time-picker--dropdown': mode === 'dropdown', 'igx-time-picker--vertical': vertical && mode === 'dialog'}\">\n    <div *ngIf=\"mode === 'dialog'\" class=\"igx-time-picker__header\">\n        <h5 class=\"igx-time-picker__header-ampm\">{{ selectedAmPm }}</h5>\n        <h2 class=\"igx-time-picker__header-hour\">\n            <span>{{ selectedHour }}</span>:<span>{{ selectedMinute }}</span>:<span>{{ selectedSeconds }}</span>\n        </h2>\n    </div>\n    <div class=\"igx-time-picker__main\">\n        <div class=\"igx-time-picker__body\">\n            <div *ngIf=\"showHoursList\" #hourList [igxItemList]=\"'hourList'\">\n                <span [igxHourItem]=\"hour\"\n                [ngClass]=\"{'igx-time-picker__item--disabled': applyDisabledStyleForItem(timeParts.Hour, hour)}\"\n                *ngFor=\"let hour of hourView\">{{ hour }}</span>\n            </div>\n            <div *ngIf=\"showMinutesList\" #minuteList [igxItemList]=\"'minuteList'\">\n                <span [igxMinuteItem]=\"minute\"\n                [ngClass]=\"{'igx-time-picker__item--disabled': applyDisabledStyleForItem(timeParts.Minute, minute)}\"\n                *ngFor=\"let minute of minuteView\" >{{ minute }}</span>\n            </div>\n            <div *ngIf=\"showSecondsList\" #secondsList [igxItemList]=\"'secondsList'\">\n                <span [igxSecondsItem]=\"seconds\"\n                [ngClass]=\"{'igx-time-picker__item--disabled': applyDisabledStyleForItem(timeParts.Seconds, seconds)}\"\n                *ngFor=\"let seconds of secondsView\">{{ seconds }}</span>\n            </div>\n            <div *ngIf=\"showAmPmList\" #ampmList [igxItemList]=\"'ampmList'\">\n                <span [igxAmPmItem]=\"ampm\"\n                [ngClass]=\"{'igx-time-picker__item--disabled': applyDisabledStyleForItem(timeParts.amPM, ampm)}\"\n                *ngFor=\"let ampm of ampmView\">{{ ampm }}</span>\n            </div>\n        </div>\n        <ng-container\n            *ngTemplateOutlet=\"timePickerActionsDirective ? timePickerActionsDirective.template : defaultTimePickerActions\">\n        </ng-container>\n    </div>\n</div>\n",
                styles: [`:host {
            display: block;
        }`]
            }]
    }], function () { return [{ type: ɵngcc0.Injector }, { type: ɵngcc0.ChangeDetectorRef }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], disabled: [{
            type: Input
        }], isSpinLoop: [{
            type: Input
        }], vertical: [{
            type: Input
        }], promptChar: [{
            type: Input
        }], mode: [{
            type: Input
        }], onValueChanged: [{
            type: Output
        }], onValidationFailed: [{
            type: Output
        }], onOpened: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], value: [{
            type: Input
        }], resourceStrings: [{
            type: Input
        }], okButtonLabel: [{
            type: Input
        }], cancelButtonLabel: [{
            type: Input
        }], itemsDelta: [{
            type: Input
        }], format: [{
            type: Input
        }], overlaySettings: [{
            type: Input
        }], 
    /**
     * @hidden
     */
    onKeydownSpace: [{
            type: HostListener,
            args: ['keydown.spacebar', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.space', ['$event']]
        }], 
    /**
     * @hidden
     */
    onAltArrowDown: [{
            type: HostListener,
            args: ['keydown.Alt.ArrowDown']
        }], minValue: [{
            type: Input
        }], maxValue: [{
            type: Input
        }], outlet: [{
            type: Input
        }], hourList: [{
            type: ViewChild,
            args: ['hourList']
        }], minuteList: [{
            type: ViewChild,
            args: ['minuteList']
        }], secondsList: [{
            type: ViewChild,
            args: ['secondsList']
        }], ampmList: [{
            type: ViewChild,
            args: ['ampmList']
        }], defaultTimePickerTemplate: [{
            type: ViewChild,
            args: ['defaultTimePickerTemplate', { read: TemplateRef, static: true }]
        }], dropdownInputTemplate: [{
            type: ViewChild,
            args: ['dropdownInputTemplate', { read: TemplateRef, static: true }]
        }], timePickerTemplateDirective: [{
            type: ContentChild,
            args: [IgxTimePickerTemplateDirective, { read: IgxTimePickerTemplateDirective }]
        }], timePickerActionsDirective: [{
            type: ContentChild,
            args: [IgxTimePickerActionsDirective, { read: IgxTimePickerActionsDirective }]
        }], labelDirective: [{
            type: ContentChild,
            args: [IgxLabelDirective]
        }], toggleRef: [{
            type: ViewChild,
            args: [IgxToggleDirective, { static: true }]
        }], _inputElementRef: [{
            type: ViewChild,
            args: [IgxInputDirective, { read: ElementRef }]
        }], _inputDirective: [{
            type: ViewChild,
            args: [IgxInputDirective, { read: IgxInputDirective }]
        }], _inputDirectiveUserTemplate: [{
            type: ContentChild,
            args: [IgxInputDirective, { read: IgxInputDirective }]
        }], _inputGroup: [{
            type: ViewChild,
            args: [IgxInputGroupComponent, { read: IgxInputGroupComponent }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTimePickerModule, { declarations: function () { return [IgxTimePickerComponent, IgxHourItemDirective, IgxMinuteItemDirective, IgxSecondsItemDirective, IgxItemListDirective, IgxAmPmItemDirective, IgxTimePickerTemplateDirective, IgxTimePickerActionsDirective, TimeDisplayFormatPipe, TimeInputFormatPipe]; }, imports: function () { return [CommonModule, IgxInputGroupModule, IgxIconModule, IgxButtonModule, IgxMaskModule, IgxToggleModule, IgxTextSelectionModule]; }, exports: function () { return [IgxTimePickerComponent, IgxTimePickerTemplateDirective, IgxTimePickerActionsDirective, TimeDisplayFormatPipe, TimeInputFormatPipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTimePickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxTimePickerComponent,
                    IgxHourItemDirective,
                    IgxMinuteItemDirective,
                    IgxSecondsItemDirective,
                    IgxItemListDirective,
                    IgxAmPmItemDirective,
                    IgxTimePickerTemplateDirective,
                    IgxTimePickerActionsDirective,
                    TimeDisplayFormatPipe,
                    TimeInputFormatPipe
                ],
                exports: [
                    IgxTimePickerComponent,
                    IgxTimePickerTemplateDirective,
                    IgxTimePickerActionsDirective,
                    TimeDisplayFormatPipe,
                    TimeInputFormatPipe
                ],
                imports: [
                    CommonModule,
                    IgxInputGroupModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxMaskModule,
                    IgxToggleModule,
                    IgxTextSelectionModule
                ],
                providers: []
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxToastComponent, [{
        type: Component,
        args: [{
                selector: 'igx-toast',
                template: "<ng-content></ng-content>\n<span>{{ toastMessage }}</span>\n\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }, { type: IgxOverlayService, decorators: [{
                type: Inject,
                args: [IgxOverlayService]
            }] }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-toast']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], onShowing: [{
            type: Output
        }], onShown: [{
            type: Output
        }], onHiding: [{
            type: Output
        }], onHidden: [{
            type: Output
        }], role: [{
            type: Input
        }], autoHide: [{
            type: Input
        }], displayTime: [{
            type: Input
        }], isVisibleChange: [{
            type: Output
        }], position: [{
            type: Input
        }], isVisible: [{
            type: Input
        }], message: [{
            type: Input
        }], outlet: [{
            type: Input
        }] }); })();
/**
 * @hidden
 */
class IgxToastModule {
}
IgxToastModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxToastModule });
IgxToastModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxToastModule_Factory(t) { return new (t || IgxToastModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxToastModule, { declarations: function () { return [IgxToastComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxToastComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxToastModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxToastComponent],
                exports: [IgxToastComponent],
                imports: [CommonModule]
            }]
    }], null, null); })();

/**
 * Represents individual resizable/collapsible panes.
 * @igxModule IgxSplitterModule
 *
 * @igxParent IgxSplitterComponent
 *
 * @igxKeywords pane
 *
 * @igxGroup presentation
 *
 * @remarks
 *  Users can control the resize behavior via the min and max size properties.
 */
class IgxSplitterPaneComponent {
    constructor(el) {
        this.el = el;
        this._size = 'auto';
        this._collapsed = false;
        /**
         * Gets/Sets whether pane is resizable.
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane [resizable]='false'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         * @remarks
         * If pane is not resizable its related splitter bar cannot be dragged.
         */
        this.resizable = true;
        /**
         * Event fired when collapsed state of pane is changed.
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane (onToggle)='onPaneToggle($event)'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.onToggle = new EventEmitter();
        /**
         * @hidden @internal
         * Gets/Sets the `overflow`.
         */
        this.overflow = 'auto';
        /**
         * @hidden @internal
         * Gets/Sets the `minHeight` and `minWidth` properties of the current pane.
         */
        this.minHeight = 0;
        /**
         * @hidden @internal
         * Gets/Sets the `maxHeight` and `maxWidth` properties of the current `IgxSplitterPaneComponent`.
         */
        this.maxHeight = '100%';
        /**
         * @hidden @internal
         * Gets/Sets the 'display' property of the current pane.
         */
        this.display = 'flex';
    }
    /**
     * Gets/Sets the size of the current pane.
     *  * @example
     * ```html
     * <igx-splitter>
     *  <igx-splitter-pane [size]='size'>...</igx-splitter-pane>
     * </igx-splitter>
     * ```
     */
    get size() {
        return this._size;
    }
    set size(value) {
        this._size = value;
        this.el.nativeElement.style.flex = this.flex;
    }
    /**
     *
     * @hidden @internal
     * Gets the host native element.
     */
    get element() {
        return this.el.nativeElement;
    }
    /**
     * @hidden @internal
     * Gets the `flex` property of the current `IgxSplitterPaneComponent`.
     */
    get flex() {
        const grow = this.size !== 'auto' ? 0 : 1;
        const shrink = this.size !== 'auto' ? 0 : 1;
        return `${grow} ${shrink} ${this.size}`;
    }
    /**
     * Gets/Sets whether current pane is collapsed.
     * @example
     * ```typescript
     * const isCollapsed = pane.collapsed;
     * ```
     */
    set collapsed(value) {
        this._collapsed = value;
        this.display = this._collapsed ? 'none' : 'flex';
    }
    get collapsed() {
        return this._collapsed;
    }
    /** @hidden @internal */
    _getSiblings() {
        const panes = this.owner.panes.toArray();
        const index = panes.indexOf(this);
        const siblings = [];
        if (index !== 0) {
            siblings.push(panes[index - 1]);
        }
        if (index !== panes.length - 1) {
            siblings.push(panes[index + 1]);
        }
        return siblings;
    }
    /**
     * Toggles the collapsed state of the pane.
     * @example
     * ```typescript
     * pane.toggle();
     * ```
     */
    toggle() {
        // reset sibling sizes when pane collapse state changes.
        this._getSiblings().forEach(sibling => sibling.size = 'auto');
        this.collapsed = !this.collapsed;
        this.onToggle.emit(this);
    }
}
IgxSplitterPaneComponent.ɵfac = function IgxSplitterPaneComponent_Factory(t) { return new (t || IgxSplitterPaneComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxSplitterPaneComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSplitterPaneComponent, selectors: [["igx-splitter-pane"]], hostVars: 16, hostBindings: function IgxSplitterPaneComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("overflow", ctx.overflow)("min-height", ctx.minHeight)("min-width", ctx.minHeight)("max-height", ctx.maxHeight)("max-width", ctx.maxHeight)("display", ctx.display)("flex", ctx.flex)("order", ctx.order);
    } }, inputs: { resizable: "resizable", size: "size", collapsed: "collapsed", minSize: "minSize", maxSize: "maxSize" }, outputs: { onToggle: "onToggle" }, ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxSplitterPaneComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
IgxSplitterPaneComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxSplitterPaneComponent.propDecorators = {
    size: [{ type: Input }],
    minSize: [{ type: Input }],
    maxSize: [{ type: Input }],
    resizable: [{ type: Input }],
    onToggle: [{ type: Output }],
    order: [{ type: HostBinding, args: ['style.order',] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }],
    minHeight: [{ type: HostBinding, args: ['style.min-height',] }, { type: HostBinding, args: ['style.min-width',] }],
    maxHeight: [{ type: HostBinding, args: ['style.max-height',] }, { type: HostBinding, args: ['style.max-width',] }],
    flex: [{ type: HostBinding, args: ['style.flex',] }],
    display: [{ type: HostBinding, args: ['style.display',] }],
    collapsed: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSplitterPaneComponent, [{
        type: Component,
        args: [{
                selector: 'igx-splitter-pane',
                template: "<ng-content></ng-content>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { resizable: [{
            type: Input
        }], onToggle: [{
            type: Output
        }], overflow: [{
            type: HostBinding,
            args: ['style.overflow']
        }], minHeight: [{
            type: HostBinding,
            args: ['style.min-height']
        }, {
            type: HostBinding,
            args: ['style.min-width']
        }], maxHeight: [{
            type: HostBinding,
            args: ['style.max-height']
        }, {
            type: HostBinding,
            args: ['style.max-width']
        }], display: [{
            type: HostBinding,
            args: ['style.display']
        }], size: [{
            type: Input
        }], flex: [{
            type: HostBinding,
            args: ['style.flex']
        }], collapsed: [{
            type: Input
        }], minSize: [{
            type: Input
        }], maxSize: [{
            type: Input
        }], order: [{
            type: HostBinding,
            args: ['style.order']
        }] }); })();

/**
 * An enumeration that defines the `SplitterComponent` panes orientation.
 */
var SplitterType;
(function (SplitterType) {
    SplitterType[SplitterType["Horizontal"] = 0] = "Horizontal";
    SplitterType[SplitterType["Vertical"] = 1] = "Vertical";
})(SplitterType || (SplitterType = {}));
/**
 * Provides a framework for a simple layout, splitting the view horizontally or vertically
 * into multiple smaller resizable and collapsible areas.
 * @igxModule IgxSplitterModule
 *
 * @igxParent Layouts
 *
 * @igxTheme igx-splitter-theme
 *
 * @igxKeywords splitter panes layout
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <igx-splitter>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 * </igx-splitter>
 * ```
 */
class IgxSplitterComponent {
    constructor() {
        this._type = SplitterType.Horizontal;
        /**
         * @hidden @internal
         * Gets/Sets the `overflow` property of the current splitter.
         */
        this.overflow = 'hidden';
        /**
         * @hidden @internal
         * Sets/Gets the `display` property of the current splitter.
         */
        this.display = 'flex';
    }
    /**
     * Gets/Sets the splitter orientation.
     * @example
     * ```html
     * <igx-splitter [type]="type">...</igx-splitter>
     * ```
     */
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
        if (this.panes) {
            // if type is changed runtime, should reset sizes.
            this.panes.forEach(x => x.size = 'auto');
        }
    }
    /**
     * @hidden @internal
     * Gets the `flex-direction` property of the current `SplitterComponent`.
     */
    get direction() {
        return this.type === SplitterType.Horizontal ? 'row' : 'column';
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this.panes.forEach(pane => pane.owner = this);
        this.assignFlexOrder();
        this.panes.changes.subscribe(() => {
            this.panes.forEach(pane => pane.owner = this);
            this.assignFlexOrder();
        });
    }
    /**
     * @hidden @internal
     * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.
     * @param pane - the main pane associated with the currently dragged bar.
     */
    onMoveStart(pane) {
        const panes = this.panes.toArray();
        this.pane = pane;
        this.sibling = panes[panes.indexOf(this.pane) + 1];
        const paneRect = this.pane.element.getBoundingClientRect();
        this.initialPaneSize = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        if (this.pane.size === 'auto') {
            this.pane.size = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        }
        const siblingRect = this.sibling.element.getBoundingClientRect();
        this.initialSiblingSize = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        if (this.sibling.size === 'auto') {
            this.sibling.size = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        }
    }
    /**
     * @hidden @internal
     * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.
     * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.
     */
    onMoving(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        this.pane.size = paneSize + 'px';
        this.sibling.size = siblingSize + 'px';
    }
    /**
     * @hidden @internal
     * This method assigns the order of each pane.
     */
    assignFlexOrder() {
        let k = 0;
        this.panes.forEach((pane) => {
            pane.order = k;
            k += 2;
        });
    }
    /** @hidden @internal */
    getPaneSiblingsByOrder(order, barIndex) {
        const panes = this.panes.toArray();
        const prevPane = panes[order - barIndex - 1];
        const nextPane = panes[order - barIndex];
        const siblings = [prevPane, nextPane];
        return siblings;
    }
}
IgxSplitterComponent.ɵfac = function IgxSplitterComponent_Factory(t) { return new (t || IgxSplitterComponent)(); };
IgxSplitterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSplitterComponent, selectors: [["igx-splitter"]], contentQueries: function IgxSplitterComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSplitterPaneComponent, false, IgxSplitterPaneComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panes = _t);
    } }, hostVars: 6, hostBindings: function IgxSplitterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("overflow", ctx.overflow)("display", ctx.display)("flex-direction", ctx.direction);
    } }, inputs: { type: "type" }, ngContentSelectors: _c250, decls: 2, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["role", "separator", 3, "order", "type", "pane", "siblings", "moveStart", "moving", 4, "ngIf"], ["role", "separator", 3, "order", "type", "pane", "siblings", "moveStart", "moving"]], template: function IgxSplitterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c249);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, IgxSplitterComponent_ng_container_1_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.panes);
    } }, directives: function () { return [ɵngcc2.NgForOf, ɵngcc2.NgIf, IgxSplitBarComponent]; }, encapsulation: 2 });
IgxSplitterComponent.propDecorators = {
    type: [{ type: Input }],
    panes: [{ type: ContentChildren, args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent },] }],
    direction: [{ type: HostBinding, args: ['style.flex-direction',] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }],
    display: [{ type: HostBinding, args: ['style.display',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSplitterComponent, [{
        type: Component,
        args: [{
                selector: 'igx-splitter',
                template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\">\n    </igx-splitter-bar>\n</ng-container>\n"
            }]
    }], function () { return []; }, { overflow: [{
            type: HostBinding,
            args: ['style.overflow']
        }], display: [{
            type: HostBinding,
            args: ['style.display']
        }], type: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ['style.flex-direction']
        }], panes: [{
            type: ContentChildren,
            args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent }]
        }] }); })();

const SPLITTER_INTERACTION_KEYS = new Set('right down left up arrowright arrowdown arrowleft arrowup'.split(' '));
/**
 * @hidden @internal
 * Represents the draggable bar that visually separates panes and allows for changing their sizes.
 */
class IgxSplitBarComponent {
    constructor() {
        /**
         * Set css class to the host element.
         */
        this.cssClass = 'igx-splitter-bar-host';
        /**
         * Gets/Sets the orientation.
         */
        this.type = SplitterType.Horizontal;
        /**
         * An event that is emitted whenever we start dragging the current `SplitBarComponent`.
         */
        this.moveStart = new EventEmitter();
        /**
         * An event that is emitted while we are dragging the current `SplitBarComponent`.
         */
        this.moving = new EventEmitter();
    }
    /**
     * @hidden
     * @internal
     */
    get tabindex() {
        return this.resizeDisallowed ? null : 0;
    }
    /**
     * @hidden
     * @internal
     */
    get orientation() {
        return this.type === SplitterType.Horizontal ? 'horizontal' : 'vertical';
    }
    /**
     * @hidden
     * @internal
     */
    get cursor() {
        if (this.resizeDisallowed) {
            return '';
        }
        return this.type === SplitterType.Horizontal ? 'col-resize' : 'row-resize';
    }
    /**
     * @hidden @internal
     */
    get prevButtonHidden() {
        return this.siblings[0].collapsed && !this.siblings[1].collapsed;
    }
    /**
     * @hidden @internal
     */
    keyEvent(event) {
        const key = event.key.toLowerCase();
        const ctrl = event.ctrlKey;
        event.stopPropagation();
        if (SPLITTER_INTERACTION_KEYS.has(key)) {
            event.preventDefault();
        }
        switch (key) {
            case 'arrowup':
            case 'up':
                if (this.type === SplitterType.Vertical) {
                    if (ctrl) {
                        this.onCollapsing(false);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(10);
                    }
                }
                break;
            case 'arrowdown':
            case 'down':
                if (this.type === SplitterType.Vertical) {
                    if (ctrl) {
                        this.onCollapsing(true);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(-10);
                    }
                }
                break;
            case 'arrowleft':
            case 'left':
                if (this.type === SplitterType.Horizontal) {
                    if (ctrl) {
                        this.onCollapsing(false);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(10);
                    }
                }
                break;
            case 'arrowright':
            case 'right':
                if (this.type === SplitterType.Horizontal) {
                    if (ctrl) {
                        this.onCollapsing(true);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(-10);
                    }
                }
                break;
            default:
                break;
        }
    }
    /**
     * @hidden @internal
     */
    get dragDir() {
        return this.type === SplitterType.Horizontal ? DragDirection.VERTICAL : DragDirection.HORIZONTAL;
    }
    /**
     * @hidden @internal
     */
    get nextButtonHidden() {
        return this.siblings[1].collapsed && !this.siblings[0].collapsed;
    }
    /**
     * @hidden @internal
     */
    onDragStart(event) {
        if (this.resizeDisallowed) {
            event.cancel = true;
            return;
        }
        this.startPoint = this.type === SplitterType.Horizontal ? event.startX : event.startY;
        this.moveStart.emit(this.pane);
    }
    /**
     * @hidden @internal
     */
    onDragMove(event) {
        const isHorizontal = this.type === SplitterType.Horizontal;
        const curr = isHorizontal ? event.pageX : event.pageY;
        const delta = this.startPoint - curr;
        if (delta !== 0) {
            this.moving.emit(delta);
            event.cancel = true;
            event.owner.element.nativeElement.style.transform = '';
        }
    }
    get resizeDisallowed() {
        const relatedTabs = this.siblings;
        return !!relatedTabs.find(x => x.resizable === false || x.collapsed === true);
    }
    /**
     * @hidden @internal
     */
    onCollapsing(next) {
        const prevSibling = this.siblings[0];
        const nextSibling = this.siblings[1];
        let target;
        if (next) {
            // if next is clicked when prev pane is hidden, show prev pane, else hide next pane.
            target = prevSibling.collapsed ? prevSibling : nextSibling;
        }
        else {
            // if prev is clicked when next pane is hidden, show next pane, else hide prev pane.
            target = nextSibling.collapsed ? nextSibling : prevSibling;
        }
        target.toggle();
    }
}
IgxSplitBarComponent.ɵfac = function IgxSplitBarComponent_Factory(t) { return new (t || IgxSplitBarComponent)(); };
IgxSplitBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSplitBarComponent, selectors: [["igx-splitter-bar"]], hostVars: 6, hostBindings: function IgxSplitBarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function IgxSplitBarComponent_keydown_HostBindingHandler($event) { return ctx.keyEvent($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("aria-orientation", ctx.orientation);
        ɵngcc0.ɵɵstyleProp("order", ctx.order);
        ɵngcc0.ɵɵclassProp("igx-splitter-bar-host", ctx.cssClass);
    } }, inputs: { type: "type", order: "order", pane: "pane", siblings: "siblings" }, outputs: { moveStart: "moveStart", moving: "moving" }, decls: 4, vars: 8, consts: [["igxDrag", "", 1, "igx-splitter-bar", 3, "ghost", "dragDirection", "dragStart", "dragMove"], ["igxDragIgnore", "", 1, "igx-splitter-bar__expander--start", 3, "hidden", "click"], [1, "igx-splitter-bar__handle"], ["igxDragIgnore", "", 1, "igx-splitter-bar__expander--end", 3, "hidden", "click"]], template: function IgxSplitBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("dragStart", function IgxSplitBarComponent_Template_div_dragStart_0_listener($event) { return ctx.onDragStart($event); })("dragMove", function IgxSplitBarComponent_Template_div_dragMove_0_listener($event) { return ctx.onDragMove($event); });
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵlistener("click", function IgxSplitBarComponent_Template_div_click_1_listener() { return ctx.onCollapsing(false); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵlistener("click", function IgxSplitBarComponent_Template_div_click_3_listener() { return ctx.onCollapsing(true); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("cursor", ctx.cursor);
        ɵngcc0.ɵɵclassProp("igx-splitter-bar--vertical", ctx.type === 0);
        ɵngcc0.ɵɵproperty("ghost", false)("dragDirection", ctx.dragDir);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hidden", ctx.prevButtonHidden);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("hidden", ctx.nextButtonHidden);
    } }, directives: [IgxDragDirective, IgxDragIgnoreDirective], encapsulation: 2 });
IgxSplitBarComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-splitter-bar-host',] }],
    type: [{ type: Input }],
    order: [{ type: HostBinding, args: ['style.order',] }, { type: Input }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    orientation: [{ type: HostBinding, args: ['attr.aria-orientation',] }],
    pane: [{ type: Input }],
    siblings: [{ type: Input }],
    moveStart: [{ type: Output }],
    moving: [{ type: Output }],
    keyEvent: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSplitBarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-splitter-bar',
                template: "<div class=\"igx-splitter-bar\"\n    [class.igx-splitter-bar--vertical]='type === 0'\n    [style.cursor]='cursor'\n    igxDrag\n    [ghost]=\"false\"\n    [dragDirection]='dragDir'\n    (dragStart)='onDragStart($event)'\n    (dragMove)=\"onDragMove($event)\"\n>\n    <div class=\"igx-splitter-bar__expander--start\" igxDragIgnore (click)='onCollapsing(false)' [hidden]='prevButtonHidden'></div>\n    <div class=\"igx-splitter-bar__handle\" ></div>\n    <div class=\"igx-splitter-bar__expander--end\" igxDragIgnore (click)='onCollapsing(true)' [hidden]='nextButtonHidden'></div>\n</div>\n"
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-splitter-bar-host']
        }], type: [{
            type: Input
        }], moveStart: [{
            type: Output
        }], moving: [{
            type: Output
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], orientation: [{
            type: HostBinding,
            args: ['attr.aria-orientation']
        }], 
    /**
     * @hidden @internal
     */
    keyEvent: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], order: [{
            type: HostBinding,
            args: ['style.order']
        }, {
            type: Input
        }], pane: [{
            type: Input
        }], siblings: [{
            type: Input
        }] }); })();

class IgxSplitterModule {
}
IgxSplitterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxSplitterModule });
IgxSplitterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxSplitterModule_Factory(t) { return new (t || IgxSplitterModule)(); }, imports: [[
            CommonModule, IgxIconModule, IgxDragDropModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxSplitterModule, { declarations: function () { return [IgxSplitterComponent, IgxSplitterPaneComponent, IgxSplitBarComponent]; }, imports: function () { return [CommonModule, IgxIconModule, IgxDragDropModule]; }, exports: function () { return [IgxSplitterComponent, IgxSplitterPaneComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSplitterModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule, IgxIconModule, IgxDragDropModule
                ],
                declarations: [
                    IgxSplitterComponent,
                    IgxSplitterPaneComponent,
                    IgxSplitBarComponent
                ],
                exports: [
                    IgxSplitterComponent,
                    IgxSplitterPaneComponent
                ]
            }]
    }], null, null); })();

/** @hidden @internal */
class DateRangePickerFormatPipe {
    transform(values, appliedFormat, locale, formatter) {
        if (!values || !values.start && !values.end) {
            return '';
        }
        if (formatter) {
            return formatter(values);
        }
        const { start, end } = values;
        const startDate = appliedFormat ? DatePickerUtil.formatDate(start, appliedFormat, locale || 'en') : start === null || start === void 0 ? void 0 : start.toLocaleDateString();
        const endDate = appliedFormat ? DatePickerUtil.formatDate(end, appliedFormat, locale || 'en') : end === null || end === void 0 ? void 0 : end.toLocaleDateString();
        let formatted;
        if (start) {
            formatted = `${startDate} - `;
            if (end) {
                formatted += endDate;
            }
        }
        return formatted ? formatted : '';
    }
}
DateRangePickerFormatPipe.ɵfac = function DateRangePickerFormatPipe_Factory(t) { return new (t || DateRangePickerFormatPipe)(); };
DateRangePickerFormatPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "dateRange", type: DateRangePickerFormatPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DateRangePickerFormatPipe, [{
        type: Pipe,
        args: [{ name: 'dateRange' }]
    }], null, null); })();
/** @hidden @internal */
class IgxDateRangeInputsBaseComponent extends IgxInputGroupComponent {
    /** @hidden @internal */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /** @hidden @internal */
    setFocus() {
        this.input.focus();
    }
    /** @hidden @internal */
    updateInputValue(value) {
        if (this.ngControl) {
            this.ngControl.control.setValue(value);
        }
        else {
            this.dateTimeEditor.value = value;
        }
    }
    /** @hidden @internal */
    updateInputValidity(state) {
        this.inputDirective.valid = state;
    }
}
IgxDateRangeInputsBaseComponent.ɵfac = function IgxDateRangeInputsBaseComponent_Factory(t) { return ɵIgxDateRangeInputsBaseComponent_BaseFactory(t || IgxDateRangeInputsBaseComponent); };
IgxDateRangeInputsBaseComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDateRangeInputsBaseComponent, selectors: [["igx-date-range-base"]], contentQueries: function IgxDateRangeInputsBaseComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgControl, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDateTimeEditorDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxInputDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ngControl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dateTimeEditor = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputDirective = _t.first);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxInputGroupBase, useExisting: IgxDateRangeInputsBaseComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IgxDateRangeInputsBaseComponent_Template(rf, ctx) { }, encapsulation: 2 });
IgxDateRangeInputsBaseComponent.propDecorators = {
    ngControl: [{ type: ContentChild, args: [NgControl,] }],
    dateTimeEditor: [{ type: ContentChild, args: [IgxDateTimeEditorDirective,] }],
    inputDirective: [{ type: ContentChild, args: [IgxInputDirective,] }]
};
const ɵIgxDateRangeInputsBaseComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxDateRangeInputsBaseComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateRangeInputsBaseComponent, [{
        type: Component,
        args: [{
                template: ``,
                selector: `igx-date-range-base`,
                providers: [{ provide: IgxInputGroupBase, useExisting: IgxDateRangeInputsBaseComponent }]
            }]
    }], null, { ngControl: [{
            type: ContentChild,
            args: [NgControl]
        }], dateTimeEditor: [{
            type: ContentChild,
            args: [IgxDateTimeEditorDirective]
        }], inputDirective: [{
            type: ContentChild,
            args: [IgxInputDirective]
        }] }); })();
/**
 * Templates the default icon in the `IgxDateRangePicker`.
 *
 * @igxModule IgxDateRangePickerModule
 *
 * @igxKeyWords date range icon, date picker icon
 *
 * @igxGroup scheduling
 *
 * @example
 * ```html
 * <igx-date-range-picker>
 *   <igx-picker-toggle igxSuffix>
 *      <igx-icon>calendar_view_day</igx-icon>
 *   </igx-picker-toggle>
 * </igx-date-range-picker>
 * ```
 */
class IgxPickerToggleComponent {
    constructor() {
        this.clicked = new EventEmitter();
    }
    onClick(event) {
        // do not focus input on click
        event.stopPropagation();
        this.clicked.emit();
    }
}
IgxPickerToggleComponent.ɵfac = function IgxPickerToggleComponent_Factory(t) { return new (t || IgxPickerToggleComponent)(); };
IgxPickerToggleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxPickerToggleComponent, selectors: [["igx-picker-toggle"]], hostBindings: function IgxPickerToggleComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxPickerToggleComponent_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } }, outputs: { clicked: "clicked" }, ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxPickerToggleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
IgxPickerToggleComponent.propDecorators = {
    clicked: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxPickerToggleComponent, [{
        type: Component,
        args: [{
                template: `<ng-content></ng-content>`,
                selector: 'igx-picker-toggle'
            }]
    }], function () { return []; }, { clicked: [{
            type: Output
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
/**
 * Defines the start input for a date range picker
 *
 * @igxModule IgxDateRangePickerModule
 *
 * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme
 *
 * @igxKeywords date, range, date range, date picker
 *
 * @igxGroup scheduling
 *
 * @remarks
 * When templating, start input has to be templated separately
 *
 * @example
 * ```html
 * <igx-date-range-picker mode="dropdown">
 *      <igx-date-range-start>
 *          <input igxInput igxDateTimeEditor type="text">
 *      </igx-date-range-start>
 *      ...
 * </igx-date-range-picker>
 * ```
 */
class IgxDateRangeStartComponent extends IgxDateRangeInputsBaseComponent {
}
IgxDateRangeStartComponent.ɵfac = function IgxDateRangeStartComponent_Factory(t) { return ɵIgxDateRangeStartComponent_BaseFactory(t || IgxDateRangeStartComponent); };
IgxDateRangeStartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDateRangeStartComponent, selectors: [["igx-date-range-start"]], features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: IgxInputGroupBase, useExisting: IgxDateRangeStartComponent },
            { provide: IgxDateRangeInputsBaseComponent, useExisting: IgxDateRangeStartComponent }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c8, decls: 20, vars: 3, consts: [["class", "igx-input-group__wrapper", 4, "ngIf", "ngIfElse"], ["class", "igx-input-group__border", 4, "ngIf"], [1, "igx-input-group__hint", 3, "click"], ["label", ""], ["input", ""], ["prefix", ""], ["suffix", ""], ["materialBundle", ""], ["fluentBundle", ""], ["bootstrapBundle", ""], ["bundle", ""], [1, "igx-input-group__wrapper"], [4, "ngTemplateOutlet"], [1, "igx-input-group__border"], [1, "igx-input-group__bundle"], [1, "igx-input-group__bundle-main"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"]], template: function IgxDateRangeStartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵtemplate(0, IgxDateRangeStartComponent_div_0_Template, 2, 1, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_div_1_Template, 1, 0, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵlistener("click", function IgxDateRangeStartComponent_Template_div_click_2_listener($event) { return ctx.hintClickHandler($event); });
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, IgxDateRangeStartComponent_ng_template_4_Template, 1, 0, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxDateRangeStartComponent_ng_template_6_Template, 1, 0, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, IgxDateRangeStartComponent_ng_template_8_Template, 1, 0, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(10, IgxDateRangeStartComponent_ng_template_10_Template, 1, 0, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(12, IgxDateRangeStartComponent_ng_template_12_Template, 6, 4, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(14, IgxDateRangeStartComponent_ng_template_14_Template, 6, 4, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(16, IgxDateRangeStartComponent_ng_template_16_Template, 5, 4, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(18, IgxDateRangeStartComponent_ng_template_18_Template, 5, 4, "ng-template", null, 10, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r16 = ɵngcc0.ɵɵreference(19);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isTypeBox)("ngIfElse", _r16);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasBorder);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase, ɵngcc2.NgSwitchDefault], encapsulation: 2 });
const ɵIgxDateRangeStartComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxDateRangeStartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateRangeStartComponent, [{
        type: Component,
        args: [{
                selector: 'igx-date-range-start',
                template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n\n<div class=\"igx-input-group__hint\" (click)=\"hintClickHandler($event)\">\n    <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n</div>\n\n<ng-template #label>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #input>\n    <ng-content select=\"[igxInput]\"></ng-content>\n</ng-template>\n\n<ng-template #prefix>\n    <ng-content select=\"igx-prefix, [igxPrefix]\"></ng-content>\n</ng-template>\n\n<ng-template #suffix>\n    <ng-content select=\"igx-suffix, [igxSuffix]\"></ng-content>\n</ng-template>\n\n<ng-template #materialBundle>\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #fluentBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bootstrapBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bundle>\n    <ng-container [ngSwitch]=\"theme\">\n        <ng-container *ngSwitchCase=\"'bootstrap'\">\n            <ng-container *ngTemplateOutlet=\"bootstrapBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'fluent'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'indigo-design'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"materialBundle\"></ng-container>\n        </ng-container>\n    </ng-container>\n</ng-template>\n",
                providers: [
                    { provide: IgxInputGroupBase, useExisting: IgxDateRangeStartComponent },
                    { provide: IgxDateRangeInputsBaseComponent, useExisting: IgxDateRangeStartComponent }
                ]
            }]
    }], null, null); })();
/**
 * Defines the end input for a date range picker
 *
 * @igxModule IgxDateRangeModule
 *
 * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme
 *
 * @igxKeywords date, range, date range, date picker
 *
 * @igxGroup scheduling
 *
 * @remarks
 * When templating, end input has to be template separately
 *
 * @example
 * ```html
 * <igx-date-range-picker mode="dropdown">
 *      <igx-date-range-end>
 *          <input igxInput igxDateTimeEditor type="text">
 *      </igx-date-range-end>
 *      ...
 * </igx-date-range-picker>
 * ```
 */
class IgxDateRangeEndComponent extends IgxDateRangeInputsBaseComponent {
}
IgxDateRangeEndComponent.ɵfac = function IgxDateRangeEndComponent_Factory(t) { return ɵIgxDateRangeEndComponent_BaseFactory(t || IgxDateRangeEndComponent); };
IgxDateRangeEndComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDateRangeEndComponent, selectors: [["igx-date-range-end"]], features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: IgxInputGroupBase, useExisting: IgxDateRangeEndComponent },
            { provide: IgxDateRangeInputsBaseComponent, useExisting: IgxDateRangeEndComponent }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c8, decls: 20, vars: 3, consts: [["class", "igx-input-group__wrapper", 4, "ngIf", "ngIfElse"], ["class", "igx-input-group__border", 4, "ngIf"], [1, "igx-input-group__hint", 3, "click"], ["label", ""], ["input", ""], ["prefix", ""], ["suffix", ""], ["materialBundle", ""], ["fluentBundle", ""], ["bootstrapBundle", ""], ["bundle", ""], [1, "igx-input-group__wrapper"], [4, "ngTemplateOutlet"], [1, "igx-input-group__border"], [1, "igx-input-group__bundle"], [1, "igx-input-group__bundle-main"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"]], template: function IgxDateRangeEndComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵtemplate(0, IgxDateRangeEndComponent_div_0_Template, 2, 1, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_div_1_Template, 1, 0, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵlistener("click", function IgxDateRangeEndComponent_Template_div_click_2_listener($event) { return ctx.hintClickHandler($event); });
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, IgxDateRangeEndComponent_ng_template_4_Template, 1, 0, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxDateRangeEndComponent_ng_template_6_Template, 1, 0, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, IgxDateRangeEndComponent_ng_template_8_Template, 1, 0, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(10, IgxDateRangeEndComponent_ng_template_10_Template, 1, 0, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(12, IgxDateRangeEndComponent_ng_template_12_Template, 6, 4, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(14, IgxDateRangeEndComponent_ng_template_14_Template, 6, 4, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(16, IgxDateRangeEndComponent_ng_template_16_Template, 5, 4, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(18, IgxDateRangeEndComponent_ng_template_18_Template, 5, 4, "ng-template", null, 10, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r16 = ɵngcc0.ɵɵreference(19);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isTypeBox)("ngIfElse", _r16);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasBorder);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase, ɵngcc2.NgSwitchDefault], encapsulation: 2 });
const ɵIgxDateRangeEndComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(IgxDateRangeEndComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateRangeEndComponent, [{
        type: Component,
        args: [{
                selector: 'igx-date-range-end',
                template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n\n<div class=\"igx-input-group__hint\" (click)=\"hintClickHandler($event)\">\n    <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n</div>\n\n<ng-template #label>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #input>\n    <ng-content select=\"[igxInput]\"></ng-content>\n</ng-template>\n\n<ng-template #prefix>\n    <ng-content select=\"igx-prefix, [igxPrefix]\"></ng-content>\n</ng-template>\n\n<ng-template #suffix>\n    <ng-content select=\"igx-suffix, [igxSuffix]\"></ng-content>\n</ng-template>\n\n<ng-template #materialBundle>\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #fluentBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        </div>\n\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bootstrapBundle>\n    <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-container *ngTemplateOutlet=\"prefix\"></ng-container>\n\n        <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n\n        <ng-container *ngTemplateOutlet=\"suffix\"></ng-container>\n    </div>\n</ng-template>\n\n<ng-template #bundle>\n    <ng-container [ngSwitch]=\"theme\">\n        <ng-container *ngSwitchCase=\"'bootstrap'\">\n            <ng-container *ngTemplateOutlet=\"bootstrapBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'fluent'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchCase=\"'indigo-design'\">\n            <ng-container *ngTemplateOutlet=\"fluentBundle\"></ng-container>\n        </ng-container>\n\n        <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"materialBundle\"></ng-container>\n        </ng-container>\n    </ng-container>\n</ng-template>\n",
                providers: [
                    { provide: IgxInputGroupBase, useExisting: IgxDateRangeEndComponent },
                    { provide: IgxDateRangeInputsBaseComponent, useExisting: IgxDateRangeEndComponent }
                ]
            }]
    }], null, null); })();
class IgxDateRangeSeparatorDirective {
}
IgxDateRangeSeparatorDirective.ɵfac = function IgxDateRangeSeparatorDirective_Factory(t) { return new (t || IgxDateRangeSeparatorDirective)(); };
IgxDateRangeSeparatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDateRangeSeparatorDirective, selectors: [["", "igxDateRangeSeparator", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateRangeSeparatorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDateRangeSeparator]'
            }]
    }], null, null); })();

const SingleInputDatesConcatenationString = ' - ';
/**
 * Provides the ability to select a range of dates from a calendar UI or editable inputs.
 *
 * @igxModule IgxDateRangeModule
 *
 * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme
 *
 * @igxKeywords date, range, date range, date picker
 *
 * @igxGroup scheduling
 *
 * @remarks
 * It displays the range selection in a single or two input fields.
 * The default template displays a single *readonly* input field
 * while projecting `igx-date-range-start` and `igx-date-range-end`
 * displays two *editable* input fields.
 *
 * @example
 * ```html
 * <igx-date-range-picker mode="dropdown"></igx-date-range-picker>
 * ```
 */
class IgxDateRangePickerComponent extends DisplayDensityBase {
    constructor(element, _displayDensityOptions, localeId, _injector) {
        super(_displayDensityOptions);
        this.element = element;
        this._displayDensityOptions = _displayDensityOptions;
        this.localeId = localeId;
        this._injector = _injector;
        /**
         * Display calendar in either `dialog` or `dropdown` mode.
         * @remarks
         * Default mode is `dialog`
         *
         * @example
         * ```html
         * <igx-date-range-picker mode="dropdown"></igx-date-range-picker>
         * ```
         */
        this.mode = InteractionMode.Dialog;
        /**
         * The number of displayed month views.
         *
         * @remarks
         * Default is `2`.
         *
         * @example
         * ```html
         * <igx-date-range-picker [monthsViewNumber]="3"></igx-date-range-picker>
         * ```
         */
        this.monthsViewNumber = 2;
        /**
         * The start day of the week.
         *
         * @remarks
         * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
         *
         * @example
         * ```html
         * <igx-date-range-picker [weekStart]="1"></igx-date-range-picker>
         * ```
         */
        this.weekStart = WEEKDAYS.SUNDAY;
        /**
         * The default text of the calendar dialog `done` button.
         *
         * @remarks
         * Default value is `Done`.
         * The button will only show up in `dialog` mode.
         *
         * @example
         * ```html
         * <igx-date-range-picker doneButtonText="完了"></igx-date-range-picker>
         * ```
         */
        this.doneButtonText = 'Done';
        /**
         * Enables/Disables the `IgxDateRangePickerComponent`.
         *  @example
         * ```html
         * <igx-date-range-picker [disabled]="'true'"></igx-date-range-picker>
         * ```
         */
        this.disabled = false;
        /**
         * Sets the `placeholder` for single-input `IgxDateRangePickerComponent`.
         *   @example
         * ```html
         * <igx-date-range-picker [placeholder]="'Choose your dates'"></igx-date-range-picker>
         * ```
         */
        this.placeholder = '';
        /**
         * Emitted when a range is selected.
         *
         * @example
         * ```html
         * <igx-date-range-picker (rangeSelected)="handleSelected($event)"></igx-date-range-picker>
         * ```
         */
        this.rangeSelected = new EventEmitter();
        /**
         * Emitted when the calendar starts opening, cancelable.
         *
         * @example
         * ```html
         * <igx-date-range-picker (onOpening)="handleOpening($event)"></igx-date-range-picker>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted when the `IgxDateRangeComponent` is opened.
         *
         * @example
         * ```html
         * <igx-date-range-picker (onOpened)="handleOpened($event)"></igx-date-range-picker>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted when the calendar starts closing, cancelable.
         *
         * @example
         * ```html
         * <igx-date-range-picker (onClosing)="handleClosing($event)"></igx-date-range-picker>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted when the `IgxDateRangeComponent` is closed.
         *
         * @example
         * ```html
         * <igx-date-range-picker (onClosed)="handleClosed($event)"></igx-date-range-picker>
         * ```
         */
        this.onClosed = new EventEmitter();
        /** @hidden @internal */
        this.cssClass = 'igx-date-range-picker';
        /** @hidden @internal */
        this.dateSeparator = CurrentResourceStrings.DateRangePickerResStrings.igx_date_range_picker_date_separator;
        this._collapsed = true;
        this.$destroy = new Subject();
        this.$toggleClickNotifier = new Subject();
        this._dialogOverlaySettings = {
            closeOnOutsideClick: true,
            modal: true
        };
        this._dropDownOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false
        };
        this.onChangeCallback = (dateRange) => { };
        this.onTouchCallback = () => { };
        this.onValidatorChange = () => { };
        this.onStatusChanged = () => {
            if ((this._ngControl.control.touched || this._ngControl.control.dirty) &&
                (this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {
                if (this.inputGroup) {
                    this.inputDirective.valid = this.getInputState(this.inputGroup.isFocused);
                }
                else if (this.hasProjectedInputs) {
                    this.projectedInputs
                        .forEach(i => { i.inputDirective.valid = this.getInputState(i.isFocused); });
                }
            }
            this.setRequiredToInputs();
        };
        this.locale = this.locale || this.localeId;
    }
    /**
     * The minimum value in a valid range.
     *
     * @example
     * <igx-date-range-picker [minValue]="minDate"></igx-date-range-picker>
     */
    set minValue(value) {
        this._minValue = value;
        this.onValidatorChange();
    }
    get minValue() {
        return this._minValue;
    }
    /**
     * The maximum value in a valid range.
     *
     * @example
     * <igx-date-range-picker [maxValue]="maxDate"></igx-date-range-picker>
     */
    set maxValue(value) {
        this._maxValue = value;
        this.onValidatorChange();
    }
    get maxValue() {
        return this._maxValue;
    }
    /** @hidden @internal */
    get appliedFormat() {
        return DatePickerUtil.getLocaleDateFormat(this.locale, this.displayFormat)
            || DatePickerUtil.DEFAULT_INPUT_FORMAT;
    }
    /** @hidden @internal */
    get singleInputFormat() {
        if (this.placeholder !== '') {
            return this.placeholder;
        }
        const format = this.appliedFormat;
        return `${format}${SingleInputDatesConcatenationString}${format}`;
    }
    /** @hidden @internal */
    get hasProjectedInputs() {
        var _a;
        return ((_a = this.projectedInputs) === null || _a === void 0 ? void 0 : _a.length) > 0;
    }
    get dropdownOverlaySettings() {
        return Object.assign({}, this._dropDownOverlaySettings, this.overlaySettings);
    }
    get dialogOverlaySettings() {
        return Object.assign({}, this._dialogOverlaySettings, this.overlaySettings);
    }
    get required() {
        if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
            const error = this._ngControl.control.validator({});
            return (error && error.required) ? true : false;
        }
        return false;
    }
    /**
     * Opens the date range picker's dropdown or dialog.
     *
     * @example
     * ```html
     * <igx-date-range-picker #dateRange></igx-date-range-picker>
     *
     * <button (click)="dateRange.open()">Open Dialog</button
     * ```
     */
    open(overlaySettings) {
        if (!this.collapsed || this.disabled) {
            return;
        }
        this.updateCalendar();
        const settings = this.mode === InteractionMode.Dialog ? this.dialogOverlaySettings : this.dropdownOverlaySettings;
        this.toggleDirective.open(Object.assign(settings, overlaySettings));
    }
    /**
     * Closes the date range picker's dropdown or dialog.
     *
     * @example
     * html```
     * <igx-date-range-picker #dateRange></igx-date-range-picker>
     *
     * <button (click)="dateRange.close()">Close Dialog</button>
     * ```
     */
    close() {
        if (!this.collapsed) {
            this.toggleDirective.close();
        }
    }
    /**
     * Toggles the date range picker's dropdown or dialog
     *
     * @example
     * html```
     * <igx-date-range-picker #dateRange></igx-date-range-picker>
     *
     * <button (click)="dateRange.toggle()">Toggle Dialog</button>
     * ```
     */
    toggle(overlaySettings) {
        if (!this.collapsed) {
            this.close();
        }
        else {
            this.open(overlaySettings);
        }
    }
    /**
     * Gets calendar state.
     *
     * ```typescript
     * let state = this.dateRange.collapsed;
     * ```
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * The currently selected value / range from the calendar
     *
     * @remarks
     * The current value is of type `DateRange`
     *
     * @example
     * ```typescript
     * const newValue: DateRange = { start: new Date("2/2/2012"), end: new Date("3/3/2013")};
     * this.dateRangePicker.value = newValue;
     * ```
     */
    get value() {
        return this._value;
    }
    set value(value) {
        this.updateValue(value);
        this.onChangeCallback(value);
    }
    updateValue(value) {
        this._value = value ? value : null;
        this.updateInputs();
    }
    /**
     * Selects a range of dates. If no `endDate` is passed, range is 1 day (only `startDate`)
     *
     * @example
     * ```typescript
     * public selectFiveDayRange() {
     *  const inFiveDays = new Date(new Date().setDate(today.getDate() + 5));
     *  const today = new Date();
     *  this.dateRange.selectRange(today, inFiveDays);
     * }
     * ```
     */
    selectRange(startDate, endDate) {
        endDate = endDate !== null && endDate !== void 0 ? endDate : startDate;
        const dateRange = [startDate, endDate];
        this.calendar.selectDate(dateRange);
        this.handleSelection(dateRange);
    }
    /** @hidden @internal */
    writeValue(value) {
        this.updateValue(value);
    }
    /** @hidden @internal */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /** @hidden @internal */
    registerOnTouched(fn) {
        this.onTouchCallback = fn;
    }
    /** @hidden @internal */
    validate(control) {
        const value = control.value;
        const errors = {};
        if (value) {
            if (this.hasProjectedInputs) {
                const startInput = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);
                const endInput = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);
                if (!startInput.dateTimeEditor.value) {
                    Object.assign(errors, { 'startValue': true });
                }
                if (!endInput.dateTimeEditor.value) {
                    Object.assign(errors, { 'endValue': true });
                }
            }
            const min = DatePickerUtil.parseDate(this.minValue);
            const max = DatePickerUtil.parseDate(this.maxValue);
            const start = DatePickerUtil.parseDate(value.start);
            const end = DatePickerUtil.parseDate(value.end);
            if ((min && start && DatePickerUtil.lessThanMinValue(start, min, false))
                || (min && end && DatePickerUtil.lessThanMinValue(end, min, false))) {
                Object.assign(errors, { 'minValue': true });
            }
            if ((max && start && DatePickerUtil.greaterThanMaxValue(start, max, false))
                || (max && end && DatePickerUtil.greaterThanMaxValue(end, max, false))) {
                Object.assign(errors, { 'maxValue': true });
            }
        }
        return Object.keys(errors).length > 0 ? errors : null;
    }
    /** @hidden @internal */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /** @hidden @internal */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /** @hidden @internal */
    get separatorClass() {
        return this.getComponentDensityClass('igx-date-range-picker__label');
    }
    /** @hidden */
    ngOnInit() {
        this._ngControl = this._injector.get(NgControl, null);
    }
    /** @hidden */
    ngAfterViewInit() {
        if (this.mode === InteractionMode.DropDown) {
            this.attachOnKeydown();
        }
        this.subscribeToDateEditorEvents();
        this.configPositionStrategy();
        this.configOverlaySettings();
        this.cacheFocusedInput();
        this.attachOnTouched();
        const subsToClicked = () => {
            this.$toggleClickNotifier.next();
            this.toggleComponents.forEach(toggle => {
                toggle.clicked.pipe(takeUntil(this.$toggleClickNotifier)).subscribe(() => this.open());
            });
        };
        this.toggleComponents.changes.pipe(takeUntil(this.$destroy)).subscribe(() => subsToClicked());
        subsToClicked();
        this.setRequiredToInputs();
        if (this._ngControl) {
            this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
        }
        // delay invocations until the current change detection cycle has completed
        Promise.resolve().then(() => {
            this.updateDisabledState();
            this.initialSetValue();
            this.updateInputs();
        });
        this.updateDisplayFormat();
        this.updateInputFormat();
    }
    /** @hidden @internal */
    ngOnChanges(changes) {
        if (changes['locale']) {
            this.inputFormat = DatePickerUtil.getDefaultInputFormat(this.locale || 'en') || DatePickerUtil.DEFAULT_INPUT_FORMAT;
        }
        if (changes['displayFormat'] && this.hasProjectedInputs) {
            this.updateDisplayFormat();
        }
        if (changes['inputFormat'] && this.hasProjectedInputs) {
            this.updateInputFormat();
        }
        if (changes['disabled']) {
            this.updateDisabledState();
        }
    }
    /** @hidden @internal */
    ngOnDestroy() {
        this.$destroy.next();
        this.$destroy.complete();
        this.$toggleClickNotifier.next();
        this.$toggleClickNotifier.complete();
    }
    /** @hidden @internal */
    handleOpening(event) {
        const args = { owner: this, cancel: event.cancel, event: event.event };
        this.onOpening.emit(args);
        event.cancel = args.cancel;
        if (!args.cancel) {
            this._collapsed = false;
        }
    }
    /** @hidden @internal */
    handleOpened() {
        this.calendar.daysView.focusActiveDate();
        this.onOpened.emit({ owner: this });
    }
    /** @hidden @internal */
    handleClosing(event) {
        if (this.value && !this.value.start && !this.value.end) {
            this.value = null;
        }
        const args = { owner: this, cancel: event.cancel, event: event.event };
        this.onClosing.emit(args);
        event.cancel = args.cancel;
        if (args.cancel) {
            return;
        }
        if (this.mode === InteractionMode.DropDown && event.event && !this.element.nativeElement.contains(event.event.target)) {
            // outside click
            this.updateValidityOnBlur();
        }
        else {
            // input click
            if (this.hasProjectedInputs && this._focusedInput) {
                this._focusedInput.setFocus();
                this._focusedInput = null;
            }
            if (this.inputDirective) {
                this.inputDirective.focus();
            }
        }
    }
    updateValidityOnBlur() {
        this.onTouchCallback();
        if (this._ngControl) {
            if (this.hasProjectedInputs) {
                this.projectedInputs.forEach(i => {
                    if (!this._ngControl.valid) {
                        i.updateInputValidity(IgxInputState.INVALID);
                    }
                    else {
                        i.updateInputValidity(IgxInputState.INITIAL);
                    }
                });
            }
            if (this.inputDirective) {
                if (!this._ngControl.valid) {
                    this.inputDirective.valid = IgxInputState.INVALID;
                }
                else {
                    this.inputDirective.valid = IgxInputState.INITIAL;
                }
            }
        }
    }
    /** @hidden @internal */
    handleClosed() {
        this._collapsed = true;
        this.onClosed.emit({ owner: this });
    }
    /** @hidden @internal */
    onKeyDown(event) {
        switch (event.key) {
            case "ArrowUp" /* UP_ARROW */:
            case "Up" /* UP_ARROW_IE */:
                if (event.altKey) {
                    this.close();
                }
                break;
            case "ArrowDown" /* DOWN_ARROW */:
            case "Down" /* DOWN_ARROW_IE */:
                if (event.altKey) {
                    this.open();
                }
                break;
            case "Escape" /* ESCAPE */:
            case "Esc" /* ESCAPE_IE */:
                this.close();
                break;
        }
    }
    /** @hidden @internal */
    handleSelection(selectionData) {
        this.value = this.extractRange(selectionData);
        this.rangeSelected.emit(this.value);
    }
    updateDisabledState() {
        if (this.hasProjectedInputs) {
            const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);
            const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);
            start.inputDirective.disabled = this.disabled;
            end.inputDirective.disabled = this.disabled;
            return;
        }
        if (this.inputDirective) {
            this.inputDirective.disabled = this.disabled;
        }
    }
    getInputState(focused) {
        if (focused) {
            return this._ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
        }
        else {
            return this._ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
        }
    }
    setRequiredToInputs() {
        // workaround for igxInput setting required
        Promise.resolve().then(() => {
            const isRequired = this.required;
            if (this.inputGroup && this.inputGroup.isRequired !== isRequired) {
                this.inputGroup.isRequired = isRequired;
            }
            else if (this.hasProjectedInputs && this._ngControl) {
                this.projectedInputs.forEach(i => i.isRequired = isRequired);
            }
        });
    }
    parseMinValue(value) {
        let minValue = DatePickerUtil.parseDate(value);
        if (!minValue && this.hasProjectedInputs) {
            const start = this.projectedInputs.filter(i => i instanceof IgxDateRangeStartComponent)[0];
            if (start) {
                minValue = DatePickerUtil.parseDate(start.dateTimeEditor.minValue);
            }
        }
        return minValue;
    }
    parseMaxValue(value) {
        let maxValue = DatePickerUtil.parseDate(value);
        if (!maxValue && this.projectedInputs) {
            const end = this.projectedInputs.filter(i => i instanceof IgxDateRangeEndComponent)[0];
            if (end) {
                maxValue = DatePickerUtil.parseDate(end.dateTimeEditor.maxValue);
            }
        }
        return maxValue;
    }
    updateCalendar() {
        var _a, _b;
        this.calendar.disabledDates = [];
        const minValue = this.parseMinValue(this.minValue);
        if (minValue) {
            this.calendar.disabledDates.push({ type: DateRangeType.Before, dateRange: [minValue] });
        }
        const maxValue = this.parseMaxValue(this.maxValue);
        if (maxValue) {
            this.calendar.disabledDates.push({ type: DateRangeType.After, dateRange: [maxValue] });
        }
        const range = [];
        if (((_a = this.value) === null || _a === void 0 ? void 0 : _a.start) && ((_b = this.value) === null || _b === void 0 ? void 0 : _b.end)) {
            if (DatePickerUtil.greaterThanMaxValue(this.value.start, this.value.end)) {
                this.swapEditorDates();
            }
            if (this.valueInRange(this.value, minValue, maxValue)) {
                range.push(this.value.start, this.value.end);
            }
        }
        if (range.length > 0) {
            this.calendar.selectDate(range);
        }
        else {
            this.calendar.deselectDate();
        }
        this.calendar.viewDate = range[0] || new Date();
    }
    swapEditorDates() {
        if (this.hasProjectedInputs) {
            const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);
            const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);
            [start.dateTimeEditor.value, end.dateTimeEditor.value] = [end.dateTimeEditor.value, start.dateTimeEditor.value];
            [this.value.start, this.value.end] = [this.value.end, this.value.start];
        }
    }
    valueInRange(value, minValue, maxValue) {
        if (minValue && DatePickerUtil.lessThanMinValue(value.start, minValue, false)) {
            return false;
        }
        if (maxValue && DatePickerUtil.greaterThanMaxValue(value.end, maxValue, false)) {
            return false;
        }
        return true;
    }
    extractRange(selection) {
        return {
            start: selection[0],
            end: selection.length > 0 ? selection[selection.length - 1] : null
        };
    }
    attachOnKeydown() {
        fromEvent(this.element.nativeElement, 'keydown')
            .pipe(takeUntil(this.$destroy))
            .subscribe((evt) => this.onKeyDown(evt));
    }
    subscribeToDateEditorEvents() {
        if (this.hasProjectedInputs) {
            const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);
            const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);
            if (start && end) {
                start.dateTimeEditor.valueChange
                    .pipe(takeUntil(this.$destroy))
                    .subscribe(value => {
                    if (this.value) {
                        this.value = { start: value, end: this.value.end };
                    }
                    else {
                        this.value = { start: value, end: null };
                    }
                });
                end.dateTimeEditor.valueChange
                    .pipe(takeUntil(this.$destroy))
                    .subscribe(value => {
                    if (this.value) {
                        this.value = { start: this.value.start, end: value };
                    }
                    else {
                        this.value = { start: null, end: value };
                    }
                });
            }
        }
    }
    attachOnTouched() {
        if (this.hasProjectedInputs) {
            this.projectedInputs.forEach(i => {
                fromEvent(i.dateTimeEditor.nativeElement, 'blur')
                    .pipe(takeUntil(this.$destroy))
                    .subscribe(() => {
                    if (this.collapsed) {
                        this.updateValidityOnBlur();
                    }
                });
            });
        }
        else {
            fromEvent(this.inputDirective.nativeElement, 'blur')
                .pipe(takeUntil(this.$destroy))
                .subscribe(() => {
                if (this.collapsed) {
                    this.updateValidityOnBlur();
                }
            });
        }
    }
    cacheFocusedInput() {
        if (this.hasProjectedInputs) {
            this.projectedInputs.forEach(i => {
                fromEvent(i.dateTimeEditor.nativeElement, 'focus')
                    .pipe(takeUntil(this.$destroy))
                    .subscribe(() => this._focusedInput = i);
            });
        }
    }
    configPositionStrategy() {
        this._positionSettings = {
            openAnimation: fadeIn,
            closeAnimation: fadeOut
        };
        this._dropDownOverlaySettings.positionStrategy = new AutoPositionStrategy(this._positionSettings);
        this.dropdownOverlaySettings.target = this.element.nativeElement;
    }
    configOverlaySettings() {
        if (this.overlaySettings !== null) {
            this._dropDownOverlaySettings = Object.assign({}, this._dropDownOverlaySettings, this.overlaySettings);
            this._dialogOverlaySettings = Object.assign({}, this._dialogOverlaySettings, this.overlaySettings);
        }
    }
    initialSetValue() {
        // if there is no value and no ngControl on the picker but we have inputs we may have value set through
        // their ngModels - we should generate our initial control value
        if ((!this.value || (!this.value.start && !this.value.end)) && this.hasProjectedInputs && !this._ngControl) {
            const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);
            const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);
            this._value = {
                start: start.dateTimeEditor.value,
                end: end.dateTimeEditor.value
            };
        }
    }
    updateInputs() {
        var _a, _b, _c, _d, _e, _f;
        const start = (_a = this.projectedInputs) === null || _a === void 0 ? void 0 : _a.find(i => i instanceof IgxDateRangeStartComponent);
        const end = (_b = this.projectedInputs) === null || _b === void 0 ? void 0 : _b.find(i => i instanceof IgxDateRangeEndComponent);
        if (start && end) {
            start.updateInputValue((_d = (_c = this.value) === null || _c === void 0 ? void 0 : _c.start) !== null && _d !== void 0 ? _d : null);
            end.updateInputValue((_f = (_e = this.value) === null || _e === void 0 ? void 0 : _e.end) !== null && _f !== void 0 ? _f : null);
        }
    }
    updateDisplayFormat() {
        this.projectedInputs.forEach(i => {
            const input = i;
            input.dateTimeEditor.displayFormat = this.displayFormat;
        });
    }
    updateInputFormat() {
        this.projectedInputs.forEach(i => {
            const input = i;
            if (input.dateTimeEditor.inputFormat !== this.inputFormat) {
                input.dateTimeEditor.inputFormat = this.inputFormat;
            }
        });
    }
}
IgxDateRangePickerComponent.ɵfac = function IgxDateRangePickerComponent_Factory(t) { return new (t || IgxDateRangePickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
IgxDateRangePickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDateRangePickerComponent, selectors: [["igx-date-range-picker"]], contentQueries: function IgxDateRangePickerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxLabelDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDateRangeSeparatorDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxPickerToggleComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDateRangeInputsBaseComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.label = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dateSeparatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleComponents = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.projectedInputs = _t);
    } }, viewQuery: function IgxDateRangePickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxCalendarComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxInputGroupComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxInputDirective, true);
        ɵngcc0.ɵɵviewQuery(IgxToggleDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.calendar = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleDirective = _t.first);
    } }, hostVars: 2, hostBindings: function IgxDateRangePickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-date-range-picker", ctx.cssClass);
    } }, inputs: { mode: "mode", monthsViewNumber: "monthsViewNumber", weekStart: "weekStart", doneButtonText: "doneButtonText", disabled: "disabled", placeholder: "placeholder", locale: "locale", minValue: "minValue", maxValue: "maxValue", value: "value", inputFormat: "inputFormat", hideOutsideDays: "hideOutsideDays", formatter: "formatter", overlaySettings: "overlaySettings", displayFormat: "displayFormat" }, outputs: { rangeSelected: "rangeSelected", onOpening: "onOpening", onOpened: "onOpened", onClosing: "onClosing", onClosed: "onClosed" }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NG_VALUE_ACCESSOR, useExisting: IgxDateRangePickerComponent, multi: true },
            { provide: NG_VALIDATORS, useExisting: IgxDateRangePickerComponent, multi: true }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c252, decls: 17, vars: 14, consts: [["igxToggle", "", 1, "igx-date-picker", 3, "onOpening", "onOpened", "onClosing", "onClosed"], ["toggle", "toggle"], ["selection", "range", 3, "weekStart", "hideOutsideDays", "monthsViewNumber", "locale", "keydown", "onSelection"], ["calendar", ""], [1, "igx-date-range-picker-buttons"], [4, "ngIf"], [4, "ngTemplateOutlet"], ["singleTemplate", ""], ["startEndTemplate", ""], ["defIcon", ""], ["defDateSeparatorTemplate", ""], ["defTemplate", ""], ["igxButton", "", "type", "button", 3, "click"], [1, "content-wrap", 3, "click"], [3, "className"], [3, "click"], ["igxInput", "", "type", "text", "readonly", "", "role", "combobox", "aria-haspopup", "grid", 3, "placeholder", "value"], ["singleInput", ""], ["ngProjectAs", "[igxLabel]", 5, ["", "igxLabel", ""]], ["ngProjectAs", "igx-prefix", 5, ["igx-prefix"]], ["ngProjectAs", "igx-suffix", 5, ["igx-suffix"]], ["ngProjectAs", "igx-hint", 5, ["igx-hint"]]], template: function IgxDateRangePickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c251);
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵlistener("onOpening", function IgxDateRangePickerComponent_Template_div_onOpening_0_listener($event) { return ctx.handleOpening($event); })("onOpened", function IgxDateRangePickerComponent_Template_div_onOpened_0_listener() { return ctx.handleOpened(); })("onClosing", function IgxDateRangePickerComponent_Template_div_onClosing_0_listener($event) { return ctx.handleClosing($event); })("onClosed", function IgxDateRangePickerComponent_Template_div_onClosed_0_listener() { return ctx.handleClosed(); });
        ɵngcc0.ɵɵelementStart(2, "igx-calendar", 2, 3);
        ɵngcc0.ɵɵlistener("keydown", function IgxDateRangePickerComponent_Template_igx_calendar_keydown_2_listener($event) { return ctx.onKeyDown($event); })("onSelection", function IgxDateRangePickerComponent_Template_igx_calendar_onSelection_2_listener($event) { return ctx.handleSelection($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵtemplate(5, IgxDateRangePickerComponent_ng_container_5_Template, 3, 1, "ng-container", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, IgxDateRangePickerComponent_ng_container_6_Template, 1, 0, "ng-container", 6);
        ɵngcc0.ɵɵtemplate(7, IgxDateRangePickerComponent_ng_template_7_Template, 2, 0, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(9, IgxDateRangePickerComponent_ng_template_9_Template, 4, 2, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(11, IgxDateRangePickerComponent_ng_template_11_Template, 2, 0, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(13, IgxDateRangePickerComponent_ng_template_13_Template, 1, 1, "ng-template", null, 10, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(15, IgxDateRangePickerComponent_ng_template_15_Template, 13, 10, "ng-template", null, 11, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r6 = ɵngcc0.ɵɵreference(10);
        const _r12 = ɵngcc0.ɵɵreference(16);
        ɵngcc0.ɵɵstyleProp("flex-basis", ctx.monthsViewNumber * 320 + "px")("width", ctx.monthsViewNumber * 320 + "px")("max-width", "90vw");
        ɵngcc0.ɵɵclassProp("igx-date-picker--dropdown", ctx.mode === "dropdown");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("weekStart", ctx.weekStart)("hideOutsideDays", ctx.hideOutsideDays)("monthsViewNumber", ctx.monthsViewNumber)("locale", ctx.locale);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.mode === "dialog");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasProjectedInputs ? _r6 : _r12);
    } }, directives: [IgxToggleDirective, IgxCalendarComponent, ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, IgxButtonDirective, IgxIconComponent, IgxInputGroupComponent, IgxInputDirective, IgxPrefixDirective], pipes: [DateRangePickerFormatPipe], encapsulation: 2 });
IgxDateRangePickerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: Injector }
];
IgxDateRangePickerComponent.propDecorators = {
    mode: [{ type: Input }],
    monthsViewNumber: [{ type: Input }],
    hideOutsideDays: [{ type: Input }],
    weekStart: [{ type: Input }],
    locale: [{ type: Input }],
    formatter: [{ type: Input }],
    doneButtonText: [{ type: Input }],
    overlaySettings: [{ type: Input }],
    displayFormat: [{ type: Input }],
    inputFormat: [{ type: Input }],
    minValue: [{ type: Input }],
    maxValue: [{ type: Input }],
    disabled: [{ type: Input }],
    placeholder: [{ type: Input }],
    rangeSelected: [{ type: Output }],
    onOpening: [{ type: Output }],
    onOpened: [{ type: Output }],
    onClosing: [{ type: Output }],
    onClosed: [{ type: Output }],
    cssClass: [{ type: HostBinding, args: ['class.igx-date-range-picker',] }],
    calendar: [{ type: ViewChild, args: [IgxCalendarComponent,] }],
    inputGroup: [{ type: ViewChild, args: [IgxInputGroupComponent,] }],
    inputDirective: [{ type: ViewChild, args: [IgxInputDirective,] }],
    toggleDirective: [{ type: ViewChild, args: [IgxToggleDirective,] }],
    toggleComponents: [{ type: ContentChildren, args: [IgxPickerToggleComponent, { descendants: true },] }],
    projectedInputs: [{ type: ContentChildren, args: [IgxDateRangeInputsBaseComponent,] }],
    label: [{ type: ContentChild, args: [IgxLabelDirective,] }],
    dateSeparatorTemplate: [{ type: ContentChild, args: [IgxDateRangeSeparatorDirective, { read: TemplateRef },] }],
    value: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateRangePickerComponent, [{
        type: Component,
        args: [{
                selector: 'igx-date-range-picker',
                template: "<div #toggle=\"toggle\" igxToggle class=\"igx-date-picker\" [class.igx-date-picker--dropdown]=\"mode === 'dropdown'\"\n    (onOpening)=\"handleOpening($event)\" (onOpened)=\"handleOpened()\"\n    (onClosing)=\"handleClosing($event)\" (onClosed)=\"handleClosed()\"\n    [style.flex-basis]=\"monthsViewNumber * 320 + 'px'\"\n    [style.width]=\"monthsViewNumber * 320 + 'px'\"\n    [style.max-width]=\"'90vw'\"\n>\n    <!-- TODO: use IgxCalendarContainerComponent instead -->\n    <igx-calendar #calendar (keydown)=\"onKeyDown($event)\" selection=\"range\" [weekStart]=\"weekStart\"\n        [hideOutsideDays]=\"hideOutsideDays\" [monthsViewNumber]=\"monthsViewNumber\" [locale]=\"locale\"\n        (onSelection)=\"handleSelection($event)\"></igx-calendar>\n    <div class=\"igx-date-range-picker-buttons\">\n        <ng-container *ngIf=\"mode === 'dialog'\">\n            <button igxButton type=\"button\" (click)=\"close()\">{{ doneButtonText }}</button>\n        </ng-container>\n    </div>\n</div>\n\n<ng-container *ngTemplateOutlet=\"this.hasProjectedInputs ? startEndTemplate : defTemplate\"></ng-container>\n\n<ng-template #singleTemplate>\n    <div (click)=\"open()\" class=\"content-wrap\">\n        <ng-content select=\"igx-date-single\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #startEndTemplate>\n    <ng-content select=\"igx-date-range-start\"></ng-content>\n    <div [className]=\"separatorClass\">\n        <ng-container *ngTemplateOutlet=\"dateSeparatorTemplate ? dateSeparatorTemplate : defDateSeparatorTemplate;\"></ng-container>\n    </div>\n    <ng-content select=\"igx-date-range-end\"></ng-content>\n</ng-template>\n\n<ng-template #defIcon>\n    <igx-icon>\n        calendar_today\n    </igx-icon>\n</ng-template>\n\n<ng-template #defDateSeparatorTemplate>{{ dateSeparator }}</ng-template>\n\n<ng-template #defTemplate>\n    <igx-input-group (click)=\"open()\">\n        <input #singleInput igxInput type=\"text\" readonly\n            [placeholder]=\"this.value ? '' : singleInputFormat\"\n            role=\"combobox\"\n            aria-haspopup=\"grid\"\n            [attr.aria-expanded]=\"!toggle.collapsed\"\n            [attr.aria-labelledby]=\"this.label?.id\"\n            [value]=\"this.value | dateRange: this.appliedFormat : this.locale : this.formatter\"\n        />\n\n        <igx-prefix *ngIf=\"!this.toggleComponents.length\">\n            <ng-container *ngTemplateOutlet=\"defIcon\"></ng-container>\n        </igx-prefix>\n\n        <ng-container ngProjectAs=\"[igxLabel]\">\n            <ng-content select=\"[igxLabel]\"></ng-content>\n        </ng-container>\n        <ng-container ngProjectAs=\"igx-prefix\">\n            <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n        </ng-container>\n        <ng-container ngProjectAs=\"igx-suffix\">\n            <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n        </ng-container>\n        <ng-container ngProjectAs=\"igx-hint\">\n            <ng-content select=\"igx-hint,[igxHint]\"></ng-content>\n        </ng-container>\n    </igx-input-group>\n</ng-template>\n",
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: IgxDateRangePickerComponent, multi: true },
                    { provide: NG_VALIDATORS, useExisting: IgxDateRangePickerComponent, multi: true }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }, { type: ɵngcc0.Injector }]; }, { mode: [{
            type: Input
        }], monthsViewNumber: [{
            type: Input
        }], weekStart: [{
            type: Input
        }], doneButtonText: [{
            type: Input
        }], disabled: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], rangeSelected: [{
            type: Output
        }], onOpening: [{
            type: Output
        }], onOpened: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-date-range-picker']
        }], locale: [{
            type: Input
        }], minValue: [{
            type: Input
        }], maxValue: [{
            type: Input
        }], value: [{
            type: Input
        }], inputFormat: [{
            type: Input
        }], hideOutsideDays: [{
            type: Input
        }], formatter: [{
            type: Input
        }], overlaySettings: [{
            type: Input
        }], displayFormat: [{
            type: Input
        }], calendar: [{
            type: ViewChild,
            args: [IgxCalendarComponent]
        }], inputGroup: [{
            type: ViewChild,
            args: [IgxInputGroupComponent]
        }], inputDirective: [{
            type: ViewChild,
            args: [IgxInputDirective]
        }], toggleDirective: [{
            type: ViewChild,
            args: [IgxToggleDirective]
        }], toggleComponents: [{
            type: ContentChildren,
            args: [IgxPickerToggleComponent, { descendants: true }]
        }], projectedInputs: [{
            type: ContentChildren,
            args: [IgxDateRangeInputsBaseComponent]
        }], label: [{
            type: ContentChild,
            args: [IgxLabelDirective]
        }], dateSeparatorTemplate: [{
            type: ContentChild,
            args: [IgxDateRangeSeparatorDirective, { read: TemplateRef }]
        }] }); })();

/**
 * @hidden
 */
class IgxDateRangePickerModule {
}
IgxDateRangePickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDateRangePickerModule });
IgxDateRangePickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDateRangePickerModule_Factory(t) { return new (t || IgxDateRangePickerModule)(); }, imports: [[
            CommonModule,
            IgxIconModule,
            IgxButtonModule,
            IgxToggleModule,
            IgxCalendarModule,
            IgxInputGroupModule,
            IgxDateTimeEditorModule
        ], IgxDateTimeEditorModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDateRangePickerModule, { declarations: function () { return [IgxDateRangePickerComponent, IgxDateRangeStartComponent, IgxDateRangeEndComponent, IgxDateRangeInputsBaseComponent, DateRangePickerFormatPipe, IgxPickerToggleComponent, IgxDateRangeSeparatorDirective]; }, imports: function () { return [CommonModule, IgxIconModule, IgxButtonModule, IgxToggleModule, IgxCalendarModule, IgxInputGroupModule, IgxDateTimeEditorModule]; }, exports: function () { return [IgxDateRangePickerComponent, IgxDateRangeStartComponent, IgxDateRangeEndComponent, IgxDateRangeSeparatorDirective, IgxDateTimeEditorModule, IgxPickerToggleComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateRangePickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxDateRangePickerComponent,
                    IgxDateRangeStartComponent,
                    IgxDateRangeEndComponent,
                    IgxDateRangeInputsBaseComponent,
                    DateRangePickerFormatPipe,
                    IgxPickerToggleComponent,
                    IgxDateRangeSeparatorDirective
                ],
                imports: [
                    CommonModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxToggleModule,
                    IgxCalendarModule,
                    IgxInputGroupModule,
                    IgxDateTimeEditorModule
                ],
                exports: [
                    IgxDateRangePickerComponent,
                    IgxDateRangeStartComponent,
                    IgxDateRangeEndComponent,
                    IgxDateRangeSeparatorDirective,
                    IgxDateTimeEditorModule,
                    IgxPickerToggleComponent
                ]
            }]
    }], null, null); })();

/*
 * Public API Surface of igniteui-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AbsolutePosition, AbsoluteScrollStrategy, AutoPositionStrategy, BaseFilteringStrategy, BaseProgressDirective, BlockScrollStrategy, ButtonGroupAlignment, Calendar, CalendarHammerConfig, CalendarSelection, CalendarView, CarouselAnimationType, CarouselHammerConfig, CarouselIndicatorsOrientation, CloseScrollStrategy, ColumnDisplayOrder, ColumnPinningPosition, ConnectedPositioningStrategy, ContainerPositionStrategy, CsvFileTypes, DataType, DataUtil, DatePart, DateRangePickerFormatPipe, DateRangeType, DefaultSortingStrategy, DisplayDensity, DisplayDensityBase, DisplayDensityToken, DragDirection, ElasticPositionStrategy, FilterListItem, FilterMode, FilteringExpressionsTree, FilteringExpressionsTreeType, FilteringLogic, FilteringStrategy, GlobalPositionStrategy, GridBaseAPIService, GridPagingMode, GridSelectionMode, GridSummaryCalculationMode, GridSummaryPosition, GroupedRecords, HorizontalAlignment, IGX_CHECKBOX_REQUIRED_VALIDATOR, IGX_INPUT_GROUP_TYPE, IGX_SWITCH_REQUIRED_VALIDATOR, IgxActionStripComponent, IgxActionStripModule, IgxAppendDropStrategy, IgxAutocompleteDirective, IgxAutocompleteModule, IgxAvatarComponent, IgxAvatarModule, IgxAvatarSize, IgxAvatarType, IgxBadgeComponent, IgxBadgeModule, IgxBadgeType, IgxBannerComponent, IgxBannerModule, IgxBaseExporter, IgxBaseTransactionService, IgxBooleanFilteringOperand, IgxBottomNavComponent, IgxBottomNavModule, IgxButtonDirective, IgxButtonGroupComponent, IgxButtonGroupModule, IgxButtonModule, IgxCalendarBaseDirective, IgxCalendarComponent, IgxCalendarHeaderTemplateDirective, IgxCalendarModule, IgxCalendarMonthDirective, IgxCalendarScrollMonthDirective, IgxCalendarSubheaderTemplateDirective, IgxCalendarYearDirective, IgxCardActionsComponent, IgxCardActionsLayout, IgxCardComponent, IgxCardContentDirective, IgxCardFooterDirective, IgxCardHeaderComponent, IgxCardHeaderSubtitleDirective, IgxCardHeaderTitleDirective, IgxCardMediaDirective, IgxCardModule, IgxCardThumbnailDirective, IgxCardType, IgxCarouselComponent, IgxCarouselModule, IgxCellEditorTemplateDirective, IgxCellFooterTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellTemplateDirective, IgxCheckboxComponent, IgxCheckboxModule, IgxCheckboxRequiredDirective, IgxChipComponent, IgxChipsAreaComponent, IgxChipsModule, IgxCircularProgressBarComponent, IgxCollapsibleIndicatorTemplateDirective, IgxColumnActionsBaseDirective, IgxColumnActionsComponent, IgxColumnActionsModule, IgxColumnComponent, IgxColumnGroupComponent, IgxColumnHidingComponent, IgxColumnHidingModule, IgxColumnLayoutComponent, IgxColumnPinningComponent, IgxComboComponent, IgxComboModule, IgxComboState, IgxCsvExporterOptions, IgxCsvExporterService, IgxDataLoadingTemplateDirective, IgxDataRecordSorting, IgxDateFilteringOperand, IgxDatePickerComponent, IgxDatePickerModule, IgxDateRangeEndComponent, IgxDateRangeInputsBaseComponent, IgxDateRangePickerComponent, IgxDateRangePickerModule, IgxDateRangeSeparatorDirective, IgxDateRangeStartComponent, IgxDateSummaryOperand, IgxDateTimeEditorDirective, IgxDateTimeEditorModule, IgxDaysViewComponent, IgxDefaultDropStrategy, IgxDialogComponent, IgxDialogModule, IgxDisplayDensityModule, IgxDividerDirective, IgxDividerModule, IgxDividerType, IgxDragDirective, IgxDragDropModule, IgxDragHandleDirective, IgxDragIgnoreDirective, IgxDragLocation, IgxDropDirective, IgxDropDownBaseDirective, IgxDropDownComponent, IgxDropDownGroupComponent, IgxDropDownItemBaseDirective, IgxDropDownItemComponent, IgxDropDownItemNavigationDirective, IgxDropDownModule, IgxEmptyListTemplateDirective, IgxExcelExporterOptions, IgxExcelExporterService, IgxExcelStyleClearFiltersComponent, IgxExcelStyleColumnOperationsTemplateDirective, IgxExcelStyleConditionalFilterComponent, IgxExcelStyleFilterOperationsTemplateDirective, IgxExcelStyleHeaderComponent, IgxExcelStyleHidingComponent, IgxExcelStyleLoadingValuesTemplateDirective, IgxExcelStyleMovingComponent, IgxExcelStylePinningComponent, IgxExcelStyleSearchComponent, IgxExcelStyleSelectingComponent, IgxExcelStyleSortingComponent, IgxExpansionPanelBodyComponent, IgxExpansionPanelComponent, IgxExpansionPanelHeaderComponent, IgxExpansionPanelModule, IgxExporterOptionsBase, IgxFilterCellTemplateDirective, IgxFilterDirective, IgxFilterModule, IgxFilterOptions, IgxFilterPipe, IgxFilteringOperand, IgxFlexDirective, IgxFocusDirective, IgxFocusModule, IgxForOfContext, IgxForOfDirective, IgxForOfModule, IgxGridAPIService, IgxGridActionsBaseDirective, IgxGridBaseDirective, IgxGridBodyDirective, IgxGridCellComponent, IgxGridCommonModule, IgxGridComponent, IgxGridDetailTemplateDirective, IgxGridEditingActionsComponent, IgxGridExcelStyleFilteringComponent, IgxGridExpandableCellComponent, IgxGridForOfDirective, IgxGridGroupByRowComponent, IgxGridHierarchicalPagingPipe, IgxGridHierarchicalPipe, IgxGridModule, IgxGridPinningActionsComponent, IgxGridRowComponent, IgxGridStateDirective, IgxGridStateModule, IgxGridTransaction, IgxGroupAreaDropDirective, IgxGroupByRowTemplateDirective, IgxGrouping, IgxHeaderCollapseIndicatorDirective, IgxHeaderExpandIndicatorDirective, IgxHierarchicalGridAPIService, IgxHierarchicalGridBaseDirective, IgxHierarchicalGridCellComponent, IgxHierarchicalGridComponent, IgxHierarchicalGridModule, IgxHierarchicalRowComponent, IgxHierarchicalTransactionService, IgxHierarchicalTransactionServiceFactory, IgxHintDirective, IgxIconComponent, IgxIconModule, IgxIconService, IgxInputDirective, IgxInputGroupComponent, IgxInputGroupModule, IgxInputState, IgxInsertDropStrategy, IgxLabelDirective, IgxLayoutDirective, IgxLayoutModule, IgxLeftButtonStyleDirective, IgxLinearProgressBarComponent, IgxListActionDirective, IgxListBaseDirective, IgxListComponent, IgxListItemComponent, IgxListItemLeftPanningTemplateDirective, IgxListItemRightPanningTemplateDirective, IgxListLineDirective, IgxListLineSubTitleDirective, IgxListLineTitleDirective, IgxListModule, IgxListPanState, IgxListThumbnailDirective, IgxMaskDirective, IgxMaskModule, IgxMonthPickerBaseDirective, IgxMonthPickerComponent, IgxMonthsViewComponent, IgxNavDrawerItemDirective, IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective, IgxNavbarActionDirective, IgxNavbarComponent, IgxNavbarModule, IgxNavbarTitleDirective, IgxNavigationCloseDirective, IgxNavigationDrawerComponent, IgxNavigationDrawerModule, IgxNavigationModule, IgxNavigationService, IgxNavigationToggleDirective, IgxNumberFilteringOperand, IgxNumberSummaryOperand, IgxOverlayOutletDirective, IgxOverlayService, IgxPaginatorComponent, IgxPaginatorModule, IgxPickerToggleComponent, IgxPrefixDirective, IgxPrefixModule, IgxPrependDropStrategy, IgxProgressBarModule, IgxProgressType, IgxRadioComponent, IgxRadioGroupDirective, IgxRadioModule, IgxRightButtonStyleDirective, IgxRippleDirective, IgxRippleModule, IgxRowCollapsedIndicatorDirective, IgxRowDirective, IgxRowExpandedIndicatorDirective, IgxRowIslandAPIService, IgxRowIslandComponent, IgxSelectComponent, IgxSelectFooterDirective, IgxSelectGroupComponent, IgxSelectHeaderDirective, IgxSelectItemComponent, IgxSelectModule, IgxSelectToggleIconDirective, IgxSliderComponent, IgxSliderModule, IgxSliderType, IgxSnackbarComponent, IgxSnackbarModule, IgxSorting, IgxSplitterComponent, IgxSplitterModule, IgxSplitterPaneComponent, IgxStringFilteringOperand, IgxSuffixDirective, IgxSuffixModule, IgxSummaryOperand, IgxSwitchComponent, IgxSwitchModule, IgxSwitchRequiredDirective, IgxTabComponent, IgxTabItemComponent, IgxTabItemTemplateDirective, IgxTabPanelComponent, IgxTabTemplateDirective, IgxTabsComponent, IgxTabsGroupComponent, IgxTabsModule, IgxTabsType, IgxTextAlign, IgxTextHighlightDirective, IgxTextHighlightModule, IgxTextSelectionDirective, IgxTextSelectionModule, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, IgxTickLabelTemplateDirective, IgxTimePickerComponent, IgxTimePickerModule, IgxToastComponent, IgxToastModule, IgxToastPosition, IgxToggleActionDirective, IgxToggleDirective, IgxToggleModule, IgxTooltipDirective, IgxTooltipModule, IgxTooltipTargetDirective, IgxTransactionService, IgxTreeGridAPIService, IgxTreeGridCellComponent, IgxTreeGridComponent, IgxTreeGridModule, IgxTreeGridRowComponent, IgxYearsViewComponent, InteractionMode, LabelPosition, NoOpScrollStrategy, NoopFilteringStrategy, NoopSortingStrategy, PagingError, Point, PredefinedFormatOptions, RadioLabelPosition, RelativePosition, RelativePositionStrategy, RowEditPositionStrategy, RowPinningPosition, ScrollMonth, ScrollStrategy, SliderHandle, SortingDirection, SplitterType, SwitchLabelPosition, TickLabelsOrientation, TicksOrientation, TimePickerHammerConfig, TransactionEventOrigin, TransactionType, VerticalAlignment, WEEKDAYS, blink, changei18n, fadeIn, fadeOut, filteringStateDefaults, flipBottom, flipHorBck, flipHorFwd, flipLeft, flipRight, flipTop, flipVerBck, flipVerFwd, getCurrentResourceStrings, getTypeNameForDebugging, growVerIn, growVerOut, heartbeat, hierarchicalTransactionServiceFactory, isDateInRanges, isLeap, monthRange, pulsateBck, pulsateFwd, range, rotateInBl, rotateInBottom, rotateInBr, rotateInCenter, rotateInDiagonal1, rotateInDiagonal2, rotateInHor, rotateInLeft, rotateInRight, rotateInTl, rotateInTop, rotateInTr, rotateInVer, rotateOutBl, rotateOutBottom, rotateOutBr, rotateOutCenter, rotateOutDiagonal1, rotateOutDiagonal2, rotateOutHor, rotateOutLeft, rotateOutRight, rotateOutTl, rotateOutTop, rotateOutTr, rotateOutVer, scaleInBl, scaleInBottom, scaleInBr, scaleInCenter, scaleInHorCenter, scaleInHorLeft, scaleInHorRight, scaleInLeft, scaleInRight, scaleInTl, scaleInTop, scaleInTr, scaleInVerBottom, scaleInVerCenter, scaleInVerTop, scaleOutBl, scaleOutBottom, scaleOutBr, scaleOutCenter, scaleOutHorCenter, scaleOutHorLeft, scaleOutHorRight, scaleOutLeft, scaleOutRight, scaleOutTl, scaleOutTop, scaleOutTr, scaleOutVerBottom, scaleOutVerCenter, scaleOutVerTop, shakeBl, shakeBottom, shakeBr, shakeCenter, shakeHor, shakeLeft, shakeRight, shakeTl, shakeTop, shakeTr, shakeVer, slideInBl, slideInBottom, slideInBr, slideInLeft, slideInRight, slideInTl, slideInTop, slideInTr, slideOutBl, slideOutBottom, slideOutBr, slideOutLeft, slideOutRight, slideOutTl, slideOutTop, slideOutTr, swingInBottomBck, swingInBottomFwd, swingInLeftBck, swingInLeftFwd, swingInRightBck, swingInRightFwd, swingInTopBck, swingInTopFwd, swingOutBottomBck, swingOutBottomFwd, swingOutLeftBck, swingOutLefttFwd, swingOutRightBck, swingOutRightFwd, swingOutTopBck, swingOutTopFwd, toPercent, valueInRange, weekDay, ɵ0$1 as ɵ0, ɵ1$1 as ɵ1, ɵ2, IgxActionStripMenuItemDirective as ɵa, IGX_DROPDOWN_BASE as ɵb, getHierarchy as ɵba, IgxGridActionButtonComponent as ɵbb, IgxBannerActionsDirective as ɵbc, IgxExpansionPanelTitleDirective as ɵbd, IgxExpansionPanelDescriptionDirective as ɵbe, IgxExpansionPanelIconDirective as ɵbf, IgxDaysViewNavigationService as ɵbg, IgxDayItemComponent as ɵbh, IgxMonthViewSlotsCalendar as ɵbi, IgxGetViewDateCalendar as ɵbj, IgxCarouselIndicatorDirective as ɵbk, IgxCarouselNextButtonDirective as ɵbl, IgxCarouselPrevButtonDirective as ɵbm, IgxSlideComponent as ɵbn, IgxComboAPIService as ɵbo, IGX_COMBO_COMPONENT as ɵbp, IgxComboDropDownComponent as ɵbr, IgxComboItemComponent as ɵbs, IgxComboHeaderDirective as ɵbt, IgxComboFooterDirective as ɵbu, IgxComboItemDirective as ɵbv, IgxComboEmptyDirective as ɵbw, IgxComboHeaderItemDirective as ɵbx, IgxComboAddItemDirective as ɵby, IgxComboToggleIconDirective as ɵbz, IgxComboClearIconDirective as ɵca, IgxComboFilteringPipe as ɵcb, IgxComboGroupingPipe as ɵcc, IgxComboAddItemComponent as ɵcd, IgxDatePickerTemplateDirective as ɵce, IgxDatePickerActionsDirective as ɵcf, IgxCalendarContainerComponent as ɵcg, DatePickerDisplayValuePipe as ɵch, DatePickerInputValuePipe as ɵci, IGX_DATE_PICKER_COMPONENT as ɵcj, IgxDialogTitleDirective as ɵcl, IgxDialogActionsDirective as ɵcm, ColumnChooserBaseDirective as ɵcn, ItemPropertyValueChangedDirective as ɵco, ColumnChooserItemBaseDirective as ɵcp, IgxGridSharedModules as ɵcq, IgxTemplateOutletDirective as ɵcr, IgxTemplateOutletModule as ɵcs, IgxProcessBarTextTemplateDirective as ɵct, IgxProgressBarGradientDirective as ɵcu, DIR_DOCUMENT as ɵcv, DIR_DOCUMENT_FACTORY as ɵcw, IgxDirectionality as ɵcx, IgxSelectItemNavigationDirective as ɵcy, WatchChanges as ɵcz, IgxGridCRUDService as ɵd, WatchColumnChanges as ɵda, notifyChanges as ɵdb, IgxGridColumnResizerComponent as ɵdc, IgxColumnResizingService as ɵdd, IgxColumnResizerDirective as ɵde, IgxGridHeaderGroupComponent as ɵdf, IgxGridHeaderComponent as ɵdg, IgxGridFilteringCellComponent as ɵdh, IgxFilteringService as ɵdi, IgxSummaryRowComponent as ɵdj, IgxSummaryCellComponent as ɵdk, IgxGridToolbarCustomContentDirective as ɵdl, IgxRowSelectorDirective as ɵdm, IgxHeadSelectorDirective as ɵdn, IgxRowDragDirective as ɵdo, IgxDragIndicatorIconDirective as ɵdp, IgxRowDragGhostDirective as ɵdq, IgxRowDragModule as ɵdr, IgxGridFilteringRowComponent as ɵds, IgxRowEditTemplateDirective as ɵdt, IgxRowEditTextDirective as ɵdu, IgxRowEditActionsDirective as ɵdv, IgxRowEditTabStopDirective as ɵdw, IgxGridToolbarComponent as ɵdx, IgxColumnHidingDirective as ɵdy, IgxColumnPinningDirective as ɵdz, IgxGridSelectionService as ɵe, IgxGridNavigationService as ɵea, IgxGridSummaryService as ɵeb, IgxExcelStyleCustomDialogComponent as ɵec, IgxExcelStyleDefaultExpressionComponent as ɵed, IgxExcelStyleDateExpressionComponent as ɵee, HammerGesturesManager as ɵef, ConnectedPositioningStrategy as ɵeg, IgxGridFooterComponent as ɵeh, IgxAdvancedFilteringDialogComponent as ɵei, IgxColumnPinningModule as ɵej, IgxColumnPinningItemDirective as ɵek, IgxGridPipesModule as ɵel, IgxGridCellStyleClassesPipe as ɵem, IgxGridCellStylesPipe as ɵen, IgxGridNotGroupedPipe as ɵeo, IgxGridTopLevelColumns as ɵep, IgxGridFilterConditionPipe as ɵeq, IgxGridTransactionPipe as ɵer, IgxGridPaginatorOptionsPipe as ɵes, IgxHasVisibleColumnsPipe as ɵet, IgxGridRowPinningPipe as ɵeu, IgxColumnActionEnabledPipe as ɵev, IgxFilterActionColumnsPipe as ɵew, IgxSortActionColumnsPipe as ɵex, IgxGridDataMapperPipe as ɵey, IgxStringReplacePipe as ɵez, IgxColumnHidingItemDirective as ɵf, IgxGridTransactionStatePipe as ɵfa, IgxColumnFormatterPipe as ɵfb, IgxGridAddRowPipe as ɵfc, IgxGridColumnModule as ɵfd, IgxGridHeadersModule as ɵfe, SortingIndexPipe as ɵff, IgxGridFilteringModule as ɵfg, IgxColumnMovingModule as ɵfh, IgxColumnMovingDropDirective as ɵfi, IgxColumnMovingService as ɵfj, IgxColumnMovingDragDirective as ɵfk, IgxGridResizingModule as ɵfl, IgxResizeHandleDirective as ɵfm, IgxGridExcelStyleFilteringModule as ɵfn, IgxGridSelectionModule as ɵfo, IgxGridDragSelectDirective as ɵfp, IgxGridSummaryModule as ɵfq, IgxSummaryDataPipe as ɵfr, IgxGridToolbarModule as ɵfs, IgxGridSortingPipe as ɵft, IgxGridGroupingPipe as ɵfu, IgxGridPagingPipe as ɵfv, IgxGridFilteringPipe as ɵfw, IgxGridSummaryPipe as ɵfx, IgxGridDetailsPipe as ɵfy, IgxRowLoadingIndicatorTemplateDirective as ɵfz, IgxTreeGridHierarchizingPipe as ɵga, IgxTreeGridFlatteningPipe as ɵgb, IgxTreeGridSortingPipe as ɵgc, IgxTreeGridPagingPipe as ɵgd, IgxTreeGridTransactionPipe as ɵge, IgxTreeGridNormalizeRecordsPipe as ɵgf, IgxTreeGridFilteringPipe as ɵgg, IgxTreeGridSummaryPipe as ɵgh, IgxHierarchicalGridNavigationService as ɵgi, IgxChildGridRowComponent as ɵgj, IgxSliderThumbComponent as ɵgk, IgxThumbLabelComponent as ɵgl, IgxTicksComponent as ɵgm, IgxTickLabelsPipe as ɵgn, IgxTabsBase as ɵgo, IgxTabItemBase as ɵgp, IgxTabsGroupBase as ɵgq, IGX_TIME_PICKER_COMPONENT as ɵgr, IgxItemListDirective as ɵgt, IgxHourItemDirective as ɵgu, IgxMinuteItemDirective as ɵgv, IgxSecondsItemDirective as ɵgw, IgxAmPmItemDirective as ɵgx, IgxTimePickerTemplateDirective as ɵgy, IgxTimePickerActionsDirective as ɵgz, IGX_EXPANSION_PANEL_COMPONENT as ɵh, TimeDisplayFormatPipe as ɵha, TimeInputFormatPipe as ɵhb, IgxSplitBarComponent as ɵhc, PlatformUtil as ɵi, EaseIn as ɵj, EaseOut as ɵk, IgxInputGroupBase as ɵl, DeprecateClass as ɵm, DeprecateMethod as ɵn, DeprecateProperty as ɵo, IgxForOfSyncService as ɵp, IgxForOfScrollSyncService as ɵq, IgxSelectionAPIService as ɵr, DisplayContainerComponent as ɵs, VirtualHelperComponent as ɵt, VirtualHelperBaseDirective as ɵu, HVirtualHelperComponent as ɵv, IgxScrollInertiaDirective as ɵw, IgxScrollInertiaModule as ɵx, MaskParsingService as ɵy, isHierarchyMatch as ɵz };

//# sourceMappingURL=igniteui-angular.js.map