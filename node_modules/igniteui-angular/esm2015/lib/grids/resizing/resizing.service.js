import { Injectable, NgZone } from '@angular/core';
/**
 * @hidden
 * @internal
 */
import * as ɵngcc0 from '@angular/core';
export class IgxColumnResizingService {
    constructor(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = null;
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    /**
     * @hidden
     */
    get resizerHeight() {
        let height = this.column.grid.getVisibleContentHeight();
        // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
        let columnHeightMultiplier = 1;
        if (this.column.columnLayoutChild) {
            columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
        }
        if (this.column.level !== 0) {
            height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
        }
        return height;
    }
    /**
     * Returns the minimal possible width to which the column can be resized.
     */
    get restrictResizeMin() {
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const minWidth = this.column.minWidthPx < actualWidth ? this.column.minWidthPx : actualWidth;
        return actualWidth - minWidth;
    }
    /**
     * Returns the maximal possible width to which the column can be resized.
     */
    get restrictResizeMax() {
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const maxWidth = this.column.maxWidthPx;
        if (this.column.maxWidth) {
            return maxWidth - actualWidth;
        }
        else {
            return Number.MAX_SAFE_INTEGER;
        }
    }
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     */
    autosizeColumnOnDblClick() {
        const currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const isPercentageWidth = this.column.width && typeof this.column.width === 'string' && this.column.width.indexOf('%') !== -1;
        let size = this.column.getAutoSize();
        const maxWidth = isPercentageWidth ? this.column.maxWidthPercent : this.column.maxWidthPx;
        const minWidth = isPercentageWidth ? this.column.minWidthPercent : this.column.minWidthPx;
        if (this.column.maxWidth && (parseFloat(size) > maxWidth)) {
            size = isPercentageWidth ? maxWidth + '%' : maxWidth + 'px';
        }
        else if (parseFloat(size) < minWidth) {
            size = isPercentageWidth ? minWidth + '%' : minWidth + 'px';
        }
        this.column.width = size;
        this.zone.run(() => { });
        this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    }
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     */
    resizeColumn(event) {
        this.showResizer = false;
        const diff = event.clientX - this.startResizePos;
        const colWidth = this.column.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        let currentColWidth = parseFloat(colWidth);
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) ? parseFloat(actualWidth) : currentColWidth;
        if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
        }
        else if (isPercentageWidth) {
            this._handlePercentageResize(diff, this.column);
        }
        else {
            this._handlePixelResize(diff, this.column);
        }
        this.zone.run(() => { });
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: isPercentageWidth ? currentColWidth + '%' : currentColWidth + 'px',
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    }
    _handlePixelResize(diff, column) {
        const currentColWidth = parseFloat(column.width);
        const colMinWidth = column.minWidthPx;
        const colMaxWidth = column.maxWidthPx;
        if (currentColWidth + diff < colMinWidth) {
            column.width = colMinWidth + 'px';
        }
        else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
            column.width = colMaxWidth + 'px';
        }
        else {
            column.width = (currentColWidth + diff) + 'px';
        }
    }
    _handlePercentageResize(diff, column) {
        const currentPercentWidth = parseFloat(column.width);
        const gridAvailableSize = column.grid.calcWidth;
        const diffPercentage = (diff / gridAvailableSize) * 100;
        const colMinWidth = column.minWidthPercent;
        const colMaxWidth = column.maxWidthPercent;
        if (currentPercentWidth + diffPercentage < colMinWidth) {
            column.width = colMinWidth + '%';
        }
        else if (colMaxWidth && (currentPercentWidth + diffPercentage > colMaxWidth)) {
            column.width = colMaxWidth + '%';
        }
        else {
            column.width = (currentPercentWidth + diffPercentage) + '%';
        }
    }
    getColMinWidth(column) {
        let currentColWidth = parseFloat(column.width);
        const actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        const actualMinWidth = parseFloat(column.minWidth);
        return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;
    }
    resizeColumnLayoutFor(column, diff) {
        const relativeColumns = column.getResizableColUnderEnd();
        const combinedSpan = relativeColumns.reduce((acc, col) => acc + col.spanUsed, 0);
        // Resize first those who might reach min/max width
        let columnsToResize = [...relativeColumns];
        let updatedDiff = diff;
        let updatedCombinedSpan = combinedSpan;
        let setMinMaxCols = false;
        do {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            let newCombinedSpan = updatedCombinedSpan;
            const newColsToResize = [];
            columnsToResize.forEach((col) => {
                const currentResizeWidth = parseFloat(col.target.calcWidth);
                const resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                const colWidth = col.target.width;
                const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
                const minWidth = col.target.minWidthPx;
                const maxWidth = col.target.maxWidthPx;
                if (currentResizeWidth + resizeScaled < minWidth) {
                    col.target.width = isPercentageWidth ? col.target.minWidthPercent + '%' : minWidth + 'px';
                    updatedDiff += (currentResizeWidth - minWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                    col.target.width = isPercentageWidth ? col.target.maxWidthPercent + '%' : col.target.maxWidthPx + 'px';
                    updatedDiff -= (maxWidth - currentResizeWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else {
                    // Save new ones that can be resized
                    newColsToResize.push(col);
                }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
        } while (setMinMaxCols);
        // Those left that don't reach min/max size resize them normally.
        columnsToResize.forEach((col) => {
            const resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
            const colWidth = col.target.width;
            const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
            if (isPercentageWidth) {
                this._handlePercentageResize(resizeScaled, col.target);
            }
            else {
                this._handlePixelResize(resizeScaled, col.target);
            }
        });
    }
}
IgxColumnResizingService.ɵfac = function IgxColumnResizingService_Factory(t) { return new (t || IgxColumnResizingService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
IgxColumnResizingService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxColumnResizingService, factory: IgxColumnResizingService.ɵfac });
IgxColumnResizingService.ctorParameters = () => [
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnResizingService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXppbmcuc2VydmljZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL3Jlc2l6aW5nL3Jlc2l6aW5nLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHbkQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxNQUFNLE9BQU8sd0JBQXdCO0FBQ3JDLElBc0JJLFlBQW9CLElBQVk7QUFBSSxRQUFoQixTQUFJLEdBQUosSUFBSSxDQUFRO0FBQUMsUUFiakM7QUFDSjtBQUNJLFdBQUc7QUFDUCxRQUFXLGlCQUFZLEdBQVcsSUFBSSxDQUFDO0FBQ3ZDLFFBQUk7QUFDSjtBQUNJLFdBQUc7QUFDUCxRQUFXLGdCQUFXLEdBQUcsS0FBSyxDQUFDO0FBQy9CLElBS3dDLENBQUM7QUFDekMsSUFDSTtBQUNKO0FBQ0EsT0FBTztBQUNQLElBQUksSUFBSSxhQUFhO0FBQUssUUFDbEIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztBQUNoRSxRQUNRLG9IQUFvSDtBQUM1SCxRQUFRLElBQUksc0JBQXNCLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZDLFFBQVEsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFpQixFQUFFO0FBQzNDLFlBQVksc0JBQXNCLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZHLFNBQVM7QUFDVCxRQUNRLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEtBQUssQ0FBQyxFQUFFO0FBQ3JDLFlBQVksTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLFdBQVcs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QU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO0FBQ3hDLFlBQVksTUFBTSxZQUFZLEdBQUcsQ0FBQyxXQUFXLEdBQUcsbUJBQW1CLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQztBQUNqRyxZQUFZLE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO0FBQzlDLFlBQVksTUFBTSxpQkFBaUIsR0FBRyxRQUFRLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDL0csWUFBWSxJQUFJLGlCQUFpQixFQUFFO0FBQ25DLGdCQUFnQixJQUFJLENBQUMsdUJBQXVCLENBQUMsWUFBWSxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN2RSxhQUFhO0FBQUMsaUJBQUs7QUFDbkIsZ0JBQWdCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2xFLGFBQWE7QUFDYixRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ1gsSUFBSSxDQUFDO0FBQ0w7b0RBak9DLFVBQVU7d0lBQ1Q7QUFBQztBQUdDLFlBWGlCLE1BQU07QUFBRzs7O3VFQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneENvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4uL2NvbHVtbnMvY29sdW1uLmNvbXBvbmVudCc7XG5cbi8qKlxuICogQGhpZGRlblxuICogQGludGVybmFsXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBJZ3hDb2x1bW5SZXNpemluZ1NlcnZpY2Uge1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzdGFydFJlc2l6ZVBvczogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgY29sdW1uIGlzIGN1cnJlbnRseSBiZWluZyByZXNpemVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBpc0NvbHVtblJlc2l6aW5nOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVzaXplQ3Vyc29yOiBzdHJpbmcgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2hvd1Jlc2l6ZXIgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgY29sdW1uIGJlaW5nIHJlc2l6ZWQuXG4gICAgICovXG4gICAgcHVibGljIGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB6b25lOiBOZ1pvbmUpIHsgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCByZXNpemVySGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmNvbHVtbi5ncmlkLmdldFZpc2libGVDb250ZW50SGVpZ2h0KCk7XG5cbiAgICAgICAgLy8gQ29sdW1uIGhlaWdodCBtdWx0aXBsaWVyIGluIGNhc2UgdGhlcmUgYXJlIENvbHVtbiBMYXlvdXRzLiBUaGUgcmVzaXplciBoZWlnaHQgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCByb3dTdGFydC5cbiAgICAgICAgbGV0IGNvbHVtbkhlaWdodE11bHRpcGxpZXIgPSAxO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW4uY29sdW1uTGF5b3V0Q2hpbGQpIHtcbiAgICAgICAgICAgIGNvbHVtbkhlaWdodE11bHRpcGxpZXIgPSB0aGlzLmNvbHVtbi5ncmlkLm11bHRpUm93TGF5b3V0Um93U2l6ZSAtIHRoaXMuY29sdW1uLnJvd1N0YXJ0ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5sZXZlbCAhPT0gMCkge1xuICAgICAgICAgICAgaGVpZ2h0IC09IHRoaXMuY29sdW1uLnRvcExldmVsUGFyZW50LmhlYWRlckdyb3VwLmhlaWdodCAtIHRoaXMuY29sdW1uLmhlYWRlckdyb3VwLmhlaWdodCAqIGNvbHVtbkhlaWdodE11bHRpcGxpZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1pbmltYWwgcG9zc2libGUgd2lkdGggdG8gd2hpY2ggdGhlIGNvbHVtbiBjYW4gYmUgcmVzaXplZC5cbiAgICAgKi9cbiAgICBnZXQgcmVzdHJpY3RSZXNpemVNaW4oKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgYWN0dWFsV2lkdGggPSB0aGlzLmNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSB0aGlzLmNvbHVtbi5taW5XaWR0aFB4IDwgYWN0dWFsV2lkdGggPyB0aGlzLmNvbHVtbi5taW5XaWR0aFB4IDogYWN0dWFsV2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIGFjdHVhbFdpZHRoIC0gbWluV2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF4aW1hbCBwb3NzaWJsZSB3aWR0aCB0byB3aGljaCB0aGUgY29sdW1uIGNhbiBiZSByZXNpemVkLlxuICAgICAqL1xuICAgIGdldCByZXN0cmljdFJlc2l6ZU1heCgpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBhY3R1YWxXaWR0aCA9IHRoaXMuY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IHRoaXMuY29sdW1uLm1heFdpZHRoUHg7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5tYXhXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG1heFdpZHRoIC0gYWN0dWFsV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdXRvc2l6ZXMgdGhlIGNvbHVtbiB0byB0aGUgbG9uZ2VzdCBjdXJyZW50bHkgdmlzaWJsZSBjZWxsIHZhbHVlLCBpbmNsdWRpbmcgdGhlIGhlYWRlciBjZWxsLlxuICAgICAqIElmIHRoZSBjb2x1bW4gaGFzIGEgcHJlZGlmaW5lZCBtYXhXaWR0aCBhbmQgdGhlIGF1dG9zaXplZCBjb2x1bW4gd2lkdGggd2lsbCBiZWNvbWUgYmlnZ2VyIHRoYW4gaXQsXG4gICAgICogdGhlbiB0aGUgY29sdW1uIGlzIHNpemVkIHRvIGl0cyBtYXhXaWR0aC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXV0b3NpemVDb2x1bW5PbkRibENsaWNrKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q29sV2lkdGggPSB0aGlzLmNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgY29uc3QgaXNQZXJjZW50YWdlV2lkdGggPSB0aGlzLmNvbHVtbi53aWR0aCAmJiB0eXBlb2YgdGhpcy5jb2x1bW4ud2lkdGggPT09ICdzdHJpbmcnICYmIHRoaXMuY29sdW1uLndpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTE7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5jb2x1bW4uZ2V0QXV0b1NpemUoKTtcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSBpc1BlcmNlbnRhZ2VXaWR0aCA/IHRoaXMuY29sdW1uLm1heFdpZHRoUGVyY2VudCA6IHRoaXMuY29sdW1uLm1heFdpZHRoUHg7XG4gICAgICAgIGNvbnN0IG1pbldpZHRoID0gaXNQZXJjZW50YWdlV2lkdGggPyB0aGlzLmNvbHVtbi5taW5XaWR0aFBlcmNlbnQgOiB0aGlzLmNvbHVtbi5taW5XaWR0aFB4O1xuICAgICAgICBpZiAodGhpcy5jb2x1bW4ubWF4V2lkdGggJiYgKHBhcnNlRmxvYXQoc2l6ZSkgPiBtYXhXaWR0aCkpIHtcbiAgICAgICAgICAgIHNpemUgPSBpc1BlcmNlbnRhZ2VXaWR0aCA/IG1heFdpZHRoICsgJyUnIDogbWF4V2lkdGggKyAncHgnO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnNlRmxvYXQoc2l6ZSkgPCBtaW5XaWR0aCkge1xuICAgICAgICAgICAgc2l6ZSA9IGlzUGVyY2VudGFnZVdpZHRoID8gbWluV2lkdGggKyAnJScgOiBtaW5XaWR0aCArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSBzaXplO1xuXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge30pO1xuXG4gICAgICAgIHRoaXMuY29sdW1uLmdyaWQub25Db2x1bW5SZXNpemVkLmVtaXQoe1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgIHByZXZXaWR0aDogY3VycmVudENvbFdpZHRoLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBuZXdXaWR0aDogdGhpcy5jb2x1bW4ud2lkdGhcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgY29sdW1uIHJlZ2FyaWRuZyB0byB0aGUgY29sdW1uIG1pbldpZHRoIGFuZCBtYXhXaWR0aC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVzaXplQ29sdW1uKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2hvd1Jlc2l6ZXIgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZGlmZiA9IGV2ZW50LmNsaWVudFggLSB0aGlzLnN0YXJ0UmVzaXplUG9zO1xuXG4gICAgICAgIGNvbnN0IGNvbFdpZHRoID0gdGhpcy5jb2x1bW4ud2lkdGg7XG4gICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gY29sV2lkdGggJiYgdHlwZW9mIGNvbFdpZHRoID09PSAnc3RyaW5nJyAmJiBjb2xXaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuICAgICAgICBsZXQgY3VycmVudENvbFdpZHRoID0gcGFyc2VGbG9hdChjb2xXaWR0aCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gdGhpcy5jb2x1bW4uaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IE51bWJlci5pc05hTihjdXJyZW50Q29sV2lkdGgpID8gcGFyc2VGbG9hdChhY3R1YWxXaWR0aCkgOiBjdXJyZW50Q29sV2lkdGg7XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLmdyaWQuaGFzQ29sdW1uTGF5b3V0cykge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVDb2x1bW5MYXlvdXRGb3IodGhpcy5jb2x1bW4sIGRpZmYpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGVyY2VudGFnZVdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVQZXJjZW50YWdlUmVzaXplKGRpZmYsIHRoaXMuY29sdW1uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVBpeGVsUmVzaXplKGRpZmYsIHRoaXMuY29sdW1uKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7fSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRDb2xXaWR0aCAhPT0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi53aWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uLmdyaWQub25Db2x1bW5SZXNpemVkLmVtaXQoe1xuICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgcHJldldpZHRoOiBpc1BlcmNlbnRhZ2VXaWR0aCA/IGN1cnJlbnRDb2xXaWR0aCArICclJyA6IGN1cnJlbnRDb2xXaWR0aCArICdweCcsXG4gICAgICAgICAgICAgICAgbmV3V2lkdGg6IHRoaXMuY29sdW1uLndpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNDb2x1bW5SZXNpemluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfaGFuZGxlUGl4ZWxSZXNpemUoZGlmZjogbnVtYmVyLCBjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q29sV2lkdGggPSBwYXJzZUZsb2F0KGNvbHVtbi53aWR0aCk7XG4gICAgICAgIGNvbnN0IGNvbE1pbldpZHRoID0gY29sdW1uLm1pbldpZHRoUHg7XG4gICAgICAgIGNvbnN0IGNvbE1heFdpZHRoID0gY29sdW1uLm1heFdpZHRoUHg7XG4gICAgICAgIGlmIChjdXJyZW50Q29sV2lkdGggKyBkaWZmIDwgY29sTWluV2lkdGgpIHtcbiAgICAgICAgICAgIGNvbHVtbi53aWR0aCA9IGNvbE1pbldpZHRoICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIGlmIChjb2xNYXhXaWR0aCAmJiAoY3VycmVudENvbFdpZHRoICsgZGlmZiA+IGNvbE1heFdpZHRoKSkge1xuICAgICAgICAgICAgY29sdW1uLndpZHRoID0gY29sTWF4V2lkdGggKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sdW1uLndpZHRoID0gKGN1cnJlbnRDb2xXaWR0aCArIGRpZmYpICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBfaGFuZGxlUGVyY2VudGFnZVJlc2l6ZShkaWZmOiBudW1iZXIsIGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJjZW50V2lkdGggPSBwYXJzZUZsb2F0KGNvbHVtbi53aWR0aCk7XG4gICAgICAgIGNvbnN0IGdyaWRBdmFpbGFibGVTaXplID0gY29sdW1uLmdyaWQuY2FsY1dpZHRoO1xuXG4gICAgICAgIGNvbnN0IGRpZmZQZXJjZW50YWdlID0gKGRpZmYgLyBncmlkQXZhaWxhYmxlU2l6ZSkgKiAxMDA7XG4gICAgICAgIGNvbnN0IGNvbE1pbldpZHRoID0gY29sdW1uLm1pbldpZHRoUGVyY2VudDtcbiAgICAgICAgY29uc3QgY29sTWF4V2lkdGggPSAgY29sdW1uLm1heFdpZHRoUGVyY2VudDtcblxuICAgICAgICBpZiAoY3VycmVudFBlcmNlbnRXaWR0aCArIGRpZmZQZXJjZW50YWdlIDwgY29sTWluV2lkdGgpIHtcbiAgICAgICAgICAgIGNvbHVtbi53aWR0aCA9IGNvbE1pbldpZHRoICsgJyUnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbE1heFdpZHRoICYmIChjdXJyZW50UGVyY2VudFdpZHRoICsgZGlmZlBlcmNlbnRhZ2UgPiBjb2xNYXhXaWR0aCkpIHtcbiAgICAgICAgICAgIGNvbHVtbi53aWR0aCA9IGNvbE1heFdpZHRoICsgJyUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sdW1uLndpZHRoID0gKGN1cnJlbnRQZXJjZW50V2lkdGggKyBkaWZmUGVyY2VudGFnZSkgKyAnJSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0Q29sTWluV2lkdGgoY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IHBhcnNlRmxvYXQoY29sdW1uLndpZHRoKTtcbiAgICAgICAgY29uc3QgYWN0dWFsV2lkdGggPSBjb2x1bW4uaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IE51bWJlci5pc05hTihjdXJyZW50Q29sV2lkdGgpIHx8IChjdXJyZW50Q29sV2lkdGggPCBhY3R1YWxXaWR0aCkgPyBhY3R1YWxXaWR0aCA6IGN1cnJlbnRDb2xXaWR0aDtcblxuICAgICAgICBjb25zdCBhY3R1YWxNaW5XaWR0aCA9IHBhcnNlRmxvYXQoY29sdW1uLm1pbldpZHRoKTtcbiAgICAgICAgcmV0dXJuIGFjdHVhbE1pbldpZHRoIDwgY3VycmVudENvbFdpZHRoID8gYWN0dWFsTWluV2lkdGggOiBjdXJyZW50Q29sV2lkdGg7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHJlc2l6ZUNvbHVtbkxheW91dEZvcihjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCwgZGlmZjogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlQ29sdW1ucyA9IGNvbHVtbi5nZXRSZXNpemFibGVDb2xVbmRlckVuZCgpO1xuICAgICAgICBjb25zdCBjb21iaW5lZFNwYW4gPSByZWxhdGl2ZUNvbHVtbnMucmVkdWNlKChhY2MsIGNvbCkgPT4gIGFjYyArIGNvbC5zcGFuVXNlZCwgMCk7XG5cbiAgICAgICAgLy8gUmVzaXplIGZpcnN0IHRob3NlIHdobyBtaWdodCByZWFjaCBtaW4vbWF4IHdpZHRoXG4gICAgICAgIGxldCBjb2x1bW5zVG9SZXNpemUgPSBbLi4ucmVsYXRpdmVDb2x1bW5zXTtcbiAgICAgICAgbGV0IHVwZGF0ZWREaWZmID0gZGlmZjtcbiAgICAgICAgbGV0IHVwZGF0ZWRDb21iaW5lZFNwYW4gPSBjb21iaW5lZFNwYW47XG4gICAgICAgIGxldCBzZXRNaW5NYXhDb2xzID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIEN5Y2xlIHRoZW0gdW50aWwgdGhlcmUgYXJlIG5vdCBvbmVzIHRoYXQgcmVhY2ggbWluL21heCBzaXplLCBiZWNhdXNlIHRoZSBkaWZmIGFjY3VtdWxhdGVzIGFmdGVyIGVhY2ggY3ljbGUuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2UgY2FuIGhhdmUgYXQgZmlyc3QgMiBjb2xzIHJlYWNoaW5nIG1pbiB3aWR0aCBhbmQgdGhlbiBhZnRlclxuICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGluZyB0aGUgZGlmZiB0aGVyZSBtaWdodCBiZSAxIG1vcmUgdGhhdCByZWFjaGVzIG1pbiB3aWR0aC5cbiAgICAgICAgICAgIHNldE1pbk1heENvbHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBuZXdDb21iaW5lZFNwYW4gPSB1cGRhdGVkQ29tYmluZWRTcGFuO1xuICAgICAgICAgICAgY29uc3QgbmV3Q29sc1RvUmVzaXplID0gW107XG4gICAgICAgICAgICBjb2x1bW5zVG9SZXNpemUuZm9yRWFjaCgoY29sKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFJlc2l6ZVdpZHRoID0gcGFyc2VGbG9hdChjb2wudGFyZ2V0LmNhbGNXaWR0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzaXplU2NhbGVkID0gKGRpZmYgLyB1cGRhdGVkQ29tYmluZWRTcGFuKSAqIGNvbC50YXJnZXQuZ3JpZENvbHVtblNwYW47XG4gICAgICAgICAgICAgICAgY29uc3QgY29sV2lkdGggPSBjb2wudGFyZ2V0LndpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gY29sV2lkdGggJiYgdHlwZW9mIGNvbFdpZHRoID09PSAnc3RyaW5nJyAmJiBjb2xXaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWluV2lkdGggPSBjb2wudGFyZ2V0Lm1pbldpZHRoUHg7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4V2lkdGggPSBjb2wudGFyZ2V0Lm1heFdpZHRoUHg7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSZXNpemVXaWR0aCArIHJlc2l6ZVNjYWxlZCA8IG1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbC50YXJnZXQud2lkdGggPSBpc1BlcmNlbnRhZ2VXaWR0aCA/IGNvbC50YXJnZXQubWluV2lkdGhQZXJjZW50ICsgJyUnIDogbWluV2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkRGlmZiArPSAoY3VycmVudFJlc2l6ZVdpZHRoIC0gbWluV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb21iaW5lZFNwYW4gLT0gY29sLnNwYW5Vc2VkO1xuICAgICAgICAgICAgICAgICAgICBzZXRNaW5NYXhDb2xzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1heFdpZHRoICYmIChjdXJyZW50UmVzaXplV2lkdGggKyByZXNpemVTY2FsZWQgPiBtYXhXaWR0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sLnRhcmdldC53aWR0aCA9IGlzUGVyY2VudGFnZVdpZHRoID8gY29sLnRhcmdldC5tYXhXaWR0aFBlcmNlbnQgKyAnJScgOiBjb2wudGFyZ2V0Lm1heFdpZHRoUHggKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkRGlmZiAtPSAobWF4V2lkdGggLSBjdXJyZW50UmVzaXplV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb21iaW5lZFNwYW4gLT0gY29sLnNwYW5Vc2VkO1xuICAgICAgICAgICAgICAgICAgICBzZXRNaW5NYXhDb2xzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIG5ldyBvbmVzIHRoYXQgY2FuIGJlIHJlc2l6ZWRcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29sc1RvUmVzaXplLnB1c2goY29sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdXBkYXRlZENvbWJpbmVkU3BhbiA9IG5ld0NvbWJpbmVkU3BhbjtcbiAgICAgICAgICAgIGNvbHVtbnNUb1Jlc2l6ZSA9IG5ld0NvbHNUb1Jlc2l6ZTtcbiAgICAgICAgfSB3aGlsZSAoc2V0TWluTWF4Q29scyk7XG5cbiAgICAgICAgLy8gVGhvc2UgbGVmdCB0aGF0IGRvbid0IHJlYWNoIG1pbi9tYXggc2l6ZSByZXNpemUgdGhlbSBub3JtYWxseS5cbiAgICAgICAgY29sdW1uc1RvUmVzaXplLmZvckVhY2goKGNvbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzaXplU2NhbGVkID0gKHVwZGF0ZWREaWZmIC8gdXBkYXRlZENvbWJpbmVkU3BhbikgKiBjb2wudGFyZ2V0LmdyaWRDb2x1bW5TcGFuO1xuICAgICAgICAgICAgY29uc3QgY29sV2lkdGggPSBjb2wudGFyZ2V0LndpZHRoO1xuICAgICAgICAgICAgY29uc3QgaXNQZXJjZW50YWdlV2lkdGggPSBjb2xXaWR0aCAmJiB0eXBlb2YgY29sV2lkdGggPT09ICdzdHJpbmcnICYmIGNvbFdpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTE7XG4gICAgICAgICAgICBpZiAoaXNQZXJjZW50YWdlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVQZXJjZW50YWdlUmVzaXplKHJlc2l6ZVNjYWxlZCwgY29sLnRhcmdldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVBpeGVsUmVzaXplKHJlc2l6ZVNjYWxlZCwgY29sLnRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdfQ==