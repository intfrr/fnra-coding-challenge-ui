import { IgxGridNavigationService } from '../grid-navigation.service';
import { first } from 'rxjs/operators';
import { SUPPORTED_KEYS, NAVIGATION_KEYS } from '../../core/utils';
import { Injectable } from '@angular/core';
import { IgxChildGridRowComponent } from './child-grid-row.component';
export class IgxHierarchicalGridNavigationService extends IgxGridNavigationService {
    constructor() {
        super(...arguments);
        this._pendingNavigation = false;
    }
    dispatchEvent(event) {
        const key = event.key.toLowerCase();
        if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) &&
            !this.grid.crudService.rowEditingBlocked && !this.grid.rowInEditMode) {
            return;
        }
        const targetGrid = this.getClosestElemByTag(event.target, 'igx-hierarchical-grid');
        if (targetGrid !== this.grid.nativeElement) {
            return;
        }
        if (this._pendingNavigation && NAVIGATION_KEYS.has(key)) {
            // In case focus needs to be moved from one grid to another, however there is a pending scroll operation
            // which is an async operation, any additional navigation keys should be ignored
            // untill operation complete.
            event.preventDefault();
            return;
        }
        super.dispatchEvent(event);
    }
    navigateInBody(rowIndex, visibleColIndex, cb = null) {
        const rec = this.grid.dataView[rowIndex];
        if (rec && this.grid.isChildGridRecord(rec)) {
            // target is child grid
            const virtState = this.grid.verticalScrollContainer.state;
            const inView = rowIndex >= virtState.startIndex && rowIndex <= virtState.startIndex + virtState.chunkSize;
            const isNext = this.activeNode.row < rowIndex;
            const targetLayoutIndex = isNext ? null : this.grid.childLayoutKeys.length - 1;
            if (inView) {
                this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            }
            else {
                let scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(rowIndex, !isNext);
                scrollAmount += isNext ? 1 : -1;
                this.grid.verticalScrollContainer.getScroll().scrollTop = scrollAmount;
                this._pendingNavigation = true;
                this.grid.verticalScrollContainer.onChunkLoad.pipe(first()).subscribe(() => {
                    this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
                    this._pendingNavigation = false;
                });
            }
            return;
        }
        const isLast = rowIndex === this.grid.dataView.length;
        if ((rowIndex === -1 || isLast) &&
            this.grid.parent !== null) {
            // reached end of child grid
            const nextSiblingIndex = this.nextSiblingIndex(isLast);
            if (nextSiblingIndex !== null) {
                this.grid.parent.navigation._moveToChild(this.grid.childRow.index, visibleColIndex, isLast, nextSiblingIndex, cb);
            }
            else {
                this._moveToParent(isLast, visibleColIndex, cb);
            }
            return;
        }
        if (this.grid.parent) {
            const isNext = this.activeNode && typeof this.activeNode.row === 'number' ? rowIndex > this.activeNode.row : false;
            const cbHandler = (args) => {
                this._handleScrollInChild(rowIndex, isNext);
                cb(args);
            };
            if (!this.activeNode) {
                this.activeNode = { row: null, column: null };
            }
            super.navigateInBody(rowIndex, visibleColIndex, cbHandler);
            return;
        }
        if (!this.activeNode) {
            this.activeNode = { row: null, column: null };
        }
        super.navigateInBody(rowIndex, visibleColIndex, cb);
    }
    shouldPerformVerticalScroll(index, visibleColumnIndex = -1, isNext) {
        const targetRec = this.grid.dataView[index];
        if (this.grid.isChildGridRecord(targetRec)) {
            const scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(index, !isNext);
            const currScroll = this.grid.verticalScrollContainer.getScroll().scrollTop;
            const shouldScroll = !isNext ? scrollAmount > currScroll : currScroll < scrollAmount;
            return shouldScroll;
        }
        else {
            return super.shouldPerformVerticalScroll(index, visibleColumnIndex);
        }
    }
    focusTbody(event) {
        if (!this.activeNode || this.activeNode.row === null) {
            this.activeNode = {
                row: 0,
                column: 0
            };
            this.grid.navigateTo(0, 0, (obj) => {
                this.grid.clearCellSelection();
                obj.target.activate(event);
            });
        }
        else {
            super.focusTbody(event);
        }
    }
    nextSiblingIndex(isNext) {
        const layoutKey = this.grid.childRow.layout.key;
        const layoutIndex = this.grid.parent.childLayoutKeys.indexOf(layoutKey);
        const nextIndex = isNext ? layoutIndex + 1 : layoutIndex - 1;
        if (nextIndex <= this.grid.parent.childLayoutKeys.length - 1 && nextIndex > -1) {
            return nextIndex;
        }
        else {
            return null;
        }
    }
    /**
     * Handles scrolling in child grid and ensures target child row is in main grid view port.
     * @param rowIndex The row index which should be in view.
     * @param isNext  Optional. Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    _handleScrollInChild(rowIndex, isNext, cb) {
        const shouldScroll = this.shouldPerformVerticalScroll(rowIndex, -1, isNext);
        if (shouldScroll) {
            this.grid.navigation.performVerticalScrollToCell(rowIndex, -1, () => {
                this.positionInParent(rowIndex, isNext, cb);
            });
        }
        else {
            this.positionInParent(rowIndex, isNext, cb);
        }
    }
    /**
     *
     * @param rowIndex Row index that should come in view.
     * @param isNext  Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    positionInParent(rowIndex, isNext, cb) {
        const rowObj = this.grid.getRowByIndex(rowIndex);
        if (!rowObj) {
            if (cb) {
                cb();
            }
            return;
        }
        const positionInfo = this.getPositionInfo(rowObj, isNext);
        if (!positionInfo.inView) {
            // stop event from triggering multiple times before scrolling is complete.
            this._pendingNavigation = true;
            const scrollableGrid = isNext ? this.getNextScrollableDown(this.grid) : this.getNextScrollableUp(this.grid);
            scrollableGrid.grid.verticalScrollContainer.recalcUpdateSizes();
            scrollableGrid.grid.verticalScrollContainer.addScrollTop(positionInfo.offset);
            scrollableGrid.grid.verticalScrollContainer.onChunkLoad.pipe(first()).subscribe(() => {
                this._pendingNavigation = false;
                if (cb) {
                    cb();
                }
            });
        }
        else {
            if (cb) {
                cb();
            }
        }
    }
    /**
     * Moves navigation to child grid.
     * @param parentRowIndex The parent row index, at which the child grid is rendered.
     * @param childLayoutIndex Optional. The index of the child row island to which the child grid belongs to. Uses first if not set.
     */
    _moveToChild(parentRowIndex, visibleColIndex, isNext, childLayoutIndex, cb) {
        const ri = typeof childLayoutIndex !== 'number' ?
            this.grid.childLayoutList.first : this.grid.childLayoutList.toArray()[childLayoutIndex];
        const rowId = this.grid.dataView[parentRowIndex].rowID;
        const pathSegment = {
            rowID: rowId,
            rowIslandKey: ri.key
        };
        const childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
        const targetIndex = isNext ? 0 : childGrid.dataView.length - 1;
        const targetRec = childGrid.dataView[targetIndex];
        if (!targetRec) {
            // if no target rec, then move on in next sibling or parent
            childGrid.navigation.navigateInBody(targetIndex, visibleColIndex, cb);
            return;
        }
        if (childGrid.isChildGridRecord(targetRec)) {
            // if target is a child grid record should move into it.
            this.grid.navigation.activeNode.row = null;
            childGrid.navigation.activeNode = { row: targetIndex, column: this.activeNode.column };
            childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
                const targetLayoutIndex = isNext ? 0 : childGrid.childLayoutList.toArray().length - 1;
                childGrid.navigation._moveToChild(targetIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            });
            return;
        }
        const childGridNav = childGrid.navigation;
        this.clearActivation();
        const lastVisibleIndex = childGridNav.lastColumnIndex;
        const columnIndex = visibleColIndex <= lastVisibleIndex ? visibleColIndex : lastVisibleIndex;
        childGridNav.activeNode = { row: targetIndex, column: columnIndex };
        childGrid.tbody.nativeElement.focus({ preventScroll: true });
        this._pendingNavigation = false;
        childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
            childGrid.navigateTo(targetIndex, columnIndex, cb);
        });
    }
    /**
     * Moves navigation back to parent grid.
     * @param rowIndex
     */
    _moveToParent(isNext, columnIndex, cb) {
        const indexInParent = this.grid.childRow.index;
        const hasNextTarget = this.hasNextTarget(this.grid.parent, indexInParent, isNext);
        if (!hasNextTarget) {
            return;
        }
        this.clearActivation();
        const targetRowIndex = isNext ? indexInParent + 1 : indexInParent - 1;
        const lastVisibleIndex = this.grid.parent.navigation.lastColumnIndex;
        const nextColumnIndex = columnIndex <= lastVisibleIndex ? columnIndex : lastVisibleIndex;
        this._pendingNavigation = true;
        const cbFunc = (args) => {
            this._pendingNavigation = false;
            cb(args);
            args.target.grid.tbody.nativeElement.focus();
        };
        this.grid.parent.navigation.navigateInBody(targetRowIndex, nextColumnIndex, cbFunc);
    }
    /**
     * Gets information on the row position relative to the root grid view port.
     * Returns whether the row is in view and its offset.
     * @param rowObj
     * @param isNext
     */
    getPositionInfo(rowObj, isNext) {
        let rowElem = rowObj.nativeElement;
        if (rowObj instanceof IgxChildGridRowComponent) {
            const childLayoutKeys = this.grid.childLayoutKeys;
            const riKey = isNext ? childLayoutKeys[0] : childLayoutKeys[childLayoutKeys.length - 1];
            const pathSegment = {
                rowID: rowObj.rowData.rowID,
                rowIslandKey: riKey
            };
            const childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
            rowElem = childGrid.tfoot.nativeElement;
        }
        const gridBottom = this._getMinBottom(this.grid);
        const diffBottom = rowElem.getBoundingClientRect().bottom - gridBottom;
        const gridTop = this._getMaxTop(this.grid);
        const diffTop = rowElem.getBoundingClientRect().bottom -
            rowElem.offsetHeight - gridTop;
        const isInView = isNext ? diffBottom <= 0 : diffTop >= 0;
        const calcOffset = isNext ? diffBottom : diffTop;
        return { inView: isInView, offset: calcOffset };
    }
    clearActivation() {
        // clear if previous activation exists.
        if (this.activeNode) {
            this.activeNode.row = null;
        }
    }
    hasNextTarget(grid, index, isNext) {
        const targetRowIndex = isNext ? index + 1 : index - 1;
        const hasTargetRecord = !!grid.dataView[targetRowIndex];
        if (hasTargetRecord) {
            return true;
        }
        else {
            let hasTargetRecordInParent = false;
            if (grid.parent) {
                const indexInParent = grid.childRow.index;
                hasTargetRecordInParent = this.hasNextTarget(grid.parent, indexInParent, isNext);
            }
            return hasTargetRecordInParent;
        }
    }
    /**
     * Gets closest element by its tag name.
     * @param sourceElem The element from which to start the search.
     * @param targetTag The target element tag name, for which to search.
     */
    getClosestElemByTag(sourceElem, targetTag) {
        let result = sourceElem;
        while (result !== null && result.nodeType === 1) {
            if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {
                return result;
            }
            result = result.parentNode;
        }
        return null;
    }
    /**
     * Gets the max top view in the current grid hierarchy.
     * @param grid
     */
    _getMaxTop(grid) {
        let currGrid = grid;
        let top = currGrid.tbody.nativeElement.getBoundingClientRect().top;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top + pinnedRowsHeight);
        }
        return top;
    }
    /**
     * Gets the min bottom view in the current grid hierarchy.
     * @param grid
     */
    _getMinBottom(grid) {
        let currGrid = grid;
        let bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && !currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom - pinnedRowsHeight);
        }
        return bottom;
    }
    /**
     * Finds the next grid that allows scrolling down.
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableDown(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid: grid, prev: null };
        }
        let scrollTop = currGrid.verticalScrollContainer.scrollPosition;
        let scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
        let nonScrollable = scrollHeight === 0 ||
            Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            scrollTop = currGrid.verticalScrollContainer.scrollPosition;
            scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
            nonScrollable = scrollHeight === 0 ||
                Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        }
        return { grid: currGrid, prev: prev };
    }
    /**
     * Finds the next grid that allows scrolling up.
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableUp(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid: grid, prev: null };
        }
        let nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        }
        return { grid: currGrid, prev: prev };
    }
}
IgxHierarchicalGridNavigationService.decorators = [
    { type: Injectable }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGllcmFyY2hpY2FsLWdyaWQtbmF2aWdhdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL2hpZXJhcmNoaWNhbC1ncmlkL2hpZXJhcmNoaWNhbC1ncmlkLW5hdmlnYXRpb24uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUV0RSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDdkMsT0FBTyxFQUFFLGNBQWMsRUFBRSxlQUFlLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNuRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBTXRFLE1BQU0sT0FBTyxvQ0FBcUMsU0FBUSx3QkFBd0I7SUFEbEY7O1FBSWMsdUJBQWtCLEdBQUcsS0FBSyxDQUFDO0lBeVh6QyxDQUFDO0lBdFhHLGFBQWEsQ0FBQyxLQUFvQjtRQUM5QixNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLEtBQUssSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNuRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGlCQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFBRSxPQUFPO1NBQUU7UUFFakYsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFD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blNlcnZpY2UgfSBmcm9tICcuLi9ncmlkLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hIaWVyYXJjaGljYWxHcmlkQ29tcG9uZW50IH0gZnJvbSAnLi9oaWVyYXJjaGljYWwtZ3JpZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTVVBQT1JURURfS0VZUywgTkFWSUdBVElPTl9LRVlTIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hDaGlsZEdyaWRSb3dDb21wb25lbnQgfSBmcm9tICcuL2NoaWxkLWdyaWQtcm93LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hSb3dEaXJlY3RpdmUsIElneEdyaWRCYXNlRGlyZWN0aXZlIH0gZnJvbSAnLi4vZ3JpZC9wdWJsaWNfYXBpJztcbmltcG9ydCB7IEdyaWRUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElQYXRoU2VnbWVudCB9IGZyb20gJy4vaGllcmFyY2hpY2FsLWdyaWQtYmFzZS5kaXJlY3RpdmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSWd4SGllcmFyY2hpY2FsR3JpZE5hdmlnYXRpb25TZXJ2aWNlIGV4dGVuZHMgSWd4R3JpZE5hdmlnYXRpb25TZXJ2aWNlIHtcbiAgICBwdWJsaWMgZ3JpZDogSWd4SGllcmFyY2hpY2FsR3JpZENvbXBvbmVudDtcblxuICAgIHByb3RlY3RlZCBfcGVuZGluZ05hdmlnYXRpb24gPSBmYWxzZTtcblxuXG4gICAgZGlzcGF0Y2hFdmVudChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBjb25zdCBrZXkgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZU5vZGUgfHwgIShTVVBQT1JURURfS0VZUy5oYXMoa2V5KSB8fCAoa2V5ID09PSAndGFiJyAmJiB0aGlzLmdyaWQuY3J1ZFNlcnZpY2UuY2VsbCkpICYmXG4gICAgICAgICF0aGlzLmdyaWQuY3J1ZFNlcnZpY2Uucm93RWRpdGluZ0Jsb2NrZWQgJiYgIXRoaXMuZ3JpZC5yb3dJbkVkaXRNb2RlKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldEdyaWQgPSB0aGlzLmdldENsb3Nlc3RFbGVtQnlUYWcoZXZlbnQudGFyZ2V0LCAnaWd4LWhpZXJhcmNoaWNhbC1ncmlkJyk7XG4gICAgICAgIGlmICh0YXJnZXRHcmlkICE9PSB0aGlzLmdyaWQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdOYXZpZ2F0aW9uICYmIE5BVklHQVRJT05fS0VZUy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBmb2N1cyBuZWVkcyB0byBiZSBtb3ZlZCBmcm9tIG9uZSBncmlkIHRvIGFub3RoZXIsIGhvd2V2ZXIgdGhlcmUgaXMgYSBwZW5kaW5nIHNjcm9sbCBvcGVyYXRpb25cbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGFuIGFzeW5jIG9wZXJhdGlvbiwgYW55IGFkZGl0aW9uYWwgbmF2aWdhdGlvbiBrZXlzIHNob3VsZCBiZSBpZ25vcmVkXG4gICAgICAgICAgICAvLyB1bnRpbGwgb3BlcmF0aW9uIGNvbXBsZXRlLlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmF2aWdhdGVJbkJvZHkocm93SW5kZXgsIHZpc2libGVDb2xJbmRleCwgY2I6IEZ1bmN0aW9uID0gbnVsbCk6IHZvaWQge1xuICAgICAgICBjb25zdCByZWMgPSB0aGlzLmdyaWQuZGF0YVZpZXdbcm93SW5kZXhdO1xuICAgICAgICBpZiAocmVjICYmIHRoaXMuZ3JpZC5pc0NoaWxkR3JpZFJlY29yZChyZWMpKSB7XG4gICAgICAgICAgICAgLy8gdGFyZ2V0IGlzIGNoaWxkIGdyaWRcbiAgICAgICAgICAgIGNvbnN0IHZpcnRTdGF0ZSA9IHRoaXMuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5zdGF0ZTtcbiAgICAgICAgICAgICBjb25zdCBpblZpZXcgPSByb3dJbmRleCA+PSB2aXJ0U3RhdGUuc3RhcnRJbmRleCAmJiByb3dJbmRleCA8PSB2aXJ0U3RhdGUuc3RhcnRJbmRleCArIHZpcnRTdGF0ZS5jaHVua1NpemU7XG4gICAgICAgICAgICAgY29uc3QgaXNOZXh0ID0gIHRoaXMuYWN0aXZlTm9kZS5yb3cgPCByb3dJbmRleDtcbiAgICAgICAgICAgICBjb25zdCB0YXJnZXRMYXlvdXRJbmRleCA9IGlzTmV4dCA/IG51bGwgOiB0aGlzLmdyaWQuY2hpbGRMYXlvdXRLZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgaWYgKGluVmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVUb0NoaWxkKHJvd0luZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGlzTmV4dCwgdGFyZ2V0TGF5b3V0SW5kZXgsIGNiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHNjcm9sbEFtb3VudCA9IHRoaXMuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5nZXRTY3JvbGxGb3JJbmRleChyb3dJbmRleCwgIWlzTmV4dCk7XG4gICAgICAgICAgICAgICAgc2Nyb2xsQW1vdW50ICs9IGlzTmV4dCA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsKCkuc2Nyb2xsVG9wID0gc2Nyb2xsQW1vdW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdOYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIub25DaHVua0xvYWQucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlVG9DaGlsZChyb3dJbmRleCwgdmlzaWJsZUNvbEluZGV4LCBpc05leHQsIHRhcmdldExheW91dEluZGV4LCBjYik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdOYXZpZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0xhc3QgPSByb3dJbmRleCA9PT0gdGhpcy5ncmlkLmRhdGFWaWV3Lmxlbmd0aDtcbiAgICAgICAgaWYgKChyb3dJbmRleCA9PT0gLTEgfHwgaXNMYXN0KSAmJlxuICAgICAgICAgICAgdGhpcy5ncmlkLnBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gcmVhY2hlZCBlbmQgb2YgY2hpbGQgZ3JpZFxuICAgICAgICAgICAgY29uc3QgbmV4dFNpYmxpbmdJbmRleCA9IHRoaXMubmV4dFNpYmxpbmdJbmRleChpc0xhc3QpO1xuICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQucGFyZW50Lm5hdmlnYXRpb24uX21vdmVUb0NoaWxkKHRoaXMuZ3JpZC5jaGlsZFJvdy5pbmRleCwgdmlzaWJsZUNvbEluZGV4LCBpc0xhc3QsIG5leHRTaWJsaW5nSW5kZXgsIGNiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZVRvUGFyZW50KGlzTGFzdCwgdmlzaWJsZUNvbEluZGV4LCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ncmlkLnBhcmVudCkge1xuICAgICAgICAgICAgY29uc3QgaXNOZXh0ID0gdGhpcy5hY3RpdmVOb2RlICYmIHR5cGVvZiB0aGlzLmFjdGl2ZU5vZGUucm93ID09PSAnbnVtYmVyJyA/IHJvd0luZGV4ID4gdGhpcy5hY3RpdmVOb2RlLnJvdyA6IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY2JIYW5kbGVyID0gKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVTY3JvbGxJbkNoaWxkKHJvd0luZGV4LCBpc05leHQpO1xuICAgICAgICAgICAgICAgIGNiKGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmVOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlID0geyByb3c6IG51bGwsIGNvbHVtbjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VwZXIubmF2aWdhdGVJbkJvZHkocm93SW5kZXgsIHZpc2libGVDb2xJbmRleCwgY2JIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU5vZGUgPSB7IHJvdzogbnVsbCwgY29sdW1uOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubmF2aWdhdGVJbkJvZHkocm93SW5kZXgsIHZpc2libGVDb2xJbmRleCwgY2IpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzaG91bGRQZXJmb3JtVmVydGljYWxTY3JvbGwoaW5kZXgsIHZpc2libGVDb2x1bW5JbmRleCA9IC0xLCBpc05leHQ/KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFJlYyA9IHRoaXMuZ3JpZC5kYXRhVmlld1tpbmRleF07XG4gICAgICAgIGlmICh0aGlzLmdyaWQuaXNDaGlsZEdyaWRSZWNvcmQodGFyZ2V0UmVjKSkge1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQW1vdW50ID0gdGhpcy5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbEZvckluZGV4KGluZGV4LCAhaXNOZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJTY3JvbGwgPSB0aGlzLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsKCkuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gIWlzTmV4dCA/IHNjcm9sbEFtb3VudCA+IGN1cnJTY3JvbGwgOiBjdXJyU2Nyb2xsIDwgc2Nyb2xsQW1vdW50O1xuICAgICAgICAgICAgcmV0dXJuIHNob3VsZFNjcm9sbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5zaG91bGRQZXJmb3JtVmVydGljYWxTY3JvbGwoaW5kZXgsIHZpc2libGVDb2x1bW5JbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb2N1c1Rib2R5KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVOb2RlIHx8IHRoaXMuYWN0aXZlTm9kZS5yb3cgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTm9kZSA9IHtcbiAgICAgICAgICAgICAgICByb3c6IDAsXG4gICAgICAgICAgICAgICAgY29sdW1uOiAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmdyaWQubmF2aWdhdGVUbygwLCAwLCAob2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLmNsZWFyQ2VsbFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIG9iai50YXJnZXQuYWN0aXZhdGUoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLmZvY3VzVGJvZHkoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG5leHRTaWJsaW5nSW5kZXgoaXNOZXh0KSB7XG4gICAgICAgIGNvbnN0IGxheW91dEtleSA9IHRoaXMuZ3JpZC5jaGlsZFJvdy5sYXlvdXQua2V5O1xuICAgICAgICBjb25zdCBsYXlvdXRJbmRleCA9IHRoaXMuZ3JpZC5wYXJlbnQuY2hpbGRMYXlvdXRLZXlzLmluZGV4T2YobGF5b3V0S2V5KTtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gaXNOZXh0ID8gbGF5b3V0SW5kZXggKyAxIDogbGF5b3V0SW5kZXggLSAxO1xuICAgICAgICBpZiAobmV4dEluZGV4IDw9IHRoaXMuZ3JpZC5wYXJlbnQuY2hpbGRMYXlvdXRLZXlzLmxlbmd0aCAtIDEgJiYgbmV4dEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc2Nyb2xsaW5nIGluIGNoaWxkIGdyaWQgYW5kIGVuc3VyZXMgdGFyZ2V0IGNoaWxkIHJvdyBpcyBpbiBtYWluIGdyaWQgdmlldyBwb3J0LlxuICAgICAqIEBwYXJhbSByb3dJbmRleCBUaGUgcm93IGluZGV4IHdoaWNoIHNob3VsZCBiZSBpbiB2aWV3LlxuICAgICAqIEBwYXJhbSBpc05leHQgIE9wdGlvbmFsLiBXaGV0aGVyIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIG5leHQuIFVzZWQgdG8gZGV0ZXJtaW5lIHNjcm9sbCBkaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIGNiICBPcHRpb25hbC5DYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgd2hlbiBvcGVyYXRpb24gaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9oYW5kbGVTY3JvbGxJbkNoaWxkKHJvd0luZGV4OiBudW1iZXIsIGlzTmV4dD86IGJvb2xlYW4sIGNiPzogRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gdGhpcy5zaG91bGRQZXJmb3JtVmVydGljYWxTY3JvbGwocm93SW5kZXgsIC0xLCBpc05leHQpO1xuICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQubmF2aWdhdGlvbi5wZXJmb3JtVmVydGljYWxTY3JvbGxUb0NlbGwocm93SW5kZXgsIC0xLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkluUGFyZW50KHJvd0luZGV4LCBpc05leHQsIGNiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkluUGFyZW50KHJvd0luZGV4LCBpc05leHQsIGNiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvd0luZGV4IFJvdyBpbmRleCB0aGF0IHNob3VsZCBjb21lIGluIHZpZXcuXG4gICAgICogQHBhcmFtIGlzTmV4dCAgV2hldGhlciB3ZSBhcmUgbmF2aWdhdGluZyB0byBuZXh0LiBVc2VkIHRvIGRldGVybWluZSBzY3JvbGwgZGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjYiAgT3B0aW9uYWwuQ2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIHdoZW4gb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBwb3NpdGlvbkluUGFyZW50KHJvd0luZGV4LCBpc05leHQsIGNiPzogRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3Qgcm93T2JqID0gdGhpcy5ncmlkLmdldFJvd0J5SW5kZXgocm93SW5kZXgpO1xuICAgICAgICBpZiAoIXJvd09iaikge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NpdGlvbkluZm8gPSB0aGlzLmdldFBvc2l0aW9uSW5mbyhyb3dPYmosIGlzTmV4dCk7XG4gICAgICAgIGlmICghcG9zaXRpb25JbmZvLmluVmlldykge1xuICAgICAgICAgICAgLy8gc3RvcCBldmVudCBmcm9tIHRyaWdnZXJpbmcgbXVsdGlwbGUgdGltZXMgYmVmb3JlIHNjcm9sbGluZyBpcyBjb21wbGV0ZS5cbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdOYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbGFibGVHcmlkID0gaXNOZXh0ID8gdGhpcy5nZXROZXh0U2Nyb2xsYWJsZURvd24odGhpcy5ncmlkKSA6IHRoaXMuZ2V0TmV4dFNjcm9sbGFibGVVcCh0aGlzLmdyaWQpO1xuICAgICAgICAgICAgc2Nyb2xsYWJsZUdyaWQuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5yZWNhbGNVcGRhdGVTaXplcygpO1xuICAgICAgICAgICAgc2Nyb2xsYWJsZUdyaWQuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5hZGRTY3JvbGxUb3AocG9zaXRpb25JbmZvLm9mZnNldCk7XG4gICAgICAgICAgICBzY3JvbGxhYmxlR3JpZC5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLm9uQ2h1bmtMb2FkLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIG5hdmlnYXRpb24gdG8gY2hpbGQgZ3JpZC5cbiAgICAgKiBAcGFyYW0gcGFyZW50Um93SW5kZXggVGhlIHBhcmVudCByb3cgaW5kZXgsIGF0IHdoaWNoIHRoZSBjaGlsZCBncmlkIGlzIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSBjaGlsZExheW91dEluZGV4IE9wdGlvbmFsLiBUaGUgaW5kZXggb2YgdGhlIGNoaWxkIHJvdyBpc2xhbmQgdG8gd2hpY2ggdGhlIGNoaWxkIGdyaWQgYmVsb25ncyB0by4gVXNlcyBmaXJzdCBpZiBub3Qgc2V0LlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfbW92ZVRvQ2hpbGQocGFyZW50Um93SW5kZXg6IG51bWJlciwgdmlzaWJsZUNvbEluZGV4OiBudW1iZXIsIGlzTmV4dDogYm9vbGVhbiwgY2hpbGRMYXlvdXRJbmRleD86IG51bWJlciwgY2I/OiBGdW5jdGlvbikge1xuICAgICAgICBjb25zdCByaSA9IHR5cGVvZiBjaGlsZExheW91dEluZGV4ICE9PSAnbnVtYmVyJyA/XG4gICAgICAgICB0aGlzLmdyaWQuY2hpbGRMYXlvdXRMaXN0LmZpcnN0IDogdGhpcy5ncmlkLmNoaWxkTGF5b3V0TGlzdC50b0FycmF5KClbY2hpbGRMYXlvdXRJbmRleF07XG4gICAgICAgIGNvbnN0IHJvd0lkID0gdGhpcy5ncmlkLmRhdGFWaWV3W3BhcmVudFJvd0luZGV4XS5yb3dJRDtcbiAgICAgICAgY29uc3QgcGF0aFNlZ21lbnQ6IElQYXRoU2VnbWVudCA9IHtcbiAgICAgICAgICAgIHJvd0lEOiByb3dJZCxcbiAgICAgICAgICAgIHJvd0lzbGFuZEtleTogcmkua2V5XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoaWxkR3JpZCA9ICB0aGlzLmdyaWQuaGdyaWRBUEkuZ2V0Q2hpbGRHcmlkKFtwYXRoU2VnbWVudF0pO1xuICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IGlzTmV4dCA/IDAgOiBjaGlsZEdyaWQuZGF0YVZpZXcubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgdGFyZ2V0UmVjID0gIGNoaWxkR3JpZC5kYXRhVmlld1t0YXJnZXRJbmRleF07XG4gICAgICAgIGlmICghdGFyZ2V0UmVjKSB7XG4gICAgICAgICAgICAvLyBpZiBubyB0YXJnZXQgcmVjLCB0aGVuIG1vdmUgb24gaW4gbmV4dCBzaWJsaW5nIG9yIHBhcmVudFxuICAgICAgICAgICAgY2hpbGRHcmlkLm5hdmlnYXRpb24ubmF2aWdhdGVJbkJvZHkodGFyZ2V0SW5kZXgsIHZpc2libGVDb2xJbmRleCwgY2IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEdyaWQuaXNDaGlsZEdyaWRSZWNvcmQodGFyZ2V0UmVjKSkge1xuICAgICAgICAgICAgLy8gaWYgdGFyZ2V0IGlzIGEgY2hpbGQgZ3JpZCByZWNvcmQgc2hvdWxkIG1vdmUgaW50byBpdC5cbiAgICAgICAgICAgIHRoaXMuZ3JpZC5uYXZpZ2F0aW9uLmFjdGl2ZU5vZGUucm93ID0gbnVsbDtcbiAgICAgICAgICAgIGNoaWxkR3JpZC5uYXZpZ2F0aW9uLmFjdGl2ZU5vZGUgPSB7IHJvdzogdGFyZ2V0SW5kZXgsIGNvbHVtbjogdGhpcy5hY3RpdmVOb2RlLmNvbHVtbn07XG4gICAgICAgICAgICBjaGlsZEdyaWQubmF2aWdhdGlvbi5faGFuZGxlU2Nyb2xsSW5DaGlsZCh0YXJnZXRJbmRleCwgaXNOZXh0LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0TGF5b3V0SW5kZXggPSBpc05leHQgPyAwIDogY2hpbGRHcmlkLmNoaWxkTGF5b3V0TGlzdC50b0FycmF5KCkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjaGlsZEdyaWQubmF2aWdhdGlvbi5fbW92ZVRvQ2hpbGQodGFyZ2V0SW5kZXgsIHZpc2libGVDb2xJbmRleCwgaXNOZXh0LCB0YXJnZXRMYXlvdXRJbmRleCwgY2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZEdyaWROYXYgPSAgY2hpbGRHcmlkLm5hdmlnYXRpb247XG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGxhc3RWaXNpYmxlSW5kZXggPSBjaGlsZEdyaWROYXYubGFzdENvbHVtbkluZGV4O1xuICAgICAgICBjb25zdCBjb2x1bW5JbmRleCA9IHZpc2libGVDb2xJbmRleCA8PSBsYXN0VmlzaWJsZUluZGV4ID8gdmlzaWJsZUNvbEluZGV4IDogbGFzdFZpc2libGVJbmRleDtcbiAgICAgICAgY2hpbGRHcmlkTmF2LmFjdGl2ZU5vZGUgPSB7IHJvdzogdGFyZ2V0SW5kZXgsIGNvbHVtbjogY29sdW1uSW5kZXh9O1xuICAgICAgICBjaGlsZEdyaWQudGJvZHkubmF0aXZlRWxlbWVudC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICBjaGlsZEdyaWQubmF2aWdhdGlvbi5faGFuZGxlU2Nyb2xsSW5DaGlsZCh0YXJnZXRJbmRleCwgaXNOZXh0LCAoKSA9PiB7XG4gICAgICAgICAgICBjaGlsZEdyaWQubmF2aWdhdGVUbyh0YXJnZXRJbmRleCwgY29sdW1uSW5kZXgsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgbmF2aWdhdGlvbiBiYWNrIHRvIHBhcmVudCBncmlkLlxuICAgICAqIEBwYXJhbSByb3dJbmRleFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfbW92ZVRvUGFyZW50KGlzTmV4dDogYm9vbGVhbiwgY29sdW1uSW5kZXgsIGNiPykge1xuICAgICAgICBjb25zdCBpbmRleEluUGFyZW50ID0gdGhpcy5ncmlkLmNoaWxkUm93LmluZGV4O1xuICAgICAgICBjb25zdCBoYXNOZXh0VGFyZ2V0ID0gdGhpcy5oYXNOZXh0VGFyZ2V0KHRoaXMuZ3JpZC5wYXJlbnQsIGluZGV4SW5QYXJlbnQsIGlzTmV4dCk7XG4gICAgICAgIGlmICghaGFzTmV4dFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmF0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldFJvd0luZGV4ID0gIGlzTmV4dCA/IGluZGV4SW5QYXJlbnQgKyAxIDogaW5kZXhJblBhcmVudCAtIDE7XG4gICAgICAgIGNvbnN0IGxhc3RWaXNpYmxlSW5kZXggPSB0aGlzLmdyaWQucGFyZW50Lm5hdmlnYXRpb24ubGFzdENvbHVtbkluZGV4O1xuICAgICAgICBjb25zdCBuZXh0Q29sdW1uSW5kZXggPSBjb2x1bW5JbmRleCA8PSBsYXN0VmlzaWJsZUluZGV4ID8gY29sdW1uSW5kZXggOiBsYXN0VmlzaWJsZUluZGV4O1xuICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IGNiRnVuYyA9IChhcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgY2IoYXJncyk7XG4gICAgICAgICAgICBhcmdzLnRhcmdldC5ncmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ncmlkLnBhcmVudC5uYXZpZ2F0aW9uLm5hdmlnYXRlSW5Cb2R5KHRhcmdldFJvd0luZGV4LCBuZXh0Q29sdW1uSW5kZXgsIGNiRnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBpbmZvcm1hdGlvbiBvbiB0aGUgcm93IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSByb290IGdyaWQgdmlldyBwb3J0LlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgcm93IGlzIGluIHZpZXcgYW5kIGl0cyBvZmZzZXQuXG4gICAgICogQHBhcmFtIHJvd09ialxuICAgICAqIEBwYXJhbSBpc05leHRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0UG9zaXRpb25JbmZvKHJvd09iajogSWd4Um93RGlyZWN0aXZlPElneEdyaWRCYXNlRGlyZWN0aXZlICYgR3JpZFR5cGU+LCBpc05leHQ6IGJvb2xlYW4pIHtcbiAgICAgICAgbGV0IHJvd0VsZW0gPSByb3dPYmoubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKHJvd09iaiBpbnN0YW5jZW9mIElneENoaWxkR3JpZFJvd0NvbXBvbmVudCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRMYXlvdXRLZXlzID0gdGhpcy5ncmlkLmNoaWxkTGF5b3V0S2V5cztcbiAgICAgICAgICAgIGNvbnN0IHJpS2V5ID0gaXNOZXh0ID8gY2hpbGRMYXlvdXRLZXlzWzBdIDogY2hpbGRMYXlvdXRLZXlzW2NoaWxkTGF5b3V0S2V5cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhTZWdtZW50OiBJUGF0aFNlZ21lbnQgPSB7XG4gICAgICAgICAgICAgICAgcm93SUQ6IHJvd09iai5yb3dEYXRhLnJvd0lELFxuICAgICAgICAgICAgICAgIHJvd0lzbGFuZEtleTogcmlLZXlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjaGlsZEdyaWQgPSAgdGhpcy5ncmlkLmhncmlkQVBJLmdldENoaWxkR3JpZChbcGF0aFNlZ21lbnRdKTtcbiAgICAgICAgICAgIHJvd0VsZW0gPSBjaGlsZEdyaWQudGZvb3QubmF0aXZlRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncmlkQm90dG9tID0gdGhpcy5fZ2V0TWluQm90dG9tKHRoaXMuZ3JpZCk7XG4gICAgICAgIGNvbnN0IGRpZmZCb3R0b20gPVxuICAgICAgICByb3dFbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIGdyaWRCb3R0b207XG4gICAgICAgIGNvbnN0IGdyaWRUb3AgPSB0aGlzLl9nZXRNYXhUb3AodGhpcy5ncmlkKTtcbiAgICAgICAgY29uc3QgZGlmZlRvcCA9IHJvd0VsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC1cbiAgICAgICAgcm93RWxlbS5vZmZzZXRIZWlnaHQgLSBncmlkVG9wO1xuICAgICAgICBjb25zdCBpc0luVmlldyA9IGlzTmV4dCA/IGRpZmZCb3R0b20gPD0gMCA6IGRpZmZUb3AgPj0gMDtcbiAgICAgICAgY29uc3QgY2FsY09mZnNldCA9ICBpc05leHQgPyBkaWZmQm90dG9tIDogZGlmZlRvcDtcblxuICAgICAgICByZXR1cm4geyBpblZpZXc6IGlzSW5WaWV3LCBvZmZzZXQ6IGNhbGNPZmZzZXQgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFyQWN0aXZhdGlvbigpIHtcbiAgICAgICAgLy8gY2xlYXIgaWYgcHJldmlvdXMgYWN0aXZhdGlvbiBleGlzdHMuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTm9kZS5yb3cgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYXNOZXh0VGFyZ2V0KGdyaWQsIGluZGV4OiBudW1iZXIsIGlzTmV4dDogYm9vbGVhbikge1xuICAgICAgICBjb25zdCB0YXJnZXRSb3dJbmRleCA9ICBpc05leHQgPyBpbmRleCArIDEgOiBpbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGhhc1RhcmdldFJlY29yZCA9ICEhZ3JpZC5kYXRhVmlld1t0YXJnZXRSb3dJbmRleF07XG4gICAgICAgIGlmIChoYXNUYXJnZXRSZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGhhc1RhcmdldFJlY29yZEluUGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZ3JpZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleEluUGFyZW50ID0gZ3JpZC5jaGlsZFJvdy5pbmRleDtcbiAgICAgICAgICAgICAgICBoYXNUYXJnZXRSZWNvcmRJblBhcmVudCA9IHRoaXMuaGFzTmV4dFRhcmdldChncmlkLnBhcmVudCwgaW5kZXhJblBhcmVudCwgaXNOZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYXNUYXJnZXRSZWNvcmRJblBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2xvc2VzdCBlbGVtZW50IGJ5IGl0cyB0YWcgbmFtZS5cbiAgICAgKiBAcGFyYW0gc291cmNlRWxlbSBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHN0YXJ0IHRoZSBzZWFyY2guXG4gICAgICogQHBhcmFtIHRhcmdldFRhZyBUaGUgdGFyZ2V0IGVsZW1lbnQgdGFnIG5hbWUsIGZvciB3aGljaCB0byBzZWFyY2guXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldENsb3Nlc3RFbGVtQnlUYWcoc291cmNlRWxlbSwgdGFyZ2V0VGFnKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzb3VyY2VFbGVtO1xuICAgICAgICB3aGlsZSAocmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHRhcmdldFRhZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1heCB0b3AgdmlldyBpbiB0aGUgY3VycmVudCBncmlkIGhpZXJhcmNoeS5cbiAgICAgKiBAcGFyYW0gZ3JpZFxuICAgICAqL1xuICAgIHByaXZhdGUgX2dldE1heFRvcChncmlkKSB7XG4gICAgICAgIGxldCBjdXJyR3JpZCA9IGdyaWQ7XG4gICAgICAgIGxldCB0b3AgPSBjdXJyR3JpZC50Ym9keS5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgd2hpbGUgKGN1cnJHcmlkLnBhcmVudCkge1xuICAgICAgICAgICAgY3VyckdyaWQgPSBjdXJyR3JpZC5wYXJlbnQ7XG4gICAgICAgICAgICBjb25zdCBwaW5uZWRSb3dzSGVpZ2h0ID0gY3VyckdyaWQuaGFzUGlubmVkUmVjb3JkcyAmJiBjdXJyR3JpZC5pc1Jvd1Bpbm5pbmdUb1RvcCA/IGN1cnJHcmlkLnBpbm5lZFJvd0hlaWdodCA6IDA7XG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIGN1cnJHcmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgcGlubmVkUm93c0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtaW4gYm90dG9tIHZpZXcgaW4gdGhlIGN1cnJlbnQgZ3JpZCBoaWVyYXJjaHkuXG4gICAgICogQHBhcmFtIGdyaWRcbiAgICAgKi9cbiAgICBwcml2YXRlIF9nZXRNaW5Cb3R0b20oZ3JpZCkge1xuICAgICAgICBsZXQgY3VyckdyaWQgPSBncmlkO1xuICAgICAgICBsZXQgYm90dG9tID0gY3VyckdyaWQudGJvZHkubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b207XG4gICAgICAgIHdoaWxlIChjdXJyR3JpZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGN1cnJHcmlkID0gY3VyckdyaWQucGFyZW50O1xuICAgICAgICAgICAgY29uc3QgcGlubmVkUm93c0hlaWdodCA9IGN1cnJHcmlkLmhhc1Bpbm5lZFJlY29yZHMgJiYgIWN1cnJHcmlkLmlzUm93UGlubmluZ1RvVG9wID8gY3VyckdyaWQucGlubmVkUm93SGVpZ2h0IDogMDtcbiAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWluKGJvdHRvbSwgY3VyckdyaWQudGJvZHkubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBwaW5uZWRSb3dzSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm90dG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBuZXh0IGdyaWQgdGhhdCBhbGxvd3Mgc2Nyb2xsaW5nIGRvd24uXG4gICAgICogQHBhcmFtIGdyaWQgVGhlIGdyaWQgZnJvbSB3aGljaCB0byBiZWdpbiB0aGUgc2VhcmNoLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0TmV4dFNjcm9sbGFibGVEb3duKGdyaWQpIHtcbiAgICAgICAgbGV0IGN1cnJHcmlkID0gZ3JpZC5wYXJlbnQ7XG4gICAgICAgIGlmICghY3VyckdyaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGdyaWQ6IGdyaWQsIHByZXY6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuc2Nyb2xsUG9zaXRpb247XG4gICAgICAgIGxldCBzY3JvbGxIZWlnaHQgPSBjdXJyR3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5nZXRTY3JvbGwoKS5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIGxldCBub25TY3JvbGxhYmxlID0gc2Nyb2xsSGVpZ2h0ID09PSAwIHx8XG4gICAgICAgICAgICBNYXRoLnJvdW5kKHNjcm9sbFRvcCArIGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmlneEZvckNvbnRhaW5lclNpemUpID09PSBzY3JvbGxIZWlnaHQ7XG4gICAgICAgIGxldCBwcmV2ID0gZ3JpZDtcbiAgICAgICAgd2hpbGUgKG5vblNjcm9sbGFibGUgJiYgY3VyckdyaWQucGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmV2ID0gY3VyckdyaWQ7XG4gICAgICAgICAgICBjdXJyR3JpZCA9IGN1cnJHcmlkLnBhcmVudDtcbiAgICAgICAgICAgIHNjcm9sbFRvcCA9IGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFBvc2l0aW9uO1xuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsKCkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgbm9uU2Nyb2xsYWJsZSA9IHNjcm9sbEhlaWdodCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoc2Nyb2xsVG9wICsgY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuaWd4Rm9yQ29udGFpbmVyU2l6ZSkgPT09IHNjcm9sbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBncmlkOiBjdXJyR3JpZCwgcHJldjogcHJldiB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBuZXh0IGdyaWQgdGhhdCBhbGxvd3Mgc2Nyb2xsaW5nIHVwLlxuICAgICAqIEBwYXJhbSBncmlkIFRoZSBncmlkIGZyb20gd2hpY2ggdG8gYmVnaW4gdGhlIHNlYXJjaC5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldE5leHRTY3JvbGxhYmxlVXAoZ3JpZCkge1xuICAgICAgICBsZXQgY3VyckdyaWQgPSBncmlkLnBhcmVudDtcbiAgICAgICAgaWYgKCFjdXJyR3JpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZ3JpZDogZ3JpZCwgcHJldjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBub25TY3JvbGxhYmxlID0gY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuc2Nyb2xsUG9zaXRpb24gPT09IDA7XG4gICAgICAgIGxldCBwcmV2ID0gZ3JpZDtcbiAgICAgICAgd2hpbGUgKG5vblNjcm9sbGFibGUgJiYgY3VyckdyaWQucGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmV2ID0gY3VyckdyaWQ7XG4gICAgICAgICAgICBjdXJyR3JpZCA9IGN1cnJHcmlkLnBhcmVudDtcbiAgICAgICAgICAgIG5vblNjcm9sbGFibGUgPSBjdXJyR3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5zY3JvbGxQb3NpdGlvbiA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBncmlkOiBjdXJyR3JpZCwgcHJldjogcHJldiB9O1xuICAgIH1cbn1cbiJdfQ==