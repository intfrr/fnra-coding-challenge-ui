import { Component, ContentChild, ElementRef, EventEmitter, HostBinding, Inject, Input, Optional, Output, ViewChild, Renderer2 } from '@angular/core';
import { fromEvent, interval } from 'rxjs';
import { debounce } from 'rxjs/operators';
import { IgxNavigationService } from '../core/navigation';
import { HammerGesturesManager } from '../core/touch';
import { IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective } from './navigation-drawer.directives';
import { PlatformUtil } from '../core/utils';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../core/navigation';
import * as ɵngcc2 from '../core/touch';
import * as ɵngcc3 from '../core/utils';
import * as ɵngcc4 from '@angular/common';
import * as ɵngcc5 from './navigation-drawer.directives';

const _c0 = ["aside"];
const _c1 = ["overlay"];
const _c2 = ["dummy"];
function IgxNavigationDrawerComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtext(1, "Navigation Drawer");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "div", 9);
    ɵngcc0.ɵɵtext(3, " Start by adding");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "div", 9);
    ɵngcc0.ɵɵelementStart(5, "code");
    ɵngcc0.ɵɵtext(6, "<ng-template igxDrawer>");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "div", 9);
    ɵngcc0.ɵɵtext(8, " And some items inside ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "div", 9);
    ɵngcc0.ɵɵtext(10, " Style with igxDrawerItem ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(11, "div", 9);
    ɵngcc0.ɵɵtext(12, " and igxRipple directives");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("isHeader", true);
} }
function IgxNavigationDrawerComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
let NEXT_ID = 0;
/**
 * **Ignite UI for Angular Navigation Drawer** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer)
 *
 * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
 *
 * Example:
 * ```html
 * <igx-nav-drawer id="navigation" [isOpen]="true">
 *   <ng-template igxDrawer>
 *     <nav>
 *       <span igxDrawerItem [isHeader]="true">Email</span>
 *       <span igxDrawerItem igxRipple>Inbox</span>
 *       <span igxDrawerItem igxRipple>Deleted</span>
 *       <span igxDrawerItem igxRipple>Sent</span>
 *     </nav>
 *   </ng-template>
 * </igx-nav-drawer>
 * ```
 */
export class IgxNavigationDrawerComponent {
    constructor(elementRef, _state, renderer, _touchManager, platformUtil) {
        this.elementRef = elementRef;
        this._state = _state;
        this.renderer = renderer;
        this._touchManager = _touchManager;
        this.platformUtil = platformUtil;
        this._isOpen = false;
        /** @hidden @internal */
        this.cssClass = true;
        /**
         * ID of the component
         *
         * ```typescript
         * // get
         * let myNavDrawerId = this.navdrawer.id;
         * ```
         *
         * ```html
         * <!--set-->
         *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
         * ```
         */
        this.id = `igx-nav-drawer-${NEXT_ID++}`;
        /**
         * Position of the Navigation Drawer. Can be "left"(default) or "right".
         *
         * ```typescript
         * // get
         * let myNavDrawerPosition = this.navdrawer.position;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
         * ```
         */
        this.position = 'left';
        /**
         * Enables the use of touch gestures to manipulate the drawer:
         * - swipe/pan from edge to open, swipe-toggle and pan-drag.
         *
         * ```typescript
         * // get
         * let gesturesEnabled = this.navdrawer.enableGestures;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
         * ```
         */
        this.enableGestures = true;
        /**
         * @hidden
         */
        this.isOpenChange = new EventEmitter();
        /**
         * When pinned the drawer is relatively positioned instead of sitting above content.
         * May require additional layout styling.
         *
         * ```typescript
         * // get
         * let navDrawerIsPinned = this.navdrawer.pin;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
         * ```
         */
        this.pin = false;
        /**
         * Minimum device width required for automatic pin to be toggled.
         * Default is 1024, can be set to a falsy value to disable this behavior.
         *
         * ```typescript
         * // get
         * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
         * ```
         */
        this.pinThreshold = 1024;
        /**
         * Width of the drawer in its open state. Defaults to "280px".
         *
         * ```typescript
         * // get
         * let navDrawerWidth = this.navdrawer.width;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
         * ```
         */
        this.width = '280px';
        /**
         * Enables/disables the animation, when toggling the drawer. Set to `false` by default.
         * ````html
         * <igx-nav-drawer [disableAnimation]="true"></igx-nav-drawer>
         * ````
         */
        this.disableAnimation = false;
        /**
         * Width of the drawer in its mini state. Defaults to 68px.
         *
         * ```typescript
         * // get
         * let navDrawerMiniWidth = this.navdrawer.miniWidth;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
         * ```
         */
        this.miniWidth = '68px';
        /**
         * Pinned state change output for two-way binding.
         *
         * ```html
         * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
         * ```
         */
        this.pinChange = new EventEmitter(true);
        /**
         * Event fired as the Navigation Drawer is about to open.
         *
         * ```html
         *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
         * ```
         */
        this.opening = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has opened.
         *
         * ```html
         * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
         * ```
         */
        this.opened = new EventEmitter();
        /**
         * Event fired as the Navigation Drawer is about to close.
         *
         * ```html
         * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
         * ```
         */
        this.closing = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has closed.
         *
         * ```html
         * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
         * ```
         */
        this.closed = new EventEmitter();
        this._gesturesAttached = false;
        this._widthCache = { width: null, miniWidth: null, windowWidth: null };
        this.css = {
            drawer: 'igx-nav-drawer__aside',
            mini: 'igx-nav-drawer__aside--mini',
            overlay: 'igx-nav-drawer__overlay',
            styleDummy: 'igx-nav-drawer__style-dummy'
        };
        /** Pan animation properties */
        this._panning = false;
        this._maxEdgeZone = 50;
        this.checkPinThreshold = (evt) => {
            if (!this.platformUtil.isBrowser) {
                return;
            }
            let windowWidth;
            if (this.pinThreshold) {
                windowWidth = this.getWindowWidth();
                if (evt && this._widthCache.windowWidth === windowWidth) {
                    return;
                }
                this._widthCache.windowWidth = windowWidth;
                if (!this.pin && windowWidth >= this.pinThreshold) {
                    this.pin = true;
                    this.pinChange.emit(true);
                }
                else if (this.pin && windowWidth < this.pinThreshold) {
                    this.pin = false;
                    this.pinChange.emit(false);
                }
            }
        };
        this.swipe = (evt) => {
            // TODO: Could also force input type: http://stackoverflow.com/a/27108052
            if (!this.enableGestures || evt.pointerType !== 'touch') {
                return;
            }
            // HammerJS swipe is horizontal-only by default, don't check deltaY
            let deltaX;
            let startPosition;
            if (this.position === 'right') {
                // when on the right use inverse of deltaX
                deltaX = -evt.deltaX;
                startPosition = this.getWindowWidth() - (evt.center.x + evt.distance);
            }
            else {
                deltaX = evt.deltaX;
                startPosition = evt.center.x - evt.distance;
            }
            // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
            if ((this.isOpen && deltaX < 0) ||
                // positive deltaX from the edge:
                (deltaX > 0 && startPosition < this.maxEdgeZone)) {
                this.toggle();
            }
        };
        this.panstart = (evt) => {
            if (!this.enableGestures || this.pin || evt.pointerType !== 'touch') {
                return;
            }
            const startPosition = this.position === 'right' ? this.getWindowWidth() - (evt.center.x + evt.distance)
                : evt.center.x - evt.distance;
            // cache width during animation, flag to allow further handling
            if (this.isOpen || (startPosition < this.maxEdgeZone)) {
                this._panning = true;
                this._panStartWidth = this.getExpectedWidth(!this.isOpen);
                this._panLimit = this.getExpectedWidth(this.isOpen);
                this.renderer.addClass(this.overlay, 'panning');
                this.renderer.addClass(this.drawer, 'panning');
            }
        };
        this.pan = (evt) => {
            // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
            // get actual delta (not total session one) from event?
            // pan WILL also fire after a full swipe, only resize on flag
            if (!this._panning) {
                return;
            }
            const right = this.position === 'right';
            // when on the right use inverse of deltaX
            const deltaX = right ? -evt.deltaX : evt.deltaX;
            let visibleWidth;
            let newX;
            let percent;
            visibleWidth = this._panStartWidth + deltaX;
            if (this.isOpen && deltaX < 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth <= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panLimit) / (this._panStartWidth - this._panLimit);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panStartWidth;
                    newX = evt.deltaX;
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
            else if (!this.isOpen && deltaX > 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth >= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panStartWidth) / (this._panLimit - this._panStartWidth);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panLimit;
                    newX = (this._panLimit - visibleWidth) * (right ? 1 : -1);
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
        };
        this.panEnd = (evt) => {
            if (this._panning) {
                const deltaX = this.position === 'right' ? -evt.deltaX : evt.deltaX;
                const visibleWidth = this._panStartWidth + deltaX;
                this.resetPan();
                // check if pan brought the drawer to 50%
                if (this.isOpen && visibleWidth <= this._panStartWidth / 2) {
                    this.close();
                }
                else if (!this.isOpen && visibleWidth >= this._panLimit / 2) {
                    this.open();
                }
                this._panStartWidth = null;
            }
        };
        this.toggleOpenedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleOpenedEvent, false);
            this.opened.emit();
        };
        this.toggleClosedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleClosedEvent, false);
            this.closed.emit();
        };
    }
    /**
     * State of the drawer.
     *
     * ```typescript
     * // get
     * let navDrawerIsOpen = this.navdrawer.isOpen;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <!--set-->
     * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>
     * ```
     */
    get isOpen() {
        return this._isOpen;
    }
    set isOpen(value) {
        this._isOpen = value;
        this.isOpenChange.emit(this._isOpen);
    }
    /**
     * Returns nativeElement of the component.
     *
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get template() {
        if (this.miniTemplate && !this.isOpen) {
            return this.miniTemplate.template;
        }
        else if (this.contentTemplate) {
            return this.contentTemplate.template;
        }
    }
    /**
     * @hidden
     */
    get miniTemplate() {
        return this._miniTemplate;
    }
    /**
     * @hidden
     */
    set miniTemplate(v) {
        if (!this.isOpen) {
            this.setDrawerWidth(v ? this.miniWidth : '');
        }
        this._miniTemplate = v;
    }
    /**
     * @hidden
     */
    get flexWidth() {
        if (!this.pin) {
            return '0px';
        }
        if (this.isOpen) {
            return this.width;
        }
        if (this.miniTemplate && this.miniWidth) {
            return this.miniWidth;
        }
        return '0px';
    }
    /** @hidden */
    get isPinnedRight() {
        return this.pin && this.position === 'right' ? '1' : '0';
    }
    /**
     * @hidden
     */
    get drawer() {
        return this._drawer.nativeElement;
    }
    /**
     * @hidden
     */
    get overlay() {
        return this._overlay.nativeElement;
    }
    /**
     * @hidden
     */
    get styleDummy() {
        return this._styleDummy.nativeElement;
    }
    /**
     * Property to decide whether to change width or translate the drawer from pan gesture.
     *
     * @hidden
     */
    get hasAnimateWidth() {
        return this.pin || !!this.miniTemplate;
    }
    /**
     * Used for touch gestures (swipe and pan).
     * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
     *
     * @hidden
     */
    get maxEdgeZone() {
        return this._maxEdgeZone;
    }
    /**
     * Gets the Drawer width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     *
     * @hidden
     */
    get expectedWidth() {
        return this.getExpectedWidth(false);
    }
    /**
     * Get the Drawer mini width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     * @hidden
     */
    get expectedMiniWidth() {
        return this.getExpectedWidth(true);
    }
    /**
     * @hidden
     */
    get touchManager() {
        return this._touchManager;
    }
    /**
     * Exposes optional navigation service
     *
     * @hidden
     */
    get state() {
        return this._state;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        // DOM and @Input()-s initialized
        if (this._state) {
            this._state.add(this.id, this);
        }
        if (this.isOpen) {
            this.setDrawerWidth(this.width);
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        // wait for template and ng-content to be ready
        this.updateEdgeZone();
        this.checkPinThreshold();
        this.ensureEvents();
        // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
        // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._touchManager.destroy();
        if (this._state) {
            this._state.remove(this.id);
        }
        if (this._resizeObserver) {
            this._resizeObserver.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
        if (changes.enableGestures && changes.enableGestures.currentValue !== undefined) {
            this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
            this.ensureEvents();
        }
        if (changes.pin && changes.pin.currentValue !== undefined) {
            this.pin = !!(this.pin && this.pin.toString() === 'true');
            if (this.pin) {
                this._touchManager.destroy();
                this._gesturesAttached = false;
            }
            else {
                this.ensureEvents();
            }
        }
        if (changes.pinThreshold) {
            if (this.pinThreshold) {
                this.ensureEvents();
                this.checkPinThreshold();
            }
        }
        if (changes.width && this.isOpen) {
            this.setDrawerWidth(changes.width.currentValue);
        }
        if (changes.isOpen) {
            this.setDrawerWidth(this.isOpen ? this.width : (this.miniTemplate ? this.miniWidth : ''));
        }
        if (changes.miniWidth) {
            if (!this.isOpen) {
                this.setDrawerWidth(changes.miniWidth.currentValue);
            }
            this.updateEdgeZone();
        }
    }
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     */
    toggle() {
        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     */
    open() {
        if (this._panning) {
            this.resetPan();
        }
        if (this.isOpen) {
            return;
        }
        this.opening.emit();
        this.isOpen = true;
        // TODO: Switch to animate API when available
        // var animationCss = this.animate.css();
        //     animationCss
        //         .setStyles({'width':'50px'}, {'width':'400px'})
        //         .start(this.elementRef.nativeElement)
        //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
        this.setDrawerWidth(this.width);
    }
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     */
    close() {
        if (this._panning) {
            this.resetPan();
        }
        if (!this.isOpen) {
            return;
        }
        this.closing.emit();
        this.isOpen = false;
        this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
    }
    /**
     * @hidden
     */
    set_maxEdgeZone(value) {
        this._maxEdgeZone = value;
    }
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @param [mini] - Request mini width instead
     */
    getExpectedWidth(mini) {
        if (mini) {
            if (!this.miniTemplate) {
                return 0;
            }
            if (this.miniWidth) {
                return parseFloat(this.miniWidth);
            }
            else {
                // if (!this.isOpen) { // This WON'T work due to transition timings...
                //     return this.elementRef.nativeElement.children[1].offsetWidth;
                // } else {
                if (this._widthCache.miniWidth === null) {
                    // force class for width calc. TODO?
                    // force class for width calc. TODO?
                    this.renderer.addClass(this.styleDummy, this.css.drawer);
                    this.renderer.addClass(this.styleDummy, this.css.mini);
                    this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                    this.renderer.removeClass(this.styleDummy, this.css.drawer);
                    this.renderer.removeClass(this.styleDummy, this.css.mini);
                }
                return this._widthCache.miniWidth;
            }
        }
        else {
            if (this.width) {
                return parseFloat(this.width);
            }
            else {
                if (this._widthCache.width === null) {
                    // force class for width calc. TODO?
                    // force class for width calc. TODO?
                    this.renderer.addClass(this.styleDummy, this.css.drawer);
                    this._widthCache.width = this.styleDummy.offsetWidth;
                    this.renderer.removeClass(this.styleDummy, this.css.drawer);
                }
                return this._widthCache.width;
            }
        }
    }
    getWindowWidth() {
        return (window.innerWidth > 0) ? window.innerWidth : screen.width;
    }
    /**
     * Sets the drawer width.
     */
    setDrawerWidth(width) {
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(() => {
                if (this.drawer) {
                    this.renderer.setStyle(this.drawer, 'width', width);
                }
            });
        }
        else {
            this.renderer.setStyle(this.drawer, 'width', width);
        }
    }
    /**
     * Get current Drawer width.
     */
    getDrawerWidth() {
        return this.drawer.offsetWidth;
    }
    ensureEvents() {
        // set listeners for swipe/pan only if needed, but just once
        if (this.enableGestures && !this.pin && !this._gesturesAttached) {
            // Built-in manager handler(L20887) causes endless loop and max stack exception.
            // https://github.com/angular/angular/issues/6993
            // Use ours for now (until beta.10):
            // this.renderer.listen(document, "swipe", this.swipe);
            this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);
            this._gesturesAttached = true;
            // this.renderer.listen(document, "panstart", this.panstart);
            // this.renderer.listen(document, "pan", this.pan);
            this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);
            this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);
            this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
        }
        if (!this._resizeObserver && this.platformUtil.isBrowser) {
            this._resizeObserver = fromEvent(window, 'resize').pipe(debounce(() => interval(150)))
                .subscribe((value) => {
                this.checkPinThreshold(value);
            });
        }
    }
    updateEdgeZone() {
        let maxValue;
        if (this.miniTemplate) {
            maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
            this.set_maxEdgeZone(maxValue);
        }
    }
    resetPan() {
        this._panning = false;
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        this.renderer.removeClass(this.overlay, 'panning');
        this.renderer.removeClass(this.drawer, 'panning');
        this.setXSize(0, '');
    }
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @param x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param opacity optional value to apply to the overlay
     */
    setXSize(x, opacity) {
        // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
        window.requestAnimationFrame(() => {
            if (this.hasAnimateWidth) {
                this.renderer.setStyle(this.drawer, 'width', x ? Math.abs(x) + 'px' : '');
            }
            else {
                this.renderer.setStyle(this.drawer, 'transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
                this.renderer.setStyle(this.drawer, '-webkit-transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
            }
            if (opacity !== undefined) {
                this.renderer.setStyle(this.overlay, 'opacity', opacity);
            }
        });
    }
}
IgxNavigationDrawerComponent.ɵfac = function IgxNavigationDrawerComponent_Factory(t) { return new (t || IgxNavigationDrawerComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IgxNavigationService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.HammerGesturesManager), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.PlatformUtil)); };
IgxNavigationDrawerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxNavigationDrawerComponent, selectors: [["igx-nav-drawer"]], contentQueries: function IgxNavigationDrawerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxNavDrawerMiniTemplateDirective, true, IgxNavDrawerMiniTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxNavDrawerTemplateDirective, true, IgxNavDrawerTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.miniTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
    } }, viewQuery: function IgxNavigationDrawerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
        ɵngcc0.ɵɵstaticViewQuery(_c1, true);
        ɵngcc0.ɵɵstaticViewQuery(_c2, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._drawer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._overlay = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._styleDummy = _t.first);
    } }, hostVars: 9, hostBindings: function IgxNavigationDrawerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵstyleProp("flex-basis", ctx.flexWidth)("order", ctx.isPinnedRight);
        ɵngcc0.ɵɵclassProp("igx-nav-drawer", ctx.cssClass)("igx-nav-drawer--disable-animation", ctx.disableAnimation);
    } }, inputs: { id: "id", position: "position", enableGestures: "enableGestures", pin: "pin", pinThreshold: "pinThreshold", width: "width", disableAnimation: "disableAnimation", miniWidth: "miniWidth", isOpen: "isOpen" }, outputs: { isOpenChange: "isOpenChange", pinChange: "pinChange", opening: "opening", opened: "opened", closing: "closing", closed: "closed" }, features: [ɵngcc0.ɵɵProvidersFeature([HammerGesturesManager]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 9, vars: 18, consts: [["defaultItemsTemplate", ""], [1, "igx-nav-drawer__overlay", 3, "hidden", "click"], ["overlay", ""], ["role", "navigation", 1, "igx-nav-drawer__aside"], ["aside", ""], [4, "ngTemplateOutlet"], [1, "igx-nav-drawer__style-dummy"], ["dummy", ""], ["igxDrawerItem", "", 3, "isHeader"], ["igxDrawerItem", ""]], template: function IgxNavigationDrawerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxNavigationDrawerComponent_ng_template_0_Template, 13, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵlistener("click", function IgxNavigationDrawerComponent_Template_div_click_2_listener() { return ctx.close(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "aside", 3, 4);
        ɵngcc0.ɵɵtemplate(6, IgxNavigationDrawerComponent_ng_container_6_Template, 1, 0, "ng-container", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(7, "div", 6, 7);
    } if (rf & 2) {
        const _r0 = ɵngcc0.ɵɵreference(1);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("igx-nav-drawer__overlay--hidden", !ctx.isOpen)("igx-nav-drawer--disable-animation", ctx.disableAnimation);
        ɵngcc0.ɵɵproperty("hidden", ctx.pin);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("igx-nav-drawer__aside--collapsed", !ctx.miniTemplate && !ctx.isOpen)("igx-nav-drawer__aside--mini", ctx.miniTemplate && !ctx.isOpen)("igx-nav-drawer__aside--normal", !ctx.miniTemplate || ctx.isOpen)("igx-nav-drawer__aside--pinned", ctx.pin)("igx-nav-drawer__aside--right", ctx.position == "right")("igx-nav-drawer--disable-animation", ctx.disableAnimation);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template || _r0);
    } }, directives: [ɵngcc4.NgTemplateOutlet, ɵngcc5.IgxNavDrawerItemDirective], styles: ["[_nghost-%COMP%] {\n            display: block;\n            height: 100%;\n        }"] });
IgxNavigationDrawerComponent.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] },
    { type: Renderer2 },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];
IgxNavigationDrawerComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-nav-drawer',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    position: [{ type: Input }],
    enableGestures: [{ type: Input }],
    isOpen: [{ type: Input }],
    isOpenChange: [{ type: Output }],
    pin: [{ type: Input }],
    pinThreshold: [{ type: Input }],
    width: [{ type: Input }],
    disableAnimation: [{ type: HostBinding, args: ['class.igx-nav-drawer--disable-animation',] }, { type: Input }],
    miniWidth: [{ type: Input }],
    pinChange: [{ type: Output }],
    opening: [{ type: Output }],
    opened: [{ type: Output }],
    closing: [{ type: Output }],
    closed: [{ type: Output }],
    miniTemplate: [{ type: ContentChild, args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective },] }],
    contentTemplate: [{ type: ContentChild, args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective },] }],
    flexWidth: [{ type: HostBinding, args: ['style.flexBasis',] }],
    isPinnedRight: [{ type: HostBinding, args: ['style.order',] }],
    _drawer: [{ type: ViewChild, args: ['aside', { static: true },] }],
    _overlay: [{ type: ViewChild, args: ['overlay', { static: true },] }],
    _styleDummy: [{ type: ViewChild, args: ['dummy', { static: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavigationDrawerComponent, [{
        type: Component,
        args: [{
                providers: [HammerGesturesManager],
                selector: 'igx-nav-drawer',
                template: "<ng-template #defaultItemsTemplate>\n    <div igxDrawerItem [isHeader]=\"true\">Navigation Drawer</div>\n    <div igxDrawerItem> Start by adding</div>\n    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>\n    <div igxDrawerItem> And some items inside </div>\n    <div igxDrawerItem> Style with igxDrawerItem </div>\n    <div igxDrawerItem> and igxRipple directives</div>\n</ng-template>\n\n<div [hidden]=\"pin\"\n    class=\"igx-nav-drawer__overlay\"\n    [class.igx-nav-drawer__overlay--hidden]=\"!isOpen\"\n    [class.igx-nav-drawer--disable-animation]=\"disableAnimation\"\n    (click)=\"close()\" #overlay>\n</div>\n<aside role=\"navigation\"\n    class=\"igx-nav-drawer__aside\"\n    [class.igx-nav-drawer__aside--collapsed]=\"!miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--mini]=\"miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--normal]=\"!miniTemplate || isOpen\"\n    [class.igx-nav-drawer__aside--pinned]=\"pin\"\n    [class.igx-nav-drawer__aside--right]=\"position == 'right'\" #aside\n    [class.igx-nav-drawer--disable-animation]=\"disableAnimation\">\n\n    <ng-container *ngTemplateOutlet=\"template || defaultItemsTemplate\"></ng-container>\n</aside>\n<div class=\"igx-nav-drawer__style-dummy\" #dummy></div>\n",
                styles: [`
        :host {
            display: block;
            height: 100%;
        }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef, decorators: [{
                type: Inject,
                args: [ElementRef]
            }] }, { type: ɵngcc1.IgxNavigationService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.HammerGesturesManager }, { type: ɵngcc3.PlatformUtil }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-nav-drawer']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], position: [{
            type: Input
        }], enableGestures: [{
            type: Input
        }], isOpenChange: [{
            type: Output
        }], pin: [{
            type: Input
        }], pinThreshold: [{
            type: Input
        }], width: [{
            type: Input
        }], disableAnimation: [{
            type: HostBinding,
            args: ['class.igx-nav-drawer--disable-animation']
        }, {
            type: Input
        }], miniWidth: [{
            type: Input
        }], pinChange: [{
            type: Output
        }], opening: [{
            type: Output
        }], opened: [{
            type: Output
        }], closing: [{
            type: Output
        }], closed: [{
            type: Output
        }], isOpen: [{
            type: Input
        }], miniTemplate: [{
            type: ContentChild,
            args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective }]
        }], flexWidth: [{
            type: HostBinding,
            args: ['style.flexBasis']
        }], isPinnedRight: [{
            type: HostBinding,
            args: ['style.order']
        }], contentTemplate: [{
            type: ContentChild,
            args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective }]
        }], _drawer: [{
            type: ViewChild,
            args: ['aside', { static: true }]
        }], _overlay: [{
            type: ViewChild,
            args: ['overlay', { static: true }]
        }], _styleDummy: [{
            type: ViewChild,
            args: ['dummy', { static: true }]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdGlvbi1kcmF3ZXIuY29tcG9uZW50LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvbmF2aWdhdGlvbi1kcmF3ZXIvbmF2aWdhdGlvbi1kcmF3ZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFSCxTQUFTLEVBQ1QsWUFBWSxFQUNaLFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLE1BQU0sRUFDTixLQUFLLEVBSUwsUUFBUSxFQUNSLE1BQU0sRUFFTixTQUFTLEVBQ1QsU0FBUyxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUN6RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUMsT0FBTyxFQUFFLG9CQUFvQixFQUFlLE1BQU0sb0JBQW9CLENBQUM7QUFDdkUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxpQ0FBaUMsRUFBRSw2QkFBNkIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ2xILE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTdDLElBQUksT0FBTyxHQUFHLENBQUMsQ0FBQztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFZSCxNQUFNLE9BQU8sNEJBQTRCO0FBQUcsSUFvWHhDLFlBQ2dDLFVBQXNCLEVBQzlCLE1BQTRCLEVBQ3RDLFFBQW1CLEVBQ3JCLGFBQW9DLEVBQ3BDLFlBQTBCO0FBQzFDLFFBTG9DLGVBQVUsR0FBVixV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LDRCQWVBLFdBQVcsU0FBQyxhQUFhO0FBQ3pCLHNCQWNBLFNBQVMsU0FBQyxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO0FBQU8sdUJBQzFDLFNBQVMsU0FBQyxTQUFTLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO0FBQU8sMEJBQzVDLFNBQVMsU0FBQyxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO0FBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPbkNoYW5nZXMsXG4gICAgT25EZXN0cm95LFxuICAgIE9uSW5pdCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2ltcGxlQ2hhbmdlLFxuICAgIFZpZXdDaGlsZCxcbiAgICBSZW5kZXJlcjJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIGludGVydmFsLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSWd4TmF2aWdhdGlvblNlcnZpY2UsIElUb2dnbGVWaWV3IH0gZnJvbSAnLi4vY29yZS9uYXZpZ2F0aW9uJztcbmltcG9ydCB7IEhhbW1lckdlc3R1cmVzTWFuYWdlciB9IGZyb20gJy4uL2NvcmUvdG91Y2gnO1xuaW1wb3J0IHsgSWd4TmF2RHJhd2VyTWluaVRlbXBsYXRlRGlyZWN0aXZlLCBJZ3hOYXZEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSB9IGZyb20gJy4vbmF2aWdhdGlvbi1kcmF3ZXIuZGlyZWN0aXZlcyc7XG5pbXBvcnQgeyBQbGF0Zm9ybVV0aWwgfSBmcm9tICcuLi9jb3JlL3V0aWxzJztcblxubGV0IE5FWFRfSUQgPSAwO1xuLyoqXG4gKiAqKklnbml0ZSBVSSBmb3IgQW5ndWxhciBOYXZpZ2F0aW9uIERyYXdlcioqIC1cbiAqIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5pbmZyYWdpc3RpY3MuY29tL3Byb2R1Y3RzL2lnbml0ZS11aS1hbmd1bGFyL2FuZ3VsYXIvY29tcG9uZW50cy9uYXZkcmF3ZXIpXG4gKlxuICogVGhlIElnbml0ZSBVSSBOYXZpZ2F0aW9uIERyYXdlciBpcyBhIGNvbGxhcHNpYmxlIHNpZGUgbmF2aWdhdGlvbiBjb250YWluZXIgY29tbW9ubHkgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSBOYXZiYXIuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtbmF2LWRyYXdlciBpZD1cIm5hdmlnYXRpb25cIiBbaXNPcGVuXT1cInRydWVcIj5cbiAqICAgPG5nLXRlbXBsYXRlIGlneERyYXdlcj5cbiAqICAgICA8bmF2PlxuICogICAgICAgPHNwYW4gaWd4RHJhd2VySXRlbSBbaXNIZWFkZXJdPVwidHJ1ZVwiPkVtYWlsPC9zcGFuPlxuICogICAgICAgPHNwYW4gaWd4RHJhd2VySXRlbSBpZ3hSaXBwbGU+SW5ib3g8L3NwYW4+XG4gKiAgICAgICA8c3BhbiBpZ3hEcmF3ZXJJdGVtIGlneFJpcHBsZT5EZWxldGVkPC9zcGFuPlxuICogICAgICAgPHNwYW4gaWd4RHJhd2VySXRlbSBpZ3hSaXBwbGU+U2VudDwvc3Bhbj5cbiAqICAgICA8L25hdj5cbiAqICAgPC9uZy10ZW1wbGF0ZT5cbiAqIDwvaWd4LW5hdi1kcmF3ZXI+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgcHJvdmlkZXJzOiBbSGFtbWVyR2VzdHVyZXNNYW5hZ2VyXSxcbiAgICBzZWxlY3RvcjogJ2lneC1uYXYtZHJhd2VyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ25hdmlnYXRpb24tZHJhd2VyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZXM6IFtgXG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG4gICAgYF1cbn0pXG5leHBvcnQgY2xhc3MgSWd4TmF2aWdhdGlvbkRyYXdlckNvbXBvbmVudCBpbXBsZW1lbnRzXG4gICAgSVRvZ2dsZVZpZXcsXG4gICAgT25Jbml0LFxuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgT25EZXN0cm95LFxuICAgIE9uQ2hhbmdlcyB7XG5cbiAgICBwcml2YXRlIF9pc09wZW4gPSBmYWxzZTtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LW5hdi1kcmF3ZXInKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJRCBvZiB0aGUgY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG15TmF2RHJhd2VySWQgPSB0aGlzLm5hdmRyYXdlci5pZDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogIDxpZ3gtbmF2LWRyYXdlciBpZD0nbmF2ZHJhd2VyJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KCkgcHVibGljIGlkID0gYGlneC1uYXYtZHJhd2VyLSR7TkVYVF9JRCsrfWA7XG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiBvZiB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIuIENhbiBiZSBcImxlZnRcIihkZWZhdWx0KSBvciBcInJpZ2h0XCIuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG15TmF2RHJhd2VyUG9zaXRpb24gPSB0aGlzLm5hdmRyYXdlci5wb3NpdGlvbjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1uYXYtZHJhd2VyIFtwb3NpdGlvbl09XCInbGVmdCdcIj48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwb3NpdGlvbiA9ICdsZWZ0JztcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHVzZSBvZiB0b3VjaCBnZXN0dXJlcyB0byBtYW5pcHVsYXRlIHRoZSBkcmF3ZXI6XG4gICAgICogLSBzd2lwZS9wYW4gZnJvbSBlZGdlIHRvIG9wZW4sIHN3aXBlLXRvZ2dsZSBhbmQgcGFuLWRyYWcuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IGdlc3R1cmVzRW5hYmxlZCA9IHRoaXMubmF2ZHJhd2VyLmVuYWJsZUdlc3R1cmVzO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW2VuYWJsZUdlc3R1cmVzXT0ndHJ1ZSc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgZW5hYmxlR2VzdHVyZXMgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU3RhdGUgb2YgdGhlIGRyYXdlci5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbmF2RHJhd2VySXNPcGVuID0gdGhpcy5uYXZkcmF3ZXIuaXNPcGVuO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW2lzT3Blbl09J2ZhbHNlJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVHdvLXdheSBkYXRhIGJpbmRpbmcuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgWyhpc09wZW4pXT0nbW9kZWwuaXNPcGVuJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc09wZW47XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgaXNPcGVuKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2lzT3BlbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlzT3BlbkNoYW5nZS5lbWl0KHRoaXMuX2lzT3Blbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgaXNPcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBwaW5uZWQgdGhlIGRyYXdlciBpcyByZWxhdGl2ZWx5IHBvc2l0aW9uZWQgaW5zdGVhZCBvZiBzaXR0aW5nIGFib3ZlIGNvbnRlbnQuXG4gICAgICogTWF5IHJlcXVpcmUgYWRkaXRpb25hbCBsYXlvdXQgc3R5bGluZy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbmF2RHJhd2VySXNQaW5uZWQgPSB0aGlzLm5hdmRyYXdlci5waW47XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbcGluXT0nZmFsc2UnPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHBpbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBkZXZpY2Ugd2lkdGggcmVxdWlyZWQgZm9yIGF1dG9tYXRpYyBwaW4gdG8gYmUgdG9nZ2xlZC5cbiAgICAgKiBEZWZhdWx0IGlzIDEwMjQsIGNhbiBiZSBzZXQgdG8gYSBmYWxzeSB2YWx1ZSB0byBkaXNhYmxlIHRoaXMgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG5hdkRyYXdlclBpblRyZXNob2xkID0gdGhpcy5uYXZkcmF3ZXIucGluVGhyZXNob2xkO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW3BpblRyZXNob2xkXT0nMTAyNCc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgcGluVGhyZXNob2xkID0gMTAyNDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlRWxlbWVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgdGhlIGRyYXdlciBpbiBpdHMgb3BlbiBzdGF0ZS4gRGVmYXVsdHMgdG8gXCIyODBweFwiLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJXaWR0aCA9IHRoaXMubmF2ZHJhd2VyLndpZHRoO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW3dpZHRoXT1cIicyMjhweCdcIj48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyB3aWR0aCA9ICcyODBweCc7XG5cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMvZGlzYWJsZXMgdGhlIGFuaW1hdGlvbiwgd2hlbiB0b2dnbGluZyB0aGUgZHJhd2VyLiBTZXQgdG8gYGZhbHNlYCBieSBkZWZhdWx0LlxuICAgICAqIGBgYGBodG1sXG4gICAgICogPGlneC1uYXYtZHJhd2VyIFtkaXNhYmxlQW5pbWF0aW9uXT1cInRydWVcIj48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcgKCdjbGFzcy5pZ3gtbmF2LWRyYXdlci0tZGlzYWJsZS1hbmltYXRpb24nKVxuICAgIEBJbnB1dCgpIHB1YmxpYyBkaXNhYmxlQW5pbWF0aW9uID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgZHJhd2VyIGluIGl0cyBtaW5pIHN0YXRlLiBEZWZhdWx0cyB0byA2OHB4LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJNaW5pV2lkdGggPSB0aGlzLm5hdmRyYXdlci5taW5pV2lkdGg7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbbWluaVdpZHRoXT1cIiczNHB4J1wiPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIG1pbmlXaWR0aCA9ICc2OHB4JztcblxuICAgIC8qKlxuICAgICAqIFBpbm5lZCBzdGF0ZSBjaGFuZ2Ugb3V0cHV0IGZvciB0d28td2F5IGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1uYXYtZHJhd2VyIFsocGluKV09J2lzUGlubmVkJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcGluQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCBhcyB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIgaXMgYWJvdXQgdG8gb3Blbi5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiAgPGlneC1uYXYtZHJhd2VyIChvcGVuaW5nKT0nb25PcGVuaW5nKCknPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBvcGVuaW5nID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIE5hdmlnYXRpb24gRHJhd2VyIGhhcyBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1uYXYtZHJhd2VyIChvcGVuZWQpPSdvbk9wZW5lZCgpJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgb3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIGFzIHRoZSBOYXZpZ2F0aW9uIERyYXdlciBpcyBhYm91dCB0byBjbG9zZS5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgKGNsb3NpbmcpPSdvbkNsb3NpbmcoKSc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIGNsb3NpbmcgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIgaGFzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgKGNsb3NlZCk9J29uQ2xvc2VkKCknPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBjbG9zZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5taW5pVGVtcGxhdGUgJiYgIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW5pVGVtcGxhdGUudGVtcGxhdGU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb250ZW50VGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX21pbmlUZW1wbGF0ZTogSWd4TmF2RHJhd2VyTWluaVRlbXBsYXRlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1pbmlUZW1wbGF0ZSgpOiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluaVRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneE5hdkRyYXdlck1pbmlUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwdWJsaWMgc2V0IG1pbmlUZW1wbGF0ZSh2OiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aCh2ID8gdGhpcy5taW5pV2lkdGggOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWluaVRlbXBsYXRlID0gdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hOYXZEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hOYXZEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSB9KVxuICAgIHByb3RlY3RlZCBjb250ZW50VGVtcGxhdGU6IElneE5hdkRyYXdlclRlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuZmxleEJhc2lzJylcbiAgICBnZXQgZmxleFdpZHRoKCkge1xuICAgICAgICBpZiAoIXRoaXMucGluKSB7XG4gICAgICAgICAgICByZXR1cm4gJzBweCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taW5pVGVtcGxhdGUgJiYgdGhpcy5taW5pV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbmlXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnMHB4JztcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUub3JkZXInKVxuICAgIGdldCBpc1Bpbm5lZFJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waW4gJiYgdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/ICcxJyA6ICcwJztcbiAgICB9XG5cbiAgICBwcml2YXRlIF9nZXN0dXJlc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfd2lkdGhDYWNoZTogeyB3aWR0aDogbnVtYmVyLCBtaW5pV2lkdGg6IG51bWJlciwgd2luZG93V2lkdGg6IG51bWJlciB9ID0geyB3aWR0aDogbnVsbCwgbWluaVdpZHRoOiBudWxsLCB3aW5kb3dXaWR0aDogbnVsbCB9O1xuICAgIHByaXZhdGUgX3Jlc2l6ZU9ic2VydmVyOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBjc3M6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZzsgfSA9IHtcbiAgICAgICAgZHJhd2VyOiAnaWd4LW5hdi1kcmF3ZXJfX2FzaWRlJyxcbiAgICAgICAgbWluaTogJ2lneC1uYXYtZHJhd2VyX19hc2lkZS0tbWluaScsXG4gICAgICAgIG92ZXJsYXk6ICdpZ3gtbmF2LWRyYXdlcl9fb3ZlcmxheScsXG4gICAgICAgIHN0eWxlRHVtbXk6ICdpZ3gtbmF2LWRyYXdlcl9fc3R5bGUtZHVtbXknXG4gICAgfTtcblxuICAgIEBWaWV3Q2hpbGQoJ2FzaWRlJywgeyBzdGF0aWM6IHRydWUgfSkgcHJpdmF0ZSBfZHJhd2VyOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ292ZXJsYXknLCB7IHN0YXRpYzogdHJ1ZSB9KSBwcml2YXRlIF9vdmVybGF5OiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ2R1bW15JywgeyBzdGF0aWM6IHRydWUgfSkgcHJpdmF0ZSBfc3R5bGVEdW1teTogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZHJhd2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJhd2VyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBvdmVybGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc3R5bGVEdW1teSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRHVtbXkubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKiogUGFuIGFuaW1hdGlvbiBwcm9wZXJ0aWVzICovXG4gICAgcHJpdmF0ZSBfcGFubmluZyA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3BhblN0YXJ0V2lkdGg6IG51bWJlcjtcbiAgICBwcml2YXRlIF9wYW5MaW1pdDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgdG8gZGVjaWRlIHdoZXRoZXIgdG8gY2hhbmdlIHdpZHRoIG9yIHRyYW5zbGF0ZSB0aGUgZHJhd2VyIGZyb20gcGFuIGdlc3R1cmUuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBoYXNBbmltYXRlV2lkdGgoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpbiB8fCAhIXRoaXMubWluaVRlbXBsYXRlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX21heEVkZ2Vab25lID0gNTA7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgdG91Y2ggZ2VzdHVyZXMgKHN3aXBlIGFuZCBwYW4pLlxuICAgICAqIERlZmF1bHRzIHRvIDUwIChpbiBweCkgYW5kIGlzIGV4dGVuZGVkIHRvIGF0IGxlYXN0IDExMCUgb2YgdGhlIG1pbmkgdGVtcGxhdGUgd2lkdGggaWYgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWF4RWRnZVpvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhFZGdlWm9uZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBEcmF3ZXIgd2lkdGggZm9yIHNwZWNpZmljIHN0YXRlLlxuICAgICAqIFdpbGwgYXR0ZW1wdCB0byBldmFsdWF0ZSByZXF1ZXN0ZWQgc3RhdGUgYW5kIGNhY2hlLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBleHBlY3RlZFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFeHBlY3RlZFdpZHRoKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIERyYXdlciBtaW5pIHdpZHRoIGZvciBzcGVjaWZpYyBzdGF0ZS5cbiAgICAgKiBXaWxsIGF0dGVtcHQgdG8gZXZhbHVhdGUgcmVxdWVzdGVkIHN0YXRlIGFuZCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGV4cGVjdGVkTWluaVdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFeHBlY3RlZFdpZHRoKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRvdWNoTWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoTWFuYWdlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2VzIG9wdGlvbmFsIG5hdmlnYXRpb24gc2VydmljZVxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChFbGVtZW50UmVmKSBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3N0YXRlOiBJZ3hOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgcHJvdGVjdGVkIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICAgIHByaXZhdGUgX3RvdWNoTWFuYWdlcjogSGFtbWVyR2VzdHVyZXNNYW5hZ2VyLFxuICAgICAgICBwcml2YXRlIHBsYXRmb3JtVXRpbDogUGxhdGZvcm1VdGlsKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgLy8gRE9NIGFuZCBASW5wdXQoKS1zIGluaXRpYWxpemVkXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUuYWRkKHRoaXMuaWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aCh0aGlzLndpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICAvLyB3YWl0IGZvciB0ZW1wbGF0ZSBhbmQgbmctY29udGVudCB0byBiZSByZWFkeVxuICAgICAgICB0aGlzLnVwZGF0ZUVkZ2Vab25lKCk7XG4gICAgICAgIHRoaXMuY2hlY2tQaW5UaHJlc2hvbGQoKTtcblxuICAgICAgICB0aGlzLmVuc3VyZUV2ZW50cygpO1xuXG4gICAgICAgIC8vIFRPRE86IGFwcGx5IHBsYXRmb3JtLXNhZmUgUnVsZXIgZnJvbSBodHRwOi8vcGxua3IuY28vZWRpdC84MW5XRHlyZVlNemt1bmloZlJnWD9wPXByZXZpZXdcbiAgICAgICAgLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzY1MTUpLCBibG9ja2VkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzY5MDRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLnJlbW92ZSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHsgW3Byb3BOYW1lOiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xuICAgICAgICAvLyBzaW1wbGUgc2V0dGluZ3MgY2FuIGNvbWUgZnJvbSBhdHRyaWJ1dGUgc2V0IChyYXRoZXIgdGhhbiBiaW5kaW5nKSwgbWFrZSBzdXJlIGJvb2xlYW4gcHJvcHMgYXJlIGNvbnZlcnRlZFxuICAgICAgICBpZiAoY2hhbmdlcy5lbmFibGVHZXN0dXJlcyAmJiBjaGFuZ2VzLmVuYWJsZUdlc3R1cmVzLmN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUdlc3R1cmVzID0gISEodGhpcy5lbmFibGVHZXN0dXJlcyAmJiB0aGlzLmVuYWJsZUdlc3R1cmVzLnRvU3RyaW5nKCkgPT09ICd0cnVlJyk7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUV2ZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLnBpbiAmJiBjaGFuZ2VzLnBpbi5jdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5waW4gPSAhISh0aGlzLnBpbiAmJiB0aGlzLnBpbi50b1N0cmluZygpID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGluKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXN0dXJlc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlcy5waW5UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBpblRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1BpblRocmVzaG9sZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZXMud2lkdGggJiYgdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhd2VyV2lkdGgoY2hhbmdlcy53aWR0aC5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyYXdlcldpZHRoKHRoaXMuaXNPcGVuID8gdGhpcy53aWR0aCA6ICh0aGlzLm1pbmlUZW1wbGF0ZSA/IHRoaXMubWluaVdpZHRoIDogJycpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VzLm1pbmlXaWR0aCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJhd2VyV2lkdGgoY2hhbmdlcy5taW5pV2lkdGguY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWRnZVpvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgb3BlbiBzdGF0ZSBvZiB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5uYXZkcmF3ZXIudG9nZ2xlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIE5hdmlnYXRpb24gRHJhd2VyLiBIYXMgbm8gZWZmZWN0IGlmIGFscmVhZHkgb3BlbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubmF2ZHJhd2VyLm9wZW4oKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgb3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Bhbm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRQYW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZW5pbmcuZW1pdCgpO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG5cbiAgICAgICAgLy8gVE9ETzogU3dpdGNoIHRvIGFuaW1hdGUgQVBJIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgIC8vIHZhciBhbmltYXRpb25Dc3MgPSB0aGlzLmFuaW1hdGUuY3NzKCk7XG4gICAgICAgIC8vICAgICBhbmltYXRpb25Dc3NcbiAgICAgICAgLy8gICAgICAgICAuc2V0U3R5bGVzKHsnd2lkdGgnOic1MHB4J30sIHsnd2lkdGgnOic0MDBweCd9KVxuICAgICAgICAvLyAgICAgICAgIC5zdGFydCh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudClcbiAgICAgICAgLy8gICAgICAgICAub25Db21wbGV0ZSgoKSA9PiBhbmltYXRpb25Dc3Muc2V0VG9TdHlsZXMoeyd3aWR0aCc6J2F1dG8nfSkuc3RhcnQodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKTtcblxuICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy50b2dnbGVPcGVuZWRFdmVudCwgZmFsc2UpO1xuICAgICAgICB0aGlzLnNldERyYXdlcldpZHRoKHRoaXMud2lkdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBOYXZpZ2F0aW9uIERyYXdlci4gSGFzIG5vIGVmZmVjdCBpZiBhbHJlYWR5IGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm5hdmRyYXdlci5jbG9zZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Bhbm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRQYW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zaW5nLmVtaXQoKTtcblxuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldERyYXdlcldpZHRoKHRoaXMubWluaVRlbXBsYXRlID8gdGhpcy5taW5pV2lkdGggOiAnJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRvZ2dsZUNsb3NlZEV2ZW50LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzZXRfbWF4RWRnZVpvbmUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tYXhFZGdlWm9uZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgRHJhd2VyIHdpZHRoIGZvciBzcGVjaWZpYyBzdGF0ZS4gV2lsbCBhdHRlbXB0IHRvIGV2YWx1YXRlIHJlcXVlc3RlZCBzdGF0ZSBhbmQgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQHBhcmFtIFttaW5pXSAtIFJlcXVlc3QgbWluaSB3aWR0aCBpbnN0ZWFkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEV4cGVjdGVkV2lkdGgobWluaT86IGJvb2xlYW4pOiBudW1iZXIge1xuICAgICAgICBpZiAobWluaSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1pbmlUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWluaVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5taW5pV2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAoIXRoaXMuaXNPcGVuKSB7IC8vIFRoaXMgV09OJ1Qgd29yayBkdWUgdG8gdHJhbnNpdGlvbiB0aW1pbmdzLi4uXG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jaGlsZHJlblsxXS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aENhY2hlLm1pbmlXaWR0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBjbGFzcyBmb3Igd2lkdGggY2FsYy4gVE9ETz9cbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgY2xhc3MgZm9yIHdpZHRoIGNhbGMuIFRPRE8/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5zdHlsZUR1bW15LCB0aGlzLmNzcy5kcmF3ZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3MubWluaSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoQ2FjaGUubWluaVdpZHRoID0gdGhpcy5zdHlsZUR1bW15Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3MuZHJhd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzLm1pbmkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGhDYWNoZS5taW5pV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMud2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fd2lkdGhDYWNoZS53aWR0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBjbGFzcyBmb3Igd2lkdGggY2FsYy4gVE9ETz9cbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgY2xhc3MgZm9yIHdpZHRoIGNhbGMuIFRPRE8/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5zdHlsZUR1bW15LCB0aGlzLmNzcy5kcmF3ZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93aWR0aENhY2hlLndpZHRoID0gdGhpcy5zdHlsZUR1bW15Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3MuZHJhd2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoQ2FjaGUud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFdpbmRvd1dpZHRoKCkge1xuICAgICAgICByZXR1cm4gKHdpbmRvdy5pbm5lcldpZHRoID4gMCkgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IHNjcmVlbi53aWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkcmF3ZXIgd2lkdGguXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZXREcmF3ZXJXaWR0aCh3aWR0aDogc3RyaW5nKSB7XG4gICAgICAgIGlmICh0aGlzLnBsYXRmb3JtVXRpbC5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5kcmF3ZXIsICd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5kcmF3ZXIsICd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IERyYXdlciB3aWR0aC5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldERyYXdlcldpZHRoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdlci5vZmZzZXRXaWR0aDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGVuc3VyZUV2ZW50cygpIHtcbiAgICAgICAgLy8gc2V0IGxpc3RlbmVycyBmb3Igc3dpcGUvcGFuIG9ubHkgaWYgbmVlZGVkLCBidXQganVzdCBvbmNlXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUdlc3R1cmVzICYmICF0aGlzLnBpbiAmJiAhdGhpcy5fZ2VzdHVyZXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgLy8gQnVpbHQtaW4gbWFuYWdlciBoYW5kbGVyKEwyMDg4NykgY2F1c2VzIGVuZGxlc3MgbG9vcCBhbmQgbWF4IHN0YWNrIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzY5OTNcbiAgICAgICAgICAgIC8vIFVzZSBvdXJzIGZvciBub3cgKHVudGlsIGJldGEuMTApOlxuICAgICAgICAgICAgLy8gdGhpcy5yZW5kZXJlci5saXN0ZW4oZG9jdW1lbnQsIFwic3dpcGVcIiwgdGhpcy5zd2lwZSk7XG4gICAgICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcignZG9jdW1lbnQnLCAnc3dpcGUnLCB0aGlzLnN3aXBlKTtcbiAgICAgICAgICAgIHRoaXMuX2dlc3R1cmVzQXR0YWNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyB0aGlzLnJlbmRlcmVyLmxpc3Rlbihkb2N1bWVudCwgXCJwYW5zdGFydFwiLCB0aGlzLnBhbnN0YXJ0KTtcbiAgICAgICAgICAgIC8vIHRoaXMucmVuZGVyZXIubGlzdGVuKGRvY3VtZW50LCBcInBhblwiLCB0aGlzLnBhbik7XG4gICAgICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcignZG9jdW1lbnQnLCAncGFuc3RhcnQnLCB0aGlzLnBhbnN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlci5hZGRHbG9iYWxFdmVudExpc3RlbmVyKCdkb2N1bWVudCcsICdwYW5tb3ZlJywgdGhpcy5wYW4pO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIoJ2RvY3VtZW50JywgJ3BhbmVuZCcsIHRoaXMucGFuRW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3Jlc2l6ZU9ic2VydmVyICYmIHRoaXMucGxhdGZvcm1VdGlsLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBmcm9tRXZlbnQod2luZG93LCAncmVzaXplJykucGlwZShkZWJvdW5jZSgoKSA9PiBpbnRlcnZhbCgxNTApKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGluVGhyZXNob2xkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlRWRnZVpvbmUoKSB7XG4gICAgICAgIGxldCBtYXhWYWx1ZTtcblxuICAgICAgICBpZiAodGhpcy5taW5pVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXgodGhpcy5fbWF4RWRnZVpvbmUsIHRoaXMuZ2V0RXhwZWN0ZWRXaWR0aCh0cnVlKSAqIDEuMSk7XG4gICAgICAgICAgICB0aGlzLnNldF9tYXhFZGdlWm9uZShtYXhWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNoZWNrUGluVGhyZXNob2xkID0gKGV2dD86IEV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5wbGF0Zm9ybVV0aWwuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdpbmRvd1dpZHRoO1xuICAgICAgICBpZiAodGhpcy5waW5UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHdpbmRvd1dpZHRoID0gdGhpcy5nZXRXaW5kb3dXaWR0aCgpO1xuICAgICAgICAgICAgaWYgKGV2dCAmJiB0aGlzLl93aWR0aENhY2hlLndpbmRvd1dpZHRoID09PSB3aW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3dpZHRoQ2FjaGUud2luZG93V2lkdGggPSB3aW5kb3dXaWR0aDtcbiAgICAgICAgICAgIGlmICghdGhpcy5waW4gJiYgd2luZG93V2lkdGggPj0gdGhpcy5waW5UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5waW5DaGFuZ2UuZW1pdCh0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5waW4gJiYgd2luZG93V2lkdGggPCB0aGlzLnBpblRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5waW5DaGFuZ2UuZW1pdChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN3aXBlID0gKGV2dDogSGFtbWVySW5wdXQpID0+IHtcbiAgICAgICAgLy8gVE9ETzogQ291bGQgYWxzbyBmb3JjZSBpbnB1dCB0eXBlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNzEwODA1MlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlR2VzdHVyZXMgfHwgZXZ0LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW1tZXJKUyBzd2lwZSBpcyBob3Jpem9udGFsLW9ubHkgYnkgZGVmYXVsdCwgZG9uJ3QgY2hlY2sgZGVsdGFZXG4gICAgICAgIGxldCBkZWx0YVg7XG4gICAgICAgIGxldCBzdGFydFBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgLy8gd2hlbiBvbiB0aGUgcmlnaHQgdXNlIGludmVyc2Ugb2YgZGVsdGFYXG4gICAgICAgICAgICBkZWx0YVggPSAtZXZ0LmRlbHRhWDtcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSB0aGlzLmdldFdpbmRvd1dpZHRoKCkgLSAoZXZ0LmNlbnRlci54ICsgZXZ0LmRpc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IGV2dC5kZWx0YVg7XG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uID0gZXZ0LmNlbnRlci54IC0gZXZ0LmRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9ubHkgYWNjZXB0IGNsb3Npbmcgc3dpcGUgKGlnbm9yaW5nIG1pbkVkZ2Vab25lKSB3aGVuIHRoZSBkcmF3ZXIgaXMgZXhwYW5kZWQ6XG4gICAgICAgIGlmICgodGhpcy5pc09wZW4gJiYgZGVsdGFYIDwgMCkgfHxcbiAgICAgICAgICAgIC8vIHBvc2l0aXZlIGRlbHRhWCBmcm9tIHRoZSBlZGdlOlxuICAgICAgICAgICAgKGRlbHRhWCA+IDAgJiYgc3RhcnRQb3NpdGlvbiA8IHRoaXMubWF4RWRnZVpvbmUpKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYW5zdGFydCA9IChldnQ6IEhhbW1lcklucHV0KSA9PiB7IC8vIFRPRE86IHRlc3QgY29kZVxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlR2VzdHVyZXMgfHwgdGhpcy5waW4gfHwgZXZ0LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gPT09ICdyaWdodCcgPyB0aGlzLmdldFdpbmRvd1dpZHRoKCkgLSAoZXZ0LmNlbnRlci54ICsgZXZ0LmRpc3RhbmNlKVxuICAgICAgICAgICAgOiBldnQuY2VudGVyLnggLSBldnQuZGlzdGFuY2U7XG5cbiAgICAgICAgLy8gY2FjaGUgd2lkdGggZHVyaW5nIGFuaW1hdGlvbiwgZmxhZyB0byBhbGxvdyBmdXJ0aGVyIGhhbmRsaW5nXG4gICAgICAgIGlmICh0aGlzLmlzT3BlbiB8fCAoc3RhcnRQb3NpdGlvbiA8IHRoaXMubWF4RWRnZVpvbmUpKSB7XG4gICAgICAgICAgICB0aGlzLl9wYW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3BhblN0YXJ0V2lkdGggPSB0aGlzLmdldEV4cGVjdGVkV2lkdGgoIXRoaXMuaXNPcGVuKTtcbiAgICAgICAgICAgIHRoaXMuX3BhbkxpbWl0ID0gdGhpcy5nZXRFeHBlY3RlZFdpZHRoKHRoaXMuaXNPcGVuKTtcblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLm92ZXJsYXksICdwYW5uaW5nJyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZHJhd2VyLCAncGFubmluZycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYW4gPSAoZXZ0OiBIYW1tZXJJbnB1dCkgPT4ge1xuICAgICAgICAvLyBUT0RPOiBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgICAgICAgLy8gZ2V0IGFjdHVhbCBkZWx0YSAobm90IHRvdGFsIHNlc3Npb24gb25lKSBmcm9tIGV2ZW50P1xuICAgICAgICAvLyBwYW4gV0lMTCBhbHNvIGZpcmUgYWZ0ZXIgYSBmdWxsIHN3aXBlLCBvbmx5IHJlc2l6ZSBvbiBmbGFnXG4gICAgICAgIGlmICghdGhpcy5fcGFubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJpZ2h0OiBib29sZWFuID0gdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JztcbiAgICAgICAgLy8gd2hlbiBvbiB0aGUgcmlnaHQgdXNlIGludmVyc2Ugb2YgZGVsdGFYXG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IHJpZ2h0ID8gLWV2dC5kZWx0YVggOiBldnQuZGVsdGFYO1xuICAgICAgICBsZXQgdmlzaWJsZVdpZHRoO1xuICAgICAgICBsZXQgbmV3WDtcbiAgICAgICAgbGV0IHBlcmNlbnQ7XG5cbiAgICAgICAgdmlzaWJsZVdpZHRoID0gdGhpcy5fcGFuU3RhcnRXaWR0aCArIGRlbHRhWDtcblxuICAgICAgICBpZiAodGhpcy5pc09wZW4gJiYgZGVsdGFYIDwgMCkge1xuICAgICAgICAgICAgLy8gd2hlbiB2aXNpYmxlV2lkdGggaGl0cyBsaW1pdCAtIHN0b3AgYW5pbWF0aW5nXG4gICAgICAgICAgICBpZiAodmlzaWJsZVdpZHRoIDw9IHRoaXMuX3BhbkxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNBbmltYXRlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gKHZpc2libGVXaWR0aCAtIHRoaXMuX3BhbkxpbWl0KSAvICh0aGlzLl9wYW5TdGFydFdpZHRoIC0gdGhpcy5fcGFuTGltaXQpO1xuICAgICAgICAgICAgICAgIG5ld1ggPSB2aXNpYmxlV2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSB2aXNpYmxlV2lkdGggLyB0aGlzLl9wYW5TdGFydFdpZHRoO1xuICAgICAgICAgICAgICAgIG5ld1ggPSBldnQuZGVsdGFYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRYU2l6ZShuZXdYLCBwZXJjZW50LnRvUHJlY2lzaW9uKDIpKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzT3BlbiAmJiBkZWx0YVggPiAwKSB7XG4gICAgICAgICAgICAvLyB3aGVuIHZpc2libGVXaWR0aCBoaXRzIGxpbWl0IC0gc3RvcCBhbmltYXRpbmdcbiAgICAgICAgICAgIGlmICh2aXNpYmxlV2lkdGggPj0gdGhpcy5fcGFuTGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0FuaW1hdGVXaWR0aCkge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAodmlzaWJsZVdpZHRoIC0gdGhpcy5fcGFuU3RhcnRXaWR0aCkgLyAodGhpcy5fcGFuTGltaXQgLSB0aGlzLl9wYW5TdGFydFdpZHRoKTtcbiAgICAgICAgICAgICAgICBuZXdYID0gdmlzaWJsZVdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gdmlzaWJsZVdpZHRoIC8gdGhpcy5fcGFuTGltaXQ7XG4gICAgICAgICAgICAgICAgbmV3WCA9ICh0aGlzLl9wYW5MaW1pdCAtIHZpc2libGVXaWR0aCkgKiAocmlnaHQgPyAxIDogLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRYU2l6ZShuZXdYLCBwZXJjZW50LnRvUHJlY2lzaW9uKDIpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcGFuRW5kID0gKGV2dDogSGFtbWVySW5wdXQpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3Bhbm5pbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhWCA9IHRoaXMucG9zaXRpb24gPT09ICdyaWdodCcgPyAtZXZ0LmRlbHRhWCA6IGV2dC5kZWx0YVg7XG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlV2lkdGg6IG51bWJlciA9IHRoaXMuX3BhblN0YXJ0V2lkdGggKyBkZWx0YVg7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UGFuKCk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHBhbiBicm91Z2h0IHRoZSBkcmF3ZXIgdG8gNTAlXG4gICAgICAgICAgICBpZiAodGhpcy5pc09wZW4gJiYgdmlzaWJsZVdpZHRoIDw9IHRoaXMuX3BhblN0YXJ0V2lkdGggLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc09wZW4gJiYgdmlzaWJsZVdpZHRoID49IHRoaXMuX3BhbkxpbWl0IC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFuU3RhcnRXaWR0aCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlc2V0UGFuKCkge1xuICAgICAgICB0aGlzLl9wYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8qIHN0eWxlcyBmYWlsIHRvIGFwcGx5IHdoZW4gc2V0IG9uIHBhcmVudCBkdWUgdG8gZXh0cmEgYXR0cmlidXRlcywgcHJvYiBuZyBidWcgKi9cbiAgICAgICAgLyogc3R5bGVzIGZhaWwgdG8gYXBwbHkgd2hlbiBzZXQgb24gcGFyZW50IGR1ZSB0byBleHRyYSBhdHRyaWJ1dGVzLCBwcm9iIG5nIGJ1ZyAqL1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMub3ZlcmxheSwgJ3Bhbm5pbmcnKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmRyYXdlciwgJ3Bhbm5pbmcnKTtcbiAgICAgICAgdGhpcy5zZXRYU2l6ZSgwLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb3Igd2lkdGggaW4gY2FzZSB0aGUgZHJhd2VyIGRvZXNuJ3QgY2hhbmdlIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB4IHRoZSBudW1iZXIgcGl4ZWxzIHRvIHRyYW5zbGF0ZSBvbiB0aGUgWCBheGlzIG9yIHRoZSB3aWR0aCB0byBzZXQuIDAgd2lkdGggd2lsbCBjbGVhciB0aGUgc3R5bGUgaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gb3BhY2l0eSBvcHRpb25hbCB2YWx1ZSB0byBhcHBseSB0byB0aGUgb3ZlcmxheVxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0WFNpemUoeDogbnVtYmVyLCBvcGFjaXR5Pzogc3RyaW5nKSB7XG4gICAgICAgIC8vIEFuZ3VsYXIgcG9seWZpbGxzIHBhdGNoZXMgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSwgYnV0IHN3aXRjaCB0byBEb21BZGFwdGVyIEFQSSAoVE9ETylcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNBbmltYXRlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZHJhd2VyLCAnd2lkdGgnLCB4ID8gTWF0aC5hYnMoeCkgKyAncHgnIDogJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZHJhd2VyLCAndHJhbnNmb3JtJywgeCA/ICd0cmFuc2xhdGUzZCgnICsgeCArICdweCwwLDApJyA6ICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZHJhd2VyLCAnLXdlYmtpdC10cmFuc2Zvcm0nLCB4ID8gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJ3B4LDAsMCknIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5vdmVybGF5LCAnb3BhY2l0eScsIG9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZU9wZW5lZEV2ZW50ID0gKGV2dD8pID0+IHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudG9nZ2xlT3BlbmVkRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5vcGVuZWQuZW1pdCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdG9nZ2xlQ2xvc2VkRXZlbnQgPSAoZXZ0PykgPT4ge1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy50b2dnbGVDbG9zZWRFdmVudCwgZmFsc2UpO1xuICAgICAgICB0aGlzLmNsb3NlZC5lbWl0KCk7XG4gICAgfVxufVxuIl19