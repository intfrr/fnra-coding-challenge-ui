import { Component, ContentChild, ElementRef, EventEmitter, HostBinding, Inject, Input, Optional, Output, ViewChild, Renderer2 } from '@angular/core';
import { fromEvent, interval } from 'rxjs';
import { debounce } from 'rxjs/operators';
import { IgxNavigationService } from '../core/navigation';
import { HammerGesturesManager } from '../core/touch';
import { IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective } from './navigation-drawer.directives';
import { PlatformUtil } from '../core/utils';
let NEXT_ID = 0;
/**
 * **Ignite UI for Angular Navigation Drawer** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer)
 *
 * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
 *
 * Example:
 * ```html
 * <igx-nav-drawer id="navigation" [isOpen]="true">
 *   <ng-template igxDrawer>
 *     <nav>
 *       <span igxDrawerItem [isHeader]="true">Email</span>
 *       <span igxDrawerItem igxRipple>Inbox</span>
 *       <span igxDrawerItem igxRipple>Deleted</span>
 *       <span igxDrawerItem igxRipple>Sent</span>
 *     </nav>
 *   </ng-template>
 * </igx-nav-drawer>
 * ```
 */
export class IgxNavigationDrawerComponent {
    constructor(elementRef, _state, renderer, _touchManager, platformUtil) {
        this.elementRef = elementRef;
        this._state = _state;
        this.renderer = renderer;
        this._touchManager = _touchManager;
        this.platformUtil = platformUtil;
        this._isOpen = false;
        /** @hidden @internal */
        this.cssClass = true;
        /**
         * ID of the component
         *
         * ```typescript
         * // get
         * let myNavDrawerId = this.navdrawer.id;
         * ```
         *
         * ```html
         * <!--set-->
         *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
         * ```
         */
        this.id = `igx-nav-drawer-${NEXT_ID++}`;
        /**
         * Position of the Navigation Drawer. Can be "left"(default) or "right".
         *
         * ```typescript
         * // get
         * let myNavDrawerPosition = this.navdrawer.position;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
         * ```
         */
        this.position = 'left';
        /**
         * Enables the use of touch gestures to manipulate the drawer:
         * - swipe/pan from edge to open, swipe-toggle and pan-drag.
         *
         * ```typescript
         * // get
         * let gesturesEnabled = this.navdrawer.enableGestures;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
         * ```
         */
        this.enableGestures = true;
        /**
         * @hidden
         */
        this.isOpenChange = new EventEmitter();
        /**
         * When pinned the drawer is relatively positioned instead of sitting above content.
         * May require additional layout styling.
         *
         * ```typescript
         * // get
         * let navDrawerIsPinned = this.navdrawer.pin;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
         * ```
         */
        this.pin = false;
        /**
         * Minimum device width required for automatic pin to be toggled.
         * Default is 1024, can be set to a falsy value to disable this behavior.
         *
         * ```typescript
         * // get
         * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
         * ```
         */
        this.pinThreshold = 1024;
        /**
         * Width of the drawer in its open state. Defaults to "280px".
         *
         * ```typescript
         * // get
         * let navDrawerWidth = this.navdrawer.width;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
         * ```
         */
        this.width = '280px';
        /**
         * Enables/disables the animation, when toggling the drawer. Set to `false` by default.
         * ````html
         * <igx-nav-drawer [disableAnimation]="true"></igx-nav-drawer>
         * ````
         */
        this.disableAnimation = false;
        /**
         * Width of the drawer in its mini state. Defaults to 68px.
         *
         * ```typescript
         * // get
         * let navDrawerMiniWidth = this.navdrawer.miniWidth;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
         * ```
         */
        this.miniWidth = '68px';
        /**
         * Pinned state change output for two-way binding.
         *
         * ```html
         * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
         * ```
         */
        this.pinChange = new EventEmitter(true);
        /**
         * Event fired as the Navigation Drawer is about to open.
         *
         * ```html
         *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
         * ```
         */
        this.opening = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has opened.
         *
         * ```html
         * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
         * ```
         */
        this.opened = new EventEmitter();
        /**
         * Event fired as the Navigation Drawer is about to close.
         *
         * ```html
         * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
         * ```
         */
        this.closing = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has closed.
         *
         * ```html
         * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
         * ```
         */
        this.closed = new EventEmitter();
        this._gesturesAttached = false;
        this._widthCache = { width: null, miniWidth: null, windowWidth: null };
        this.css = {
            drawer: 'igx-nav-drawer__aside',
            mini: 'igx-nav-drawer__aside--mini',
            overlay: 'igx-nav-drawer__overlay',
            styleDummy: 'igx-nav-drawer__style-dummy'
        };
        /** Pan animation properties */
        this._panning = false;
        this._maxEdgeZone = 50;
        this.checkPinThreshold = (evt) => {
            if (!this.platformUtil.isBrowser) {
                return;
            }
            let windowWidth;
            if (this.pinThreshold) {
                windowWidth = this.getWindowWidth();
                if (evt && this._widthCache.windowWidth === windowWidth) {
                    return;
                }
                this._widthCache.windowWidth = windowWidth;
                if (!this.pin && windowWidth >= this.pinThreshold) {
                    this.pin = true;
                    this.pinChange.emit(true);
                }
                else if (this.pin && windowWidth < this.pinThreshold) {
                    this.pin = false;
                    this.pinChange.emit(false);
                }
            }
        };
        this.swipe = (evt) => {
            // TODO: Could also force input type: http://stackoverflow.com/a/27108052
            if (!this.enableGestures || evt.pointerType !== 'touch') {
                return;
            }
            // HammerJS swipe is horizontal-only by default, don't check deltaY
            let deltaX;
            let startPosition;
            if (this.position === 'right') {
                // when on the right use inverse of deltaX
                deltaX = -evt.deltaX;
                startPosition = this.getWindowWidth() - (evt.center.x + evt.distance);
            }
            else {
                deltaX = evt.deltaX;
                startPosition = evt.center.x - evt.distance;
            }
            // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
            if ((this.isOpen && deltaX < 0) ||
                // positive deltaX from the edge:
                (deltaX > 0 && startPosition < this.maxEdgeZone)) {
                this.toggle();
            }
        };
        this.panstart = (evt) => {
            if (!this.enableGestures || this.pin || evt.pointerType !== 'touch') {
                return;
            }
            const startPosition = this.position === 'right' ? this.getWindowWidth() - (evt.center.x + evt.distance)
                : evt.center.x - evt.distance;
            // cache width during animation, flag to allow further handling
            if (this.isOpen || (startPosition < this.maxEdgeZone)) {
                this._panning = true;
                this._panStartWidth = this.getExpectedWidth(!this.isOpen);
                this._panLimit = this.getExpectedWidth(this.isOpen);
                this.renderer.addClass(this.overlay, 'panning');
                this.renderer.addClass(this.drawer, 'panning');
            }
        };
        this.pan = (evt) => {
            // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
            // get actual delta (not total session one) from event?
            // pan WILL also fire after a full swipe, only resize on flag
            if (!this._panning) {
                return;
            }
            const right = this.position === 'right';
            // when on the right use inverse of deltaX
            const deltaX = right ? -evt.deltaX : evt.deltaX;
            let visibleWidth;
            let newX;
            let percent;
            visibleWidth = this._panStartWidth + deltaX;
            if (this.isOpen && deltaX < 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth <= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panLimit) / (this._panStartWidth - this._panLimit);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panStartWidth;
                    newX = evt.deltaX;
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
            else if (!this.isOpen && deltaX > 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth >= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panStartWidth) / (this._panLimit - this._panStartWidth);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panLimit;
                    newX = (this._panLimit - visibleWidth) * (right ? 1 : -1);
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
        };
        this.panEnd = (evt) => {
            if (this._panning) {
                const deltaX = this.position === 'right' ? -evt.deltaX : evt.deltaX;
                const visibleWidth = this._panStartWidth + deltaX;
                this.resetPan();
                // check if pan brought the drawer to 50%
                if (this.isOpen && visibleWidth <= this._panStartWidth / 2) {
                    this.close();
                }
                else if (!this.isOpen && visibleWidth >= this._panLimit / 2) {
                    this.open();
                }
                this._panStartWidth = null;
            }
        };
        this.toggleOpenedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleOpenedEvent, false);
            this.opened.emit();
        };
        this.toggleClosedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleClosedEvent, false);
            this.closed.emit();
        };
    }
    /**
     * State of the drawer.
     *
     * ```typescript
     * // get
     * let navDrawerIsOpen = this.navdrawer.isOpen;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <!--set-->
     * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>
     * ```
     */
    get isOpen() {
        return this._isOpen;
    }
    set isOpen(value) {
        this._isOpen = value;
        this.isOpenChange.emit(this._isOpen);
    }
    /**
     * Returns nativeElement of the component.
     *
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get template() {
        if (this.miniTemplate && !this.isOpen) {
            return this.miniTemplate.template;
        }
        else if (this.contentTemplate) {
            return this.contentTemplate.template;
        }
    }
    /**
     * @hidden
     */
    get miniTemplate() {
        return this._miniTemplate;
    }
    /**
     * @hidden
     */
    set miniTemplate(v) {
        if (!this.isOpen) {
            this.setDrawerWidth(v ? this.miniWidth : '');
        }
        this._miniTemplate = v;
    }
    /**
     * @hidden
     */
    get flexWidth() {
        if (!this.pin) {
            return '0px';
        }
        if (this.isOpen) {
            return this.width;
        }
        if (this.miniTemplate && this.miniWidth) {
            return this.miniWidth;
        }
        return '0px';
    }
    /** @hidden */
    get isPinnedRight() {
        return this.pin && this.position === 'right' ? '1' : '0';
    }
    /**
     * @hidden
     */
    get drawer() {
        return this._drawer.nativeElement;
    }
    /**
     * @hidden
     */
    get overlay() {
        return this._overlay.nativeElement;
    }
    /**
     * @hidden
     */
    get styleDummy() {
        return this._styleDummy.nativeElement;
    }
    /**
     * Property to decide whether to change width or translate the drawer from pan gesture.
     *
     * @hidden
     */
    get hasAnimateWidth() {
        return this.pin || !!this.miniTemplate;
    }
    /**
     * Used for touch gestures (swipe and pan).
     * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
     *
     * @hidden
     */
    get maxEdgeZone() {
        return this._maxEdgeZone;
    }
    /**
     * Gets the Drawer width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     *
     * @hidden
     */
    get expectedWidth() {
        return this.getExpectedWidth(false);
    }
    /**
     * Get the Drawer mini width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     * @hidden
     */
    get expectedMiniWidth() {
        return this.getExpectedWidth(true);
    }
    /**
     * @hidden
     */
    get touchManager() {
        return this._touchManager;
    }
    /**
     * Exposes optional navigation service
     *
     * @hidden
     */
    get state() {
        return this._state;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        // DOM and @Input()-s initialized
        if (this._state) {
            this._state.add(this.id, this);
        }
        if (this.isOpen) {
            this.setDrawerWidth(this.width);
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        // wait for template and ng-content to be ready
        this.updateEdgeZone();
        this.checkPinThreshold();
        this.ensureEvents();
        // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
        // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._touchManager.destroy();
        if (this._state) {
            this._state.remove(this.id);
        }
        if (this._resizeObserver) {
            this._resizeObserver.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
        if (changes.enableGestures && changes.enableGestures.currentValue !== undefined) {
            this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
            this.ensureEvents();
        }
        if (changes.pin && changes.pin.currentValue !== undefined) {
            this.pin = !!(this.pin && this.pin.toString() === 'true');
            if (this.pin) {
                this._touchManager.destroy();
                this._gesturesAttached = false;
            }
            else {
                this.ensureEvents();
            }
        }
        if (changes.pinThreshold) {
            if (this.pinThreshold) {
                this.ensureEvents();
                this.checkPinThreshold();
            }
        }
        if (changes.width && this.isOpen) {
            this.setDrawerWidth(changes.width.currentValue);
        }
        if (changes.isOpen) {
            this.setDrawerWidth(this.isOpen ? this.width : (this.miniTemplate ? this.miniWidth : ''));
        }
        if (changes.miniWidth) {
            if (!this.isOpen) {
                this.setDrawerWidth(changes.miniWidth.currentValue);
            }
            this.updateEdgeZone();
        }
    }
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     */
    toggle() {
        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     */
    open() {
        if (this._panning) {
            this.resetPan();
        }
        if (this.isOpen) {
            return;
        }
        this.opening.emit();
        this.isOpen = true;
        // TODO: Switch to animate API when available
        // var animationCss = this.animate.css();
        //     animationCss
        //         .setStyles({'width':'50px'}, {'width':'400px'})
        //         .start(this.elementRef.nativeElement)
        //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
        this.setDrawerWidth(this.width);
    }
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     */
    close() {
        if (this._panning) {
            this.resetPan();
        }
        if (!this.isOpen) {
            return;
        }
        this.closing.emit();
        this.isOpen = false;
        this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
    }
    /**
     * @hidden
     */
    set_maxEdgeZone(value) {
        this._maxEdgeZone = value;
    }
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @param [mini] - Request mini width instead
     */
    getExpectedWidth(mini) {
        if (mini) {
            if (!this.miniTemplate) {
                return 0;
            }
            if (this.miniWidth) {
                return parseFloat(this.miniWidth);
            }
            else {
                // if (!this.isOpen) { // This WON'T work due to transition timings...
                //     return this.elementRef.nativeElement.children[1].offsetWidth;
                // } else {
                if (this._widthCache.miniWidth === null) {
                    // force class for width calc. TODO?
                    // force class for width calc. TODO?
                    this.renderer.addClass(this.styleDummy, this.css.drawer);
                    this.renderer.addClass(this.styleDummy, this.css.mini);
                    this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                    this.renderer.removeClass(this.styleDummy, this.css.drawer);
                    this.renderer.removeClass(this.styleDummy, this.css.mini);
                }
                return this._widthCache.miniWidth;
            }
        }
        else {
            if (this.width) {
                return parseFloat(this.width);
            }
            else {
                if (this._widthCache.width === null) {
                    // force class for width calc. TODO?
                    // force class for width calc. TODO?
                    this.renderer.addClass(this.styleDummy, this.css.drawer);
                    this._widthCache.width = this.styleDummy.offsetWidth;
                    this.renderer.removeClass(this.styleDummy, this.css.drawer);
                }
                return this._widthCache.width;
            }
        }
    }
    getWindowWidth() {
        return (window.innerWidth > 0) ? window.innerWidth : screen.width;
    }
    /**
     * Sets the drawer width.
     */
    setDrawerWidth(width) {
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(() => {
                if (this.drawer) {
                    this.renderer.setStyle(this.drawer, 'width', width);
                }
            });
        }
        else {
            this.renderer.setStyle(this.drawer, 'width', width);
        }
    }
    /**
     * Get current Drawer width.
     */
    getDrawerWidth() {
        return this.drawer.offsetWidth;
    }
    ensureEvents() {
        // set listeners for swipe/pan only if needed, but just once
        if (this.enableGestures && !this.pin && !this._gesturesAttached) {
            // Built-in manager handler(L20887) causes endless loop and max stack exception.
            // https://github.com/angular/angular/issues/6993
            // Use ours for now (until beta.10):
            // this.renderer.listen(document, "swipe", this.swipe);
            this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);
            this._gesturesAttached = true;
            // this.renderer.listen(document, "panstart", this.panstart);
            // this.renderer.listen(document, "pan", this.pan);
            this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);
            this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);
            this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
        }
        if (!this._resizeObserver && this.platformUtil.isBrowser) {
            this._resizeObserver = fromEvent(window, 'resize').pipe(debounce(() => interval(150)))
                .subscribe((value) => {
                this.checkPinThreshold(value);
            });
        }
    }
    updateEdgeZone() {
        let maxValue;
        if (this.miniTemplate) {
            maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
            this.set_maxEdgeZone(maxValue);
        }
    }
    resetPan() {
        this._panning = false;
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        this.renderer.removeClass(this.overlay, 'panning');
        this.renderer.removeClass(this.drawer, 'panning');
        this.setXSize(0, '');
    }
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @param x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param opacity optional value to apply to the overlay
     */
    setXSize(x, opacity) {
        // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
        window.requestAnimationFrame(() => {
            if (this.hasAnimateWidth) {
                this.renderer.setStyle(this.drawer, 'width', x ? Math.abs(x) + 'px' : '');
            }
            else {
                this.renderer.setStyle(this.drawer, 'transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
                this.renderer.setStyle(this.drawer, '-webkit-transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
            }
            if (opacity !== undefined) {
                this.renderer.setStyle(this.overlay, 'opacity', opacity);
            }
        });
    }
}
IgxNavigationDrawerComponent.decorators = [
    { type: Component, args: [{
                providers: [HammerGesturesManager],
                selector: 'igx-nav-drawer',
                template: "<ng-template #defaultItemsTemplate>\n    <div igxDrawerItem [isHeader]=\"true\">Navigation Drawer</div>\n    <div igxDrawerItem> Start by adding</div>\n    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>\n    <div igxDrawerItem> And some items inside </div>\n    <div igxDrawerItem> Style with igxDrawerItem </div>\n    <div igxDrawerItem> and igxRipple directives</div>\n</ng-template>\n\n<div [hidden]=\"pin\"\n    class=\"igx-nav-drawer__overlay\"\n    [class.igx-nav-drawer__overlay--hidden]=\"!isOpen\"\n    [class.igx-nav-drawer--disable-animation]=\"disableAnimation\"\n    (click)=\"close()\" #overlay>\n</div>\n<aside role=\"navigation\"\n    class=\"igx-nav-drawer__aside\"\n    [class.igx-nav-drawer__aside--collapsed]=\"!miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--mini]=\"miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--normal]=\"!miniTemplate || isOpen\"\n    [class.igx-nav-drawer__aside--pinned]=\"pin\"\n    [class.igx-nav-drawer__aside--right]=\"position == 'right'\" #aside\n    [class.igx-nav-drawer--disable-animation]=\"disableAnimation\">\n\n    <ng-container *ngTemplateOutlet=\"template || defaultItemsTemplate\"></ng-container>\n</aside>\n<div class=\"igx-nav-drawer__style-dummy\" #dummy></div>\n",
                styles: [`
        :host {
            display: block;
            height: 100%;
        }
    `]
            },] }
];
IgxNavigationDrawerComponent.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] },
    { type: Renderer2 },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];
IgxNavigationDrawerComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-nav-drawer',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    position: [{ type: Input }],
    enableGestures: [{ type: Input }],
    isOpen: [{ type: Input }],
    isOpenChange: [{ type: Output }],
    pin: [{ type: Input }],
    pinThreshold: [{ type: Input }],
    width: [{ type: Input }],
    disableAnimation: [{ type: HostBinding, args: ['class.igx-nav-drawer--disable-animation',] }, { type: Input }],
    miniWidth: [{ type: Input }],
    pinChange: [{ type: Output }],
    opening: [{ type: Output }],
    opened: [{ type: Output }],
    closing: [{ type: Output }],
    closed: [{ type: Output }],
    miniTemplate: [{ type: ContentChild, args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective },] }],
    contentTemplate: [{ type: ContentChild, args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective },] }],
    flexWidth: [{ type: HostBinding, args: ['style.flexBasis',] }],
    isPinnedRight: [{ type: HostBinding, args: ['style.order',] }],
    _drawer: [{ type: ViewChild, args: ['aside', { static: true },] }],
    _overlay: [{ type: ViewChild, args: ['overlay', { static: true },] }],
    _styleDummy: [{ type: ViewChild, args: ['dummy', { static: true },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdGlvbi1kcmF3ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL25hdmlnYXRpb24tZHJhd2VyL25hdmlnYXRpb24tZHJhd2VyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUgsU0FBUyxFQUNULFlBQVksRUFDWixVQUFVLEVBQ1YsWUFBWSxFQUNaLFdBQVcsRUFDWCxNQUFNLEVBQ04sS0FBSyxFQUlMLFFBQVEsRUFDUixNQUFNLEVBRU4sU0FBUyxFQUNULFNBQVMsRUFDWixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDekQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzFDLE9BQU8sRUFBRSxvQkFBb0IsRUFBZSxNQUFNLG9CQUFvQixDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0RCxPQUFPLEVBQUUsaUNBQWlDLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNsSCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTdDLElBQUksT0FBTyxHQUFHLENBQUMsQ0FBQztBQUNoQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1CRztBQVlILE1BQU0sT0FBTyw0QkFBNEI7SUFvWHJDLFlBQ2dDLFVBQXNCLEVBQzlCLE1BQTRCLEVBQ3RDLFFBQW1CLEVBQ3JCLGFBQW9DLEVBQ3BDLFlBQTBCO1FBSk4sZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUM5QixXQUFNLEdBQU4sTUFBTSxDQUFzQjtRQUN0QyxhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQ3JCLGtCQUFhLEdBQWIsYUFBYSxDQUF1QjtRQUNwQyxpQkFBWSxHQUFaLFlB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dCI6WyJpbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT25DaGFuZ2VzLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNpbXBsZUNoYW5nZSxcbiAgICBWaWV3Q2hpbGQsXG4gICAgUmVuZGVyZXIyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBpbnRlcnZhbCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElneE5hdmlnYXRpb25TZXJ2aWNlLCBJVG9nZ2xlVmlldyB9IGZyb20gJy4uL2NvcmUvbmF2aWdhdGlvbic7XG5pbXBvcnQgeyBIYW1tZXJHZXN0dXJlc01hbmFnZXIgfSBmcm9tICcuLi9jb3JlL3RvdWNoJztcbmltcG9ydCB7IElneE5hdkRyYXdlck1pbmlUZW1wbGF0ZURpcmVjdGl2ZSwgSWd4TmF2RHJhd2VyVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL25hdmlnYXRpb24tZHJhd2VyLmRpcmVjdGl2ZXMnO1xuaW1wb3J0IHsgUGxhdGZvcm1VdGlsIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5cbmxldCBORVhUX0lEID0gMDtcbi8qKlxuICogKipJZ25pdGUgVUkgZm9yIEFuZ3VsYXIgTmF2aWdhdGlvbiBEcmF3ZXIqKiAtXG4gKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cuaW5mcmFnaXN0aWNzLmNvbS9wcm9kdWN0cy9pZ25pdGUtdWktYW5ndWxhci9hbmd1bGFyL2NvbXBvbmVudHMvbmF2ZHJhd2VyKVxuICpcbiAqIFRoZSBJZ25pdGUgVUkgTmF2aWdhdGlvbiBEcmF3ZXIgaXMgYSBjb2xsYXBzaWJsZSBzaWRlIG5hdmlnYXRpb24gY29udGFpbmVyIGNvbW1vbmx5IHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgTmF2YmFyLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8aWd4LW5hdi1kcmF3ZXIgaWQ9XCJuYXZpZ2F0aW9uXCIgW2lzT3Blbl09XCJ0cnVlXCI+XG4gKiAgIDxuZy10ZW1wbGF0ZSBpZ3hEcmF3ZXI+XG4gKiAgICAgPG5hdj5cbiAqICAgICAgIDxzcGFuIGlneERyYXdlckl0ZW0gW2lzSGVhZGVyXT1cInRydWVcIj5FbWFpbDwvc3Bhbj5cbiAqICAgICAgIDxzcGFuIGlneERyYXdlckl0ZW0gaWd4UmlwcGxlPkluYm94PC9zcGFuPlxuICogICAgICAgPHNwYW4gaWd4RHJhd2VySXRlbSBpZ3hSaXBwbGU+RGVsZXRlZDwvc3Bhbj5cbiAqICAgICAgIDxzcGFuIGlneERyYXdlckl0ZW0gaWd4UmlwcGxlPlNlbnQ8L3NwYW4+XG4gKiAgICAgPC9uYXY+XG4gKiAgIDwvbmctdGVtcGxhdGU+XG4gKiA8L2lneC1uYXYtZHJhd2VyPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHByb3ZpZGVyczogW0hhbW1lckdlc3R1cmVzTWFuYWdlcl0sXG4gICAgc2VsZWN0b3I6ICdpZ3gtbmF2LWRyYXdlcicsXG4gICAgdGVtcGxhdGVVcmw6ICduYXZpZ2F0aW9uLWRyYXdlci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVzOiBbYFxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgfVxuICAgIGBdXG59KVxuZXhwb3J0IGNsYXNzIElneE5hdmlnYXRpb25EcmF3ZXJDb21wb25lbnQgaW1wbGVtZW50c1xuICAgIElUb2dnbGVWaWV3LFxuICAgIE9uSW5pdCxcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkNoYW5nZXMge1xuXG4gICAgcHJpdmF0ZSBfaXNPcGVuID0gZmFsc2U7XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1uYXYtZHJhd2VyJylcbiAgICBwdWJsaWMgY3NzQ2xhc3MgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSUQgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBteU5hdkRyYXdlcklkID0gdGhpcy5uYXZkcmF3ZXIuaWQ7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqICA8aWd4LW5hdi1kcmF3ZXIgaWQ9J25hdmRyYXdlcic+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpIHB1YmxpYyBpZCA9IGBpZ3gtbmF2LWRyYXdlci0ke05FWFRfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gb2YgdGhlIE5hdmlnYXRpb24gRHJhd2VyLiBDYW4gYmUgXCJsZWZ0XCIoZGVmYXVsdCkgb3IgXCJyaWdodFwiLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBteU5hdkRyYXdlclBvc2l0aW9uID0gdGhpcy5uYXZkcmF3ZXIucG9zaXRpb247XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbcG9zaXRpb25dPVwiJ2xlZnQnXCI+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgcG9zaXRpb24gPSAnbGVmdCc7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSB1c2Ugb2YgdG91Y2ggZ2VzdHVyZXMgdG8gbWFuaXB1bGF0ZSB0aGUgZHJhd2VyOlxuICAgICAqIC0gc3dpcGUvcGFuIGZyb20gZWRnZSB0byBvcGVuLCBzd2lwZS10b2dnbGUgYW5kIHBhbi1kcmFnLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBnZXN0dXJlc0VuYWJsZWQgPSB0aGlzLm5hdmRyYXdlci5lbmFibGVHZXN0dXJlcztcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1uYXYtZHJhd2VyIFtlbmFibGVHZXN0dXJlc109J3RydWUnPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGVuYWJsZUdlc3R1cmVzID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFN0YXRlIG9mIHRoZSBkcmF3ZXIuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG5hdkRyYXdlcklzT3BlbiA9IHRoaXMubmF2ZHJhd2VyLmlzT3BlbjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1uYXYtZHJhd2VyIFtpc09wZW5dPSdmYWxzZSc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFR3by13YXkgZGF0YSBiaW5kaW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1uYXYtZHJhd2VyIFsoaXNPcGVuKV09J21vZGVsLmlzT3Blbic+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNPcGVuO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGlzT3Blbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9pc09wZW4gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pc09wZW5DaGFuZ2UuZW1pdCh0aGlzLl9pc09wZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIGlzT3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcGlubmVkIHRoZSBkcmF3ZXIgaXMgcmVsYXRpdmVseSBwb3NpdGlvbmVkIGluc3RlYWQgb2Ygc2l0dGluZyBhYm92ZSBjb250ZW50LlxuICAgICAqIE1heSByZXF1aXJlIGFkZGl0aW9uYWwgbGF5b3V0IHN0eWxpbmcuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG5hdkRyYXdlcklzUGlubmVkID0gdGhpcy5uYXZkcmF3ZXIucGluO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW3Bpbl09J2ZhbHNlJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwaW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gZGV2aWNlIHdpZHRoIHJlcXVpcmVkIGZvciBhdXRvbWF0aWMgcGluIHRvIGJlIHRvZ2dsZWQuXG4gICAgICogRGVmYXVsdCBpcyAxMDI0LCBjYW4gYmUgc2V0IHRvIGEgZmFsc3kgdmFsdWUgdG8gZGlzYWJsZSB0aGlzIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJQaW5UcmVzaG9sZCA9IHRoaXMubmF2ZHJhd2VyLnBpblRocmVzaG9sZDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1uYXYtZHJhd2VyIFtwaW5UcmVzaG9sZF09JzEwMjQnPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHBpblRocmVzaG9sZCA9IDEwMjQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5hdGl2ZUVsZW1lbnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIHRoZSBkcmF3ZXIgaW4gaXRzIG9wZW4gc3RhdGUuIERlZmF1bHRzIHRvIFwiMjgwcHhcIi5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbmF2RHJhd2VyV2lkdGggPSB0aGlzLm5hdmRyYXdlci53aWR0aDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1uYXYtZHJhd2VyIFt3aWR0aF09XCInMjI4cHgnXCI+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgd2lkdGggPSAnMjgwcHgnO1xuXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzL2Rpc2FibGVzIHRoZSBhbmltYXRpb24sIHdoZW4gdG9nZ2xpbmcgdGhlIGRyYXdlci4gU2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdC5cbiAgICAgKiBgYGBgaHRtbFxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbZGlzYWJsZUFuaW1hdGlvbl09XCJ0cnVlXCI+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nICgnY2xhc3MuaWd4LW5hdi1kcmF3ZXItLWRpc2FibGUtYW5pbWF0aW9uJylcbiAgICBASW5wdXQoKSBwdWJsaWMgZGlzYWJsZUFuaW1hdGlvbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgdGhlIGRyYXdlciBpbiBpdHMgbWluaSBzdGF0ZS4gRGVmYXVsdHMgdG8gNjhweC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbmF2RHJhd2VyTWluaVdpZHRoID0gdGhpcy5uYXZkcmF3ZXIubWluaVdpZHRoO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW21pbmlXaWR0aF09XCInMzRweCdcIj48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBtaW5pV2lkdGggPSAnNjhweCc7XG5cbiAgICAvKipcbiAgICAgKiBQaW5uZWQgc3RhdGUgY2hhbmdlIG91dHB1dCBmb3IgdHdvLXdheSBiaW5kaW5nLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbKHBpbildPSdpc1Bpbm5lZCc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIHBpbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4odHJ1ZSk7XG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgYXMgdGhlIE5hdmlnYXRpb24gRHJhd2VyIGlzIGFib3V0IHRvIG9wZW4uXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogIDxpZ3gtbmF2LWRyYXdlciAob3BlbmluZyk9J29uT3BlbmluZygpJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgb3BlbmluZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBOYXZpZ2F0aW9uIERyYXdlciBoYXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciAob3BlbmVkKT0nb25PcGVuZWQoKSc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIG9wZW5lZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCBhcyB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIgaXMgYWJvdXQgdG8gY2xvc2UuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1uYXYtZHJhd2VyIChjbG9zaW5nKT0nb25DbG9zaW5nKCknPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBjbG9zaW5nID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIE5hdmlnYXRpb24gRHJhd2VyIGhhcyBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1uYXYtZHJhd2VyIChjbG9zZWQpPSdvbkNsb3NlZCgpJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgY2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWluaVRlbXBsYXRlICYmICF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWluaVRlbXBsYXRlLnRlbXBsYXRlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29udGVudFRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50VGVtcGxhdGUudGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9taW5pVGVtcGxhdGU6IElneE5hdkRyYXdlck1pbmlUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBtaW5pVGVtcGxhdGUoKTogSWd4TmF2RHJhd2VyTWluaVRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbmlUZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4TmF2RHJhd2VyTWluaVRlbXBsYXRlRGlyZWN0aXZlIH0pXG4gICAgcHVibGljIHNldCBtaW5pVGVtcGxhdGUodjogSWd4TmF2RHJhd2VyTWluaVRlbXBsYXRlRGlyZWN0aXZlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhd2VyV2lkdGgodiA/IHRoaXMubWluaVdpZHRoIDogJycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21pbmlUZW1wbGF0ZSA9IHY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4TmF2RHJhd2VyVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4TmF2RHJhd2VyVGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwcm90ZWN0ZWQgY29udGVudFRlbXBsYXRlOiBJZ3hOYXZEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmZsZXhCYXNpcycpXG4gICAgZ2V0IGZsZXhXaWR0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBpbikge1xuICAgICAgICAgICAgcmV0dXJuICcwcHgnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWluaVRlbXBsYXRlICYmIHRoaXMubWluaVdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW5pV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJzBweCc7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLm9yZGVyJylcbiAgICBnZXQgaXNQaW5uZWRSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGluICYmIHRoaXMucG9zaXRpb24gPT09ICdyaWdodCcgPyAnMScgOiAnMCc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2VzdHVyZXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3dpZHRoQ2FjaGU6IHsgd2lkdGg6IG51bWJlciwgbWluaVdpZHRoOiBudW1iZXIsIHdpbmRvd1dpZHRoOiBudW1iZXIgfSA9IHsgd2lkdGg6IG51bGwsIG1pbmlXaWR0aDogbnVsbCwgd2luZG93V2lkdGg6IG51bGwgfTtcbiAgICBwcml2YXRlIF9yZXNpemVPYnNlcnZlcjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgY3NzOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmc7IH0gPSB7XG4gICAgICAgIGRyYXdlcjogJ2lneC1uYXYtZHJhd2VyX19hc2lkZScsXG4gICAgICAgIG1pbmk6ICdpZ3gtbmF2LWRyYXdlcl9fYXNpZGUtLW1pbmknLFxuICAgICAgICBvdmVybGF5OiAnaWd4LW5hdi1kcmF3ZXJfX292ZXJsYXknLFxuICAgICAgICBzdHlsZUR1bW15OiAnaWd4LW5hdi1kcmF3ZXJfX3N0eWxlLWR1bW15J1xuICAgIH07XG5cbiAgICBAVmlld0NoaWxkKCdhc2lkZScsIHsgc3RhdGljOiB0cnVlIH0pIHByaXZhdGUgX2RyYXdlcjogRWxlbWVudFJlZjtcbiAgICBAVmlld0NoaWxkKCdvdmVybGF5JywgeyBzdGF0aWM6IHRydWUgfSkgcHJpdmF0ZSBfb3ZlcmxheTogRWxlbWVudFJlZjtcbiAgICBAVmlld0NoaWxkKCdkdW1teScsIHsgc3RhdGljOiB0cnVlIH0pIHByaXZhdGUgX3N0eWxlRHVtbXk6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGRyYXdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyYXdlci5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgb3ZlcmxheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHN0eWxlRHVtbXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsZUR1bW15Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqIFBhbiBhbmltYXRpb24gcHJvcGVydGllcyAqL1xuICAgIHByaXZhdGUgX3Bhbm5pbmcgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9wYW5TdGFydFdpZHRoOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfcGFuTGltaXQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5IHRvIGRlY2lkZSB3aGV0aGVyIHRvIGNoYW5nZSB3aWR0aCBvciB0cmFuc2xhdGUgdGhlIGRyYXdlciBmcm9tIHBhbiBnZXN0dXJlLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaGFzQW5pbWF0ZVdpZHRoKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5waW4gfHwgISF0aGlzLm1pbmlUZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tYXhFZGdlWm9uZSA9IDUwO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHRvdWNoIGdlc3R1cmVzIChzd2lwZSBhbmQgcGFuKS5cbiAgICAgKiBEZWZhdWx0cyB0byA1MCAoaW4gcHgpIGFuZCBpcyBleHRlbmRlZCB0byBhdCBsZWFzdCAxMTAlIG9mIHRoZSBtaW5pIHRlbXBsYXRlIHdpZHRoIGlmIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1heEVkZ2Vab25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4RWRnZVpvbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgRHJhd2VyIHdpZHRoIGZvciBzcGVjaWZpYyBzdGF0ZS5cbiAgICAgKiBXaWxsIGF0dGVtcHQgdG8gZXZhbHVhdGUgcmVxdWVzdGVkIHN0YXRlIGFuZCBjYWNoZS5cbiAgICAgKlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZXhwZWN0ZWRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXhwZWN0ZWRXaWR0aChmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBEcmF3ZXIgbWluaSB3aWR0aCBmb3Igc3BlY2lmaWMgc3RhdGUuXG4gICAgICogV2lsbCBhdHRlbXB0IHRvIGV2YWx1YXRlIHJlcXVlc3RlZCBzdGF0ZSBhbmQgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBleHBlY3RlZE1pbmlXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXhwZWN0ZWRXaWR0aCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCB0b3VjaE1hbmFnZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3VjaE1hbmFnZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwb3NlcyBvcHRpb25hbCBuYXZpZ2F0aW9uIHNlcnZpY2VcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoRWxlbWVudFJlZikgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9zdGF0ZTogSWd4TmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICBwcml2YXRlIF90b3VjaE1hbmFnZXI6IEhhbW1lckdlc3R1cmVzTWFuYWdlcixcbiAgICAgICAgcHJpdmF0ZSBwbGF0Zm9ybVV0aWw6IFBsYXRmb3JtVXRpbCkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgICAgIC8vIERPTSBhbmQgQElucHV0KCktcyBpbml0aWFsaXplZFxuICAgICAgICBpZiAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLmFkZCh0aGlzLmlkLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhd2VyV2lkdGgodGhpcy53aWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgLy8gd2FpdCBmb3IgdGVtcGxhdGUgYW5kIG5nLWNvbnRlbnQgdG8gYmUgcmVhZHlcbiAgICAgICAgdGhpcy51cGRhdGVFZGdlWm9uZSgpO1xuICAgICAgICB0aGlzLmNoZWNrUGluVGhyZXNob2xkKCk7XG5cbiAgICAgICAgdGhpcy5lbnN1cmVFdmVudHMoKTtcblxuICAgICAgICAvLyBUT0RPOiBhcHBseSBwbGF0Zm9ybS1zYWZlIFJ1bGVyIGZyb20gaHR0cDovL3BsbmtyLmNvL2VkaXQvODFuV0R5cmVZTXprdW5paGZSZ1g/cD1wcmV2aWV3XG4gICAgICAgIC8vIChodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy82NTE1KSwgYmxvY2tlZCBieSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy82OTA0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5yZW1vdmUodGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiB7IFtwcm9wTmFtZTogc3RyaW5nXTogU2ltcGxlQ2hhbmdlIH0pIHtcbiAgICAgICAgLy8gc2ltcGxlIHNldHRpbmdzIGNhbiBjb21lIGZyb20gYXR0cmlidXRlIHNldCAocmF0aGVyIHRoYW4gYmluZGluZyksIG1ha2Ugc3VyZSBib29sZWFuIHByb3BzIGFyZSBjb252ZXJ0ZWRcbiAgICAgICAgaWYgKGNoYW5nZXMuZW5hYmxlR2VzdHVyZXMgJiYgY2hhbmdlcy5lbmFibGVHZXN0dXJlcy5jdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVHZXN0dXJlcyA9ICEhKHRoaXMuZW5hYmxlR2VzdHVyZXMgJiYgdGhpcy5lbmFibGVHZXN0dXJlcy50b1N0cmluZygpID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgdGhpcy5lbnN1cmVFdmVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5waW4gJiYgY2hhbmdlcy5waW4uY3VycmVudFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGluID0gISEodGhpcy5waW4gJiYgdGhpcy5waW4udG9TdHJpbmcoKSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBpbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZUV2ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZXMucGluVGhyZXNob2xkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5waW5UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZUV2ZW50cygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQaW5UaHJlc2hvbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VzLndpZHRoICYmIHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyYXdlcldpZHRoKGNoYW5nZXMud2lkdGguY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aCh0aGlzLmlzT3BlbiA/IHRoaXMud2lkdGggOiAodGhpcy5taW5pVGVtcGxhdGUgPyB0aGlzLm1pbmlXaWR0aCA6ICcnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlcy5taW5pV2lkdGgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERyYXdlcldpZHRoKGNoYW5nZXMubWluaVdpZHRoLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVkZ2Vab25lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIG9wZW4gc3RhdGUgb2YgdGhlIE5hdmlnYXRpb24gRHJhd2VyLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubmF2ZHJhd2VyLnRvZ2dsZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBOYXZpZ2F0aW9uIERyYXdlci4gSGFzIG5vIGVmZmVjdCBpZiBhbHJlYWR5IG9wZW5lZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm5hdmRyYXdlci5vcGVuKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIG9wZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UGFuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGVuaW5nLmVtaXQoKTtcbiAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuXG4gICAgICAgIC8vIFRPRE86IFN3aXRjaCB0byBhbmltYXRlIEFQSSB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAvLyB2YXIgYW5pbWF0aW9uQ3NzID0gdGhpcy5hbmltYXRlLmNzcygpO1xuICAgICAgICAvLyAgICAgYW5pbWF0aW9uQ3NzXG4gICAgICAgIC8vICAgICAgICAgLnNldFN0eWxlcyh7J3dpZHRoJzonNTBweCd9LCB7J3dpZHRoJzonNDAwcHgnfSlcbiAgICAgICAgLy8gICAgICAgICAuc3RhcnQodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpXG4gICAgICAgIC8vICAgICAgICAgLm9uQ29tcGxldGUoKCkgPT4gYW5pbWF0aW9uQ3NzLnNldFRvU3R5bGVzKHsnd2lkdGgnOidhdXRvJ30pLnN0YXJ0KHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudG9nZ2xlT3BlbmVkRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aCh0aGlzLndpZHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIuIEhhcyBubyBlZmZlY3QgaWYgYWxyZWFkeSBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5uYXZkcmF3ZXIuY2xvc2UoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UGFuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2luZy5lbWl0KCk7XG5cbiAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aCh0aGlzLm1pbmlUZW1wbGF0ZSA/IHRoaXMubWluaVdpZHRoIDogJycpO1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy50b2dnbGVDbG9zZWRFdmVudCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2V0X21heEVkZ2Vab25lKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbWF4RWRnZVpvbmUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIERyYXdlciB3aWR0aCBmb3Igc3BlY2lmaWMgc3RhdGUuIFdpbGwgYXR0ZW1wdCB0byBldmFsdWF0ZSByZXF1ZXN0ZWQgc3RhdGUgYW5kIGNhY2hlLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBwYXJhbSBbbWluaV0gLSBSZXF1ZXN0IG1pbmkgd2lkdGggaW5zdGVhZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRFeHBlY3RlZFdpZHRoKG1pbmk/OiBib29sZWFuKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKG1pbmkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5taW5pVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1pbmlXaWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMubWluaVdpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKCF0aGlzLmlzT3BlbikgeyAvLyBUaGlzIFdPTidUIHdvcmsgZHVlIHRvIHRyYW5zaXRpb24gdGltaW5ncy4uLlxuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMV0ub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fd2lkdGhDYWNoZS5taW5pV2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgY2xhc3MgZm9yIHdpZHRoIGNhbGMuIFRPRE8/XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIGNsYXNzIGZvciB3aWR0aCBjYWxjLiBUT0RPP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3MuZHJhd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzLm1pbmkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93aWR0aENhY2hlLm1pbmlXaWR0aCA9IHRoaXMuc3R5bGVEdW1teS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzLmRyYXdlcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5zdHlsZUR1bW15LCB0aGlzLmNzcy5taW5pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoQ2FjaGUubWluaVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dpZHRoQ2FjaGUud2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgY2xhc3MgZm9yIHdpZHRoIGNhbGMuIFRPRE8/XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIGNsYXNzIGZvciB3aWR0aCBjYWxjLiBUT0RPP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3MuZHJhd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2lkdGhDYWNoZS53aWR0aCA9IHRoaXMuc3R5bGVEdW1teS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzLmRyYXdlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aENhY2hlLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRXaW5kb3dXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuICh3aW5kb3cuaW5uZXJXaWR0aCA+IDApID8gd2luZG93LmlubmVyV2lkdGggOiBzY3JlZW4ud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZHJhd2VyIHdpZHRoLlxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0RHJhd2VyV2lkdGgod2lkdGg6IHN0cmluZykge1xuICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybVV0aWwuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRyYXdlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZHJhd2VyLCAnd2lkdGgnLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZHJhd2VyLCAnd2lkdGgnLCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBEcmF3ZXIgd2lkdGguXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXREcmF3ZXJXaWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3ZXIub2Zmc2V0V2lkdGg7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBlbnN1cmVFdmVudHMoKSB7XG4gICAgICAgIC8vIHNldCBsaXN0ZW5lcnMgZm9yIHN3aXBlL3BhbiBvbmx5IGlmIG5lZWRlZCwgYnV0IGp1c3Qgb25jZVxuICAgICAgICBpZiAodGhpcy5lbmFibGVHZXN0dXJlcyAmJiAhdGhpcy5waW4gJiYgIXRoaXMuX2dlc3R1cmVzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIC8vIEJ1aWx0LWluIG1hbmFnZXIgaGFuZGxlcihMMjA4ODcpIGNhdXNlcyBlbmRsZXNzIGxvb3AgYW5kIG1heCBzdGFjayBleGNlcHRpb24uXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy82OTkzXG4gICAgICAgICAgICAvLyBVc2Ugb3VycyBmb3Igbm93ICh1bnRpbCBiZXRhLjEwKTpcbiAgICAgICAgICAgIC8vIHRoaXMucmVuZGVyZXIubGlzdGVuKGRvY3VtZW50LCBcInN3aXBlXCIsIHRoaXMuc3dpcGUpO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIoJ2RvY3VtZW50JywgJ3N3aXBlJywgdGhpcy5zd2lwZSk7XG4gICAgICAgICAgICB0aGlzLl9nZXN0dXJlc0F0dGFjaGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gdGhpcy5yZW5kZXJlci5saXN0ZW4oZG9jdW1lbnQsIFwicGFuc3RhcnRcIiwgdGhpcy5wYW5zdGFydCk7XG4gICAgICAgICAgICAvLyB0aGlzLnJlbmRlcmVyLmxpc3Rlbihkb2N1bWVudCwgXCJwYW5cIiwgdGhpcy5wYW4pO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIoJ2RvY3VtZW50JywgJ3BhbnN0YXJ0JywgdGhpcy5wYW5zdGFydCk7XG4gICAgICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcignZG9jdW1lbnQnLCAncGFubW92ZScsIHRoaXMucGFuKTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlci5hZGRHbG9iYWxFdmVudExpc3RlbmVyKCdkb2N1bWVudCcsICdwYW5lbmQnLCB0aGlzLnBhbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9yZXNpemVPYnNlcnZlciAmJiB0aGlzLnBsYXRmb3JtVXRpbC5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gZnJvbUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScpLnBpcGUoZGVib3VuY2UoKCkgPT4gaW50ZXJ2YWwoMTUwKSkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BpblRocmVzaG9sZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUVkZ2Vab25lKCkge1xuICAgICAgICBsZXQgbWF4VmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMubWluaVRlbXBsYXRlKSB7XG4gICAgICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KHRoaXMuX21heEVkZ2Vab25lLCB0aGlzLmdldEV4cGVjdGVkV2lkdGgodHJ1ZSkgKiAxLjEpO1xuICAgICAgICAgICAgdGhpcy5zZXRfbWF4RWRnZVpvbmUobWF4VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjaGVja1BpblRocmVzaG9sZCA9IChldnQ/OiBFdmVudCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucGxhdGZvcm1VdGlsLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3aW5kb3dXaWR0aDtcbiAgICAgICAgaWYgKHRoaXMucGluVGhyZXNob2xkKSB7XG4gICAgICAgICAgICB3aW5kb3dXaWR0aCA9IHRoaXMuZ2V0V2luZG93V2lkdGgoKTtcbiAgICAgICAgICAgIGlmIChldnQgJiYgdGhpcy5fd2lkdGhDYWNoZS53aW5kb3dXaWR0aCA9PT0gd2luZG93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl93aWR0aENhY2hlLndpbmRvd1dpZHRoID0gd2luZG93V2lkdGg7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGluICYmIHdpbmRvd1dpZHRoID49IHRoaXMucGluVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucGluQ2hhbmdlLmVtaXQodHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGluICYmIHdpbmRvd1dpZHRoIDwgdGhpcy5waW5UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucGluQ2hhbmdlLmVtaXQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzd2lwZSA9IChldnQ6IEhhbW1lcklucHV0KSA9PiB7XG4gICAgICAgIC8vIFRPRE86IENvdWxkIGFsc28gZm9yY2UgaW5wdXQgdHlwZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjcxMDgwNTJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUdlc3R1cmVzIHx8IGV2dC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFtbWVySlMgc3dpcGUgaXMgaG9yaXpvbnRhbC1vbmx5IGJ5IGRlZmF1bHQsIGRvbid0IGNoZWNrIGRlbHRhWVxuICAgICAgICBsZXQgZGVsdGFYO1xuICAgICAgICBsZXQgc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gb24gdGhlIHJpZ2h0IHVzZSBpbnZlcnNlIG9mIGRlbHRhWFxuICAgICAgICAgICAgZGVsdGFYID0gLWV2dC5kZWx0YVg7XG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uID0gdGhpcy5nZXRXaW5kb3dXaWR0aCgpIC0gKGV2dC5jZW50ZXIueCArIGV2dC5kaXN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YVggPSBldnQuZGVsdGFYO1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IGV2dC5jZW50ZXIueCAtIGV2dC5kaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvbmx5IGFjY2VwdCBjbG9zaW5nIHN3aXBlIChpZ25vcmluZyBtaW5FZGdlWm9uZSkgd2hlbiB0aGUgZHJhd2VyIGlzIGV4cGFuZGVkOlxuICAgICAgICBpZiAoKHRoaXMuaXNPcGVuICYmIGRlbHRhWCA8IDApIHx8XG4gICAgICAgICAgICAvLyBwb3NpdGl2ZSBkZWx0YVggZnJvbSB0aGUgZWRnZTpcbiAgICAgICAgICAgIChkZWx0YVggPiAwICYmIHN0YXJ0UG9zaXRpb24gPCB0aGlzLm1heEVkZ2Vab25lKSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcGFuc3RhcnQgPSAoZXZ0OiBIYW1tZXJJbnB1dCkgPT4geyAvLyBUT0RPOiB0ZXN0IGNvZGVcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUdlc3R1cmVzIHx8IHRoaXMucGluIHx8IGV2dC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnID8gdGhpcy5nZXRXaW5kb3dXaWR0aCgpIC0gKGV2dC5jZW50ZXIueCArIGV2dC5kaXN0YW5jZSlcbiAgICAgICAgICAgIDogZXZ0LmNlbnRlci54IC0gZXZ0LmRpc3RhbmNlO1xuXG4gICAgICAgIC8vIGNhY2hlIHdpZHRoIGR1cmluZyBhbmltYXRpb24sIGZsYWcgdG8gYWxsb3cgZnVydGhlciBoYW5kbGluZ1xuICAgICAgICBpZiAodGhpcy5pc09wZW4gfHwgKHN0YXJ0UG9zaXRpb24gPCB0aGlzLm1heEVkZ2Vab25lKSkge1xuICAgICAgICAgICAgdGhpcy5fcGFubmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wYW5TdGFydFdpZHRoID0gdGhpcy5nZXRFeHBlY3RlZFdpZHRoKCF0aGlzLmlzT3Blbik7XG4gICAgICAgICAgICB0aGlzLl9wYW5MaW1pdCA9IHRoaXMuZ2V0RXhwZWN0ZWRXaWR0aCh0aGlzLmlzT3Blbik7XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5vdmVybGF5LCAncGFubmluZycpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmRyYXdlciwgJ3Bhbm5pbmcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcGFuID0gKGV2dDogSGFtbWVySW5wdXQpID0+IHtcbiAgICAgICAgLy8gVE9ETzogaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XG4gICAgICAgIC8vIGdldCBhY3R1YWwgZGVsdGEgKG5vdCB0b3RhbCBzZXNzaW9uIG9uZSkgZnJvbSBldmVudD9cbiAgICAgICAgLy8gcGFuIFdJTEwgYWxzbyBmaXJlIGFmdGVyIGEgZnVsbCBzd2lwZSwgb25seSByZXNpemUgb24gZmxhZ1xuICAgICAgICBpZiAoIXRoaXMuX3Bhbm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByaWdodDogYm9vbGVhbiA9IHRoaXMucG9zaXRpb24gPT09ICdyaWdodCc7XG4gICAgICAgIC8vIHdoZW4gb24gdGhlIHJpZ2h0IHVzZSBpbnZlcnNlIG9mIGRlbHRhWFxuICAgICAgICBjb25zdCBkZWx0YVggPSByaWdodCA/IC1ldnQuZGVsdGFYIDogZXZ0LmRlbHRhWDtcbiAgICAgICAgbGV0IHZpc2libGVXaWR0aDtcbiAgICAgICAgbGV0IG5ld1g7XG4gICAgICAgIGxldCBwZXJjZW50O1xuXG4gICAgICAgIHZpc2libGVXaWR0aCA9IHRoaXMuX3BhblN0YXJ0V2lkdGggKyBkZWx0YVg7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuICYmIGRlbHRhWCA8IDApIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdmlzaWJsZVdpZHRoIGhpdHMgbGltaXQgLSBzdG9wIGFuaW1hdGluZ1xuICAgICAgICAgICAgaWYgKHZpc2libGVXaWR0aCA8PSB0aGlzLl9wYW5MaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQW5pbWF0ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICh2aXNpYmxlV2lkdGggLSB0aGlzLl9wYW5MaW1pdCkgLyAodGhpcy5fcGFuU3RhcnRXaWR0aCAtIHRoaXMuX3BhbkxpbWl0KTtcbiAgICAgICAgICAgICAgICBuZXdYID0gdmlzaWJsZVdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gdmlzaWJsZVdpZHRoIC8gdGhpcy5fcGFuU3RhcnRXaWR0aDtcbiAgICAgICAgICAgICAgICBuZXdYID0gZXZ0LmRlbHRhWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0WFNpemUobmV3WCwgcGVyY2VudC50b1ByZWNpc2lvbigyKSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc09wZW4gJiYgZGVsdGFYID4gMCkge1xuICAgICAgICAgICAgLy8gd2hlbiB2aXNpYmxlV2lkdGggaGl0cyBsaW1pdCAtIHN0b3AgYW5pbWF0aW5nXG4gICAgICAgICAgICBpZiAodmlzaWJsZVdpZHRoID49IHRoaXMuX3BhbkxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNBbmltYXRlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gKHZpc2libGVXaWR0aCAtIHRoaXMuX3BhblN0YXJ0V2lkdGgpIC8gKHRoaXMuX3BhbkxpbWl0IC0gdGhpcy5fcGFuU3RhcnRXaWR0aCk7XG4gICAgICAgICAgICAgICAgbmV3WCA9IHZpc2libGVXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9IHZpc2libGVXaWR0aCAvIHRoaXMuX3BhbkxpbWl0O1xuICAgICAgICAgICAgICAgIG5ld1ggPSAodGhpcy5fcGFuTGltaXQgLSB2aXNpYmxlV2lkdGgpICogKHJpZ2h0ID8gMSA6IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0WFNpemUobmV3WCwgcGVyY2VudC50b1ByZWNpc2lvbigyKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhbkVuZCA9IChldnQ6IEhhbW1lcklucHV0KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9wYW5uaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YVggPSB0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnID8gLWV2dC5kZWx0YVggOiBldnQuZGVsdGFYO1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZVdpZHRoOiBudW1iZXIgPSB0aGlzLl9wYW5TdGFydFdpZHRoICsgZGVsdGFYO1xuICAgICAgICAgICAgdGhpcy5yZXNldFBhbigpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBwYW4gYnJvdWdodCB0aGUgZHJhd2VyIHRvIDUwJVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuICYmIHZpc2libGVXaWR0aCA8PSB0aGlzLl9wYW5TdGFydFdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNPcGVuICYmIHZpc2libGVXaWR0aCA+PSB0aGlzLl9wYW5MaW1pdCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BhblN0YXJ0V2lkdGggPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXNldFBhbigpIHtcbiAgICAgICAgdGhpcy5fcGFubmluZyA9IGZhbHNlO1xuICAgICAgICAvKiBzdHlsZXMgZmFpbCB0byBhcHBseSB3aGVuIHNldCBvbiBwYXJlbnQgZHVlIHRvIGV4dHJhIGF0dHJpYnV0ZXMsIHByb2IgbmcgYnVnICovXG4gICAgICAgIC8qIHN0eWxlcyBmYWlsIHRvIGFwcGx5IHdoZW4gc2V0IG9uIHBhcmVudCBkdWUgdG8gZXh0cmEgYXR0cmlidXRlcywgcHJvYiBuZyBidWcgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLm92ZXJsYXksICdwYW5uaW5nJyk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5kcmF3ZXIsICdwYW5uaW5nJyk7XG4gICAgICAgIHRoaXMuc2V0WFNpemUoMCwgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9yIHdpZHRoIGluIGNhc2UgdGhlIGRyYXdlciBkb2Vzbid0IGNoYW5nZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0geCB0aGUgbnVtYmVyIHBpeGVscyB0byB0cmFuc2xhdGUgb24gdGhlIFggYXhpcyBvciB0aGUgd2lkdGggdG8gc2V0LiAwIHdpZHRoIHdpbGwgY2xlYXIgdGhlIHN0eWxlIGluc3RlYWQuXG4gICAgICogQHBhcmFtIG9wYWNpdHkgb3B0aW9uYWwgdmFsdWUgdG8gYXBwbHkgdG8gdGhlIG92ZXJsYXlcbiAgICAgKi9cbiAgICBwcml2YXRlIHNldFhTaXplKHg6IG51bWJlciwgb3BhY2l0eT86IHN0cmluZykge1xuICAgICAgICAvLyBBbmd1bGFyIHBvbHlmaWxscyBwYXRjaGVzIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGJ1dCBzd2l0Y2ggdG8gRG9tQWRhcHRlciBBUEkgKFRPRE8pXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQW5pbWF0ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmRyYXdlciwgJ3dpZHRoJywgeCA/IE1hdGguYWJzKHgpICsgJ3B4JyA6ICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmRyYXdlciwgJ3RyYW5zZm9ybScsIHggPyAndHJhbnNsYXRlM2QoJyArIHggKyAncHgsMCwwKScgOiAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmRyYXdlciwgJy13ZWJraXQtdHJhbnNmb3JtJywgeCA/ICd0cmFuc2xhdGUzZCgnICsgeCArICdweCwwLDApJyA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMub3ZlcmxheSwgJ29wYWNpdHknLCBvcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b2dnbGVPcGVuZWRFdmVudCA9IChldnQ/KSA9PiB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRvZ2dsZU9wZW5lZEV2ZW50LCBmYWxzZSk7XG4gICAgICAgIHRoaXMub3BlbmVkLmVtaXQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZUNsb3NlZEV2ZW50ID0gKGV2dD8pID0+IHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudG9nZ2xlQ2xvc2VkRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jbG9zZWQuZW1pdCgpO1xuICAgIH1cbn1cbiJdfQ==