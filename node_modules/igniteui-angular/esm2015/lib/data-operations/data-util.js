import { IgxSorting, IgxDataRecordSorting } from './sorting-strategy';
import { IgxGrouping } from './grouping-strategy';
import { PagingError } from './paging-state.interface';
import { FilteringStrategy } from './filtering-strategy';
import { cloneValue, mergeObjects, mkenum } from '../core/utils';
import { TransactionType } from '../services/transaction/transaction';
import { getHierarchy, isHierarchyMatch } from './operations';
/**
 * @hidden
 */
export const DataType = mkenum({
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Date: 'date'
});
/**
 * @hidden
 */
export class DataUtil {
    static sort(data, expressions, sorting = new IgxSorting(), grid) {
        return sorting.sort(data, expressions, grid);
    }
    static treeGridSort(hierarchicalData, expressions, sorting = new IgxDataRecordSorting(), parent, grid) {
        let res = [];
        hierarchicalData.forEach((hr) => {
            const rec = DataUtil.cloneTreeGridRecord(hr);
            rec.parent = parent;
            if (rec.children) {
                rec.children = DataUtil.treeGridSort(rec.children, expressions, sorting, rec, grid);
            }
            res.push(rec);
        });
        res = DataUtil.sort(res, expressions, sorting, grid);
        return res;
    }
    static cloneTreeGridRecord(hierarchicalRecord) {
        const rec = {
            rowID: hierarchicalRecord.rowID,
            data: hierarchicalRecord.data,
            children: hierarchicalRecord.children,
            isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
            level: hierarchicalRecord.level,
            expanded: hierarchicalRecord.expanded
        };
        return rec;
    }
    static group(data, state, grid = null, groupsRecords = [], fullResult = { data: [], metadata: [] }) {
        const grouping = new IgxGrouping();
        groupsRecords.splice(0, groupsRecords.length);
        return grouping.groupBy(data, state, grid, groupsRecords, fullResult);
    }
    static page(data, state, dataLength) {
        if (!state) {
            return data;
        }
        const len = dataLength !== undefined ? dataLength : data.length;
        const index = state.index;
        const res = [];
        const recordsPerPage = dataLength !== undefined && state.recordsPerPage > dataLength ? dataLength : state.recordsPerPage;
        state.metadata = {
            countPages: 0,
            countRecords: len,
            error: PagingError.None
        };
        if (index < 0 || isNaN(index)) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
            state.metadata.error = PagingError.IncorrectRecordsPerPage;
            return res;
        }
        state.metadata.countPages = Math.ceil(len / recordsPerPage);
        if (!len) {
            return data;
        }
        if (index >= state.metadata.countPages) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
    }
    static filter(data, state, grid) {
        if (!state.strategy) {
            state.strategy = new FilteringStrategy();
        }
        return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree, grid);
    }
    static correctPagingState(state, length) {
        const maxPage = Math.ceil(length / state.recordsPerPage) - 1;
        if (!isNaN(maxPage) && state.index > maxPage) {
            state.index = maxPage;
        }
    }
    static getHierarchy(gRow) {
        return getHierarchy(gRow);
    }
    static isHierarchyMatch(h1, h2) {
        return isHierarchyMatch(h1, h2);
    }
    /**
     * Merges all changes from provided transactions into provided data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    static mergeTransactions(data, transactions, primaryKey, deleteRows = false) {
        data.forEach((item, index) => {
            const rowId = primaryKey ? item[primaryKey] : item;
            const transaction = transactions.find(t => t.id === rowId);
            if (transaction && transaction.type === TransactionType.UPDATE) {
                data[index] = transaction.newValue;
            }
        });
        if (deleteRows) {
            transactions
                .filter(t => t.type === TransactionType.DELETE)
                .forEach(t => {
                const index = primaryKey ? data.findIndex(d => d[primaryKey] === t.id) : data.findIndex(d => d === t.id);
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
            });
        }
        data.push(...transactions
            .filter(t => t.type === TransactionType.ADD)
            .map(t => t.newValue));
        return data;
    }
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param childDataKey Data key of child collections
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    static mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey, deleteRows = false) {
        for (const transaction of transactions) {
            if (transaction.path) {
                const parent = this.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                let collection = parent ? parent[childDataKey] : data;
                switch (transaction.type) {
                    case TransactionType.ADD:
                        //  if there is no parent this is ADD row at root level
                        if (parent && !parent[childDataKey]) {
                            parent[childDataKey] = collection = [];
                        }
                        collection.push(transaction.newValue);
                        break;
                    case TransactionType.UPDATE:
                        const updateIndex = collection.findIndex(x => x[primaryKey] === transaction.id);
                        if (updateIndex !== -1) {
                            collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                        }
                        break;
                    case TransactionType.DELETE:
                        if (deleteRows) {
                            const deleteIndex = collection.findIndex(r => r[primaryKey] === transaction.id);
                            if (deleteIndex !== -1) {
                                collection.splice(deleteIndex, 1);
                            }
                        }
                        break;
                }
            }
            else {
                //  if there is no path this is ADD row in root. Push the newValue to data
                data.push(transaction.newValue);
            }
        }
        return data;
    }
    static parseValue(dataType, value) {
        if (dataType === DataType.Number) {
            value = parseFloat(value);
        }
        return value;
    }
    static findParentFromPath(data, primaryKey, childDataKey, path) {
        let collection = data;
        let result;
        for (const id of path) {
            result = collection && collection.find(x => x[primaryKey] === id);
            if (!result) {
                break;
            }
            collection = result[childDataKey];
        }
        return result;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS11dGlsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2RhdGEtb3BlcmF0aW9ucy9kYXRhLXV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxvQkFBb0IsRUFBd0IsTUFBTSxvQkFBb0IsQ0FBQztBQUM1RixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFHbEQsT0FBTyxFQUFnQixXQUFXLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQU1yRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUV6RCxPQUFPLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDakUsT0FBTyxFQUFlLGVBQWUsRUFBMkIsTUFBTSxxQ0FBcUMsQ0FBQztBQUM1RyxPQUFPLEVBQUUsWUFBWSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRzlEOztHQUVHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQztJQUMzQixNQUFNLEVBQUUsUUFBUTtJQUNoQixNQUFNLEVBQUUsUUFBUTtJQUNoQixPQUFPLEVBQUUsU0FBUztJQUNsQixJQUFJLEVBQUUsTUFBTTtDQUNmLENBQUMsQ0FBQztBQUdIOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFFBQVE7SUFDVixNQUFNLENBQUMsSUFBSSxDQUFJLElBQVMsRUFBRSxXQUFpQyxFQUFFLFVBQWdDLElBQUksVUFBVSxFQUFFLEVBQ2hILElBQWU7UUFDZixPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRU0sTUFBTSxDQUFDLFlBQVksQ0FBQyxnQkFBbUMsRUFDMUQsV0FBaUMsRUFDakMsVUFB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QUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUNuQztTQUNKO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVNLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBa0IsRUFBRSxLQUFVO1FBQ25ELElBQUksUUFBUSxLQUFLLFFBQVEsQ0FBQyxNQUFNLEVBQUU7WUFDOUIsS0FBSyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUM3QjtRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFFTyxNQUFNLENBQUMsa0JBQWtCLENBQUMsSUFBVyxFQUFFLFVBQWUsRUFBRSxZQUFpQixFQUFFLElBQVc7UUFDMUYsSUFBSSxVQUFVLEdBQVUsSUFBSSxDQUFDO1FBQzdCLElBQUksTUFBVyxDQUFDO1FBRWhCLEtBQUssTUFBTSxFQUFFLElBQUksSUFBSSxFQUFFO1lBQ25CLE1BQU0sR0FBRyxVQUFVLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUNsRSxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNULE1BQU07YUFDVDtZQUVELFVBQVUsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDckM7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJRmlsdGVyaW5nU3RhdGUgfSBmcm9tICcuL2ZpbHRlcmluZy1zdGF0ZS5pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBJZ3hTb3J0aW5nLCBJZ3hEYXRhUmVjb3JkU29ydGluZywgSUdyaWRTb3J0aW5nU3RyYXRlZ3kgfSBmcm9tICcuL3NvcnRpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgSWd4R3JvdXBpbmcgfSBmcm9tICcuL2dyb3VwaW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IElHcm91cEJ5UmVzdWx0IH0gZnJvbSAnLi9ncm91cGluZy1yZXN1bHQuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgSVBhZ2luZ1N0YXRlLCBQYWdpbmdFcnJvciB9IGZyb20gJy4vcGFnaW5nLXN0YXRlLmludGVyZmFjZSc7XG5cbmltcG9ydCB7IElHcm91cEJ5S2V5IH0gZnJvbSAnLi9ncm91cGJ5LWV4cGFuZC1zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUdyb3VwQnlSZWNvcmQgfSBmcm9tICcuL2dyb3VwYnktcmVjb3JkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJR3JvdXBpbmdTdGF0ZSB9IGZyb20gJy4vZ3JvdXBieS1zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSVNvcnRpbmdFeHByZXNzaW9uIH0gZnJvbSAnLi9zb3J0aW5nLWV4cHJlc3Npb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IEZpbHRlcmluZ1N0cmF0ZWd5IH0gZnJvbSAnLi9maWx0ZXJpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgSVRyZWVHcmlkUmVjb3JkIH0gZnJvbSAnLi4vZ3JpZHMvdHJlZS1ncmlkL3B1YmxpY19hcGknO1xuaW1wb3J0IHsgY2xvbmVWYWx1ZSwgbWVyZ2VPYmplY3RzLCBta2VudW0gfSBmcm9tICcuLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvblR5cGUsIEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vc2VydmljZXMvdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgZ2V0SGllcmFyY2h5LCBpc0hpZXJhcmNoeU1hdGNoIH0gZnJvbSAnLi9vcGVyYXRpb25zJztcbmltcG9ydCB7IEdyaWRUeXBlIH0gZnJvbSAnLi4vZ3JpZHMvY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjb25zdCBEYXRhVHlwZSA9IG1rZW51bSh7XG4gICAgU3RyaW5nOiAnc3RyaW5nJyxcbiAgICBOdW1iZXI6ICdudW1iZXInLFxuICAgIEJvb2xlYW46ICdib29sZWFuJyxcbiAgICBEYXRlOiAnZGF0ZSdcbn0pO1xuZXhwb3J0IHR5cGUgRGF0YVR5cGUgPSAodHlwZW9mIERhdGFUeXBlKVtrZXlvZiB0eXBlb2YgRGF0YVR5cGVdO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFVdGlsIHtcbiAgICBwdWJsaWMgc3RhdGljIHNvcnQ8VD4oZGF0YTogVFtdLCBleHByZXNzaW9uczogSVNvcnRpbmdFeHByZXNzaW9uW10sIHNvcnRpbmc6IElHcmlkU29ydGluZ1N0cmF0ZWd5ID0gbmV3IElneFNvcnRpbmcoKSxcbiAgICAgICAgZ3JpZD86IEdyaWRUeXBlKTogVFtdIHtcbiAgICAgICAgcmV0dXJuIHNvcnRpbmcuc29ydChkYXRhLCBleHByZXNzaW9ucywgZ3JpZCk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyB0cmVlR3JpZFNvcnQoaGllcmFyY2hpY2FsRGF0YTogSVRyZWVHcmlkUmVjb3JkW10sXG4gICAgICAgIGV4cHJlc3Npb25zOiBJU29ydGluZ0V4cHJlc3Npb25bXSxcbiAgICAgICAgc29ydGluZzogSUdyaWRTb3J0aW5nU3RyYXRlZ3kgPSBuZXcgSWd4RGF0YVJlY29yZFNvcnRpbmcoKSxcbiAgICAgICAgcGFyZW50PzogSVRyZWVHcmlkUmVjb3JkLFxuICAgICAgICBncmlkPzogR3JpZFR5cGUpOiBJVHJlZUdyaWRSZWNvcmRbXSB7XG4gICAgICAgIGxldCByZXM6IElUcmVlR3JpZFJlY29yZFtdID0gW107XG4gICAgICAgIGhpZXJhcmNoaWNhbERhdGEuZm9yRWFjaCgoaHI6IElUcmVlR3JpZFJlY29yZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVjOiBJVHJlZUdyaWRSZWNvcmQgPSBEYXRhVXRpbC5jbG9uZVRyZWVHcmlkUmVjb3JkKGhyKTtcbiAgICAgICAgICAgIHJlYy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAocmVjLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgcmVjLmNoaWxkcmVuID0gRGF0YVV0aWwudHJlZUdyaWRTb3J0KHJlYy5jaGlsZHJlbiwgZXhwcmVzc2lvbnMsIHNvcnRpbmcsIHJlYywgZ3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaChyZWMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXMgPSBEYXRhVXRpbC5zb3J0KHJlcywgZXhwcmVzc2lvbnMsIHNvcnRpbmcsIGdyaWQpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjbG9uZVRyZWVHcmlkUmVjb3JkKGhpZXJhcmNoaWNhbFJlY29yZDogSVRyZWVHcmlkUmVjb3JkKSB7XG4gICAgICAgIGNvbnN0IHJlYzogSVRyZWVHcmlkUmVjb3JkID0ge1xuICAgICAgICAgICAgcm93SUQ6IGhpZXJhcmNoaWNhbFJlY29yZC5yb3dJRCxcbiAgICAgICAgICAgIGRhdGE6IGhpZXJhcmNoaWNhbFJlY29yZC5kYXRhLFxuICAgICAgICAgICAgY2hpbGRyZW46IGhpZXJhcmNoaWNhbFJlY29yZC5jaGlsZHJlbixcbiAgICAgICAgICAgIGlzRmlsdGVyZWRPdXRQYXJlbnQ6IGhpZXJhcmNoaWNhbFJlY29yZC5pc0ZpbHRlcmVkT3V0UGFyZW50LFxuICAgICAgICAgICAgbGV2ZWw6IGhpZXJhcmNoaWNhbFJlY29yZC5sZXZlbCxcbiAgICAgICAgICAgIGV4cGFuZGVkOiBoaWVyYXJjaGljYWxSZWNvcmQuZXhwYW5kZWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlYztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwPFQ+KGRhdGE6IFRbXSwgc3RhdGU6IElHcm91cGluZ1N0YXRlLCBncmlkOiBHcmlkVHlwZSA9IG51bGwsXG4gICAgICAgIGdyb3Vwc1JlY29yZHM6IGFueVtdID0gW10sIGZ1bGxSZXN1bHQ6IElHcm91cEJ5UmVzdWx0ID0geyBkYXRhOiBbXSwgbWV0YWRhdGE6IFtdIH0pOiBJR3JvdXBCeVJlc3VsdCB7XG4gICAgICAgIGNvbnN0IGdyb3VwaW5nID0gbmV3IElneEdyb3VwaW5nKCk7XG4gICAgICAgIGdyb3Vwc1JlY29yZHMuc3BsaWNlKDAsIGdyb3Vwc1JlY29yZHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGdyb3VwaW5nLmdyb3VwQnkoZGF0YSwgc3RhdGUsIGdyaWQsIGdyb3Vwc1JlY29yZHMsIGZ1bGxSZXN1bHQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgcGFnZTxUPihkYXRhOiBUW10sIHN0YXRlOiBJUGFnaW5nU3RhdGUsIGRhdGFMZW5ndGg/OiBudW1iZXIpOiBUW10ge1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBkYXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBkYXRhTGVuZ3RoIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBjb25zdCByZWNvcmRzUGVyUGFnZSA9IGRhdGFMZW5ndGggIT09IHVuZGVmaW5lZCAmJiBzdGF0ZS5yZWNvcmRzUGVyUGFnZSA+IGRhdGFMZW5ndGggPyBkYXRhTGVuZ3RoIDogc3RhdGUucmVjb3Jkc1BlclBhZ2U7XG4gICAgICAgIHN0YXRlLm1ldGFkYXRhID0ge1xuICAgICAgICAgICAgY291bnRQYWdlczogMCxcbiAgICAgICAgICAgIGNvdW50UmVjb3JkczogbGVuLFxuICAgICAgICAgICAgZXJyb3I6IFBhZ2luZ0Vycm9yLk5vbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpc05hTihpbmRleCkpIHtcbiAgICAgICAgICAgIHN0YXRlLm1ldGFkYXRhLmVycm9yID0gUGFnaW5nRXJyb3IuSW5jb3JyZWN0UGFnZUluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjb3Jkc1BlclBhZ2UgPD0gMCB8fCBpc05hTihyZWNvcmRzUGVyUGFnZSkpIHtcbiAgICAgICAgICAgIHN0YXRlLm1ldGFkYXRhLmVycm9yID0gUGFnaW5nRXJyb3IuSW5jb3JyZWN0UmVjb3Jkc1BlclBhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1ldGFkYXRhLmNvdW50UGFnZXMgPSBNYXRoLmNlaWwobGVuIC8gcmVjb3Jkc1BlclBhZ2UpO1xuICAgICAgICBpZiAoIWxlbikge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID49IHN0YXRlLm1ldGFkYXRhLmNvdW50UGFnZXMpIHtcbiAgICAgICAgICAgIHN0YXRlLm1ldGFkYXRhLmVycm9yID0gUGFnaW5nRXJyb3IuSW5jb3JyZWN0UGFnZUluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5zbGljZShpbmRleCAqIHJlY29yZHNQZXJQYWdlLCAoaW5kZXggKyAxKSAqIHJlY29yZHNQZXJQYWdlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGZpbHRlcjxUPihkYXRhOiBUW10sIHN0YXRlOiBJRmlsdGVyaW5nU3RhdGUsIGdyaWQ/OiBHcmlkVHlwZSk6IFRbXSB7XG4gICAgICAgIGlmICghc3RhdGUuc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHN0YXRlLnN0cmF0ZWd5ID0gbmV3IEZpbHRlcmluZ1N0cmF0ZWd5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlLnN0cmF0ZWd5LmZpbHRlcihkYXRhLCBzdGF0ZS5leHByZXNzaW9uc1RyZWUsIHN0YXRlLmFkdmFuY2VkRXhwcmVzc2lvbnNUcmVlLCBncmlkKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGNvcnJlY3RQYWdpbmdTdGF0ZShzdGF0ZTogSVBhZ2luZ1N0YXRlLCBsZW5ndGg6IG51bWJlcikge1xuICAgICAgICBjb25zdCBtYXhQYWdlID0gTWF0aC5jZWlsKGxlbmd0aCAvIHN0YXRlLnJlY29yZHNQZXJQYWdlKSAtIDE7XG4gICAgICAgIGlmICghaXNOYU4obWF4UGFnZSkgJiYgc3RhdGUuaW5kZXggPiBtYXhQYWdlKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbmRleCA9IG1heFBhZ2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldEhpZXJhcmNoeShnUm93OiBJR3JvdXBCeVJlY29yZCk6IEFycmF5PElHcm91cEJ5S2V5PiB7XG4gICAgICAgIHJldHVybiBnZXRIaWVyYXJjaHkoZ1Jvdyk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBpc0hpZXJhcmNoeU1hdGNoKGgxOiBBcnJheTxJR3JvdXBCeUtleT4sIGgyOiBBcnJheTxJR3JvdXBCeUtleT4pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzSGllcmFyY2h5TWF0Y2goaDEsIGgyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYWxsIGNoYW5nZXMgZnJvbSBwcm92aWRlZCB0cmFuc2FjdGlvbnMgaW50byBwcm92aWRlZCBkYXRhIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gZGF0YSBDb2xsZWN0aW9uIHRvIG1lcmdlXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9ucyBUcmFuc2FjdGlvbnMgdG8gbWVyZ2UgaW50byBkYXRhXG4gICAgICogQHBhcmFtIHByaW1hcnlLZXkgUHJpbWFyeSBrZXkgb2YgdGhlIGNvbGxlY3Rpb24sIGlmIGFueVxuICAgICAqIEBwYXJhbSBkZWxldGVSb3dzIFNob3VsZCBkZWxldGUgcm93cyB3aXRoIERFTEVURSB0cmFuc2FjdGlvbiB0eXBlIGZyb20gZGF0YVxuICAgICAqIEByZXR1cm5zIFByb3ZpZGVkIGRhdGEgY29sbGVjdGlvbnMgdXBkYXRlZCB3aXRoIGFsbCBwcm92aWRlZCB0cmFuc2FjdGlvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG1lcmdlVHJhbnNhY3Rpb25zPFQ+KGRhdGE6IFRbXSwgdHJhbnNhY3Rpb25zOiBUcmFuc2FjdGlvbltdLCBwcmltYXJ5S2V5PzogYW55LCBkZWxldGVSb3dzOiBib29sZWFuID0gZmFsc2UpOiBUW10ge1xuICAgICAgICBkYXRhLmZvckVhY2goKGl0ZW06IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93SWQgPSBwcmltYXJ5S2V5ID8gaXRlbVtwcmltYXJ5S2V5XSA6IGl0ZW07XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9ucy5maW5kKHQgPT4gdC5pZCA9PT0gcm93SWQpO1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uICYmIHRyYW5zYWN0aW9uLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5VUERBVEUpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IHRyYW5zYWN0aW9uLm5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGVsZXRlUm93cykge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkRFTEVURSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwcmltYXJ5S2V5ID8gZGF0YS5maW5kSW5kZXgoZCA9PiBkW3ByaW1hcnlLZXldID09PSB0LmlkKSA6IGRhdGEuZmluZEluZGV4KGQgPT4gZCA9PT0gdC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwIDw9IGluZGV4ICYmIGluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5wdXNoKC4uLnRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFERClcbiAgICAgICAgICAgIC5tYXAodCA9PiB0Lm5ld1ZhbHVlKSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFsbCBjaGFuZ2VzIGZyb20gcHJvdmlkZWQgdHJhbnNhY3Rpb25zIGludG8gcHJvdmlkZWQgaGllcmFyY2hpY2FsIGRhdGEgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBkYXRhIENvbGxlY3Rpb24gdG8gbWVyZ2VcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25zIFRyYW5zYWN0aW9ucyB0byBtZXJnZSBpbnRvIGRhdGFcbiAgICAgKiBAcGFyYW0gY2hpbGREYXRhS2V5IERhdGEga2V5IG9mIGNoaWxkIGNvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHByaW1hcnlLZXkgUHJpbWFyeSBrZXkgb2YgdGhlIGNvbGxlY3Rpb24sIGlmIGFueVxuICAgICAqIEBwYXJhbSBkZWxldGVSb3dzIFNob3VsZCBkZWxldGUgcm93cyB3aXRoIERFTEVURSB0cmFuc2FjdGlvbiB0eXBlIGZyb20gZGF0YVxuICAgICAqIEByZXR1cm5zIFByb3ZpZGVkIGRhdGEgY29sbGVjdGlvbnMgdXBkYXRlZCB3aXRoIGFsbCBwcm92aWRlZCB0cmFuc2FjdGlvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG1lcmdlSGllcmFyY2hpY2FsVHJhbnNhY3Rpb25zKFxuICAgICAgICBkYXRhOiBhbnlbXSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBIaWVyYXJjaGljYWxUcmFuc2FjdGlvbltdLFxuICAgICAgICBjaGlsZERhdGFLZXk6IGFueSxcbiAgICAgICAgcHJpbWFyeUtleT86IGFueSxcbiAgICAgICAgZGVsZXRlUm93czogYm9vbGVhbiA9IGZhbHNlKTogYW55W10ge1xuICAgICAgICBmb3IgKGNvbnN0IHRyYW5zYWN0aW9uIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZpbmRQYXJlbnRGcm9tUGF0aChkYXRhLCBwcmltYXJ5S2V5LCBjaGlsZERhdGFLZXksIHRyYW5zYWN0aW9uLnBhdGgpO1xuICAgICAgICAgICAgICAgIGxldCBjb2xsZWN0aW9uOiBhbnlbXSA9IHBhcmVudCA/IHBhcmVudFtjaGlsZERhdGFLZXldIDogZGF0YTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRyYW5zYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuQUREOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGlmIHRoZXJlIGlzIG5vIHBhcmVudCB0aGlzIGlzIEFERCByb3cgYXQgcm9vdCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50W2NoaWxkRGF0YUtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRbY2hpbGREYXRhS2V5XSA9IGNvbGxlY3Rpb24gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaCh0cmFuc2FjdGlvbi5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuVVBEQVRFOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlSW5kZXggPSBjb2xsZWN0aW9uLmZpbmRJbmRleCh4ID0+IHhbcHJpbWFyeUtleV0gPT09IHRyYW5zYWN0aW9uLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW3VwZGF0ZUluZGV4XSA9IG1lcmdlT2JqZWN0cyhjbG9uZVZhbHVlKGNvbGxlY3Rpb25bdXBkYXRlSW5kZXhdKSwgdHJhbnNhY3Rpb24ubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkRFTEVURTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVSb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlSW5kZXggPSBjb2xsZWN0aW9uLmZpbmRJbmRleChyID0+IHJbcHJpbWFyeUtleV0gPT09IHRyYW5zYWN0aW9uLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uc3BsaWNlKGRlbGV0ZUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICBpZiB0aGVyZSBpcyBubyBwYXRoIHRoaXMgaXMgQUREIHJvdyBpbiByb290LiBQdXNoIHRoZSBuZXdWYWx1ZSB0byBkYXRhXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHRyYW5zYWN0aW9uLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHBhcnNlVmFsdWUoZGF0YVR5cGU6IERhdGFUeXBlLCB2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgaWYgKGRhdGFUeXBlID09PSBEYXRhVHlwZS5OdW1iZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmluZFBhcmVudEZyb21QYXRoKGRhdGE6IGFueVtdLCBwcmltYXJ5S2V5OiBhbnksIGNoaWxkRGF0YUtleTogYW55LCBwYXRoOiBhbnlbXSk6IGFueSB7XG4gICAgICAgIGxldCBjb2xsZWN0aW9uOiBhbnlbXSA9IGRhdGE7XG4gICAgICAgIGxldCByZXN1bHQ6IGFueTtcblxuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIHBhdGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5maW5kKHggPT4geFtwcmltYXJ5S2V5XSA9PT0gaWQpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sbGVjdGlvbiA9IHJlc3VsdFtjaGlsZERhdGFLZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iXX0=