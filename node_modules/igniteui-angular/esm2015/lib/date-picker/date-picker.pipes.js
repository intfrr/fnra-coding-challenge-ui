import { Pipe, Inject } from '@angular/core';
import { IGX_DATE_PICKER_COMPONENT } from './date-picker.common';
import { DatePickerUtil } from './date-picker.utils';
/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
export class DatePickerDisplayValuePipe {
    constructor(_datePicker) {
        this._datePicker = _datePicker;
    }
    transform(value, args) {
        if (value !== '') {
            if (value === DatePickerUtil.maskToPromptChars(this._datePicker.inputMask)) {
                return '';
            }
            this._datePicker.rawDateString = value;
            return DatePickerUtil.trimEmptyPlaceholders(value);
        }
        return '';
    }
}
DatePickerDisplayValuePipe.ɵfac = function DatePickerDisplayValuePipe_Factory(t) { return new (t || DatePickerDisplayValuePipe)(ɵngcc0.ɵɵdirectiveInject(IGX_DATE_PICKER_COMPONENT)); };
DatePickerDisplayValuePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "displayValue", type: DatePickerDisplayValuePipe, pure: true });
DatePickerDisplayValuePipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatePickerDisplayValuePipe, [{
        type: Pipe,
        args: [{
                name: 'displayValue'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_DATE_PICKER_COMPONENT]
            }] }]; }, null); })();
/**
 * @hidden
 */
export class DatePickerInputValuePipe {
    constructor(_datePicker) {
        this._datePicker = _datePicker;
    }
    transform(value, args) {
        /**
         * TODO(D.P.): This plugs into the mask, but constantly received display strings it can't handle at all
         * Those are almost immediately overridden by the pickers onFocus handling anyway; Refactor ASAP
         */
        if (this._datePicker.invalidDate !== '') {
            return this._datePicker.invalidDate;
        }
        else {
            if (this._datePicker.value === null || this._datePicker.value === undefined) {
                return DatePickerUtil.maskToPromptChars(this._datePicker.inputMask);
            }
            else {
                return this._datePicker._getEditorDate(this._datePicker.value);
                // return DatePickerUtil.addPromptCharsEditMode(this._datePicker.dateFormatParts, this._datePicker.value, value);
            }
        }
    }
}
DatePickerInputValuePipe.ɵfac = function DatePickerInputValuePipe_Factory(t) { return new (t || DatePickerInputValuePipe)(ɵngcc0.ɵɵdirectiveInject(IGX_DATE_PICKER_COMPONENT)); };
DatePickerInputValuePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "inputValue", type: DatePickerInputValuePipe, pure: true });
DatePickerInputValuePipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatePickerInputValuePipe, [{
        type: Pipe,
        args: [{
                name: 'inputValue'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_DATE_PICKER_COMPONENT]
            }] }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXIucGlwZXMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9kYXRlLXBpY2tlci9kYXRlLXBpY2tlci5waXBlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWlCLElBQUksRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDNUQsT0FBTyxFQUFFLHlCQUF5QixFQUFlLE1BQU0sc0JBQXNCLENBQUM7QUFDOUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXJEO0FBQ0E7QUFDQSxHQUFHOztBQUlILE1BQU0sT0FBTywwQkFBMEI7QUFBRyxJQUN0QyxZQUF1RCxXQUF3QjtBQUFJLFFBQTVCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO0FBQUMsSUFBRyxDQUFDO0FBQ3hGLElBQUksU0FBUyxDQUFDLEtBQVUsRUFBRSxJQUFVO0FBQUksUUFDaEMsSUFBSSxLQUFLLEtBQUssRUFBRSxFQUFFO0FBQzFCLFlBQVksSUFBSSxLQUFLLEtBQUssY0FBYyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLEVBQUU7QUFDeEYsZ0JBQWdCLE9BQU8sRUFBRSxDQUFDO0FBQzFCLGFBQWE7QUFDYixZQUFZLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztBQUNuRCxZQUFZLE9BQU8sY0FBYyxDQUFDLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQy9ELFNBQVM7QUFDVCxRQUFRLE9BQU8sRUFBRSxDQUFDO0FBQ2xCLElBQUksQ0FBQztBQUNMO3NEQWZDLElBQUksU0FBQyxrQkFDRixJQUFJLEVBQUUsY0FBYyxjQUN2QjsrSEFDSTtBQUFDO0FBQW9ELDRDQUN6QyxNQUFNLFNBQUMseUJBQXlCO0FBQVE7Ozs7Ozs7OztrQ0FBRTtBQWEzRDtBQUNBO0FBQ0EsR0FBRztBQUlILE1BQU0sT0FBTyx3QkFBd0I7QUFBRyxJQUNwQyxZQUF1RCxXQUF3QjtBQUFJLFFBQTVCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO0FBQUMsSUFBRyxDQUFDO0FBQ3hGLElBQUksU0FBUyxDQUFDLEtBQVUsRUFBRSxJQUFVO0FBQUksUUFDaEM7QUFDUjtBQUNBO0FBQ0EsV0FBVztBQUNYLFFBQVEsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsS0FBSyxFQUFFLEVBQUU7QUFDakQsWUFBWSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDO0FBQ2hELFNBQVM7QUFBQyxhQUFLO0FBQ2YsWUFBWSxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUU7QUFDekYsZ0JBQWdCLE9BQU8sY0FBYyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDcEYsYUFBYTtBQUFDLGlCQUFLO0FBQ25CLGdCQUFnQixPQUFRLElBQUksQ0FBQyxXQUFtQixDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3hGLGdCQUFnQixpSEFBaUg7QUFDakksYUFBYTtBQUNiLFNBQVM7QUFDVCxJQUFJLENBQUM7QUFDTDtvREFyQkMsSUFBSSxTQUFDLGtCQUNGLElBQUksRUFBRSxZQUFZLGNBQ3JCO3lIQUNJO0FBQUM7QUFBa0QsNENBQ3ZDLE1BQU0sU0FBQyx5QkFBeUI7QUFBUTs7Ozs7Ozs7O2tDQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaXBlVHJhbnNmb3JtLCBQaXBlLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElHWF9EQVRFX1BJQ0tFUl9DT01QT05FTlQsIElEYXRlUGlja2VyIH0gZnJvbSAnLi9kYXRlLXBpY2tlci5jb21tb24nO1xuaW1wb3J0IHsgRGF0ZVBpY2tlclV0aWwgfSBmcm9tICcuL2RhdGUtcGlja2VyLnV0aWxzJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAnZGlzcGxheVZhbHVlJ1xufSlcbmV4cG9ydCBjbGFzcyBEYXRlUGlja2VyRGlzcGxheVZhbHVlUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoSUdYX0RBVEVfUElDS0VSX0NPTVBPTkVOVCkgcHJpdmF0ZSBfZGF0ZVBpY2tlcjogSURhdGVQaWNrZXIpIHsgfVxuICAgIHRyYW5zZm9ybSh2YWx1ZTogYW55LCBhcmdzPzogYW55KTogYW55IHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBEYXRlUGlja2VyVXRpbC5tYXNrVG9Qcm9tcHRDaGFycyh0aGlzLl9kYXRlUGlja2VyLmlucHV0TWFzaykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kYXRlUGlja2VyLnJhd0RhdGVTdHJpbmcgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBEYXRlUGlja2VyVXRpbC50cmltRW1wdHlQbGFjZWhvbGRlcnModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ2lucHV0VmFsdWUnXG59KVxuZXhwb3J0IGNsYXNzIERhdGVQaWNrZXJJbnB1dFZhbHVlUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoSUdYX0RBVEVfUElDS0VSX0NPTVBPTkVOVCkgcHJpdmF0ZSBfZGF0ZVBpY2tlcjogSURhdGVQaWNrZXIpIHsgfVxuICAgIHRyYW5zZm9ybSh2YWx1ZTogYW55LCBhcmdzPzogYW55KTogYW55IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRPRE8oRC5QLik6IFRoaXMgcGx1Z3MgaW50byB0aGUgbWFzaywgYnV0IGNvbnN0YW50bHkgcmVjZWl2ZWQgZGlzcGxheSBzdHJpbmdzIGl0IGNhbid0IGhhbmRsZSBhdCBhbGxcbiAgICAgICAgICogVGhvc2UgYXJlIGFsbW9zdCBpbW1lZGlhdGVseSBvdmVycmlkZGVuIGJ5IHRoZSBwaWNrZXJzIG9uRm9jdXMgaGFuZGxpbmcgYW55d2F5OyBSZWZhY3RvciBBU0FQXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5fZGF0ZVBpY2tlci5pbnZhbGlkRGF0ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlUGlja2VyLmludmFsaWREYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RhdGVQaWNrZXIudmFsdWUgPT09IG51bGwgfHwgdGhpcy5fZGF0ZVBpY2tlci52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLm1hc2tUb1Byb21wdENoYXJzKHRoaXMuX2RhdGVQaWNrZXIuaW5wdXRNYXNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9kYXRlUGlja2VyIGFzIGFueSkuX2dldEVkaXRvckRhdGUodGhpcy5fZGF0ZVBpY2tlci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIERhdGVQaWNrZXJVdGlsLmFkZFByb21wdENoYXJzRWRpdE1vZGUodGhpcy5fZGF0ZVBpY2tlci5kYXRlRm9ybWF0UGFydHMsIHRoaXMuX2RhdGVQaWNrZXIudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==