import { isIE } from '../core/utils';
import { DatePart } from '../directives/date-time-editor/date-time-editor.common';
import { formatDate, FormatWidth, getLocaleDateFormat } from '@angular/common';
const DATE_CHARS = ['h', 'H', 'm', 's', 'S', 't', 'T'];
const TIME_CHARS = ['d', 'D', 'M', 'y', 'Y'];
/** @hidden */
export class DatePickerUtil {
    /**
     *  TODO: (in issue #6483) Unit tests and docs for all public methods.
     */
    /**
     * Parse a Date value from masked string input based on determined date parts
     * @param inputData masked value to parse
     * @param dateTimeParts Date parts array for the mask
     */
    static parseValueFromMask(inputData, dateTimeParts, promptChar) {
        const parts = {};
        dateTimeParts.forEach(dp => {
            let value = parseInt(this.getCleanVal(inputData, dp, promptChar), 10);
            if (!value) {
                value = dp.type === DatePart.Date || dp.type === DatePart.Month ? 1 : 0;
            }
            parts[dp.type] = value;
        });
        parts[DatePart.Month] -= 1;
        if (parts[DatePart.Month] < 0 || 11 < parts[DatePart.Month]) {
            return null;
        }
        // TODO: Century threshold
        if (parts[DatePart.Year] < 50) {
            parts[DatePart.Year] += 2000;
        }
        if (parts[DatePart.Date] > DatePickerUtil.daysInMonth(parts[DatePart.Year], parts[DatePart.Month])) {
            return null;
        }
        if (parts[DatePart.Hours] > 23 || parts[DatePart.Minutes] > 59 || parts[DatePart.Seconds] > 59) {
            return null;
        }
        return new Date(parts[DatePart.Year] || 2000, parts[DatePart.Month] || 0, parts[DatePart.Date] || 1, parts[DatePart.Hours] || 0, parts[DatePart.Minutes] || 0, parts[DatePart.Seconds] || 0);
    }
    /**
     * Parse the mask into date/time and literal parts
     */
    static parseDateTimeFormat(mask, locale = DatePickerUtil.DEFAULT_LOCALE) {
        const format = mask || DatePickerUtil.getDefaultInputFormat(locale);
        const dateTimeParts = [];
        const formatArray = Array.from(format);
        let currentPart = null;
        let position = 0;
        for (let i = 0; i < formatArray.length; i++, position++) {
            const type = DatePickerUtil.determineDatePart(formatArray[i]);
            if (currentPart) {
                if (currentPart.type === type) {
                    currentPart.format += formatArray[i];
                    if (i < formatArray.length - 1) {
                        continue;
                    }
                }
                DatePickerUtil.ensureLeadingZero(currentPart);
                currentPart.end = currentPart.start + currentPart.format.length;
                position = currentPart.end;
                dateTimeParts.push(currentPart);
            }
            currentPart = {
                start: position,
                end: position + formatArray[i].length,
                type: type,
                format: formatArray[i]
            };
        }
        return dateTimeParts;
    }
    static getDefaultInputFormat(locale) {
        if (!Intl || !Intl.DateTimeFormat || !Intl.DateTimeFormat.prototype.formatToParts) {
            // TODO: fallback with Intl.format for IE?
            return DatePickerUtil.SHORT_DATE_MASK;
        }
        const parts = DatePickerUtil.getDefaultLocaleMask(locale);
        parts.forEach(p => {
            if (p.type !== DatePart.Year && p.type !== DatePickerUtil.SEPARATOR) {
                p.formatType = "2-digit" /* TwoDigits */;
            }
        });
        return DatePickerUtil.getMask(parts);
    }
    static formatDate(value, format, locale, timezone) {
        let formattedDate;
        try {
            formattedDate = formatDate(value, format, locale, timezone);
        }
        catch (_a) {
            this.logMissingLocaleSettings(locale);
            const formatter = new Intl.DateTimeFormat(locale);
            formattedDate = formatter.format(value);
        }
        return formattedDate;
    }
    static getLocaleDateFormat(locale, displayFormat) {
        const formatKeys = Object.keys(FormatWidth);
        const targetKey = formatKeys.find(k => k.toLowerCase() === (displayFormat === null || displayFormat === void 0 ? void 0 : displayFormat.toLowerCase().replace('date', '')));
        if (!targetKey) {
            // if displayFormat is not shortDate, longDate, etc.
            // or if it is not set by the user
            return displayFormat;
        }
        let format;
        try {
            format = getLocaleDateFormat(locale, FormatWidth[targetKey]);
        }
        catch (_a) {
            this.logMissingLocaleSettings(locale);
            format = DatePickerUtil.getDefaultInputFormat(locale);
        }
        return format;
    }
    static isDateOrTimeChar(char) {
        return DATE_CHARS.indexOf(char) !== -1 || TIME_CHARS.indexOf(char) !== -1;
    }
    static spinDate(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth());
        let date = newDate.getDate() + delta;
        if (date > maxDate) {
            date = isSpinLoop ? date % maxDate : maxDate;
        }
        else if (date < 1) {
            date = isSpinLoop ? maxDate + (date % maxDate) : 1;
        }
        newDate.setDate(date);
    }
    static spinMonth(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth() + delta);
        if (newDate.getDate() > maxDate) {
            newDate.setDate(maxDate);
        }
        const maxMonth = 11;
        const minMonth = 0;
        let month = newDate.getMonth() + delta;
        if (month > maxMonth) {
            month = isSpinLoop ? (month % maxMonth) - 1 : maxMonth;
        }
        else if (month < minMonth) {
            month = isSpinLoop ? maxMonth + (month % maxMonth) + 1 : minMonth;
        }
        newDate.setMonth(month);
    }
    static spinYear(delta, newDate) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear() + delta, newDate.getMonth());
        if (newDate.getDate() > maxDate) {
            // clip to max to avoid leap year change shifting the entire value
            newDate.setDate(maxDate);
        }
        newDate.setFullYear(newDate.getFullYear() + delta);
    }
    static spinHours(delta, newDate, isSpinLoop) {
        const maxHour = 23;
        const minHour = 0;
        let hours = newDate.getHours() + delta;
        if (hours > maxHour) {
            hours = isSpinLoop ? hours % maxHour - 1 : maxHour;
        }
        else if (hours < minHour) {
            hours = isSpinLoop ? maxHour + (hours % maxHour) + 1 : minHour;
        }
        newDate.setHours(hours);
    }
    static spinMinutes(delta, newDate, isSpinLoop) {
        const maxMinutes = 59;
        const minMinutes = 0;
        let minutes = newDate.getMinutes() + delta;
        if (minutes > maxMinutes) {
            minutes = isSpinLoop ? minutes % maxMinutes - 1 : maxMinutes;
        }
        else if (minutes < minMinutes) {
            minutes = isSpinLoop ? maxMinutes + (minutes % maxMinutes) + 1 : minMinutes;
        }
        newDate.setMinutes(minutes);
    }
    static spinSeconds(delta, newDate, isSpinLoop) {
        const maxSeconds = 59;
        const minSeconds = 0;
        let seconds = newDate.getSeconds() + delta;
        if (seconds > maxSeconds) {
            seconds = isSpinLoop ? seconds % maxSeconds - 1 : maxSeconds;
        }
        else if (seconds < minSeconds) {
            seconds = isSpinLoop ? maxSeconds + (seconds % maxSeconds) + 1 : minSeconds;
        }
        newDate.setSeconds(seconds);
    }
    static spinAmPm(newDate, currentDate, amPmFromMask) {
        switch (amPmFromMask) {
            case 'AM':
                newDate = new Date(newDate.setHours(newDate.getHours() + 12));
                break;
            case 'PM':
                newDate = new Date(newDate.setHours(newDate.getHours() - 12));
                break;
        }
        if (newDate.getDate() !== currentDate.getDate()) {
            return currentDate;
        }
        return newDate;
    }
    /**
     * Determines whether the provided value is greater than the provided max value.
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is greater than provided maxValue
     */
    static greaterThanMaxValue(value, maxValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if maxValue is Invalid Date and value is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() > maxValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _maxValue = new Date(maxValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _maxValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _maxValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() > _maxValue.getTime();
    }
    /**
     * Determines whether the provided value is less than the provided min value.
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is less than provided minValue
     */
    static lessThanMinValue(value, minValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if value is Invalid Date and minValue is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() < minValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _minValue = new Date(minValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _minValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _minValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() < _minValue.getTime();
    }
    static logMissingLocaleSettings(locale) {
        console.warn(`Missing locale data for the locale ${locale}. Please refer to https://angular.io/guide/i18n#i18n-pipes`);
        console.warn('Using default browser locale settings.');
    }
    static ensureLeadingZero(part) {
        switch (part.type) {
            case DatePart.Date:
            case DatePart.Month:
            case DatePart.Hours:
            case DatePart.Minutes:
            case DatePart.Seconds:
                if (part.format.length === 1) {
                    part.format = part.format.repeat(2);
                }
                break;
        }
    }
    static getCleanVal(inputData, datePart, promptChar) {
        return DatePickerUtil.trimEmptyPlaceholders(inputData.substring(datePart.start, datePart.end), promptChar);
    }
    static determineDatePart(char) {
        switch (char) {
            case 'd':
            case 'D':
                return DatePart.Date;
            case 'M':
                return DatePart.Month;
            case 'y':
            case 'Y':
                return DatePart.Year;
            case 'h':
            case 'H':
                return DatePart.Hours;
            case 'm':
                return DatePart.Minutes;
            case 's':
            case 'S':
                return DatePart.Seconds;
            case 't':
            case 'T':
                return DatePart.AmPm;
            default:
                return DatePart.Literal;
        }
    }
    /**
     * This method generates date parts structure based on editor mask and locale.
     * @param maskValue: string
     * @param locale: string
     * @returns array containing information about date parts - type, position, format
     */
    static parseDateFormat(maskValue, locale = DatePickerUtil.DEFAULT_LOCALE) {
        let dateStruct = [];
        if (maskValue === undefined && !isIE()) {
            dateStruct = DatePickerUtil.getDefaultLocaleMask(locale);
        }
        else {
            const mask = (maskValue) ? maskValue : DatePickerUtil.SHORT_DATE_MASK;
            const maskArray = Array.from(mask);
            const monthInitPosition = mask.indexOf("M" /* MonthChar */);
            const dayInitPosition = mask.indexOf("d" /* DayChar */);
            const yearInitPosition = mask.indexOf("y" /* YearChar */);
            if (yearInitPosition !== -1) {
                dateStruct.push({
                    type: "year" /* Year */,
                    initialPosition: yearInitPosition,
                    formatType: DatePickerUtil.getYearFormatType(mask)
                });
            }
            if (monthInitPosition !== -1) {
                dateStruct.push({
                    type: "month" /* Month */,
                    initialPosition: monthInitPosition,
                    formatType: DatePickerUtil.getMonthFormatType(mask)
                });
            }
            if (dayInitPosition !== -1) {
                dateStruct.push({
                    type: "day" /* Day */,
                    initialPosition: dayInitPosition,
                    formatType: DatePickerUtil.getDayFormatType(mask)
                });
            }
            for (let i = 0; i < maskArray.length; i++) {
                if (!DatePickerUtil.isDateChar(maskArray[i])) {
                    dateStruct.push({
                        type: DatePickerUtil.SEPARATOR,
                        initialPosition: i,
                        value: maskArray[i]
                    });
                }
            }
            dateStruct.sort((a, b) => a.initialPosition - b.initialPosition);
            DatePickerUtil.fillDatePartsPositions(dateStruct);
        }
        return dateStruct;
    }
    /**
     * This method generates input mask based on date parts.
     * @param dateStruct array
     * @returns input mask
     */
    static getInputMask(dateStruct) {
        const inputMask = [];
        for (let i = 0; i < dateStruct.length; i++) {
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                inputMask.push(dateStruct[i].value);
            }
            else if (dateStruct[i].type === "day" /* Day */ || dateStruct[i].type === "month" /* Month */) {
                inputMask.push('00');
            }
            else if (dateStruct[i].type === "year" /* Year */) {
                switch (dateStruct[i].formatType) {
                    case "numeric" /* Numeric */: {
                        inputMask.push('0000');
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        inputMask.push('00');
                        break;
                    }
                }
            }
        }
        return inputMask.join('');
    }
    /**
     * This method generates editor mask.
     * @param dateStruct
     * @returns editor mask
     */
    static getMask(dateStruct) {
        const mask = [];
        for (let i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].formatType) {
                case "numeric" /* Numeric */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('d');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('M');
                    }
                    else {
                        mask.push('yyyy');
                    }
                    break;
                }
                case "2-digit" /* TwoDigits */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('dd');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('MM');
                    }
                    else {
                        mask.push('yy');
                    }
                }
            }
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                mask.push(dateStruct[i].value);
            }
        }
        return mask.join('');
    }
    /**
     * This method parses an input string base on date parts and returns a date and its validation state.
     * @param dateFormatParts
     * @param prevDateValue
     * @param inputValue
     * @returns object containing a date and its validation state
     */
    static parseDateArray(dateFormatParts, prevDateValue, inputValue) {
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, inputValue);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue);
        const yearStr = DatePickerUtil.getYearValueFromInput(dateFormatParts, inputValue);
        const yearFormat = DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType;
        const day = (dayStr !== '') ? parseInt(dayStr, 10) : 1;
        const month = (monthStr !== '') ? parseInt(monthStr, 10) - 1 : 0;
        let year;
        if (yearStr === '') {
            year = (yearFormat === "2-digit" /* TwoDigits */) ? '00' : '2000';
        }
        else {
            year = yearStr;
        }
        let yearPrefix;
        if (prevDateValue) {
            const originalYear = prevDateValue.getFullYear().toString();
            if (originalYear.length === 4) {
                yearPrefix = originalYear.substring(0, 2);
            }
        }
        else {
            yearPrefix = '20';
        }
        const fullYear = (yearFormat === "2-digit" /* TwoDigits */) ? yearPrefix.concat(year) : year;
        if ((month < 0) || (month > 11) || (month === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        if ((day < 1) || (day > DatePickerUtil.daysInMonth(fullYear, month)) || (day === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        return { state: "valid" /* Valid */, date: new Date(fullYear, month, day) };
    }
    static maskToPromptChars(mask) {
        const result = mask.replace(/0|L/g, DatePickerUtil.PROMPT_CHAR);
        return result;
    }
    /**
     * This method replaces prompt chars with empty string.
     * @param value
     */
    static trimEmptyPlaceholders(value, promptChar) {
        const result = value.replace(new RegExp(promptChar || '_', 'g'), '');
        return result;
    }
    /**
     * This method is used for spinning date parts.
     * @param dateFormatParts
     * @param inputValue
     * @param position
     * @param delta
     * @param isSpinLoop
     * @return modified text input
     */
    static getModifiedDateInput(dateFormatParts, inputValue, position, delta, isSpinLoop) {
        const datePart = DatePickerUtil.getDatePartOnPosition(dateFormatParts, position);
        const datePartType = datePart.type;
        const datePartFormatType = datePart.formatType;
        let newValue;
        const datePartValue = DatePickerUtil.getDateValueFromInput(dateFormatParts, datePartType, inputValue);
        newValue = parseInt(datePartValue, 10);
        let maxValue, minValue;
        const minMax = DatePickerUtil.getMinMaxValue(dateFormatParts, datePart, inputValue);
        minValue = minMax.min;
        maxValue = minMax.max;
        if (isNaN(newValue)) {
            if (minValue === 'infinite') {
                newValue = 2000;
            }
            else {
                newValue = minValue;
            }
        }
        let tempValue = newValue;
        tempValue += delta;
        // Infinite loop for full years
        if (maxValue === 'infinite' && minValue === 'infinite') {
            newValue = tempValue;
        }
        if (isSpinLoop) {
            if (tempValue > maxValue) {
                tempValue = minValue;
            }
            if (tempValue < minValue) {
                tempValue = maxValue;
            }
            newValue = tempValue;
        }
        else {
            if (tempValue <= maxValue && tempValue >= minValue) {
                newValue = tempValue;
            }
        }
        const startIdx = datePart.position[0];
        const endIdx = datePart.position[1];
        const start = inputValue.slice(0, startIdx);
        const end = inputValue.slice(endIdx, inputValue.length);
        let changedPart;
        const prefix = DatePickerUtil.getNumericFormatPrefix(datePartFormatType);
        changedPart = (newValue < 10) ? `${prefix}${newValue}` : `${newValue}`;
        return `${start}${changedPart}${end}`;
    }
    /**
     * This method returns date input with prompt chars.
     * @param dateFormatParts
     * @param date
     * @param inputValue
     * @returns date input including prompt chars
     */
    static addPromptCharsEditMode(dateFormatParts, date, inputValue) {
        const dateArray = Array.from(inputValue);
        for (let i = 0; i < dateFormatParts.length; i++) {
            if (dateFormatParts[i].formatType === "numeric" /* Numeric */) {
                if ((dateFormatParts[i].type === "day" /* Day */ && date.getDate() < 10)
                    || (dateFormatParts[i].type === "month" /* Month */ && date.getMonth() + 1 < 10)) {
                    dateArray.splice(dateFormatParts[i].position[0], 0, DatePickerUtil.PROMPT_CHAR);
                    dateArray.join('');
                }
            }
        }
        return dateArray.join('');
    }
    /**
     * This method checks if date input is done.
     * @param dateFormatParts
     * @param input
     * @returns input completeness
     */
    static checkForCompleteDateInput(dateFormatParts, input) {
        const dayValue = DatePickerUtil.getDayValueFromInput(dateFormatParts, input);
        const monthValue = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input);
        const yearValue = DatePickerUtil.getYearValueFromInput(dateFormatParts, input);
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, input, false);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input, false);
        if (DatePickerUtil.isFullInput(dayValue, dayStr)
            && DatePickerUtil.isFullInput(monthValue, monthStr)
            && DatePickerUtil.isFullYearInput(dateFormatParts, yearValue)) {
            return 'complete';
        }
        else if (dayValue === '' && monthValue === '' && yearValue === '') {
            return 'empty';
        }
        else if (dayValue === '' || monthValue === '' || yearValue === '') {
            return 'partial';
        }
        return '';
    }
    static daysInMonth(fullYear, month) {
        return new Date(fullYear, month + 1, 0).getDate();
    }
    /**
     * Parse provided input to Date.
     * @param value input to parse
     * @returns Date if parse succeed or null
     */
    static parseDate(value) {
        if (typeof value === 'number') {
            return new Date(value);
        }
        // if value is Invalid Date we should return null
        if (this.isDate(value)) {
            return this.isValidDate(value) ? value : null;
        }
        return value ? new Date(Date.parse(value)) : null;
    }
    /**
     * Returns whether provided input is date
     * @param value input to check
     * @returns true if provided input is date
     */
    static isDate(value) {
        return Object.prototype.toString.call(value) === '[object Date]';
    }
    /**
     * Returns whether the input is valid date
     * @param value input to check
     * @returns true if provided input is a valid date
     */
    static isValidDate(value) {
        if (this.isDate(value)) {
            return !isNaN(value.getTime());
        }
        return false;
    }
    static getYearFormatType(format) {
        switch (format.match(new RegExp("y" /* YearChar */, 'g')).length) {
            case 1: {
                // y (2020)
                return "numeric" /* Numeric */;
            }
            case 4: {
                // yyyy (2020)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // yy (20)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getMonthFormatType(format) {
        switch (format.match(new RegExp("M" /* MonthChar */, 'g')).length) {
            case 1: {
                // M (8)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // MM (08)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDayFormatType(format) {
        switch (format.match(new RegExp("d" /* DayChar */, 'g')).length) {
            case 1: {
                // d (6)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // dd (06)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDefaultLocaleMask(locale) {
        const dateStruct = [];
        const formatter = new Intl.DateTimeFormat(locale);
        const formatToParts = formatter.formatToParts(new Date());
        for (let i = 0; i < formatToParts.length; i++) {
            if (formatToParts[i].type === DatePickerUtil.SEPARATOR) {
                dateStruct.push({
                    type: DatePickerUtil.SEPARATOR,
                    value: formatToParts[i].value
                });
            }
            else {
                dateStruct.push({
                    type: formatToParts[i].type
                });
            }
        }
        const formatterOptions = formatter.resolvedOptions();
        for (let i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].type) {
                case "day" /* Day */: {
                    dateStruct[i].formatType = formatterOptions.day;
                    break;
                }
                case "month" /* Month */: {
                    dateStruct[i].formatType = formatterOptions.month;
                    break;
                }
                case "year" /* Year */: {
                    dateStruct[i].formatType = formatterOptions.year;
                    break;
                }
            }
        }
        DatePickerUtil.fillDatePartsPositions(dateStruct);
        return dateStruct;
    }
    static isDateChar(char) {
        return (char === "y" /* YearChar */ || char === "M" /* MonthChar */ || char === "d" /* DayChar */);
    }
    static getNumericFormatPrefix(formatType) {
        switch (formatType) {
            case "2-digit" /* TwoDigits */: {
                return '0';
            }
            case "numeric" /* Numeric */: {
                return DatePickerUtil.PROMPT_CHAR;
            }
        }
    }
    static getMinMaxValue(dateFormatParts, datePart, inputValue) {
        let maxValue, minValue;
        switch (datePart.type) {
            case "month" /* Month */: {
                minValue = 1;
                maxValue = DatePickerUtil.NUMBER_OF_MONTHS;
                break;
            }
            case "day" /* Day */: {
                minValue = 1;
                maxValue = DatePickerUtil.daysInMonth(DatePickerUtil.getFullYearFromString(DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */), inputValue), parseInt(DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue), 10));
                break;
            }
            case "year" /* Year */: {
                if (datePart.formatType === "2-digit" /* TwoDigits */) {
                    minValue = 0;
                    maxValue = 99;
                }
                else {
                    // Infinite loop
                    minValue = 'infinite';
                    maxValue = 'infinite';
                }
                break;
            }
        }
        return { min: minValue, max: maxValue };
    }
    static getDateValueFromInput(dateFormatParts, type, inputValue, trim = true) {
        const partPosition = DatePickerUtil.getDateFormatPart(dateFormatParts, type).position;
        const result = inputValue.substring(partPosition[0], partPosition[1]);
        return (trim) ? DatePickerUtil.trimEmptyPlaceholders(result) : result;
    }
    static getDayValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "day" /* Day */, inputValue, trim);
    }
    static getMonthValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "month" /* Month */, inputValue, trim);
    }
    static getYearValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "year" /* Year */, inputValue, trim);
    }
    static getDateFormatPart(dateFormatParts, type) {
        const result = dateFormatParts.filter((datePart) => (datePart.type === type))[0];
        return result;
    }
    static isFullInput(value, input) {
        return (value !== '' && input.length === 2 && input.charAt(1) !== DatePickerUtil.PROMPT_CHAR);
    }
    static isFullYearInput(dateFormatParts, value) {
        switch (DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType) {
            case "numeric" /* Numeric */: {
                return (value !== '' && value.length === 4);
            }
            case "2-digit" /* TwoDigits */: {
                return (value !== '' && value.length === 2);
            }
            default: {
                return false;
            }
        }
    }
    static getDatePartOnPosition(dateFormatParts, position) {
        const result = dateFormatParts.filter((element) => element.position[0] <= position && position <= element.position[1] && element.type !== DatePickerUtil.SEPARATOR)[0];
        return result;
    }
    static getFullYearFromString(yearPart, inputValue) {
        return parseInt(inputValue.substring(yearPart.position[0], yearPart.position[1]), 10);
    }
    static fillDatePartsPositions(dateArray) {
        let currentPos = 0;
        for (let i = 0; i < dateArray.length; i++) {
            // Day|Month part positions
            if (dateArray[i].type === "day" /* Day */ || dateArray[i].type === "month" /* Month */) {
                // Offset 2 positions for number
                dateArray[i].position = [currentPos, currentPos + 2];
                currentPos += 2;
            }
            else if (dateArray[i].type === "year" /* Year */) {
                // Year part positions
                switch (dateArray[i].formatType) {
                    case "numeric" /* Numeric */: {
                        // Offset 4 positions for full year
                        dateArray[i].position = [currentPos, currentPos + 4];
                        currentPos += 4;
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        // Offset 2 positions for short year
                        dateArray[i].position = [currentPos, currentPos + 2];
                        currentPos += 2;
                        break;
                    }
                }
            }
            else if (dateArray[i].type === DatePickerUtil.SEPARATOR) {
                // Separator positions
                dateArray[i].position = [currentPos, currentPos + 1];
                currentPos++;
            }
        }
    }
}
DatePickerUtil.DEFAULT_INPUT_FORMAT = 'MM/dd/yyyy';
// TODO: this is the def mask for the date-picker, should remove it during refactoring
DatePickerUtil.SHORT_DATE_MASK = 'MM/dd/yy';
DatePickerUtil.SEPARATOR = 'literal';
DatePickerUtil.NUMBER_OF_MONTHS = 12;
DatePickerUtil.PROMPT_CHAR = '_';
DatePickerUtil.DEFAULT_LOCALE = 'en';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXIudXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZGF0ZS1waWNrZXIvZGF0ZS1waWNrZXIudXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyQyxPQUFPLEVBQUUsUUFBUSxFQUFnQixNQUFNLHdEQUF3RCxDQUFDO0FBQ2hHLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLG1CQUFtQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUF5Qi9FLE1BQU0sVUFBVSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDdkQsTUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFVN0MsY0FBYztBQUNkLE1BQU0sT0FBZ0IsY0FBYztJQVdoQzs7T0FFRztJQUlIOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsa0JBQWtCLENBQUMsU0FBaUIsRUFBRSxhQUE2QixFQUFFLFVBQW1CO1FBQ2xHLE1BQU0sS0FBSyxHQUFrQyxFQUFTLENBQUM7UUFDdkQsYUFBYSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFBRTtZQUN2QixJQUFJLEtBQUssR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsRUFBRSxFQUFFLFVBQVUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3RFLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ1IsS0FBSyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLFFB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VSxDQUFDO0FBQzdCLHdCQUFTLEdBQUcsU0FBUyxDQUFDO0FBQ3RCLCtCQUFnQixHQUFHLEVBQUUsQ0FBQztBQUN0QiwwQkFBVyxHQUFHLEdBQUcsQ0FBQztBQUNsQiw2QkFBYyxHQUFHLElBQUksQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzSUUgfSBmcm9tICcuLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IERhdGVQYXJ0LCBEYXRlUGFydEluZm8gfSBmcm9tICcuLi9kaXJlY3RpdmVzL2RhdGUtdGltZS1lZGl0b3IvZGF0ZS10aW1lLWVkaXRvci5jb21tb24nO1xuaW1wb3J0IHsgZm9ybWF0RGF0ZSwgRm9ybWF0V2lkdGgsIGdldExvY2FsZURhdGVGb3JtYXQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIFRoaXMgZW51bSBpcyB1c2VkIHRvIGtlZXAgdGhlIGRhdGUgdmFsaWRhdGlvbiByZXN1bHQuXG4gKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgZW51bSBEYXRlU3RhdGUge1xuICAgIFZhbGlkID0gJ3ZhbGlkJyxcbiAgICBJbnZhbGlkID0gJ2ludmFsaWQnLFxufVxuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgZW51bSBGb3JtYXREZXNjIHtcbiAgICBOdW1lcmljID0gJ251bWVyaWMnLFxuICAgIFR3b0RpZ2l0cyA9ICcyLWRpZ2l0J1xufVxuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgZW51bSBEYXRlQ2hhcnMge1xuICAgIFllYXJDaGFyID0gJ3knLFxuICAgIE1vbnRoQ2hhciA9ICdNJyxcbiAgICBEYXlDaGFyID0gJ2QnXG59XG5cbmNvbnN0IERBVEVfQ0hBUlMgPSBbJ2gnLCAnSCcsICdtJywgJ3MnLCAnUycsICd0JywgJ1QnXTtcbmNvbnN0IFRJTUVfQ0hBUlMgPSBbJ2QnLCAnRCcsICdNJywgJ3knLCAnWSddO1xuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgZW51bSBEYXRlUGFydHMge1xuICAgIERheSA9ICdkYXknLFxuICAgIE1vbnRoID0gJ21vbnRoJyxcbiAgICBZZWFyID0gJ3llYXInXG59XG5cblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRlUGlja2VyVXRpbCB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0lOUFVUX0ZPUk1BVCA9ICdNTS9kZC95eXl5JztcbiAgICAvLyBUT0RPOiB0aGlzIGlzIHRoZSBkZWYgbWFzayBmb3IgdGhlIGRhdGUtcGlja2VyLCBzaG91bGQgcmVtb3ZlIGl0IGR1cmluZyByZWZhY3RvcmluZ1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFNIT1JUX0RBVEVfTUFTSyA9ICdNTS9kZC95eSc7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgU0VQQVJBVE9SID0gJ2xpdGVyYWwnO1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE5VTUJFUl9PRl9NT05USFMgPSAxMjtcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBQUk9NUFRfQ0hBUiA9ICdfJztcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0xPQ0FMRSA9ICdlbic7XG5cblxuXG4gICAgLyoqXG4gICAgICogIFRPRE86IChpbiBpc3N1ZSAjNjQ4MykgVW5pdCB0ZXN0cyBhbmQgZG9jcyBmb3IgYWxsIHB1YmxpYyBtZXRob2RzLlxuICAgICAqL1xuXG5cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgRGF0ZSB2YWx1ZSBmcm9tIG1hc2tlZCBzdHJpbmcgaW5wdXQgYmFzZWQgb24gZGV0ZXJtaW5lZCBkYXRlIHBhcnRzXG4gICAgICogQHBhcmFtIGlucHV0RGF0YSBtYXNrZWQgdmFsdWUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0gZGF0ZVRpbWVQYXJ0cyBEYXRlIHBhcnRzIGFycmF5IGZvciB0aGUgbWFza1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VWYWx1ZUZyb21NYXNrKGlucHV0RGF0YTogc3RyaW5nLCBkYXRlVGltZVBhcnRzOiBEYXRlUGFydEluZm9bXSwgcHJvbXB0Q2hhcj86IHN0cmluZyk6IERhdGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcGFydHM6IHsgW2tleSBpbiBEYXRlUGFydF06IG51bWJlciB9ID0ge30gYXMgYW55O1xuICAgICAgICBkYXRlVGltZVBhcnRzLmZvckVhY2goZHAgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VJbnQodGhpcy5nZXRDbGVhblZhbChpbnB1dERhdGEsIGRwLCBwcm9tcHRDaGFyKSwgMTApO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZHAudHlwZSA9PT0gRGF0ZVBhcnQuRGF0ZSB8fCBkcC50eXBlID09PSBEYXRlUGFydC5Nb250aCA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFydHNbZHAudHlwZV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcnRzW0RhdGVQYXJ0Lk1vbnRoXSAtPSAxO1xuXG4gICAgICAgIGlmIChwYXJ0c1tEYXRlUGFydC5Nb250aF0gPCAwIHx8IDExIDwgcGFydHNbRGF0ZVBhcnQuTW9udGhdKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IENlbnR1cnkgdGhyZXNob2xkXG4gICAgICAgIGlmIChwYXJ0c1tEYXRlUGFydC5ZZWFyXSA8IDUwKSB7XG4gICAgICAgICAgICBwYXJ0c1tEYXRlUGFydC5ZZWFyXSArPSAyMDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRzW0RhdGVQYXJ0LkRhdGVdID4gRGF0ZVBpY2tlclV0aWwuZGF5c0luTW9udGgocGFydHNbRGF0ZVBhcnQuWWVhcl0sIHBhcnRzW0RhdGVQYXJ0Lk1vbnRoXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRzW0RhdGVQYXJ0LkhvdXJzXSA+IDIzIHx8IHBhcnRzW0RhdGVQYXJ0Lk1pbnV0ZXNdID4gNTkgfHwgcGFydHNbRGF0ZVBhcnQuU2Vjb25kc10gPiA1OSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERhdGUoXG4gICAgICAgICAgICBwYXJ0c1tEYXRlUGFydC5ZZWFyXSB8fCAyMDAwLFxuICAgICAgICAgICAgcGFydHNbRGF0ZVBhcnQuTW9udGhdIHx8IDAsXG4gICAgICAgICAgICBwYXJ0c1tEYXRlUGFydC5EYXRlXSB8fCAxLFxuICAgICAgICAgICAgcGFydHNbRGF0ZVBhcnQuSG91cnNdIHx8IDAsXG4gICAgICAgICAgICBwYXJ0c1tEYXRlUGFydC5NaW51dGVzXSB8fCAwLFxuICAgICAgICAgICAgcGFydHNbRGF0ZVBhcnQuU2Vjb25kc10gfHwgMFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBtYXNrIGludG8gZGF0ZS90aW1lIGFuZCBsaXRlcmFsIHBhcnRzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZURhdGVUaW1lRm9ybWF0KG1hc2s6IHN0cmluZywgbG9jYWxlOiBzdHJpbmcgPSBEYXRlUGlja2VyVXRpbC5ERUZBVUxUX0xPQ0FMRSk6IERhdGVQYXJ0SW5mb1tdIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gbWFzayB8fCBEYXRlUGlja2VyVXRpbC5nZXREZWZhdWx0SW5wdXRGb3JtYXQobG9jYWxlKTtcbiAgICAgICAgY29uc3QgZGF0ZVRpbWVQYXJ0czogRGF0ZVBhcnRJbmZvW10gPSBbXTtcbiAgICAgICAgY29uc3QgZm9ybWF0QXJyYXkgPSBBcnJheS5mcm9tKGZvcm1hdCk7XG4gICAgICAgIGxldCBjdXJyZW50UGFydDogRGF0ZVBhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdEFycmF5Lmxlbmd0aDsgaSsrLCBwb3NpdGlvbisrKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gRGF0ZVBpY2tlclV0aWwuZGV0ZXJtaW5lRGF0ZVBhcnQoZm9ybWF0QXJyYXlbaV0pO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJ0LnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcnQuZm9ybWF0ICs9IGZvcm1hdEFycmF5W2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGZvcm1hdEFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgRGF0ZVBpY2tlclV0aWwuZW5zdXJlTGVhZGluZ1plcm8oY3VycmVudFBhcnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJ0LmVuZCA9IGN1cnJlbnRQYXJ0LnN0YXJ0ICsgY3VycmVudFBhcnQuZm9ybWF0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGN1cnJlbnRQYXJ0LmVuZDtcbiAgICAgICAgICAgICAgICBkYXRlVGltZVBhcnRzLnB1c2goY3VycmVudFBhcnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50UGFydCA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZW5kOiBwb3NpdGlvbiArIGZvcm1hdEFycmF5W2ldLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0QXJyYXlbaV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZVRpbWVQYXJ0cztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldERlZmF1bHRJbnB1dEZvcm1hdChsb2NhbGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmICghSW50bCB8fCAhSW50bC5EYXRlVGltZUZvcm1hdCB8fCAhSW50bC5EYXRlVGltZUZvcm1hdC5wcm90b3R5cGUuZm9ybWF0VG9QYXJ0cykge1xuICAgICAgICAgICAgLy8gVE9ETzogZmFsbGJhY2sgd2l0aCBJbnRsLmZvcm1hdCBmb3IgSUU/XG4gICAgICAgICAgICByZXR1cm4gRGF0ZVBpY2tlclV0aWwuU0hPUlRfREFURV9NQVNLO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGVmYXVsdExvY2FsZU1hc2sobG9jYWxlKTtcbiAgICAgICAgcGFydHMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgIT09IERhdGVQYXJ0LlllYXIgJiYgcC50eXBlICE9PSBEYXRlUGlja2VyVXRpbC5TRVBBUkFUT1IpIHtcbiAgICAgICAgICAgICAgICBwLmZvcm1hdFR5cGUgPSBGb3JtYXREZXNjLlR3b0RpZ2l0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLmdldE1hc2socGFydHMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZm9ybWF0RGF0ZSh2YWx1ZTogbnVtYmVyIHwgRGF0ZSwgZm9ybWF0OiBzdHJpbmcsIGxvY2FsZTogc3RyaW5nLCB0aW1lem9uZT86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGxldCBmb3JtYXR0ZWREYXRlOiBzdHJpbmc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWREYXRlID0gZm9ybWF0RGF0ZSh2YWx1ZSwgZm9ybWF0LCBsb2NhbGUsIHRpbWV6b25lKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB0aGlzLmxvZ01pc3NpbmdMb2NhbGVTZXR0aW5ncyhsb2NhbGUpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlKTtcbiAgICAgICAgICAgIGZvcm1hdHRlZERhdGUgPSBmb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWREYXRlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0TG9jYWxlRGF0ZUZvcm1hdChsb2NhbGU6IHN0cmluZywgZGlzcGxheUZvcm1hdD86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGZvcm1hdEtleXMgPSBPYmplY3Qua2V5cyhGb3JtYXRXaWR0aCkgYXMgKGtleW9mIEZvcm1hdFdpZHRoKVtdO1xuICAgICAgICBjb25zdCB0YXJnZXRLZXkgPSBmb3JtYXRLZXlzLmZpbmQoayA9PiBrLnRvTG93ZXJDYXNlKCkgPT09IGRpc3BsYXlGb3JtYXQ/LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnZGF0ZScsICcnKSk7XG4gICAgICAgIGlmICghdGFyZ2V0S2V5KSB7XG4gICAgICAgICAgICAvLyBpZiBkaXNwbGF5Rm9ybWF0IGlzIG5vdCBzaG9ydERhdGUsIGxvbmdEYXRlLCBldGMuXG4gICAgICAgICAgICAvLyBvciBpZiBpdCBpcyBub3Qgc2V0IGJ5IHRoZSB1c2VyXG4gICAgICAgICAgICByZXR1cm4gZGlzcGxheUZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm9ybWF0OiBzdHJpbmc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBnZXRMb2NhbGVEYXRlRm9ybWF0KGxvY2FsZSwgRm9ybWF0V2lkdGhbdGFyZ2V0S2V5XSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgdGhpcy5sb2dNaXNzaW5nTG9jYWxlU2V0dGluZ3MobG9jYWxlKTtcbiAgICAgICAgICAgIGZvcm1hdCA9IERhdGVQaWNrZXJVdGlsLmdldERlZmF1bHRJbnB1dEZvcm1hdChsb2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGlzRGF0ZU9yVGltZUNoYXIoY2hhcjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBEQVRFX0NIQVJTLmluZGV4T2YoY2hhcikgIT09IC0xIHx8IFRJTUVfQ0hBUlMuaW5kZXhPZihjaGFyKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBzcGluRGF0ZShkZWx0YTogbnVtYmVyLCBuZXdEYXRlOiBEYXRlLCBpc1NwaW5Mb29wOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1heERhdGUgPSBEYXRlUGlja2VyVXRpbC5kYXlzSW5Nb250aChuZXdEYXRlLmdldEZ1bGxZZWFyKCksIG5ld0RhdGUuZ2V0TW9udGgoKSk7XG4gICAgICAgIGxldCBkYXRlID0gbmV3RGF0ZS5nZXREYXRlKCkgKyBkZWx0YTtcbiAgICAgICAgaWYgKGRhdGUgPiBtYXhEYXRlKSB7XG4gICAgICAgICAgICBkYXRlID0gaXNTcGluTG9vcCA/IGRhdGUgJSBtYXhEYXRlIDogbWF4RGF0ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRlIDwgMSkge1xuICAgICAgICAgICAgZGF0ZSA9IGlzU3Bpbkxvb3AgPyBtYXhEYXRlICsgKGRhdGUgJSBtYXhEYXRlKSA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdEYXRlLnNldERhdGUoZGF0ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBzcGluTW9udGgoZGVsdGE6IG51bWJlciwgbmV3RGF0ZTogRGF0ZSwgaXNTcGluTG9vcDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCBtYXhEYXRlID0gRGF0ZVBpY2tlclV0aWwuZGF5c0luTW9udGgobmV3RGF0ZS5nZXRGdWxsWWVhcigpLCBuZXdEYXRlLmdldE1vbnRoKCkgKyBkZWx0YSk7XG4gICAgICAgIGlmIChuZXdEYXRlLmdldERhdGUoKSA+IG1heERhdGUpIHtcbiAgICAgICAgICAgIG5ld0RhdGUuc2V0RGF0ZShtYXhEYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1heE1vbnRoID0gMTE7XG4gICAgICAgIGNvbnN0IG1pbk1vbnRoID0gMDtcbiAgICAgICAgbGV0IG1vbnRoID0gbmV3RGF0ZS5nZXRNb250aCgpICsgZGVsdGE7XG4gICAgICAgIGlmIChtb250aCA+IG1heE1vbnRoKSB7XG4gICAgICAgICAgICBtb250aCA9IGlzU3Bpbkxvb3AgPyAobW9udGggJSBtYXhNb250aCkgLSAxIDogbWF4TW9udGg7XG4gICAgICAgIH0gZWxzZSBpZiAobW9udGggPCBtaW5Nb250aCkge1xuICAgICAgICAgICAgbW9udGggPSBpc1NwaW5Mb29wID8gbWF4TW9udGggKyAobW9udGggJSBtYXhNb250aCkgKyAxIDogbWluTW9udGg7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdEYXRlLnNldE1vbnRoKG1vbnRoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHNwaW5ZZWFyKGRlbHRhOiBudW1iZXIsIG5ld0RhdGU6IERhdGUpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWF4RGF0ZSA9IERhdGVQaWNrZXJVdGlsLmRheXNJbk1vbnRoKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSArIGRlbHRhLCBuZXdEYXRlLmdldE1vbnRoKCkpO1xuICAgICAgICBpZiAobmV3RGF0ZS5nZXREYXRlKCkgPiBtYXhEYXRlKSB7XG4gICAgICAgICAgICAvLyBjbGlwIHRvIG1heCB0byBhdm9pZCBsZWFwIHllYXIgY2hhbmdlIHNoaWZ0aW5nIHRoZSBlbnRpcmUgdmFsdWVcbiAgICAgICAgICAgIG5ld0RhdGUuc2V0RGF0ZShtYXhEYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdEYXRlLnNldEZ1bGxZZWFyKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSArIGRlbHRhKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHNwaW5Ib3VycyhkZWx0YTogbnVtYmVyLCBuZXdEYXRlOiBEYXRlLCBpc1NwaW5Mb29wOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1heEhvdXIgPSAyMztcbiAgICAgICAgY29uc3QgbWluSG91ciA9IDA7XG4gICAgICAgIGxldCBob3VycyA9IG5ld0RhdGUuZ2V0SG91cnMoKSArIGRlbHRhO1xuICAgICAgICBpZiAoaG91cnMgPiBtYXhIb3VyKSB7XG4gICAgICAgICAgICBob3VycyA9IGlzU3Bpbkxvb3AgPyBob3VycyAlIG1heEhvdXIgLSAxIDogbWF4SG91cjtcbiAgICAgICAgfSBlbHNlIGlmIChob3VycyA8IG1pbkhvdXIpIHtcbiAgICAgICAgICAgIGhvdXJzID0gaXNTcGluTG9vcCA/IG1heEhvdXIgKyAoaG91cnMgJSBtYXhIb3VyKSArIDEgOiBtaW5Ib3VyO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RGF0ZS5zZXRIb3Vycyhob3Vycyk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBzcGluTWludXRlcyhkZWx0YTogbnVtYmVyLCBuZXdEYXRlOiBEYXRlLCBpc1NwaW5Mb29wOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1heE1pbnV0ZXMgPSA1OTtcbiAgICAgICAgY29uc3QgbWluTWludXRlcyA9IDA7XG4gICAgICAgIGxldCBtaW51dGVzID0gbmV3RGF0ZS5nZXRNaW51dGVzKCkgKyBkZWx0YTtcbiAgICAgICAgaWYgKG1pbnV0ZXMgPiBtYXhNaW51dGVzKSB7XG4gICAgICAgICAgICBtaW51dGVzID0gaXNTcGluTG9vcCA/IG1pbnV0ZXMgJSBtYXhNaW51dGVzIC0gMSA6IG1heE1pbnV0ZXM7XG4gICAgICAgIH0gZWxzZSBpZiAobWludXRlcyA8IG1pbk1pbnV0ZXMpIHtcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBpc1NwaW5Mb29wID8gbWF4TWludXRlcyArIChtaW51dGVzICUgbWF4TWludXRlcykgKyAxIDogbWluTWludXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0RhdGUuc2V0TWludXRlcyhtaW51dGVzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHNwaW5TZWNvbmRzKGRlbHRhOiBudW1iZXIsIG5ld0RhdGU6IERhdGUsIGlzU3Bpbkxvb3A6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWF4U2Vjb25kcyA9IDU5O1xuICAgICAgICBjb25zdCBtaW5TZWNvbmRzID0gMDtcbiAgICAgICAgbGV0IHNlY29uZHMgPSBuZXdEYXRlLmdldFNlY29uZHMoKSArIGRlbHRhO1xuICAgICAgICBpZiAoc2Vjb25kcyA+IG1heFNlY29uZHMpIHtcbiAgICAgICAgICAgIHNlY29uZHMgPSBpc1NwaW5Mb29wID8gc2Vjb25kcyAlIG1heFNlY29uZHMgLSAxIDogbWF4U2Vjb25kcztcbiAgICAgICAgfSBlbHNlIGlmIChzZWNvbmRzIDwgbWluU2Vjb25kcykge1xuICAgICAgICAgICAgc2Vjb25kcyA9IGlzU3Bpbkxvb3AgPyBtYXhTZWNvbmRzICsgKHNlY29uZHMgJSBtYXhTZWNvbmRzKSArIDEgOiBtaW5TZWNvbmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RGF0ZS5zZXRTZWNvbmRzKHNlY29uZHMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgc3BpbkFtUG0obmV3RGF0ZTogRGF0ZSwgY3VycmVudERhdGU6IERhdGUsIGFtUG1Gcm9tTWFzazogc3RyaW5nKTogRGF0ZSB7XG4gICAgICAgIHN3aXRjaCAoYW1QbUZyb21NYXNrKSB7XG4gICAgICAgICAgICBjYXNlICdBTSc6XG4gICAgICAgICAgICAgICAgbmV3RGF0ZSA9IG5ldyBEYXRlKG5ld0RhdGUuc2V0SG91cnMobmV3RGF0ZS5nZXRIb3VycygpICsgMTIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BNJzpcbiAgICAgICAgICAgICAgICBuZXdEYXRlID0gbmV3IERhdGUobmV3RGF0ZS5zZXRIb3VycyhuZXdEYXRlLmdldEhvdXJzKCkgLSAxMikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdEYXRlLmdldERhdGUoKSAhPT0gY3VycmVudERhdGUuZ2V0RGF0ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3RGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcHJvdmlkZWQgbWF4IHZhbHVlLlxuICAgICAqIEBwYXJhbSBpbmNsdWRlVGltZSBzZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gZXhjbHVkZSB0aW1lIHBvcnRpb24gb2YgdGhlIHR3byBkYXRlc1xuICAgICAqIEBwYXJhbSBpbmNsdWRlRGF0ZSBzZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gZXhjbHVkZSB0aGUgZGF0ZSBwb3J0aW9uIG9mIHRoZSB0d28gZGF0ZXNcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBwcm92aWRlZCBtYXhWYWx1ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ3JlYXRlclRoYW5NYXhWYWx1ZSh2YWx1ZTogRGF0ZSwgbWF4VmFsdWU6IERhdGUsIGluY2x1ZGVUaW1lID0gdHJ1ZSwgaW5jbHVkZURhdGUgPSB0cnVlKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIHByb3ZpZGVkIGRhdGVzIGFyZSB2YWxpZCBkYXRlcyBhbmQgbm90IEludmFsaWQgRGF0ZVxuICAgICAgICAvLyBpZiBtYXhWYWx1ZSBpcyBJbnZhbGlkIERhdGUgYW5kIHZhbHVlIGlzIHZhbGlkIGRhdGUgdGhpcyB3aWxsIHJldHVybjpcbiAgICAgICAgLy8gLSBmYWxzZSBpZiBpbmNsdWRlRGF0ZSBpcyB0cnVlXG4gICAgICAgIC8vIC0gdHJ1ZSBpZiBpbmNsdWRlRGF0ZSBpcyBmYWxzZVxuICAgICAgICBpZiAoaW5jbHVkZVRpbWUgJiYgaW5jbHVkZURhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5nZXRUaW1lKCkgPiBtYXhWYWx1ZS5nZXRUaW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBfdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZS5nZXRUaW1lKCkpO1xuICAgICAgICBjb25zdCBfbWF4VmFsdWUgPSBuZXcgRGF0ZShtYXhWYWx1ZS5nZXRUaW1lKCkpO1xuICAgICAgICBpZiAoIWluY2x1ZGVUaW1lKSB7XG4gICAgICAgICAgICBfdmFsdWUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICBfbWF4VmFsdWUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbmNsdWRlRGF0ZSkge1xuICAgICAgICAgICAgX3ZhbHVlLnNldEZ1bGxZZWFyKDAsIDAsIDApO1xuICAgICAgICAgICAgX21heFZhbHVlLnNldEZ1bGxZZWFyKDAsIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF92YWx1ZS5nZXRUaW1lKCkgPiBfbWF4VmFsdWUuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBwcm92aWRlZCBtaW4gdmFsdWUuXG4gICAgICogQHBhcmFtIGluY2x1ZGVUaW1lIHNldCB0byBmYWxzZSBpZiB5b3Ugd2FudCB0byBleGNsdWRlIHRpbWUgcG9ydGlvbiBvZiB0aGUgdHdvIGRhdGVzXG4gICAgICogQHBhcmFtIGluY2x1ZGVEYXRlIHNldCB0byBmYWxzZSBpZiB5b3Ugd2FudCB0byBleGNsdWRlIHRoZSBkYXRlIHBvcnRpb24gb2YgdGhlIHR3byBkYXRlc1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHByb3ZpZGVkIG1pblZhbHVlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBsZXNzVGhhbk1pblZhbHVlKHZhbHVlOiBEYXRlLCBtaW5WYWx1ZTogRGF0ZSwgaW5jbHVkZVRpbWUgPSB0cnVlLCBpbmNsdWRlRGF0ZSA9IHRydWUpOiBib29sZWFuIHtcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgaWYgcHJvdmlkZWQgZGF0ZXMgYXJlIHZhbGlkIGRhdGVzIGFuZCBub3QgSW52YWxpZCBEYXRlXG4gICAgICAgIC8vIGlmIHZhbHVlIGlzIEludmFsaWQgRGF0ZSBhbmQgbWluVmFsdWUgaXMgdmFsaWQgZGF0ZSB0aGlzIHdpbGwgcmV0dXJuOlxuICAgICAgICAvLyAtIGZhbHNlIGlmIGluY2x1ZGVEYXRlIGlzIHRydWVcbiAgICAgICAgLy8gLSB0cnVlIGlmIGluY2x1ZGVEYXRlIGlzIGZhbHNlXG4gICAgICAgIGlmIChpbmNsdWRlVGltZSAmJiBpbmNsdWRlRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKSA8IG1pblZhbHVlLmdldFRpbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IF92YWx1ZSA9IG5ldyBEYXRlKHZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIGNvbnN0IF9taW5WYWx1ZSA9IG5ldyBEYXRlKG1pblZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIGlmICghaW5jbHVkZVRpbWUpIHtcbiAgICAgICAgICAgIF92YWx1ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIF9taW5WYWx1ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluY2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICBfdmFsdWUuc2V0RnVsbFllYXIoMCwgMCwgMCk7XG4gICAgICAgICAgICBfbWluVmFsdWUuc2V0RnVsbFllYXIoMCwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3ZhbHVlLmdldFRpbWUoKSA8IF9taW5WYWx1ZS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9nTWlzc2luZ0xvY2FsZVNldHRpbmdzKGxvY2FsZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGNvbnNvbGUud2FybihgTWlzc2luZyBsb2NhbGUgZGF0YSBmb3IgdGhlIGxvY2FsZSAke2xvY2FsZX0uIFBsZWFzZSByZWZlciB0byBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvaTE4biNpMThuLXBpcGVzYCk7XG4gICAgICAgIGNvbnNvbGUud2FybignVXNpbmcgZGVmYXVsdCBicm93c2VyIGxvY2FsZSBzZXR0aW5ncy4nKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBlbnN1cmVMZWFkaW5nWmVybyhwYXJ0OiBEYXRlUGFydEluZm8pIHtcbiAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuRGF0ZTpcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuTW9udGg6XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0LkhvdXJzOlxuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5NaW51dGVzOlxuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5TZWNvbmRzOlxuICAgICAgICAgICAgICAgIGlmIChwYXJ0LmZvcm1hdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5mb3JtYXQgPSBwYXJ0LmZvcm1hdC5yZXBlYXQoMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0Q2xlYW5WYWwoaW5wdXREYXRhOiBzdHJpbmcsIGRhdGVQYXJ0OiBEYXRlUGFydEluZm8sIHByb21wdENoYXI/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gRGF0ZVBpY2tlclV0aWwudHJpbUVtcHR5UGxhY2Vob2xkZXJzKGlucHV0RGF0YS5zdWJzdHJpbmcoZGF0ZVBhcnQuc3RhcnQsIGRhdGVQYXJ0LmVuZCksIHByb21wdENoYXIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGRldGVybWluZURhdGVQYXJ0KGNoYXI6IHN0cmluZyk6IERhdGVQYXJ0IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5EYXRlO1xuICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0Lk1vbnRoO1xuICAgICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZVBhcnQuWWVhcjtcbiAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0LkhvdXJzO1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0Lk1pbnV0ZXM7XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5TZWNvbmRzO1xuICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZVBhcnQuQW1QbTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0LkxpdGVyYWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBnZW5lcmF0ZXMgZGF0ZSBwYXJ0cyBzdHJ1Y3R1cmUgYmFzZWQgb24gZWRpdG9yIG1hc2sgYW5kIGxvY2FsZS5cbiAgICAgKiBAcGFyYW0gbWFza1ZhbHVlOiBzdHJpbmdcbiAgICAgKiBAcGFyYW0gbG9jYWxlOiBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBhcnJheSBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGRhdGUgcGFydHMgLSB0eXBlLCBwb3NpdGlvbiwgZm9ybWF0XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZURhdGVGb3JtYXQobWFza1ZhbHVlOiBzdHJpbmcsIGxvY2FsZTogc3RyaW5nID0gRGF0ZVBpY2tlclV0aWwuREVGQVVMVF9MT0NBTEUpOiBhbnlbXSB7XG4gICAgICAgIGxldCBkYXRlU3RydWN0ID0gW107XG4gICAgICAgIGlmIChtYXNrVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhaXNJRSgpKSB7XG4gICAgICAgICAgICBkYXRlU3RydWN0ID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGVmYXVsdExvY2FsZU1hc2sobG9jYWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSAobWFza1ZhbHVlKSA/IG1hc2tWYWx1ZSA6IERhdGVQaWNrZXJVdGlsLlNIT1JUX0RBVEVfTUFTSztcbiAgICAgICAgICAgIGNvbnN0IG1hc2tBcnJheSA9IEFycmF5LmZyb20obWFzayk7XG4gICAgICAgICAgICBjb25zdCBtb250aEluaXRQb3NpdGlvbiA9IG1hc2suaW5kZXhPZihEYXRlQ2hhcnMuTW9udGhDaGFyKTtcbiAgICAgICAgICAgIGNvbnN0IGRheUluaXRQb3NpdGlvbiA9IG1hc2suaW5kZXhPZihEYXRlQ2hhcnMuRGF5Q2hhcik7XG4gICAgICAgICAgICBjb25zdCB5ZWFySW5pdFBvc2l0aW9uID0gbWFzay5pbmRleE9mKERhdGVDaGFycy5ZZWFyQ2hhcik7XG5cbiAgICAgICAgICAgIGlmICh5ZWFySW5pdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGRhdGVTdHJ1Y3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IERhdGVQYXJ0cy5ZZWFyLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsUG9zaXRpb246IHllYXJJbml0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFR5cGU6IERhdGVQaWNrZXJVdGlsLmdldFllYXJGb3JtYXRUeXBlKG1hc2spXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtb250aEluaXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkYXRlU3RydWN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRlUGFydHMuTW9udGgsXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxQb3NpdGlvbjogbW9udGhJbml0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFR5cGU6IERhdGVQaWNrZXJVdGlsLmdldE1vbnRoRm9ybWF0VHlwZShtYXNrKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF5SW5pdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGRhdGVTdHJ1Y3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IERhdGVQYXJ0cy5EYXksXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxQb3NpdGlvbjogZGF5SW5pdFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRUeXBlOiBEYXRlUGlja2VyVXRpbC5nZXREYXlGb3JtYXRUeXBlKG1hc2spXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFza0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFEYXRlUGlja2VyVXRpbC5pc0RhdGVDaGFyKG1hc2tBcnJheVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVN0cnVjdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IERhdGVQaWNrZXJVdGlsLlNFUEFSQVRPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxQb3NpdGlvbjogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXNrQXJyYXlbaV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlU3RydWN0LnNvcnQoKGEsIGIpID0+IGEuaW5pdGlhbFBvc2l0aW9uIC0gYi5pbml0aWFsUG9zaXRpb24pO1xuICAgICAgICAgICAgRGF0ZVBpY2tlclV0aWwuZmlsbERhdGVQYXJ0c1Bvc2l0aW9ucyhkYXRlU3RydWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZVN0cnVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBnZW5lcmF0ZXMgaW5wdXQgbWFzayBiYXNlZCBvbiBkYXRlIHBhcnRzLlxuICAgICAqIEBwYXJhbSBkYXRlU3RydWN0IGFycmF5XG4gICAgICogQHJldHVybnMgaW5wdXQgbWFza1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SW5wdXRNYXNrKGRhdGVTdHJ1Y3Q6IGFueVtdKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgaW5wdXRNYXNrID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0ZVN0cnVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGRhdGVTdHJ1Y3RbaV0udHlwZSA9PT0gRGF0ZVBpY2tlclV0aWwuU0VQQVJBVE9SKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRNYXNrLnB1c2goZGF0ZVN0cnVjdFtpXS52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGVTdHJ1Y3RbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLkRheSB8fCBkYXRlU3RydWN0W2ldLnR5cGUgPT09IERhdGVQYXJ0cy5Nb250aCkge1xuICAgICAgICAgICAgICAgIGlucHV0TWFzay5wdXNoKCcwMCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRlU3RydWN0W2ldLnR5cGUgPT09IERhdGVQYXJ0cy5ZZWFyKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkYXRlU3RydWN0W2ldLmZvcm1hdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLk51bWVyaWM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0TWFzay5wdXNoKCcwMDAwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIEZvcm1hdERlc2MuVHdvRGlnaXRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dE1hc2sucHVzaCgnMDAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dE1hc2suam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGVkaXRvciBtYXNrLlxuICAgICAqIEBwYXJhbSBkYXRlU3RydWN0XG4gICAgICogQHJldHVybnMgZWRpdG9yIG1hc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldE1hc2soZGF0ZVN0cnVjdDogYW55W10pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBtYXNrID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0ZVN0cnVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3dpdGNoIChkYXRlU3RydWN0W2ldLmZvcm1hdFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEZvcm1hdERlc2MuTnVtZXJpYzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZVN0cnVjdFtpXS50eXBlID09PSBEYXRlUGFydHMuRGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrLnB1c2goJ2QnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRlU3RydWN0W2ldLnR5cGUgPT09IERhdGVQYXJ0cy5Nb250aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5wdXNoKCdNJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrLnB1c2goJ3l5eXknKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLlR3b0RpZ2l0czoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZVN0cnVjdFtpXS50eXBlID09PSBEYXRlUGFydHMuRGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrLnB1c2goJ2RkJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0ZVN0cnVjdFtpXS50eXBlID09PSBEYXRlUGFydHMuTW9udGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sucHVzaCgnTU0nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sucHVzaCgneXknKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGVTdHJ1Y3RbaV0udHlwZSA9PT0gRGF0ZVBpY2tlclV0aWwuU0VQQVJBVE9SKSB7XG4gICAgICAgICAgICAgICAgbWFzay5wdXNoKGRhdGVTdHJ1Y3RbaV0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hc2suam9pbignJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHBhcnNlcyBhbiBpbnB1dCBzdHJpbmcgYmFzZSBvbiBkYXRlIHBhcnRzIGFuZCByZXR1cm5zIGEgZGF0ZSBhbmQgaXRzIHZhbGlkYXRpb24gc3RhdGUuXG4gICAgICogQHBhcmFtIGRhdGVGb3JtYXRQYXJ0c1xuICAgICAqIEBwYXJhbSBwcmV2RGF0ZVZhbHVlXG4gICAgICogQHBhcmFtIGlucHV0VmFsdWVcbiAgICAgKiBAcmV0dXJucyBvYmplY3QgY29udGFpbmluZyBhIGRhdGUgYW5kIGl0cyB2YWxpZGF0aW9uIHN0YXRlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZURhdGVBcnJheShkYXRlRm9ybWF0UGFydHM6IGFueVtdLCBwcmV2RGF0ZVZhbHVlOiBEYXRlLCBpbnB1dFZhbHVlOiBzdHJpbmcpOiBhbnkge1xuICAgICAgICBjb25zdCBkYXlTdHIgPSBEYXRlUGlja2VyVXRpbC5nZXREYXlWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIGlucHV0VmFsdWUpO1xuICAgICAgICBjb25zdCBtb250aFN0ciA9IERhdGVQaWNrZXJVdGlsLmdldE1vbnRoVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dFZhbHVlKTtcbiAgICAgICAgY29uc3QgeWVhclN0ciA9IERhdGVQaWNrZXJVdGlsLmdldFllYXJWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIGlucHV0VmFsdWUpO1xuICAgICAgICBjb25zdCB5ZWFyRm9ybWF0ID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZUZvcm1hdFBhcnQoZGF0ZUZvcm1hdFBhcnRzLCBEYXRlUGFydHMuWWVhcikuZm9ybWF0VHlwZTtcbiAgICAgICAgY29uc3QgZGF5ID0gKGRheVN0ciAhPT0gJycpID8gcGFyc2VJbnQoZGF5U3RyLCAxMCkgOiAxO1xuICAgICAgICBjb25zdCBtb250aCA9IChtb250aFN0ciAhPT0gJycpID8gcGFyc2VJbnQobW9udGhTdHIsIDEwKSAtIDEgOiAwO1xuXG4gICAgICAgIGxldCB5ZWFyO1xuICAgICAgICBpZiAoeWVhclN0ciA9PT0gJycpIHtcbiAgICAgICAgICAgIHllYXIgPSAoeWVhckZvcm1hdCA9PT0gRm9ybWF0RGVzYy5Ud29EaWdpdHMpID8gJzAwJyA6ICcyMDAwJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHllYXIgPSB5ZWFyU3RyO1xuICAgICAgICB9XG4gICAgICAgIGxldCB5ZWFyUHJlZml4O1xuICAgICAgICBpZiAocHJldkRhdGVWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxZZWFyID0gcHJldkRhdGVWYWx1ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxZZWFyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHllYXJQcmVmaXggPSBvcmlnaW5hbFllYXIuc3Vic3RyaW5nKDAsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWVhclByZWZpeCA9ICcyMCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVsbFllYXIgPSAoeWVhckZvcm1hdCA9PT0gRm9ybWF0RGVzYy5Ud29EaWdpdHMpID8geWVhclByZWZpeC5jb25jYXQoeWVhcikgOiB5ZWFyO1xuXG4gICAgICAgIGlmICgobW9udGggPCAwKSB8fCAobW9udGggPiAxMSkgfHwgKG1vbnRoID09PSBOYU4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogRGF0ZVN0YXRlLkludmFsaWQsIHZhbHVlOiBpbnB1dFZhbHVlIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGRheSA8IDEpIHx8IChkYXkgPiBEYXRlUGlja2VyVXRpbC5kYXlzSW5Nb250aChmdWxsWWVhciwgbW9udGgpKSB8fCAoZGF5ID09PSBOYU4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogRGF0ZVN0YXRlLkludmFsaWQsIHZhbHVlOiBpbnB1dFZhbHVlIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdGF0ZTogRGF0ZVN0YXRlLlZhbGlkLCBkYXRlOiBuZXcgRGF0ZShmdWxsWWVhciwgbW9udGgsIGRheSkgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIG1hc2tUb1Byb21wdENoYXJzKG1hc2s6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hc2sucmVwbGFjZSgvMHxML2csIERhdGVQaWNrZXJVdGlsLlBST01QVF9DSEFSKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXBsYWNlcyBwcm9tcHQgY2hhcnMgd2l0aCBlbXB0eSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyB0cmltRW1wdHlQbGFjZWhvbGRlcnModmFsdWU6IHN0cmluZywgcHJvbXB0Q2hhcj86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnJlcGxhY2UobmV3IFJlZ0V4cChwcm9tcHRDaGFyIHx8ICdfJywgJ2cnKSwgJycpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHNwaW5uaW5nIGRhdGUgcGFydHMuXG4gICAgICogQHBhcmFtIGRhdGVGb3JtYXRQYXJ0c1xuICAgICAqIEBwYXJhbSBpbnB1dFZhbHVlXG4gICAgICogQHBhcmFtIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGRlbHRhXG4gICAgICogQHBhcmFtIGlzU3Bpbkxvb3BcbiAgICAgKiBAcmV0dXJuIG1vZGlmaWVkIHRleHQgaW5wdXRcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldE1vZGlmaWVkRGF0ZUlucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sXG4gICAgICAgIGlucHV0VmFsdWU6IHN0cmluZyxcbiAgICAgICAgcG9zaXRpb246IG51bWJlcixcbiAgICAgICAgZGVsdGE6IG51bWJlcixcbiAgICAgICAgaXNTcGluTG9vcDogYm9vbGVhbik6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGRhdGVQYXJ0ID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZVBhcnRPblBvc2l0aW9uKGRhdGVGb3JtYXRQYXJ0cywgcG9zaXRpb24pO1xuICAgICAgICBjb25zdCBkYXRlUGFydFR5cGUgPSBkYXRlUGFydC50eXBlO1xuICAgICAgICBjb25zdCBkYXRlUGFydEZvcm1hdFR5cGUgPSBkYXRlUGFydC5mb3JtYXRUeXBlO1xuICAgICAgICBsZXQgbmV3VmFsdWU7XG5cbiAgICAgICAgY29uc3QgZGF0ZVBhcnRWYWx1ZSA9IERhdGVQaWNrZXJVdGlsLmdldERhdGVWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIGRhdGVQYXJ0VHlwZSwgaW5wdXRWYWx1ZSk7XG4gICAgICAgIG5ld1ZhbHVlID0gcGFyc2VJbnQoZGF0ZVBhcnRWYWx1ZSwgMTApO1xuXG4gICAgICAgIGxldCBtYXhWYWx1ZSwgbWluVmFsdWU7XG4gICAgICAgIGNvbnN0IG1pbk1heCA9IERhdGVQaWNrZXJVdGlsLmdldE1pbk1heFZhbHVlKGRhdGVGb3JtYXRQYXJ0cywgZGF0ZVBhcnQsIGlucHV0VmFsdWUpO1xuICAgICAgICBtaW5WYWx1ZSA9IG1pbk1heC5taW47XG4gICAgICAgIG1heFZhbHVlID0gbWluTWF4Lm1heDtcblxuICAgICAgICBpZiAoaXNOYU4obmV3VmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAobWluVmFsdWUgPT09ICdpbmZpbml0ZScpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IDIwMDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gbWluVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRlbXBWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB0ZW1wVmFsdWUgKz0gZGVsdGE7XG5cbiAgICAgICAgLy8gSW5maW5pdGUgbG9vcCBmb3IgZnVsbCB5ZWFyc1xuICAgICAgICBpZiAobWF4VmFsdWUgPT09ICdpbmZpbml0ZScgJiYgbWluVmFsdWUgPT09ICdpbmZpbml0ZScpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdGVtcFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzU3Bpbkxvb3ApIHtcbiAgICAgICAgICAgIGlmICh0ZW1wVmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRlbXBWYWx1ZSA9IG1pblZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRlbXBWYWx1ZSA8IG1pblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGVtcFZhbHVlID0gbWF4VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRlbXBWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0ZW1wVmFsdWUgPD0gbWF4VmFsdWUgJiYgdGVtcFZhbHVlID49IG1pblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0ZW1wVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydElkeCA9IGRhdGVQYXJ0LnBvc2l0aW9uWzBdO1xuICAgICAgICBjb25zdCBlbmRJZHggPSBkYXRlUGFydC5wb3NpdGlvblsxXTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBpbnB1dFZhbHVlLnNsaWNlKDAsIHN0YXJ0SWR4KTtcbiAgICAgICAgY29uc3QgZW5kID0gaW5wdXRWYWx1ZS5zbGljZShlbmRJZHgsIGlucHV0VmFsdWUubGVuZ3RoKTtcbiAgICAgICAgbGV0IGNoYW5nZWRQYXJ0OiBzdHJpbmc7XG5cbiAgICAgICAgY29uc3QgcHJlZml4ID0gRGF0ZVBpY2tlclV0aWwuZ2V0TnVtZXJpY0Zvcm1hdFByZWZpeChkYXRlUGFydEZvcm1hdFR5cGUpO1xuICAgICAgICBjaGFuZ2VkUGFydCA9IChuZXdWYWx1ZSA8IDEwKSA/IGAke3ByZWZpeH0ke25ld1ZhbHVlfWAgOiBgJHtuZXdWYWx1ZX1gO1xuXG4gICAgICAgIHJldHVybiBgJHtzdGFydH0ke2NoYW5nZWRQYXJ0fSR7ZW5kfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBkYXRlIGlucHV0IHdpdGggcHJvbXB0IGNoYXJzLlxuICAgICAqIEBwYXJhbSBkYXRlRm9ybWF0UGFydHNcbiAgICAgKiBAcGFyYW0gZGF0ZVxuICAgICAqIEBwYXJhbSBpbnB1dFZhbHVlXG4gICAgICogQHJldHVybnMgZGF0ZSBpbnB1dCBpbmNsdWRpbmcgcHJvbXB0IGNoYXJzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBhZGRQcm9tcHRDaGFyc0VkaXRNb2RlKGRhdGVGb3JtYXRQYXJ0czogYW55W10sIGRhdGU6IERhdGUsIGlucHV0VmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGRhdGVBcnJheSA9IEFycmF5LmZyb20oaW5wdXRWYWx1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0ZUZvcm1hdFBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdFBhcnRzW2ldLmZvcm1hdFR5cGUgPT09IEZvcm1hdERlc2MuTnVtZXJpYykge1xuICAgICAgICAgICAgICAgIGlmICgoZGF0ZUZvcm1hdFBhcnRzW2ldLnR5cGUgPT09IERhdGVQYXJ0cy5EYXkgJiYgZGF0ZS5nZXREYXRlKCkgPCAxMClcbiAgICAgICAgICAgICAgICAgICAgfHwgKGRhdGVGb3JtYXRQYXJ0c1tpXS50eXBlID09PSBEYXRlUGFydHMuTW9udGggJiYgZGF0ZS5nZXRNb250aCgpICsgMSA8IDEwKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQXJyYXkuc3BsaWNlKGRhdGVGb3JtYXRQYXJ0c1tpXS5wb3NpdGlvblswXSwgMCwgRGF0ZVBpY2tlclV0aWwuUFJPTVBUX0NIQVIpO1xuICAgICAgICAgICAgICAgICAgICBkYXRlQXJyYXkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlQXJyYXkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIGRhdGUgaW5wdXQgaXMgZG9uZS5cbiAgICAgKiBAcGFyYW0gZGF0ZUZvcm1hdFBhcnRzXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICogQHJldHVybnMgaW5wdXQgY29tcGxldGVuZXNzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBjaGVja0ZvckNvbXBsZXRlRGF0ZUlucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBkYXlWYWx1ZSA9IERhdGVQaWNrZXJVdGlsLmdldERheVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgaW5wdXQpO1xuICAgICAgICBjb25zdCBtb250aFZhbHVlID0gRGF0ZVBpY2tlclV0aWwuZ2V0TW9udGhWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIGlucHV0KTtcbiAgICAgICAgY29uc3QgeWVhclZhbHVlID0gRGF0ZVBpY2tlclV0aWwuZ2V0WWVhclZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXlTdHIgPSBEYXRlUGlja2VyVXRpbC5nZXREYXlWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIGlucHV0LCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IG1vbnRoU3RyID0gRGF0ZVBpY2tlclV0aWwuZ2V0TW9udGhWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIGlucHV0LCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKERhdGVQaWNrZXJVdGlsLmlzRnVsbElucHV0KGRheVZhbHVlLCBkYXlTdHIpXG4gICAgICAgICAgICAmJiBEYXRlUGlja2VyVXRpbC5pc0Z1bGxJbnB1dChtb250aFZhbHVlLCBtb250aFN0cilcbiAgICAgICAgICAgICYmIERhdGVQaWNrZXJVdGlsLmlzRnVsbFllYXJJbnB1dChkYXRlRm9ybWF0UGFydHMsIHllYXJWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnY29tcGxldGUnO1xuICAgICAgICB9IGVsc2UgaWYgKGRheVZhbHVlID09PSAnJyAmJiBtb250aFZhbHVlID09PSAnJyAmJiB5ZWFyVmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2VtcHR5JztcbiAgICAgICAgfSBlbHNlIGlmIChkYXlWYWx1ZSA9PT0gJycgfHwgbW9udGhWYWx1ZSA9PT0gJycgfHwgeWVhclZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuICdwYXJ0aWFsJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBkYXlzSW5Nb250aChmdWxsWWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGZ1bGxZZWFyLCBtb250aCArIDEsIDApLmdldERhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBwcm92aWRlZCBpbnB1dCB0byBEYXRlLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBpbnB1dCB0byBwYXJzZVxuICAgICAqIEByZXR1cm5zIERhdGUgaWYgcGFyc2Ugc3VjY2VlZCBvciBudWxsXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZURhdGUodmFsdWU6IGFueSk6IERhdGUgfCBudWxsIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB2YWx1ZSBpcyBJbnZhbGlkIERhdGUgd2Ugc2hvdWxkIHJldHVybiBudWxsXG4gICAgICAgIGlmICh0aGlzLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWREYXRlKHZhbHVlKSA/IHZhbHVlIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZSA/IG5ldyBEYXRlKERhdGUucGFyc2UodmFsdWUpKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHByb3ZpZGVkIGlucHV0IGlzIGRhdGVcbiAgICAgKiBAcGFyYW0gdmFsdWUgaW5wdXQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIGlucHV0IGlzIGRhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGlzRGF0ZSh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpbnB1dCBpcyB2YWxpZCBkYXRlXG4gICAgICogQHBhcmFtIHZhbHVlIGlucHV0IHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCBpbnB1dCBpcyBhIHZhbGlkIGRhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGlzVmFsaWREYXRlKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldFllYXJGb3JtYXRUeXBlKGZvcm1hdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQubWF0Y2gobmV3IFJlZ0V4cChEYXRlQ2hhcnMuWWVhckNoYXIsICdnJykpLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgLy8geSAoMjAyMClcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9ybWF0RGVzYy5OdW1lcmljO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgLy8geXl5eSAoMjAyMClcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9ybWF0RGVzYy5OdW1lcmljO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgLy8geXkgKDIwKVxuICAgICAgICAgICAgICAgIHJldHVybiBGb3JtYXREZXNjLlR3b0RpZ2l0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldE1vbnRoRm9ybWF0VHlwZShmb3JtYXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0Lm1hdGNoKG5ldyBSZWdFeHAoRGF0ZUNoYXJzLk1vbnRoQ2hhciwgJ2cnKSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAvLyBNICg4KVxuICAgICAgICAgICAgICAgIHJldHVybiBGb3JtYXREZXNjLk51bWVyaWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAvLyBNTSAoMDgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZvcm1hdERlc2MuVHdvRGlnaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RGF5Rm9ybWF0VHlwZShmb3JtYXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0Lm1hdGNoKG5ldyBSZWdFeHAoRGF0ZUNoYXJzLkRheUNoYXIsICdnJykpLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgLy8gZCAoNilcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9ybWF0RGVzYy5OdW1lcmljO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgLy8gZGQgKDA2KVxuICAgICAgICAgICAgICAgIHJldHVybiBGb3JtYXREZXNjLlR3b0RpZ2l0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldERlZmF1bHRMb2NhbGVNYXNrKGxvY2FsZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGRhdGVTdHJ1Y3QgPSBbXTtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlKTtcbiAgICAgICAgY29uc3QgZm9ybWF0VG9QYXJ0cyA9IGZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKG5ldyBEYXRlKCkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdFRvUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb1BhcnRzW2ldLnR5cGUgPT09IERhdGVQaWNrZXJVdGlsLlNFUEFSQVRPUikge1xuICAgICAgICAgICAgICAgIGRhdGVTdHJ1Y3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IERhdGVQaWNrZXJVdGlsLlNFUEFSQVRPUixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZvcm1hdFRvUGFydHNbaV0udmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0ZVN0cnVjdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZm9ybWF0VG9QYXJ0c1tpXS50eXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVyT3B0aW9ucyA9IGZvcm1hdHRlci5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRlU3RydWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGRhdGVTdHJ1Y3RbaV0udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnRzLkRheToge1xuICAgICAgICAgICAgICAgICAgICBkYXRlU3RydWN0W2ldLmZvcm1hdFR5cGUgPSBmb3JtYXR0ZXJPcHRpb25zLmRheTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnRzLk1vbnRoOiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVTdHJ1Y3RbaV0uZm9ybWF0VHlwZSA9IGZvcm1hdHRlck9wdGlvbnMubW9udGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIERhdGVQYXJ0cy5ZZWFyOiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVTdHJ1Y3RbaV0uZm9ybWF0VHlwZSA9IGZvcm1hdHRlck9wdGlvbnMueWVhcjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIERhdGVQaWNrZXJVdGlsLmZpbGxEYXRlUGFydHNQb3NpdGlvbnMoZGF0ZVN0cnVjdCk7XG4gICAgICAgIHJldHVybiBkYXRlU3RydWN0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGlzRGF0ZUNoYXIoY2hhcjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoY2hhciA9PT0gRGF0ZUNoYXJzLlllYXJDaGFyIHx8IGNoYXIgPT09IERhdGVDaGFycy5Nb250aENoYXIgfHwgY2hhciA9PT0gRGF0ZUNoYXJzLkRheUNoYXIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldE51bWVyaWNGb3JtYXRQcmVmaXgoZm9ybWF0VHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoIChmb3JtYXRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEZvcm1hdERlc2MuVHdvRGlnaXRzOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRm9ybWF0RGVzYy5OdW1lcmljOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLlBST01QVF9DSEFSO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0TWluTWF4VmFsdWUoZGF0ZUZvcm1hdFBhcnRzOiBhbnlbXSwgZGF0ZVBhcnQsIGlucHV0VmFsdWU6IHN0cmluZyk6IGFueSB7XG4gICAgICAgIGxldCBtYXhWYWx1ZSwgbWluVmFsdWU7XG4gICAgICAgIHN3aXRjaCAoZGF0ZVBhcnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBEYXRlUGFydHMuTW9udGg6IHtcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBEYXRlUGlja2VyVXRpbC5OVU1CRVJfT0ZfTU9OVEhTO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBEYXRlUGFydHMuRGF5OiB7XG4gICAgICAgICAgICAgICAgbWluVmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gRGF0ZVBpY2tlclV0aWwuZGF5c0luTW9udGgoXG4gICAgICAgICAgICAgICAgICAgIERhdGVQaWNrZXJVdGlsLmdldEZ1bGxZZWFyRnJvbVN0cmluZyhEYXRlUGlja2VyVXRpbC5nZXREYXRlRm9ybWF0UGFydChkYXRlRm9ybWF0UGFydHMsIERhdGVQYXJ0cy5ZZWFyKSwgaW5wdXRWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KERhdGVQaWNrZXJVdGlsLmdldE1vbnRoVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dFZhbHVlKSwgMTApKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnRzLlllYXI6IHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZVBhcnQuZm9ybWF0VHlwZSA9PT0gRm9ybWF0RGVzYy5Ud29EaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IDk5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgbWluVmFsdWUgPSAnaW5maW5pdGUnO1xuICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9ICdpbmZpbml0ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1pbjogbWluVmFsdWUsIG1heDogbWF4VmFsdWUgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXREYXRlVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzOiBhbnlbXSwgdHlwZTogRGF0ZVBhcnRzLCBpbnB1dFZhbHVlOiBzdHJpbmcsIHRyaW06IGJvb2xlYW4gPSB0cnVlKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcGFydFBvc2l0aW9uID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZUZvcm1hdFBhcnQoZGF0ZUZvcm1hdFBhcnRzLCB0eXBlKS5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5wdXRWYWx1ZS5zdWJzdHJpbmcocGFydFBvc2l0aW9uWzBdLCBwYXJ0UG9zaXRpb25bMV0pO1xuICAgICAgICByZXR1cm4gKHRyaW0pID8gRGF0ZVBpY2tlclV0aWwudHJpbUVtcHR5UGxhY2Vob2xkZXJzKHJlc3VsdCkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RGF5VmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzOiBhbnlbXSwgaW5wdXRWYWx1ZTogc3RyaW5nLCB0cmltOiBib29sZWFuID0gdHJ1ZSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBEYXRlUGlja2VyVXRpbC5nZXREYXRlVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBEYXRlUGFydHMuRGF5LCBpbnB1dFZhbHVlLCB0cmltKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRNb250aFZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIGlucHV0VmFsdWU6IHN0cmluZywgdHJpbTogYm9vbGVhbiA9IHRydWUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgRGF0ZVBhcnRzLk1vbnRoLCBpbnB1dFZhbHVlLCB0cmltKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRZZWFyVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzOiBhbnlbXSwgaW5wdXRWYWx1ZTogc3RyaW5nLCB0cmltOiBib29sZWFuID0gdHJ1ZSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBEYXRlUGlja2VyVXRpbC5nZXREYXRlVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBEYXRlUGFydHMuWWVhciwgaW5wdXRWYWx1ZSwgdHJpbSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RGF0ZUZvcm1hdFBhcnQoZGF0ZUZvcm1hdFBhcnRzOiBhbnlbXSwgdHlwZTogRGF0ZVBhcnRzKTogYW55IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGF0ZUZvcm1hdFBhcnRzLmZpbHRlcigoZGF0ZVBhcnQpID0+IChkYXRlUGFydC50eXBlID09PSB0eXBlKSlbMF07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgaXNGdWxsSW5wdXQodmFsdWU6IGFueSwgaW5wdXQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKHZhbHVlICE9PSAnJyAmJiBpbnB1dC5sZW5ndGggPT09IDIgJiYgaW5wdXQuY2hhckF0KDEpICE9PSBEYXRlUGlja2VyVXRpbC5QUk9NUFRfQ0hBUik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgaXNGdWxsWWVhcklucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgc3dpdGNoIChEYXRlUGlja2VyVXRpbC5nZXREYXRlRm9ybWF0UGFydChkYXRlRm9ybWF0UGFydHMsIERhdGVQYXJ0cy5ZZWFyKS5mb3JtYXRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEZvcm1hdERlc2MuTnVtZXJpYzoge1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgIT09ICcnICYmIHZhbHVlLmxlbmd0aCA9PT0gNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEZvcm1hdERlc2MuVHdvRGlnaXRzOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSAhPT0gJycgJiYgdmFsdWUubGVuZ3RoID09PSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXREYXRlUGFydE9uUG9zaXRpb24oZGF0ZUZvcm1hdFBhcnRzOiBhbnlbXSwgcG9zaXRpb246IG51bWJlcikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkYXRlRm9ybWF0UGFydHMuZmlsdGVyKChlbGVtZW50KSA9PlxuICAgICAgICAgICAgZWxlbWVudC5wb3NpdGlvblswXSA8PSBwb3NpdGlvbiAmJiBwb3NpdGlvbiA8PSBlbGVtZW50LnBvc2l0aW9uWzFdICYmIGVsZW1lbnQudHlwZSAhPT0gRGF0ZVBpY2tlclV0aWwuU0VQQVJBVE9SKVswXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRGdWxsWWVhckZyb21TdHJpbmcoeWVhclBhcnQsIGlucHV0VmFsdWUpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXRWYWx1ZS5zdWJzdHJpbmcoeWVhclBhcnQucG9zaXRpb25bMF0sIHllYXJQYXJ0LnBvc2l0aW9uWzFdKSwgMTApO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGZpbGxEYXRlUGFydHNQb3NpdGlvbnMoZGF0ZUFycmF5OiBhbnlbXSk6IHZvaWQge1xuICAgICAgICBsZXQgY3VycmVudFBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRlQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIERheXxNb250aCBwYXJ0IHBvc2l0aW9uc1xuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVtpXS50eXBlID09PSBEYXRlUGFydHMuRGF5IHx8IGRhdGVBcnJheVtpXS50eXBlID09PSBEYXRlUGFydHMuTW9udGgpIHtcbiAgICAgICAgICAgICAgICAvLyBPZmZzZXQgMiBwb3NpdGlvbnMgZm9yIG51bWJlclxuICAgICAgICAgICAgICAgIGRhdGVBcnJheVtpXS5wb3NpdGlvbiA9IFtjdXJyZW50UG9zLCBjdXJyZW50UG9zICsgMl07XG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRlQXJyYXlbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLlllYXIpIHtcbiAgICAgICAgICAgICAgICAvLyBZZWFyIHBhcnQgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgc3dpdGNoIChkYXRlQXJyYXlbaV0uZm9ybWF0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEZvcm1hdERlc2MuTnVtZXJpYzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2Zmc2V0IDQgcG9zaXRpb25zIGZvciBmdWxsIHllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVBcnJheVtpXS5wb3NpdGlvbiA9IFtjdXJyZW50UG9zLCBjdXJyZW50UG9zICsgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIEZvcm1hdERlc2MuVHdvRGlnaXRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPZmZzZXQgMiBwb3NpdGlvbnMgZm9yIHNob3J0IHllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVBcnJheVtpXS5wb3NpdGlvbiA9IFtjdXJyZW50UG9zLCBjdXJyZW50UG9zICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0ZUFycmF5W2ldLnR5cGUgPT09IERhdGVQaWNrZXJVdGlsLlNFUEFSQVRPUikge1xuICAgICAgICAgICAgICAgIC8vIFNlcGFyYXRvciBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICBkYXRlQXJyYXlbaV0ucG9zaXRpb24gPSBbY3VycmVudFBvcywgY3VycmVudFBvcyArIDFdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuIl19