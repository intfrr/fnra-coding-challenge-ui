import { CommonModule } from '@angular/common';
import { Component, EventEmitter, HostBinding, Input, NgModule, Output, Renderer2, ViewChild, ContentChild, Directive } from '@angular/core';
import { IgxProcessBarTextTemplateDirective, IgxProgressBarGradientDirective, } from './progressbar.common';
import { mkenum } from '../core/utils';
import { IgxDirectionality } from '../services/direction/directionality';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '../services/direction/directionality';

const _c0 = function (a0, a1, a2, a3, a4) { return { "igx-linear-bar__value--start": a0, "igx-linear-bar__value--center": a1, "igx-linear-bar__value--end": a2, "igx-linear-bar__value--top": a3, "igx-linear-bar__value--hidden": a4 }; };
const _c1 = ["circle"];
function IgxCircularProgressBarComponent__svg_text_5__svg_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCircularProgressBarComponent__svg_text_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 9);
    ɵngcc0.ɵɵtemplate(1, IgxCircularProgressBarComponent__svg_text_5__svg_ng_container_1_Template, 1, 0, "ng-container", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    const _r4 = ɵngcc0.ɵɵreference(9);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.textTemplate ? ctx_r2.textTemplate.template : _r4)("ngTemplateOutletContext", ctx_r2.context);
} }
function IgxCircularProgressBarComponent__svg_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCircularProgressBarComponent__svg_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "tspan", 10);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.textContent ? ctx_r5.textContent : ctx_r5.valueInPercent + "%", " ");
} }
function IgxCircularProgressBarComponent__svg_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "linearGradient", 11);
    ɵngcc0.ɵɵelement(1, "stop", 12);
    ɵngcc0.ɵɵelement(2, "stop", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r7.gradientId);
} }
const _c2 = function (a0) { return { $implicit: a0 }; };
const ONE_PERCENT = 0.01;
const MIN_VALUE = 0;
export const IgxTextAlign = mkenum({
    START: 'start',
    CENTER: 'center',
    END: 'end'
});
export const IgxProgressType = mkenum({
    ERROR: 'error',
    INFO: 'info',
    WARNING: 'warning',
    SUCCESS: 'success'
});
/**
 * @hidden
 */
export class BaseProgressDirective {
    constructor() {
        this.requestAnimationId = undefined;
        this._initValue = 0;
        this._contentInit = false;
        this._valueInPercent = MIN_VALUE;
        this._max = 100;
        this._value = MIN_VALUE;
        this._newVal = MIN_VALUE;
        this._animate = true;
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *     alert("Progress made!");
         * }
         *  //...
         * ```
         * ```html
         * <igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
         * <igx-linear-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-linear-bar>
         * ```
         */
        this.onProgressChanged = new EventEmitter();
    }
    /**
     * Returns the value which update the progress indicator of the `progress bar`.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public stepValue(event) {
     *     let step = this.progressBar.step;
     *     alert(step);
     * }
     * ```
     */
    get step() {
        if (this._step) {
            return this._step;
        }
        return this._max * ONE_PERCENT;
    }
    /**
     * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0" [step]="1"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0" [step]="1"></igx-circular-bar>
     * ```
     */
    set step(val) {
        this._step = Number(val);
    }
    /**
     * Animating the progress. By default it is set to true.
     * ```html
     * <igx-linear-bar [animate]="false" [max]="200" [value]="50"></igx-linear-bar>
     * <igx-circular-bar [animate]="false" [max]="200" [value]="50"></igx-circular-bar>
     * ```
     */
    set animate(animate) {
        this._animate = animate;
    }
    /**
     * Returns whether the `progress bar` has animation true/false.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public animationStatus(event) {
     *     let animationStatus = this.progressBar.animate;
     *     alert(animationStatus);
     * }
     * ```
     */
    get animate() {
        return this._animate;
    }
    /**
     * Set maximum value that can be passed. By default it is set to 100.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
     * ```
     */
    set max(maxNum) {
        this._max = maxNum;
    }
    /**
     * Returns the the maximum progress value of the `progress bar`.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public maxValue(event) {
     *     let max = this.progressBar.max;
     *     alert(max);
     * }
     * ```
     */
    get max() {
        return this._max;
    }
    /**
     * Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     *     public setValue(event){
     *     this.progressBar.valueInPercent = 56;
     * }
     * ```
     */
    set valueInPercent(value) {
        this._valueInPercent = value;
    }
    /**
     * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     * public valuePercent(event){
     *     let percentValue = this.progressBar.valueInPercent;
     *     alert(percentValue);
     * }
     * ```
     */
    get valueInPercent() {
        return this._valueInPercent;
    }
    triggerProgressTransition(oldVal, newVal) {
        if (oldVal === newVal) {
            return;
        }
        const changedValues = {
            currentValue: newVal,
            previousValue: oldVal
        };
        const stepDirection = this.directionFlow(oldVal, newVal);
        if (this._animate) {
            this.runAnimation(newVal, stepDirection);
        }
        else {
            this.updateProgressDirectly(newVal);
        }
        this.onProgressChanged.emit(changedValues);
    }
    /**
     * @hidden
     */
    runAnimation(val, step) {
        this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
    }
    /**
     * @hidden
     */
    updateProgressSmoothly(val, step) {
        this._value = valueInRange(this._value, this._max) + step;
        const passedValue = toPercent(val, this._max);
        const progressValue = toPercent(this._value, this._max);
        if (this.valueInPercent === passedValue) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else if (this.isInLimitRange(progressValue, passedValue, step)) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else {
            this.valueInPercent = progressValue;
            this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
        }
    }
    /**
     * @hidden
     */
    updateProgressDirectly(val) {
        this._value = valueInRange(val, this._max);
        this.valueInPercent = toPercent(this._value, this._max);
    }
    /**
     * @hidden
     */
    directionFlow(currentValue, prevValue) {
        return currentValue < prevValue ? this.step : -this.step;
    }
    /**
     * @hidden
     */
    isInLimitRange(val, comparator, step) {
        return this.isExceedingUpperLimit(val, comparator, step) || this.isExceedingLowerLimit(val, comparator, step);
    }
    /**
     * @hidden
     *
     *
     * @param val
     * @param comparator
     * @param step
     */
    isExceedingUpperLimit(val, comparator, step) {
        return val > comparator && step > 0;
    }
    /**
     * @hidden
     *
     * @param val
     * @param comparator
     * @param step
     */
    isExceedingLowerLimit(val, comparator, step) {
        return val < comparator && step < 0;
    }
    /**
     * @hidden
     * @param step
     */
    updateProgress(val) {
        this._value = valueInRange(val, this._max);
        this.valueInPercent = toPercent(this._value, this._max);
    }
}
BaseProgressDirective.ɵfac = function BaseProgressDirective_Factory(t) { return new (t || BaseProgressDirective)(); };
BaseProgressDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BaseProgressDirective, hostVars: 1, hostBindings: function BaseProgressDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-valuemax", ctx.max);
    } }, inputs: { step: "step", animate: "animate", max: "max" }, outputs: { onProgressChanged: "onProgressChanged" } });
BaseProgressDirective.propDecorators = {
    onProgressChanged: [{ type: Output }],
    step: [{ type: Input }],
    animate: [{ type: Input }],
    max: [{ type: HostBinding, args: ['attr.aria-valuemax',] }, { type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BaseProgressDirective, [{
        type: Directive
    }], function () { return []; }, { onProgressChanged: [{
            type: Output
        }], step: [{
            type: Input
        }], animate: [{
            type: Input
        }], max: [{
            type: HostBinding,
            args: ['attr.aria-valuemax']
        }, {
            type: Input
        }] }); })();
let NEXT_LINEAR_ID = 0;
let NEXT_CIRCULAR_ID = 0;
let NEXT_GRADIENT_ID = 0;
export class IgxLinearProgressBarComponent extends BaseProgressDirective {
    constructor() {
        super();
        this.valueMin = 0;
        this.cssClass = 'igx-linear-bar';
        /**
         * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         * ```html
         * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.striped = false;
        /**
         * Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * An @Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
         * ```html
         * <igx-linear-bar role="progressbar"></igx-linear-bar>
         * ```
         */
        this.role = 'progressbar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.id = `igx-linear-bar-${NEXT_LINEAR_ID++}`;
        /**
         * Set the position that defines where the text is aligned.
         * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         * ```typescript
         * public positionCenter: IgxTextAlign;
         * public ngOnInit() {
         *     this.positionCenter = IgxTextAlign.CENTER;
         * }
         *  //...
         * ```
         *  ```html
         * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         * ```
         */
        this.textAlign = IgxTextAlign.START;
        /**
         * Set the text to be visible. By default it is set to true.
         * ```html
         *  <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         * ```html
         *  <igx-linear-bar type="error" [textTop]="true"></igx-linear-bar>
         * ```
         */
        this.textTop = false;
        /**
         * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="error"></igx-linear-bar>
         * ```
         */
        this.type = 'default';
    }
    /**
     * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public getValue(event) {
     *     let value = this.progressBar.value;
     *     alert(value);
     * }
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     */
    set value(val) {
        const valInRange = valueInRange(val, this.max);
        if (isNaN(valInRange) || this._value === val || this.indeterminate) {
            return;
        }
        if (this._contentInit) {
            this.triggerProgressTransition(this._value, valInRange);
        }
        else {
            this._initValue = valInRange;
        }
    }
    /**
     * @hidden
     */
    get error() {
        return this.type === IgxProgressType.ERROR;
    }
    /**
     * @hidden
     */
    get info() {
        return this.type === IgxProgressType.INFO;
    }
    /**
     * @hidden
     */
    get warning() {
        return this.type === IgxProgressType.WARNING;
    }
    /**
     * @hidden
     */
    get success() {
        return this.type === IgxProgressType.SUCCESS;
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
}
IgxLinearProgressBarComponent.ɵfac = function IgxLinearProgressBarComponent_Factory(t) { return new (t || IgxLinearProgressBarComponent)(); };
IgxLinearProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxLinearProgressBarComponent, selectors: [["igx-linear-bar"]], hostVars: 18, hostBindings: function IgxLinearProgressBarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-valuemin", ctx.valueMin)("role", ctx.role)("id", ctx.id)("aria-valuenow", ctx.value);
        ɵngcc0.ɵɵclassProp("igx-linear-bar", ctx.cssClass)("igx-linear-bar--striped", ctx.striped)("igx-linear-bar--indeterminate", ctx.indeterminate)("igx-linear-bar--danger", ctx.error)("igx-linear-bar--info", ctx.info)("igx-linear-bar--warning", ctx.warning)("igx-linear-bar--success", ctx.success);
    } }, inputs: { striped: "striped", indeterminate: "indeterminate", role: "role", id: "id", textAlign: "textAlign", textVisibility: "textVisibility", textTop: "textTop", type: "type", value: "value", text: "text" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 10, consts: [[1, "igx-linear-bar__base"], [1, "igx-linear-bar__indicator"], [1, "igx-linear-bar__value", 3, "ngClass"]], template: function IgxLinearProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelement(1, "div", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 2);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.valueInPercent, "%");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction5(4, _c0, ctx.textAlign === "start", ctx.textAlign === "center", ctx.textAlign === "end", ctx.textTop, !ctx.textVisibility));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.text ? ctx.text : ctx.valueInPercent + "%", "\n");
    } }, directives: [ɵngcc1.NgClass], encapsulation: 2 });
IgxLinearProgressBarComponent.ctorParameters = () => [];
IgxLinearProgressBarComponent.propDecorators = {
    valueMin: [{ type: HostBinding, args: ['attr.aria-valuemin',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-linear-bar',] }],
    striped: [{ type: HostBinding, args: ['class.igx-linear-bar--striped',] }, { type: Input }],
    indeterminate: [{ type: HostBinding, args: ['class.igx-linear-bar--indeterminate',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    textAlign: [{ type: Input }],
    textVisibility: [{ type: Input }],
    textTop: [{ type: Input }],
    text: [{ type: Input }],
    type: [{ type: Input }],
    value: [{ type: HostBinding, args: ['attr.aria-valuenow',] }, { type: Input }],
    error: [{ type: HostBinding, args: ['class.igx-linear-bar--danger',] }],
    info: [{ type: HostBinding, args: ['class.igx-linear-bar--info',] }],
    warning: [{ type: HostBinding, args: ['class.igx-linear-bar--warning',] }],
    success: [{ type: HostBinding, args: ['class.igx-linear-bar--success',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxLinearProgressBarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-linear-bar',
                template: "<div class=\"igx-linear-bar__base\">\n    <div class=\"igx-linear-bar__indicator\" [style.width.%]=\"valueInPercent\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n"
            }]
    }], function () { return []; }, { valueMin: [{
            type: HostBinding,
            args: ['attr.aria-valuemin']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-linear-bar']
        }], striped: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--striped']
        }, {
            type: Input
        }], indeterminate: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--indeterminate']
        }, {
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], textAlign: [{
            type: Input
        }], textVisibility: [{
            type: Input
        }], textTop: [{
            type: Input
        }], type: [{
            type: Input
        }], value: [{
            type: HostBinding,
            args: ['attr.aria-valuenow']
        }, {
            type: Input
        }], error: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--danger']
        }], info: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--info']
        }], warning: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--warning']
        }], success: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--success']
        }], text: [{
            type: Input
        }] }); })();
export class IgxCircularProgressBarComponent extends BaseProgressDirective {
    constructor(renderer, _directionality) {
        super();
        this.renderer = renderer;
        this._directionality = _directionality;
        this.STROKE_OPACITY_DVIDER = 100;
        this.STROKE_OPACITY_ADDITION = .2;
        /** @hidden */
        this.cssClass = 'igx-circular-bar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         * ```
         */
        this.id = `igx-circular-bar-${NEXT_CIRCULAR_ID++}`;
        /**
         * @hidden
         */
        this.gradientId = `igx-circular-gradient-${NEXT_GRADIENT_ID++}`;
        /**
         * An @Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
         * ```html
         * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * Sets the text visibility. By default it is set to true.
         * ```html
         * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         * ```
         */
        this.textVisibility = true;
        this._circleRadius = 46;
        this._circumference = 2 * Math.PI * this._circleRadius;
    }
    /**
     * @hidden
     */
    get context() {
        return {
            $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
        };
    }
    /**
     * Returns value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public getValue(event) {
     *     let value = this.progressBar.value;
     *     alert(value);
     * }
     * ```
     * ```html
     * <button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```html
     * <igx-circular-bar [value]="50"></igx-circular-bar>
     * ```
     */
    set value(val) {
        const valInRange = valueInRange(val, this.max);
        if (isNaN(valInRange) || this._value === val || this.indeterminate) {
            return;
        }
        if (this._contentInit) {
            this.triggerProgressTransition(this._value, valInRange);
        }
        else {
            this._initValue = valInRange;
        }
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
    ngAfterViewInit() {
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke', `url(#${this.gradientId})`);
    }
    /**
     * @hidden
     */
    updateProgressSmoothly(val, step) {
        // Set frames for the animation
        const FRAMES = [{
                strokeDashoffset: this.getProgress(this._value),
                strokeOpacity: (this._value / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }, {
                strokeDashoffset: this.getProgress(this.valueInPercent),
                strokeOpacity: (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }];
        this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards'
        });
        super.updateProgressSmoothly(val, step);
    }
    /**
     * @hidden
     */
    get textContent() {
        return this.text;
    }
    /**
     * @hidden
     */
    updateProgressDirectly(val) {
        super.updateProgressDirectly(val);
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-dashoffset', this.getProgress(this.valueInPercent));
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-opacity', (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION);
    }
    getProgress(percentage) {
        return this._directionality.rtl ?
            this._circumference + (percentage * this._circumference / 100) :
            this._circumference - (percentage * this._circumference / 100);
    }
}
IgxCircularProgressBarComponent.ɵfac = function IgxCircularProgressBarComponent_Factory(t) { return new (t || IgxCircularProgressBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.IgxDirectionality)); };
IgxCircularProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCircularProgressBarComponent, selectors: [["igx-circular-bar"]], contentQueries: function IgxCircularProgressBarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxProcessBarTextTemplateDirective, true, IgxProcessBarTextTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxProgressBarGradientDirective, true, IgxProgressBarGradientDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.textTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.gradientTemplate = _t.first);
    } }, viewQuery: function IgxCircularProgressBarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._svgCircle = _t.first);
    } }, hostVars: 5, hostBindings: function IgxCircularProgressBarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-circular-bar", ctx.cssClass)("igx-circular-bar--indeterminate", ctx.indeterminate);
    } }, inputs: { id: "id", indeterminate: "indeterminate", textVisibility: "textVisibility", value: "value", text: "text" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 12, vars: 7, consts: [["xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink", "version", "1.1", "viewBox", "0 0 100 100", "preserveAspectRatio", "xMidYMid meet", "role", "progressbar", "aria-valuemin", "0"], ["svg", ""], ["cx", "50", "cy", "50", "r", "46", 1, "igx-circular-bar__inner"], ["cx", "50", "cy", "50", "r", "46", 1, "igx-circular-bar__outer"], ["circle", ""], ["text-anchor", "middle", "x", "50", "y", "60", 4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["defaultTextTemplate", ""], ["defaultGradientTemplate", ""], ["text-anchor", "middle", "x", "50", "y", "60"], [1, "igx-circular-bar__text"], ["gradientTransform", "rotate(90)", 3, "id"], ["offset", "0%", 1, "igx-circular-bar__gradient-start"], ["offset", "100%", 1, "igx-circular-bar__gradient-end"]], template: function IgxCircularProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "svg", 0, 1);
        ɵngcc0.ɵɵelement(2, "circle", 2);
        ɵngcc0.ɵɵelement(3, "circle", 3, 4);
        ɵngcc0.ɵɵtemplate(5, IgxCircularProgressBarComponent__svg_text_5_Template, 2, 2, "text", 5);
        ɵngcc0.ɵɵelementStart(6, "defs");
        ɵngcc0.ɵɵtemplate(7, IgxCircularProgressBarComponent__svg_ng_container_7_Template, 1, 0, "ng-container", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, IgxCircularProgressBarComponent__svg_ng_template_8_Template, 2, 1, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(10, IgxCircularProgressBarComponent__svg_ng_template_10_Template, 3, 1, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r6 = ɵngcc0.ɵɵreference(11);
        ɵngcc0.ɵɵattribute("aria-valuemax", ctx.max)("aria-valuenow", ctx.value);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.textVisibility);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.gradientTemplate ? ctx.gradientTemplate.template : _r6)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(5, _c2, ctx.gradientId));
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
IgxCircularProgressBarComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: IgxDirectionality }
];
IgxCircularProgressBarComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-circular-bar',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    indeterminate: [{ type: HostBinding, args: ['class.igx-circular-bar--indeterminate',] }, { type: Input }],
    textVisibility: [{ type: Input }],
    text: [{ type: Input }],
    textTemplate: [{ type: ContentChild, args: [IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective },] }],
    gradientTemplate: [{ type: ContentChild, args: [IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective },] }],
    value: [{ type: Input }],
    _svgCircle: [{ type: ViewChild, args: ['circle', { static: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCircularProgressBarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-circular-bar',
                template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:text *ngIf=\"textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n        </ng-container>\n    </svg:text>\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultTextTemplate>\n        <svg:tspan class=\"igx-circular-bar__text\">\n            {{textContent ? textContent: valueInPercent + '%'}}\n        </svg:tspan>\n    </ng-template>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n"
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc2.IgxDirectionality }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-circular-bar']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], indeterminate: [{
            type: HostBinding,
            args: ['class.igx-circular-bar--indeterminate']
        }, {
            type: Input
        }], textVisibility: [{
            type: Input
        }], value: [{
            type: Input
        }], text: [{
            type: Input
        }], textTemplate: [{
            type: ContentChild,
            args: [IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective }]
        }], gradientTemplate: [{
            type: ContentChild,
            args: [IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective }]
        }], _svgCircle: [{
            type: ViewChild,
            args: ['circle', { static: true }]
        }] }); })();
export function valueInRange(value, max, min = 0) {
    return Math.max(Math.min(value, max), min);
}
export function toPercent(value, max) {
    return Math.floor(100 * value / max);
}
/**
 * @hidden
 */
export class IgxProgressBarModule {
}
IgxProgressBarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxProgressBarModule });
IgxProgressBarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxProgressBarModule_Factory(t) { return new (t || IgxProgressBarModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxProgressBarModule, { declarations: function () { return [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective,
        IgxProgressBarGradientDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective,
        IgxProgressBarGradientDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxProgressBarModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxLinearProgressBarComponent,
                    IgxCircularProgressBarComponent,
                    IgxProcessBarTextTemplateDirective,
                    IgxProgressBarGradientDirective,
                ],
                exports: [
                    IgxLinearProgressBarComponent,
                    IgxCircularProgressBarComponent,
                    IgxProcessBarTextTemplateDirective,
                    IgxProgressBarGradientDirective,
                ],
                imports: [CommonModule]
            }]
    }], null, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3NiYXIuY29tcG9uZW50LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQ0gsU0FBUyxFQUVULFlBQVksRUFDWixXQUFXLEVBQ1gsS0FBSyxFQUNMLFFBQVEsRUFDUixNQUFNLEVBQ04sU0FBUyxFQUNULFNBQVMsRUFDVCxZQUFZLEVBR1osU0FBUyxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFDSCxrQ0FBa0MsRUFDbEMsK0JBQStCLEdBQ2xDLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFrQixNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdkQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0NBQXNDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXpFLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQztBQUN6QixNQUFNLFNBQVMsR0FBRyxDQUFDLENBQUM7QUFFcEIsTUFBTSxDQUFDLE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQztBQUNuQyxJQUFJLEtBQUssRUFBRSxPQUFPO0FBQ2xCLElBQUksTUFBTSxFQUFFLFFBQVE7QUFDcEIsSUFBSSxHQUFHLEVBQUUsS0FBSztBQUNkLENBQUMsQ0FBQyxDQUFDO0FBR0gsTUFBTSxDQUFDLE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQztBQUN0QyxJQUFJLEtBQUssRUFBRSxPQUFPO0FBQ2xCLElBQUksSUFBSSxFQUFFLE1BQU07QUFDaEIsSUFBSSxPQUFPLEVBQUUsU0FBUztBQUN0QixJQUFJLE9BQU8sRUFBRSxTQUFTO0FBQ3RCLENBQUMsQ0FBQyxDQUFD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U0FBQyxrQ0FBa0MsRUFBRSxFQUFFLElBQUksRUFBRSxrQ0FBa0MsRUFBRTtBQUM3RiwrQkFFQSxZQUFZLFNBQUMsK0JBQStCLEVBQUUsRUFBRSxJQUFJLEVBQUUsK0JBQStCLEVBQUU7QUFDdkYsb0JBeUJBLEtBQUs7QUFDUix5QkEyQkcsU0FBUyxTQUFDLFFBQVEsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7QUFDckM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBc0VOLE1BQU0sVUFBVSxZQUFZLENBQUMsS0FBYSxFQUFFLEdBQVcsRUFBRSxHQUFHLEdBQUcsQ0FBQztBQUFJLElBQ2hFLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUMvQyxDQUFDO0FBRUQsTUFBTSxVQUFVLFNBQVMsQ0FBQyxLQUFhLEVBQUUsR0FBVztBQUNwRCxJQUFJLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFFRDtBQUNBO0FBQ0EsR0FBRztBQWdCSCxNQUFNLE9BQU8sb0JBQW9CO0FBQUc7Z0RBZm5DLFFBQVEsU0FBQyxrQkFDTjtVQUFZLEVBQUUsc0JBQ1YsNkJBQTZCLHNCQUM3QiwrQkFBK0Isc0JBQy9CLGtDQUFrQzthQUNsQywrQkFBK0IsbUJBQ2xDLGtCQUNELE9BQU8sRUFBRSxzQkFDTCw2QkFBNkIsc0JBQzdCLCtCQUErQixzQkFDL0Isa0NBQWtDO29CQUNsQywrQkFBK0IsbUJBQ2xDLGtCQUNELE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQyxjQUMxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFDSTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIElucHV0LFxuICAgIE5nTW9kdWxlLFxuICAgIE91dHB1dCxcbiAgICBSZW5kZXJlcjIsXG4gICAgVmlld0NoaWxkLFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgRGlyZWN0aXZlXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIElneFByb2dyZXNzQmFyR3JhZGllbnREaXJlY3RpdmUsXG59IGZyb20gJy4vcHJvZ3Jlc3NiYXIuY29tbW9uJztcbmltcG9ydCB7IElCYXNlRXZlbnRBcmdzLCBta2VudW0gfSBmcm9tICcuLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IElneERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnLi4vc2VydmljZXMvZGlyZWN0aW9uL2RpcmVjdGlvbmFsaXR5JztcblxuY29uc3QgT05FX1BFUkNFTlQgPSAwLjAxO1xuY29uc3QgTUlOX1ZBTFVFID0gMDtcblxuZXhwb3J0IGNvbnN0IElneFRleHRBbGlnbiA9IG1rZW51bSh7XG4gICAgU1RBUlQ6ICdzdGFydCcsXG4gICAgQ0VOVEVSOiAnY2VudGVyJyxcbiAgICBFTkQ6ICdlbmQnXG59KTtcbmV4cG9ydCB0eXBlIElneFRleHRBbGlnbiA9ICh0eXBlb2YgSWd4VGV4dEFsaWduKVtrZXlvZiB0eXBlb2YgSWd4VGV4dEFsaWduXTtcblxuZXhwb3J0IGNvbnN0IElneFByb2dyZXNzVHlwZSA9IG1rZW51bSh7XG4gICAgRVJST1I6ICdlcnJvcicsXG4gICAgSU5GTzogJ2luZm8nLFxuICAgIFdBUk5JTkc6ICd3YXJuaW5nJyxcbiAgICBTVUNDRVNTOiAnc3VjY2Vzcydcbn0pO1xuZXhwb3J0IHR5cGUgSWd4UHJvZ3Jlc3NUeXBlID0gKHR5cGVvZiBJZ3hQcm9ncmVzc1R5cGUpW2tleW9mIHR5cGVvZiBJZ3hQcm9ncmVzc1R5cGVdO1xuXG5leHBvcnQgaW50ZXJmYWNlIElDaGFuZ2VQcm9ncmVzc0V2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICBwcmV2aW91c1ZhbHVlOiBudW1iZXI7XG4gICAgY3VycmVudFZhbHVlOiBudW1iZXI7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5ARGlyZWN0aXZlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlUHJvZ3Jlc3NEaXJlY3RpdmUge1xuICAgIHByaXZhdGUgcmVxdWVzdEFuaW1hdGlvbklkOiBudW1iZXIgPSB1bmRlZmluZWQ7XG5cbiAgICBwcm90ZWN0ZWQgX2luaXRWYWx1ZSA9IDA7XG4gICAgcHJvdGVjdGVkIF9jb250ZW50SW5pdCA9IGZhbHNlO1xuICAgIHByb3RlY3RlZCBfdmFsdWVJblBlcmNlbnQgPSBNSU5fVkFMVUU7XG4gICAgcHJvdGVjdGVkIF9tYXggPSAxMDA7XG4gICAgcHJvdGVjdGVkIF92YWx1ZSA9IE1JTl9WQUxVRTtcbiAgICBwcm90ZWN0ZWQgX25ld1ZhbCA9IE1JTl9WQUxVRTtcbiAgICBwcm90ZWN0ZWQgX2FuaW1hdGUgPSB0cnVlO1xuICAgIHByb3RlY3RlZCBfc3RlcDtcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50LCB3aGljaCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgYSBwcm9ncmVzcyBpcyBjaGFuZ2VkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgcHJvZ3Jlc3NDaGFuZ2UoZXZlbnQpIHtcbiAgICAgKiAgICAgYWxlcnQoXCJQcm9ncmVzcyBtYWRlIVwiKTtcbiAgICAgKiB9XG4gICAgICogIC8vLi4uXG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIFt2YWx1ZV09XCJjdXJyZW50VmFsdWVcIiAob25Qcm9ncmVzc0NoYW5nZWQpPVwicHJvZ3Jlc3NDaGFuZ2UoJGV2ZW50KVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW3ZhbHVlXT1cImN1cnJlbnRWYWx1ZVwiIChvblByb2dyZXNzQ2hhbmdlZCk9XCJwcm9ncmVzc0NoYW5nZSgkZXZlbnQpXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25Qcm9ncmVzc0NoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPElDaGFuZ2VQcm9ncmVzc0V2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIHdoaWNoIHVwZGF0ZSB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yIG9mIHRoZSBgcHJvZ3Jlc3MgYmFyYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogIEBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICogcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudCB8IElneENpcmN1bGFyQmFyQ29tcG9uZW50O1xuICAgICAqIHB1YmxpYyBzdGVwVmFsdWUoZXZlbnQpIHtcbiAgICAgKiAgICAgbGV0IHN0ZXAgPSB0aGlzLnByb2dyZXNzQmFyLnN0ZXA7XG4gICAgICogICAgIGFsZXJ0KHN0ZXApO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBzdGVwKCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLl9zdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RlcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXggKiBPTkVfUEVSQ0VOVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBieSB3aGljaCBwcm9ncmVzcyBpbmRpY2F0b3IgaXMgdXBkYXRlZC4gQnkgZGVmYXVsdCBpdCBpcyAxJSBvZiB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIiBbc3RlcF09XCIxXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCIgW3N0ZXBdPVwiMVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgc3RlcCh2YWw6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9zdGVwID0gTnVtYmVyKHZhbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0aW5nIHRoZSBwcm9ncmVzcy4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFthbmltYXRlXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIFthbmltYXRlXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IGFuaW1hdGUoYW5pbWF0ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9hbmltYXRlID0gYW5pbWF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGBwcm9ncmVzcyBiYXJgIGhhcyBhbmltYXRpb24gdHJ1ZS9mYWxzZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogIEBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICogcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudCB8IElneENpcmN1bGFyQmFyQ29tcG9uZW50O1xuICAgICAqIHB1YmxpYyBhbmltYXRpb25TdGF0dXMoZXZlbnQpIHtcbiAgICAgKiAgICAgbGV0IGFuaW1hdGlvblN0YXR1cyA9IHRoaXMucHJvZ3Jlc3NCYXIuYW5pbWF0ZTtcbiAgICAgKiAgICAgYWxlcnQoYW5pbWF0aW9uU3RhdHVzKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBhbmltYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgbWF4aW11bSB2YWx1ZSB0aGF0IGNhbiBiZSBwYXNzZWQuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIDEwMC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVtYXgnKVxuICAgIEBJbnB1dCgpXG4gICAgc2V0IG1heChtYXhOdW06IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tYXggPSBtYXhOdW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGhlIG1heGltdW0gcHJvZ3Jlc3MgdmFsdWUgb2YgdGhlIGBwcm9ncmVzcyBiYXJgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAgQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKiBwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50IHwgSWd4Q2lyY3VsYXJCYXJDb21wb25lbnQ7XG4gICAgICogcHVibGljIG1heFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgIGxldCBtYXggPSB0aGlzLnByb2dyZXNzQmFyLm1heDtcbiAgICAgKiAgICAgYWxlcnQobWF4KTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IG1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgL2BJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YCB2YWx1ZSBpbiBwZXJjZW50YWdlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAgQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKiBwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50OyAvLyBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50XG4gICAgICogICAgIHB1YmxpYyBzZXRWYWx1ZShldmVudCl7XG4gICAgICogICAgIHRoaXMucHJvZ3Jlc3NCYXIudmFsdWVJblBlcmNlbnQgPSA1NjtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNldCB2YWx1ZUluUGVyY2VudCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlSW5QZXJjZW50ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YC9gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgdmFsdWUgaW4gcGVyY2VudGFnZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogIEBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICogcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDsgLy8gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudFxuICAgICAqIHB1YmxpYyB2YWx1ZVBlcmNlbnQoZXZlbnQpe1xuICAgICAqICAgICBsZXQgcGVyY2VudFZhbHVlID0gdGhpcy5wcm9ncmVzc0Jhci52YWx1ZUluUGVyY2VudDtcbiAgICAgKiAgICAgYWxlcnQocGVyY2VudFZhbHVlKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB2YWx1ZUluUGVyY2VudCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVJblBlcmNlbnQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHRyaWdnZXJQcm9ncmVzc1RyYW5zaXRpb24ob2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgICAgaWYgKG9sZFZhbCA9PT0gbmV3VmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGFuZ2VkVmFsdWVzID0ge1xuICAgICAgICAgICAgY3VycmVudFZhbHVlOiBuZXdWYWwsXG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiBvbGRWYWxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzdGVwRGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb25GbG93KG9sZFZhbCwgbmV3VmFsKTtcbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGUpIHtcbiAgICAgICAgICAgIHRoaXMucnVuQW5pbWF0aW9uKG5ld1ZhbCwgc3RlcERpcmVjdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzRGlyZWN0bHkobmV3VmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25Qcm9ncmVzc0NoYW5nZWQuZW1pdChjaGFuZ2VkVmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJ1bkFuaW1hdGlvbih2YWw6IG51bWJlciwgc3RlcDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgICAgICAgKCkgPT4gdGhpcy51cGRhdGVQcm9ncmVzc1Ntb290aGx5LmNhbGwodGhpcywgdmFsLCBzdGVwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCB1cGRhdGVQcm9ncmVzc1Ntb290aGx5KHZhbDogbnVtYmVyLCBzdGVwOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZUluUmFuZ2UodGhpcy5fdmFsdWUsIHRoaXMuX21heCkgKyBzdGVwO1xuICAgICAgICBjb25zdCBwYXNzZWRWYWx1ZSA9IHRvUGVyY2VudCh2YWwsIHRoaXMuX21heCk7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzVmFsdWUgPSB0b1BlcmNlbnQodGhpcy5fdmFsdWUsIHRoaXMuX21heCk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlSW5QZXJjZW50ID09PSBwYXNzZWRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzcyh2YWwpO1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXF1ZXN0QW5pbWF0aW9uSWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNJbkxpbWl0UmFuZ2UocHJvZ3Jlc3NWYWx1ZSwgcGFzc2VkVmFsdWUsIHN0ZXApKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKHZhbCk7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlcXVlc3RBbmltYXRpb25JZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlSW5QZXJjZW50ID0gcHJvZ3Jlc3NWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMudXBkYXRlUHJvZ3Jlc3NTbW9vdGhseS5jYWxsKHRoaXMsIHZhbCwgc3RlcCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCB1cGRhdGVQcm9ncmVzc0RpcmVjdGx5KHZhbDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVJblJhbmdlKHZhbCwgdGhpcy5fbWF4KTtcbiAgICAgICAgdGhpcy52YWx1ZUluUGVyY2VudCA9IHRvUGVyY2VudCh0aGlzLl92YWx1ZSwgdGhpcy5fbWF4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpcmVjdGlvbkZsb3coY3VycmVudFZhbHVlOiBudW1iZXIsIHByZXZWYWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA8IHByZXZWYWx1ZSA/IHRoaXMuc3RlcCA6IC10aGlzLnN0ZXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgaXNJbkxpbWl0UmFuZ2UodmFsOiBudW1iZXIsIGNvbXBhcmF0b3I6IG51bWJlciwgc3RlcDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRXhjZWVkaW5nVXBwZXJMaW1pdCh2YWwsIGNvbXBhcmF0b3IsIHN0ZXApIHx8IHRoaXMuaXNFeGNlZWRpbmdMb3dlckxpbWl0KHZhbCwgY29tcGFyYXRvciwgc3RlcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3JcbiAgICAgKiBAcGFyYW0gc3RlcFxuICAgICAqL1xuICAgIHByaXZhdGUgaXNFeGNlZWRpbmdVcHBlckxpbWl0KHZhbDogbnVtYmVyLCBjb21wYXJhdG9yOiBudW1iZXIsIHN0ZXA6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdmFsID4gY29tcGFyYXRvciAmJiBzdGVwID4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3JcbiAgICAgKiBAcGFyYW0gc3RlcFxuICAgICAqL1xuICAgIHByaXZhdGUgaXNFeGNlZWRpbmdMb3dlckxpbWl0KHZhbDogbnVtYmVyLCBjb21wYXJhdG9yOiBudW1iZXIsIHN0ZXA6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdmFsIDwgY29tcGFyYXRvciAmJiBzdGVwIDwgMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQHBhcmFtIHN0ZXBcbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZVByb2dyZXNzKHZhbDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVJblJhbmdlKHZhbCwgdGhpcy5fbWF4KTtcbiAgICAgICAgdGhpcy52YWx1ZUluUGVyY2VudCA9IHRvUGVyY2VudCh0aGlzLl92YWx1ZSwgdGhpcy5fbWF4KTtcbiAgICB9XG59XG5sZXQgTkVYVF9MSU5FQVJfSUQgPSAwO1xubGV0IE5FWFRfQ0lSQ1VMQVJfSUQgPSAwO1xubGV0IE5FWFRfR1JBRElFTlRfSUQgPSAwO1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtbGluZWFyLWJhcicsXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvbGluZWFyLWJhci5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlUHJvZ3Jlc3NEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLXZhbHVlbWluJylcbiAgICBwdWJsaWMgdmFsdWVNaW4gPSAwO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtbGluZWFyLWJhcicpXG4gICAgcHVibGljIGNzc0NsYXNzID0gJ2lneC1saW5lYXItYmFyJztcblxuICAgIC8qKlxuICAgICAqIFNldCBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHRvIGhhdmUgc3RyaXBlZCBzdHlsZS4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciBbc3RyaXBlZF09XCJ0cnVlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWxpbmVhci1iYXItLXN0cmlwZWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHN0cmlwZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldCBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHRvIGhhdmUgaW5kZXRlcm1pbmF0ZS4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciBbaW5kZXRlcm1pbmF0ZV09XCJ0cnVlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1pbmRldGVybWluYXRlJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpbmRldGVybWluYXRlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYHJvbGVgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgdG8gYHByb2dyZXNzYmFyYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIHJvbGU9XCJwcm9ncmVzc2JhclwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHJvbGUgPSAncHJvZ3Jlc3NiYXInO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgYGlkYCBhdHRyaWJ1dGUuIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW2lkXT1cIidpZ3gtbGluZWFyLWJhci01NSdcIiBbc3RyaXBlZF09XCJ0cnVlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWQgPSBgaWd4LWxpbmVhci1iYXItJHtORVhUX0xJTkVBUl9JRCsrfWA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBvc2l0aW9uIHRoYXQgZGVmaW5lcyB3aGVyZSB0aGUgdGV4dCBpcyBhbGlnbmVkLlxuICAgICAqIFBvc3NpYmxlIG9wdGlvbnMgLSBgSWd4VGV4dEFsaWduLlNUQVJUYCAoZGVmYXVsdCksIGBJZ3hUZXh0QWxpZ24uQ0VOVEVSYCwgYElneFRleHRBbGlnbi5FTkRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgcG9zaXRpb25DZW50ZXI6IElneFRleHRBbGlnbjtcbiAgICAgKiBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgICogICAgIHRoaXMucG9zaXRpb25DZW50ZXIgPSBJZ3hUZXh0QWxpZ24uQ0VOVEVSO1xuICAgICAqIH1cbiAgICAgKiAgLy8uLi5cbiAgICAgKiBgYGBcbiAgICAgKiAgYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciB0eXBlPVwid2FybmluZ1wiIFt0ZXh0XT1cIidDdXN0b20gdGV4dCdcIiBbdGV4dEFsaWduXT1cInBvc2l0aW9uQ2VudGVyXCIgW3N0cmlwZWRdPVwidHJ1ZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dEFsaWduOiBJZ3hUZXh0QWxpZ24gPSBJZ3hUZXh0QWxpZ24uU1RBUlQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRleHQgdG8gYmUgdmlzaWJsZS4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogIDxpZ3gtbGluZWFyLWJhciB0eXBlPVwiZGVmYXVsdFwiIFt0ZXh0VmlzaWJpbGl0eV09XCJmYWxzZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dFZpc2liaWxpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwb3NpdGlvbiB0aGF0IGRlZmluZXMgaWYgdGhlIHRleHQgc2hvdWxkIGJlIGFsaWduZWQgYWJvdmUgdGhlIHByb2dyZXNzIGxpbmUuIEJ5IGRlZmF1bHQgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiAgPGlneC1saW5lYXItYmFyIHR5cGU9XCJlcnJvclwiIFt0ZXh0VG9wXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHRUb3AgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGN1c3RvbSB0ZXh0IHRoYXQgaXMgZGlzcGxheWVkIGFjY29yZGluZyB0byB0aGUgZGVmaW5lZCBwb3NpdGlvbi5cbiAgICAgKiAgYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciB0eXBlPVwid2FybmluZ1wiIFt0ZXh0XT1cIidDdXN0b20gdGV4dCdcIiBbdGV4dEFsaWduXT1cInBvc2l0aW9uQ2VudGVyXCIgW3N0cmlwZWRdPVwidHJ1ZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHR5cGUgb2YgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuIFBvc3NpYmxlIG9wdGlvbnMgLSBgZGVmYXVsdGAsIGBzdWNjZXNzYCwgYGluZm9gLCBgd2FybmluZ2AsIGFuZCBgZXJyb3JgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW3N0cmlwZWRdPVwiZmFsc2VcIiBbbWF4XT1cIjEwMFwiIFt2YWx1ZV09XCIwXCIgdHlwZT1cImVycm9yXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0eXBlID0gJ2RlZmF1bHQnO1xuXG4gICAvKipcbiAgICAqIFJldHVybnMgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCBwb3NpdGlvbi5cbiAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAqICBAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICogcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAqIHB1YmxpYyBnZXRWYWx1ZShldmVudCkge1xuICAgICogICAgIGxldCB2YWx1ZSA9IHRoaXMucHJvZ3Jlc3NCYXIudmFsdWU7XG4gICAgKiAgICAgYWxlcnQodmFsdWUpO1xuICAgICogfVxuICAgICogYGBgXG4gICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW5vdycpXG4gICAgQElucHV0KClcbiAgICBnZXQgdmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgY3VycmVudCBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHBvc2l0aW9uLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW3N0cmlwZWRdPVwiZmFsc2VcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbCkge1xuICAgICAgICBjb25zdCB2YWxJblJhbmdlID0gdmFsdWVJblJhbmdlKHZhbCwgdGhpcy5tYXgpO1xuICAgICAgICBpZiAoaXNOYU4odmFsSW5SYW5nZSkgfHwgdGhpcy5fdmFsdWUgPT09IHZhbCB8fCB0aGlzLmluZGV0ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50SW5pdCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyUHJvZ3Jlc3NUcmFuc2l0aW9uKHRoaXMuX3ZhbHVlLCB2YWxJblJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRWYWx1ZSA9IHZhbEluUmFuZ2U7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1kYW5nZXInKVxuICAgIHB1YmxpYyBnZXQgZXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneFByb2dyZXNzVHlwZS5FUlJPUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtbGluZWFyLWJhci0taW5mbycpXG4gICAgcHVibGljIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBJZ3hQcm9ncmVzc1R5cGUuSU5GTztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtbGluZWFyLWJhci0td2FybmluZycpXG4gICAgcHVibGljIGdldCB3YXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBJZ3hQcm9ncmVzc1R5cGUuV0FSTklORztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtbGluZWFyLWJhci0tc3VjY2VzcycpXG4gICAgcHVibGljIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBJZ3hQcm9ncmVzc1R5cGUuU1VDQ0VTUztcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJQcm9ncmVzc1RyYW5zaXRpb24oTUlOX1ZBTFVFLCB0aGlzLl9pbml0VmFsdWUpO1xuICAgICAgICB0aGlzLl9jb250ZW50SW5pdCA9IHRydWU7XG4gICAgfVxufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1jaXJjdWxhci1iYXInLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGVzL2NpcmN1bGFyLWJhci5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCBleHRlbmRzIEJhc2VQcm9ncmVzc0RpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIEFmdGVyQ29udGVudEluaXQge1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBTVFJPS0VfT1BBQ0lUWV9EVklERVIgPSAxMDA7XG4gICAgcHJpdmF0ZSByZWFkb25seSBTVFJPS0VfT1BBQ0lUWV9BRERJVElPTiA9IC4yO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jaXJjdWxhci1iYXInKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtY2lyY3VsYXItYmFyJztcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIGBpZGAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jaXJjdWxhci1iYXIgW2lkXT1cIidpZ3gtY2lyY3VsYXItYmFyLTU1J1wiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1jaXJjdWxhci1iYXItJHtORVhUX0NJUkNVTEFSX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ3JhZGllbnRJZCA9IGBpZ3gtY2lyY3VsYXItZ3JhZGllbnQtJHtORVhUX0dSQURJRU5UX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaW5kZXRlcm1pbmF0ZWAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byBmYWxzZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jaXJjdWxhci1iYXIgW2luZGV0ZXJtaW5hdGVdPVwidHJ1ZVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jaXJjdWxhci1iYXItLWluZGV0ZXJtaW5hdGUnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRleHQgdmlzaWJpbGl0eS4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jaXJjdWxhci1iYXIgW3RleHRWaXNpYmlsaXR5XT1cImZhbHNlXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHRWaXNpYmlsaXR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgdGV4dCB0byBiZSBkaXNwbGF5ZWQgaW5zaWRlIHRoZSBgaWd4Q2lyY3VsYXJCYXJgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciB0ZXh0PVwiUHJvZ3Jlc3NcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCB0ZXh0ID0gdGhpcy5jaXJjdWxhckJhci50ZXh0O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHQ6IHN0cmluZztcblxuICAgIEBDb250ZW50Q2hpbGQoSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlIH0pXG4gICAgcHVibGljIHRleHRUZW1wbGF0ZTogSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZTtcblxuICAgIEBDb250ZW50Q2hpbGQoSWd4UHJvZ3Jlc3NCYXJHcmFkaWVudERpcmVjdGl2ZSwgeyByZWFkOiBJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlIH0pXG4gICAgcHVibGljIGdyYWRpZW50VGVtcGxhdGU6IElneFByb2dyZXNzQmFyR3JhZGllbnREaXJlY3RpdmU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBjb250ZXh0KCk6IGFueSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAkaW1wbGljaXQ6IHsgdmFsdWU6IHRoaXMudmFsdWUsIHZhbHVlSW5QZXJjZW50OiB0aGlzLnZhbHVlSW5QZXJjZW50LCBtYXg6IHRoaXMubWF4IH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YCBwb3NpdGlvbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogIEBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICogcHVibGljIHByb2dyZXNzQmFyOiBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICAqIHB1YmxpYyBnZXRWYWx1ZShldmVudCkge1xuICAgICAqICAgICBsZXQgdmFsdWUgPSB0aGlzLnByb2dyZXNzQmFyLnZhbHVlO1xuICAgICAqICAgICBhbGVydCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8YnV0dG9uIGlneEJ1dHRvbj1cImZhYlwiIGlneFJpcHBsZT1cIlwiIChjbGljayk9XCJnZXRWYWx1ZSgpXCI+Q2xpY2s8L2J1dHRvbj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCB2YWx1ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YCBwb3NpdGlvbi5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jaXJjdWxhci1iYXIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWw6IG51bWJlcikge1xuICAgICAgICBjb25zdCB2YWxJblJhbmdlID0gdmFsdWVJblJhbmdlKHZhbCwgdGhpcy5tYXgpO1xuICAgICAgICBpZiAoaXNOYU4odmFsSW5SYW5nZSkgfHwgdGhpcy5fdmFsdWUgPT09IHZhbCB8fCB0aGlzLmluZGV0ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50SW5pdCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyUHJvZ3Jlc3NUcmFuc2l0aW9uKHRoaXMuX3ZhbHVlLCB2YWxJblJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRWYWx1ZSA9IHZhbEluUmFuZ2U7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByaXZhdGUgX2NpcmNsZVJhZGl1cyA9IDQ2O1xuICAgIHByaXZhdGUgX2NpcmN1bWZlcmVuY2UgPSAyICogTWF0aC5QSSAqIHRoaXMuX2NpcmNsZVJhZGl1cztcblxuICAgIEBWaWV3Q2hpbGQoJ2NpcmNsZScsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJpdmF0ZSBfc3ZnQ2lyY2xlOiBFbGVtZW50UmVmO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIF9kaXJlY3Rpb25hbGl0eTogSWd4RGlyZWN0aW9uYWxpdHkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJQcm9ncmVzc1RyYW5zaXRpb24oTUlOX1ZBTFVFLCB0aGlzLl9pbml0VmFsdWUpO1xuICAgICAgICB0aGlzLl9jb250ZW50SW5pdCA9IHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShcbiAgICAgICAgICAgIHRoaXMuX3N2Z0NpcmNsZS5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgJ3N0cm9rZScsXG4gICAgICAgICAgICBgdXJsKCMke3RoaXMuZ3JhZGllbnRJZH0pYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgdXBkYXRlUHJvZ3Jlc3NTbW9vdGhseSh2YWw6IG51bWJlciwgc3RlcDogbnVtYmVyKSB7XG4gICAgICAgIC8vIFNldCBmcmFtZXMgZm9yIHRoZSBhbmltYXRpb25cbiAgICAgICAgY29uc3QgRlJBTUVTID0gW3tcbiAgICAgICAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IHRoaXMuZ2V0UHJvZ3Jlc3ModGhpcy5fdmFsdWUpLFxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogKHRoaXMuX3ZhbHVlIC8gdGhpcy5TVFJPS0VfT1BBQ0lUWV9EVklERVIpICsgdGhpcy5TVFJPS0VfT1BBQ0lUWV9BRERJVElPTlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBzdHJva2VEYXNob2Zmc2V0OiB0aGlzLmdldFByb2dyZXNzKHRoaXMudmFsdWVJblBlcmNlbnQpLFxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogKHRoaXMudmFsdWVJblBlcmNlbnQgLyB0aGlzLlNUUk9LRV9PUEFDSVRZX0RWSURFUikgKyB0aGlzLlNUUk9LRV9PUEFDSVRZX0FERElUSU9OXG4gICAgICAgIH1dO1xuICAgICAgICB0aGlzLl9zdmdDaXJjbGUubmF0aXZlRWxlbWVudC5hbmltYXRlKEZSQU1FUywge1xuICAgICAgICAgICAgZWFzaW5nOiAnZWFzZS1vdXQnLFxuICAgICAgICAgICAgZmlsbDogJ2ZvcndhcmRzJ1xuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci51cGRhdGVQcm9ncmVzc1Ntb290aGx5KHZhbCwgc3RlcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdGV4dENvbnRlbnQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZVByb2dyZXNzRGlyZWN0bHkodmFsOiBudW1iZXIpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlUHJvZ3Jlc3NEaXJlY3RseSh2YWwpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoXG4gICAgICAgICAgICB0aGlzLl9zdmdDaXJjbGUubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgICdzdHJva2UtZGFzaG9mZnNldCcsXG4gICAgICAgICAgICB0aGlzLmdldFByb2dyZXNzKHRoaXMudmFsdWVJblBlcmNlbnQpKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgICAgICAgdGhpcy5fc3ZnQ2lyY2xlLm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknLFxuICAgICAgICAgICAgKHRoaXMudmFsdWVJblBlcmNlbnQgLyB0aGlzLlNUUk9LRV9PUEFDSVRZX0RWSURFUikgKyB0aGlzLlNUUk9LRV9PUEFDSVRZX0FERElUSU9OKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFByb2dyZXNzKHBlcmNlbnRhZ2U6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uYWxpdHkucnRsID9cbiAgICAgICAgICAgIHRoaXMuX2NpcmN1bWZlcmVuY2UgKyAocGVyY2VudGFnZSAqIHRoaXMuX2NpcmN1bWZlcmVuY2UgLyAxMDApIDpcbiAgICAgICAgICAgIHRoaXMuX2NpcmN1bWZlcmVuY2UgLSAocGVyY2VudGFnZSAqIHRoaXMuX2NpcmN1bWZlcmVuY2UgLyAxMDApO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlSW5SYW5nZSh2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlciwgbWluID0gMCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHZhbHVlLCBtYXgpLCBtaW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9QZXJjZW50KHZhbHVlOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoMTAwICogdmFsdWUgLyBtYXgpO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQsXG4gICAgICAgIElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQsXG4gICAgICAgIElneFByb2Nlc3NCYXJUZXh0VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgIElneFByb2dyZXNzQmFyR3JhZGllbnREaXJlY3RpdmUsXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50LFxuICAgICAgICBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50LFxuICAgICAgICBJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlLFxuICAgIF0sXG4gICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4UHJvZ3Jlc3NCYXJNb2R1bGUgeyB9XG4iXX0=