import { Directive, HostBinding, NgModule, Input } from '@angular/core';
import { mkenum } from '../../core/utils';
import * as ɵngcc0 from '@angular/core';
export const IgxDividerType = mkenum({
    SOLID: 'solid',
    DASHED: 'dashed'
});
let NEXT_ID = 0;
export class IgxDividerDirective {
    constructor() {
        /**
         * Sets/gets the `id` of the divider.
         * If not set, `id` will have value `"igx-divider-0"`;
         * ```html
         * <igx-divider id="my-divider"></igx-divider>
         * ```
         * ```typescript
         * let dividerId =  this.divider.id;
         * ```
         */
        this.id = `igx-divider-${NEXT_ID++}`;
        /**
         * An @Input property that sets the value of the `inset` attribute.
         * If not provided it will be set to `'0'`.
         * ```html
         * <igx-divider inset="16px"></igx-divider>
         * ```
         */
        this._inset = '0';
        /**
         * An @Input property that sets the value of `role` attribute.
         * If not the default value of `separator` will be used.
         */
        this.role = 'separator';
        /**
         * Sets the type of the divider. The default value
         * is `default`. The divider can also be `dashed`;
         * ```html
         * <igx-divider type="dashed"></igx-divider>
         * ```
         */
        this.type = IgxDividerType.SOLID;
        /**
         * An @Input that sets the `middle` attribute of the divider.
         * If set to `true` and an `inset` value has been provided,
         * the divider will start shrinking from both ends.
         * ```html
         * <igx-divider [middle]="true"></igx-divider>
         * ```
         */
        this.middle = false;
        /**
         * An @Input that sets the vertical attribute of the divider.
         * ```html
         * <igx-divider [vertical]="true"></igx-divider>
         * ```
         */
        this.vertical = false;
    }
    get isDashed() {
        return this.type === IgxDividerType.DASHED;
    }
    /**
     * A getter that returns `true` if the type of the divider is `default`;
     * ```typescript
     * const isDefault = this.divider.isDefault;
     * ```
     */
    get isSolid() {
        return this.type === IgxDividerType.SOLID;
    }
    /**
     * Sets the inset of the divider from the side(s).
     * If the divider attribute `middle` is set to `true`,
     * it will inset the divider on both sides.
     * ```typescript
     * this.divider.inset = '32px';
     * ```
     */
    set inset(value) {
        this._inset = value;
    }
    /**
     * Gets the current divider inset in terms of
     * margin representation as applied to the divider.
     * ```typescript
     * const inset = this.divider.inset;
     * ```
     */
    get inset() {
        const baseMargin = '0';
        if (this.middle) {
            if (this.vertical) {
                return `${this._inset} ${baseMargin}`;
            }
            return `${baseMargin} ${this._inset}`;
        }
        else {
            if (this.vertical) {
                return `${this._inset} ${baseMargin} 0 ${baseMargin}`;
            }
            return `${baseMargin} 0 ${baseMargin} ${this._inset}`;
        }
    }
}
IgxDividerDirective.ɵfac = function IgxDividerDirective_Factory(t) { return new (t || IgxDividerDirective)(); };
IgxDividerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDividerDirective, selectors: [["igx-divider"]], hostVars: 12, hostBindings: function IgxDividerDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role);
        ɵngcc0.ɵɵstyleProp("margin", ctx.inset);
        ɵngcc0.ɵɵclassProp("igx-divider", ctx.type)("igx-divider--inset", ctx.middle)("igx-divider--vertical", ctx.vertical)("igx-divider--dashed", ctx.isDashed);
    } }, inputs: { id: "id", _inset: ["inset", "_inset"], role: "role", type: "type", middle: "middle", vertical: "vertical" } });
IgxDividerDirective.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    _inset: [{ type: Input, args: ['inset',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    type: [{ type: HostBinding, args: ['class.igx-divider',] }, { type: Input }],
    isDashed: [{ type: HostBinding, args: ['class.igx-divider--dashed',] }],
    middle: [{ type: HostBinding, args: ['class.igx-divider--inset',] }, { type: Input }],
    vertical: [{ type: HostBinding, args: ['class.igx-divider--vertical',] }, { type: Input }],
    inset: [{ type: HostBinding, args: ['style.margin',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDividerDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-divider'
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], _inset: [{
            type: Input,
            args: ['inset']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }], type: [{
            type: HostBinding,
            args: ['class.igx-divider']
        }, {
            type: Input
        }], middle: [{
            type: HostBinding,
            args: ['class.igx-divider--inset']
        }, {
            type: Input
        }], vertical: [{
            type: HostBinding,
            args: ['class.igx-divider--vertical']
        }, {
            type: Input
        }], isDashed: [{
            type: HostBinding,
            args: ['class.igx-divider--dashed']
        }], inset: [{
            type: HostBinding,
            args: ['style.margin']
        }] }); })();
export class IgxDividerModule {
}
IgxDividerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDividerModule });
IgxDividerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDividerModule_Factory(t) { return new (t || IgxDividerModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDividerModule, { declarations: [IgxDividerDirective], exports: [IgxDividerDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDividerModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxDividerDirective],
                exports: [IgxDividerDirective]
            }]
    }], null, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGl2aWRlci5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9kaXJlY3RpdmVzL2RpdmlkZXIvZGl2aWRlci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4RSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7O0FBRTFDLE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUM7QUFDckMsSUFBSSxLQUFLLEVBQUUsT0FBTztBQUNsQixJQUFJLE1BQU0sRUFBRSxRQUFRO0FBQ3BCLENBQUMsQ0FBQyxDQUFDO0FBR0gsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBTWhCLE1BQU0sT0FBTyxtQkFBbUI7QUFDaEMsSUFMQTtBQUNHLFFBSUM7QUFDSjtBQUNJO0FBQ0k7QUFDSTtBQUVQO0FBQWU7QUFDSTtBQUdmO0FBQWUsV0FEakI7QUFDUCxRQUVXLE9BQUUsR0FBRyxlQUFlLE9BQU8sRUFBRSxFQUFFLENBQUM7QUFDM0MsUUFFSTtBQUNKO0FBQ0k7QUFDSTtBQUNJO0FBRVA7QUFDTyxXQURMO0FBQ1AsUUFDWSxXQUFNLEdBQUcsR0FBRyxDQUFDO0FBQ3pCLFFBQ0k7QUFDSjtBQUNJO0FBRUosV0FETztBQUNQLFFBRVcsU0FBSSxHQUFHLFdBQVcsQ0FBQztBQUM5QixRQUNJO0FBQ0o7QUFDSTtBQUNJO0FBQ0k7QUFFUDtBQUNPLFdBREw7QUFDUCxRQUVXLFNBQUksR0FBNEIsY0FBYyxDQUFDLEtBQUssQ0FBQztBQUNoRSxRQU1JO0FBQ0o7QUFDSTtBQUNJO0FBQ0k7QUFDSTtBQUdmO0FBQWUsV0FEVDtBQUNQLFFBRVcsV0FBTSxHQUFHLEtBQUssQ0FBQztBQUMxQixRQVdJO0FBQ0o7QUFDSTtBQUNJO0FBRVA7QUFDTyxXQUREO0FBQ1AsUUFFVyxhQUFRLEdBQUcsS0FBSyxDQUFDO0FBQzVCLElBb0NBLENBQUM7QUFDRCxJQXpFSSxJQUNJLFFBQVE7QUFDaEIsUUFBUSxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssY0FBYyxDQUFDLE1BQU0sQ0FBQztBQUNuRCxJQUFJLENBQUM7QUFDTCxJQWFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsSUFBSSxJQUFJLE9BQU87QUFDZixRQUFRLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxjQUFjLENBQUMsS0FBSyxDQUFDO0FBQ2xELElBQUksQ0FBQztBQUNMLElBV0k7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsSUFBSSxJQUNJLEtBQUssQ0FBQyxLQUFhO0FBQzNCLFFBQVEsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7QUFDNUIsSUFBSSxDQUFDO0FBQ0wsSUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsSUFBSSxJQUFJLEtBQUs7QUFDYixRQUFRLE1BQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQztBQUMvQixRQUNRLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUN6QixZQUFZLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtBQUMvQixnQkFBZ0IsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLElBQUksVUFBVSxFQUFFLENBQUM7QUFDdEQsYUFBYTtBQUNiLFlBQVksT0FBTyxHQUFHLFVBQVUsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDbEQsU0FBUztBQUFDLGFBQUs7QUFDZixZQUFZLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtBQUMvQixnQkFBZ0IsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLElBQUksVUFBVSxNQUFNLFVBQVUsRUFBRSxDQUFDO0FBQ3RFLGFBQWE7QUFDYixZQUFZLE9BQU8sR0FBRyxVQUFVLE1BQU0sVUFBVSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUNsRSxTQUFTO0FBQ1QsSUFBSSxDQUFDO0FBQ0w7K0NBekhDLFNBQVMsU0FBQyxrQkFDUDtnQkFBOEMsaUJBQzlDLFFBQVEsRUFBRSxhQUFhLGNBQzFCOzs7O2tJQUNJO0FBQUM7QUFFSixpQkFTRyxXQUFXLFNBQUMsU0FBUyxjQUNyQixLQUFLO0FBQ1IscUJBVUcsS0FBSyxTQUFDLE9BQU87QUFDYixtQkFNQSxXQUFXLFNBQUMsV0FBVyxjQUN2QixLQUFLO0FBQ1IsbUJBU0csV0FBVyxTQUFDLG1CQUFtQixjQUMvQixLQUFLO0FBQ1IsdUJBRUcsV0FBVyxTQUFDLDJCQUEyQjtBQUN2QyxxQkFZQSxXQUFXLFNBQUMsMEJBQTBCLGNBQ3RDLEtBQUs7QUFDUix1QkFrQkcsV0FBVyxTQUFDLDZCQUE2QixjQUN6QyxLQUFLO0FBQ1Isb0JBVUcsV0FBVyxTQUFDLGNBQWM7QUFDM0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBZ0NOLE1BQU0sT0FBTyxnQkFBZ0I7QUFBRzs0Q0FKL0IsUUFBUSxTQUFDO0VBQ04sWUFBWSxFQUFFLENBQUMsbUJBQW1CLENBQUMsa0JBQ25DLE9BQU8sRUFBRSxDQUFDLG1CQUFtQixDQUFDLGNBQ2pDOzs7Ozs7OzswQkFDSTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0QmluZGluZywgTmdNb2R1bGUsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBta2VudW0gfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IElneERpdmlkZXJUeXBlID0gbWtlbnVtKHtcbiAgICBTT0xJRDogJ3NvbGlkJyxcbiAgICBEQVNIRUQ6ICdkYXNoZWQnXG59KTtcbmV4cG9ydCB0eXBlIElneERpdmlkZXJUeXBlID0gKHR5cGVvZiBJZ3hEaXZpZGVyVHlwZSlba2V5b2YgdHlwZW9mIElneERpdmlkZXJUeXBlXTtcblxubGV0IE5FWFRfSUQgPSAwO1xuXG5ARGlyZWN0aXZlKHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZGlyZWN0aXZlLXNlbGVjdG9yXG4gICAgc2VsZWN0b3I6ICdpZ3gtZGl2aWRlcidcbn0pXG5leHBvcnQgY2xhc3MgSWd4RGl2aWRlckRpcmVjdGl2ZSB7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBgaWRgIG9mIHRoZSBkaXZpZGVyLlxuICAgICAqIElmIG5vdCBzZXQsIGBpZGAgd2lsbCBoYXZlIHZhbHVlIGBcImlneC1kaXZpZGVyLTBcImA7XG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZGl2aWRlciBpZD1cIm15LWRpdmlkZXJcIj48L2lneC1kaXZpZGVyPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZGl2aWRlcklkID0gIHRoaXMuZGl2aWRlci5pZDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1kaXZpZGVyLSR7TkVYVF9JRCsrfWA7XG5cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaW5zZXRgIGF0dHJpYnV0ZS5cbiAgICAgKiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBzZXQgdG8gYCcwJ2AuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZGl2aWRlciBpbnNldD1cIjE2cHhcIj48L2lneC1kaXZpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgnaW5zZXQnKVxuICAgIHByaXZhdGUgX2luc2V0ID0gJzAnO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgYHJvbGVgIGF0dHJpYnV0ZS5cbiAgICAgKiBJZiBub3QgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYHNlcGFyYXRvcmAgd2lsbCBiZSB1c2VkLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByb2xlID0gJ3NlcGFyYXRvcic7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0eXBlIG9mIHRoZSBkaXZpZGVyLiBUaGUgZGVmYXVsdCB2YWx1ZVxuICAgICAqIGlzIGBkZWZhdWx0YC4gVGhlIGRpdmlkZXIgY2FuIGFsc28gYmUgYGRhc2hlZGA7XG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZGl2aWRlciB0eXBlPVwiZGFzaGVkXCI+PC9pZ3gtZGl2aWRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kaXZpZGVyJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0eXBlOiBJZ3hEaXZpZGVyVHlwZSB8IHN0cmluZyA9IElneERpdmlkZXJUeXBlLlNPTElEO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZGl2aWRlci0tZGFzaGVkJylcbiAgICBnZXQgaXNEYXNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneERpdmlkZXJUeXBlLkRBU0hFRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgdGhhdCBzZXRzIHRoZSBgbWlkZGxlYCBhdHRyaWJ1dGUgb2YgdGhlIGRpdmlkZXIuXG4gICAgICogSWYgc2V0IHRvIGB0cnVlYCBhbmQgYW4gYGluc2V0YCB2YWx1ZSBoYXMgYmVlbiBwcm92aWRlZCxcbiAgICAgKiB0aGUgZGl2aWRlciB3aWxsIHN0YXJ0IHNocmlua2luZyBmcm9tIGJvdGggZW5kcy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kaXZpZGVyIFttaWRkbGVdPVwidHJ1ZVwiPjwvaWd4LWRpdmlkZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZGl2aWRlci0taW5zZXQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIG1pZGRsZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQSBnZXR0ZXIgdGhhdCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHlwZSBvZiB0aGUgZGl2aWRlciBpcyBgZGVmYXVsdGA7XG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGlzRGVmYXVsdCA9IHRoaXMuZGl2aWRlci5pc0RlZmF1bHQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGlzU29saWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneERpdmlkZXJUeXBlLlNPTElEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCB0aGF0IHNldHMgdGhlIHZlcnRpY2FsIGF0dHJpYnV0ZSBvZiB0aGUgZGl2aWRlci5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kaXZpZGVyIFt2ZXJ0aWNhbF09XCJ0cnVlXCI+PC9pZ3gtZGl2aWRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kaXZpZGVyLS12ZXJ0aWNhbCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdmVydGljYWwgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluc2V0IG9mIHRoZSBkaXZpZGVyIGZyb20gdGhlIHNpZGUocykuXG4gICAgICogSWYgdGhlIGRpdmlkZXIgYXR0cmlidXRlIGBtaWRkbGVgIGlzIHNldCB0byBgdHJ1ZWAsXG4gICAgICogaXQgd2lsbCBpbnNldCB0aGUgZGl2aWRlciBvbiBib3RoIHNpZGVzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmRpdmlkZXIuaW5zZXQgPSAnMzJweCc7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5tYXJnaW4nKVxuICAgIHNldCBpbnNldCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2luc2V0ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBkaXZpZGVyIGluc2V0IGluIHRlcm1zIG9mXG4gICAgICogbWFyZ2luIHJlcHJlc2VudGF0aW9uIGFzIGFwcGxpZWQgdG8gdGhlIGRpdmlkZXIuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGluc2V0ID0gdGhpcy5kaXZpZGVyLmluc2V0O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBpbnNldCgpIHtcbiAgICAgICAgY29uc3QgYmFzZU1hcmdpbiA9ICcwJztcblxuICAgICAgICBpZiAodGhpcy5taWRkbGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuX2luc2V0fSAke2Jhc2VNYXJnaW59YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgJHtiYXNlTWFyZ2lufSAke3RoaXMuX2luc2V0fWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLl9pbnNldH0gJHtiYXNlTWFyZ2lufSAwICR7YmFzZU1hcmdpbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VNYXJnaW59IDAgJHtiYXNlTWFyZ2lufSAke3RoaXMuX2luc2V0fWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbSWd4RGl2aWRlckRpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW0lneERpdmlkZXJEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIElneERpdmlkZXJNb2R1bGUgeyB9XG4iXX0=