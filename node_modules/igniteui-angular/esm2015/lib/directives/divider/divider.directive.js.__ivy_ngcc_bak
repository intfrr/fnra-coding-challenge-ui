import { Directive, HostBinding, NgModule, Input } from '@angular/core';
import { mkenum } from '../../core/utils';
export const IgxDividerType = mkenum({
    SOLID: 'solid',
    DASHED: 'dashed'
});
let NEXT_ID = 0;
export class IgxDividerDirective {
    constructor() {
        /**
         * Sets/gets the `id` of the divider.
         * If not set, `id` will have value `"igx-divider-0"`;
         * ```html
         * <igx-divider id="my-divider"></igx-divider>
         * ```
         * ```typescript
         * let dividerId =  this.divider.id;
         * ```
         */
        this.id = `igx-divider-${NEXT_ID++}`;
        /**
         * An @Input property that sets the value of the `inset` attribute.
         * If not provided it will be set to `'0'`.
         * ```html
         * <igx-divider inset="16px"></igx-divider>
         * ```
         */
        this._inset = '0';
        /**
         * An @Input property that sets the value of `role` attribute.
         * If not the default value of `separator` will be used.
         */
        this.role = 'separator';
        /**
         * Sets the type of the divider. The default value
         * is `default`. The divider can also be `dashed`;
         * ```html
         * <igx-divider type="dashed"></igx-divider>
         * ```
         */
        this.type = IgxDividerType.SOLID;
        /**
         * An @Input that sets the `middle` attribute of the divider.
         * If set to `true` and an `inset` value has been provided,
         * the divider will start shrinking from both ends.
         * ```html
         * <igx-divider [middle]="true"></igx-divider>
         * ```
         */
        this.middle = false;
        /**
         * An @Input that sets the vertical attribute of the divider.
         * ```html
         * <igx-divider [vertical]="true"></igx-divider>
         * ```
         */
        this.vertical = false;
    }
    get isDashed() {
        return this.type === IgxDividerType.DASHED;
    }
    /**
     * A getter that returns `true` if the type of the divider is `default`;
     * ```typescript
     * const isDefault = this.divider.isDefault;
     * ```
     */
    get isSolid() {
        return this.type === IgxDividerType.SOLID;
    }
    /**
     * Sets the inset of the divider from the side(s).
     * If the divider attribute `middle` is set to `true`,
     * it will inset the divider on both sides.
     * ```typescript
     * this.divider.inset = '32px';
     * ```
     */
    set inset(value) {
        this._inset = value;
    }
    /**
     * Gets the current divider inset in terms of
     * margin representation as applied to the divider.
     * ```typescript
     * const inset = this.divider.inset;
     * ```
     */
    get inset() {
        const baseMargin = '0';
        if (this.middle) {
            if (this.vertical) {
                return `${this._inset} ${baseMargin}`;
            }
            return `${baseMargin} ${this._inset}`;
        }
        else {
            if (this.vertical) {
                return `${this._inset} ${baseMargin} 0 ${baseMargin}`;
            }
            return `${baseMargin} 0 ${baseMargin} ${this._inset}`;
        }
    }
}
IgxDividerDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-divider'
            },] }
];
IgxDividerDirective.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    _inset: [{ type: Input, args: ['inset',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    type: [{ type: HostBinding, args: ['class.igx-divider',] }, { type: Input }],
    isDashed: [{ type: HostBinding, args: ['class.igx-divider--dashed',] }],
    middle: [{ type: HostBinding, args: ['class.igx-divider--inset',] }, { type: Input }],
    vertical: [{ type: HostBinding, args: ['class.igx-divider--vertical',] }, { type: Input }],
    inset: [{ type: HostBinding, args: ['style.margin',] }]
};
export class IgxDividerModule {
}
IgxDividerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxDividerDirective],
                exports: [IgxDividerDirective]
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGl2aWRlci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZGlyZWN0aXZlcy9kaXZpZGVyL2RpdmlkZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRTFDLE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUM7SUFDakMsS0FBSyxFQUFFLE9BQU87SUFDZCxNQUFNLEVBQUUsUUFBUTtDQUNuQixDQUFDLENBQUM7QUFHSCxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7QUFNaEIsTUFBTSxPQUFPLG1CQUFtQjtJQUpoQztRQUtJOzs7Ozs7Ozs7V0FTRztRQUdJLE9BQUUsR0FBRyxlQUFlLE9BQU8sRUFBRSxFQUFFLENBQUM7UUFHdkM7Ozs7OztXQU1HO1FBRUssV0FBTSxHQUFHLEdBQUcsQ0FBQztRQUVyQjs7O1dBR0c7UUFHSSxTQUFJLEdBQUcsV0FBVyxDQUFDO1FBRTFCOzs7Ozs7V0FNRztRQUdJLFNBQUksR0FBNEIsY0FBYyxDQUFDLEtBQUssQ0FBQztRQU81RDs7Ozs7OztXQU9HO1FBR0ksV0FBTSxHQUFHLEtBQUssQ0FBQztRQVl0Qjs7Ozs7V0FLRztRQUdJLGFBQVEsR0FBRyxLQUFLLENBQUM7SUFxQzVCLENBQUM7SUF4RUcsSUFDSSxRQUFRO1FBQ1IsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLGNBQWMsQ0FBQyxNQUFNLENBQUM7SUFDL0MsQ0FBQztJQWNEOzs7OztPQUtHO0lBQ0gsSUFBSSxPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDOUMsQ0FBQztJQVlEOzs7Ozs7O09BT0c7SUFDSCxJQUNJLEtBQUssQ0FBQyxLQUFhO1FBQ25CLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxJQUFJLEtBQUs7UUFDTCxNQUFNLFVBQVUsR0FBRyxHQUFHLENBQUM7UUFFdkIsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2IsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNmLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxJQUFJLFVBQVUsRUFBRSxDQUFDO2FBQ3pDO1lBQ0QsT0FBTyxHQUFHLFVBQVUsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDekM7YUFBTTtZQUNILElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDZixPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxVQUFVLE1BQU0sVUFBVSxFQUFFLENBQUM7YUFDekQ7WUFDRCxPQUFPLEdBQUcsVUFBVSxNQUFNLFVBQVUsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDekQ7SUFDTCxDQUFDOzs7WUF4SEosU0FBUyxTQUFDO2dCQUNQLDhDQUE4QztnQkFDOUMsUUFBUSxFQUFFLGFBQWE7YUFDMUI7OztpQkFZSSxXQUFXLFNBQUMsU0FBUyxjQUNyQixLQUFLO3FCQVdMLEtBQUssU0FBQyxPQUFPO21CQU9iLFdBQVcsU0FBQyxXQUFXLGNBQ3ZCLEtBQUs7bUJBVUwsV0FBVyxTQUFDLG1CQUFtQixjQUMvQixLQUFLO3VCQUdMLFdBQVcsU0FBQywyQkFBMkI7cUJBYXZDLFdBQVcsU0FBQywwQkFBMEIsY0FDdEMsS0FBSzt1QkFtQkwsV0FBVyxTQUFDLDZCQUE2QixjQUN6QyxLQUFLO29CQVdMLFdBQVcsU0FBQyxjQUFjOztBQWlDL0IsTUFBTSxPQUFPLGdCQUFnQjs7O1lBSjVCLFFBQVEsU0FBQztnQkFDTixZQUFZLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQztnQkFDbkMsT0FBTyxFQUFFLENBQUMsbUJBQW1CLENBQUM7YUFDakMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RCaW5kaW5nLCBOZ01vZHVsZSwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG1rZW51bSB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgSWd4RGl2aWRlclR5cGUgPSBta2VudW0oe1xuICAgIFNPTElEOiAnc29saWQnLFxuICAgIERBU0hFRDogJ2Rhc2hlZCdcbn0pO1xuZXhwb3J0IHR5cGUgSWd4RGl2aWRlclR5cGUgPSAodHlwZW9mIElneERpdmlkZXJUeXBlKVtrZXlvZiB0eXBlb2YgSWd4RGl2aWRlclR5cGVdO1xuXG5sZXQgTkVYVF9JRCA9IDA7XG5cbkBEaXJlY3RpdmUoe1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkaXJlY3RpdmUtc2VsZWN0b3JcbiAgICBzZWxlY3RvcjogJ2lneC1kaXZpZGVyJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hEaXZpZGVyRGlyZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGBpZGAgb2YgdGhlIGRpdmlkZXIuXG4gICAgICogSWYgbm90IHNldCwgYGlkYCB3aWxsIGhhdmUgdmFsdWUgYFwiaWd4LWRpdmlkZXItMFwiYDtcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kaXZpZGVyIGlkPVwibXktZGl2aWRlclwiPjwvaWd4LWRpdmlkZXI+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBkaXZpZGVySWQgPSAgdGhpcy5kaXZpZGVyLmlkO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWQgPSBgaWd4LWRpdmlkZXItJHtORVhUX0lEKyt9YDtcblxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBpbnNldGAgYXR0cmlidXRlLlxuICAgICAqIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIHNldCB0byBgJzAnYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kaXZpZGVyIGluc2V0PVwiMTZweFwiPjwvaWd4LWRpdmlkZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCdpbnNldCcpXG4gICAgcHJpdmF0ZSBfaW5zZXQgPSAnMCc7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiBgcm9sZWAgYXR0cmlidXRlLlxuICAgICAqIElmIG5vdCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBgc2VwYXJhdG9yYCB3aWxsIGJlIHVzZWQuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHJvbGUgPSAnc2VwYXJhdG9yJztcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHR5cGUgb2YgdGhlIGRpdmlkZXIuIFRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICogaXMgYGRlZmF1bHRgLiBUaGUgZGl2aWRlciBjYW4gYWxzbyBiZSBgZGFzaGVkYDtcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kaXZpZGVyIHR5cGU9XCJkYXNoZWRcIj48L2lneC1kaXZpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWRpdmlkZXInKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHR5cGU6IElneERpdmlkZXJUeXBlIHwgc3RyaW5nID0gSWd4RGl2aWRlclR5cGUuU09MSUQ7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kaXZpZGVyLS1kYXNoZWQnKVxuICAgIGdldCBpc0Rhc2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4RGl2aWRlclR5cGUuREFTSEVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCB0aGF0IHNldHMgdGhlIGBtaWRkbGVgIGF0dHJpYnV0ZSBvZiB0aGUgZGl2aWRlci5cbiAgICAgKiBJZiBzZXQgdG8gYHRydWVgIGFuZCBhbiBgaW5zZXRgIHZhbHVlIGhhcyBiZWVuIHByb3ZpZGVkLFxuICAgICAqIHRoZSBkaXZpZGVyIHdpbGwgc3RhcnQgc2hyaW5raW5nIGZyb20gYm90aCBlbmRzLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWRpdmlkZXIgW21pZGRsZV09XCJ0cnVlXCI+PC9pZ3gtZGl2aWRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kaXZpZGVyLS1pbnNldCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgbWlkZGxlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBBIGdldHRlciB0aGF0IHJldHVybnMgYHRydWVgIGlmIHRoZSB0eXBlIG9mIHRoZSBkaXZpZGVyIGlzIGBkZWZhdWx0YDtcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgaXNEZWZhdWx0ID0gdGhpcy5kaXZpZGVyLmlzRGVmYXVsdDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgaXNTb2xpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4RGl2aWRlclR5cGUuU09MSUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHRoYXQgc2V0cyB0aGUgdmVydGljYWwgYXR0cmlidXRlIG9mIHRoZSBkaXZpZGVyLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWRpdmlkZXIgW3ZlcnRpY2FsXT1cInRydWVcIj48L2lneC1kaXZpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWRpdmlkZXItLXZlcnRpY2FsJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB2ZXJ0aWNhbCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5zZXQgb2YgdGhlIGRpdmlkZXIgZnJvbSB0aGUgc2lkZShzKS5cbiAgICAgKiBJZiB0aGUgZGl2aWRlciBhdHRyaWJ1dGUgYG1pZGRsZWAgaXMgc2V0IHRvIGB0cnVlYCxcbiAgICAgKiBpdCB3aWxsIGluc2V0IHRoZSBkaXZpZGVyIG9uIGJvdGggc2lkZXMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZGl2aWRlci5pbnNldCA9ICczMnB4JztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLm1hcmdpbicpXG4gICAgc2V0IGluc2V0KHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5faW5zZXQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGRpdmlkZXIgaW5zZXQgaW4gdGVybXMgb2ZcbiAgICAgKiBtYXJnaW4gcmVwcmVzZW50YXRpb24gYXMgYXBwbGllZCB0byB0aGUgZGl2aWRlci5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgaW5zZXQgPSB0aGlzLmRpdmlkZXIuaW5zZXQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGluc2V0KCkge1xuICAgICAgICBjb25zdCBiYXNlTWFyZ2luID0gJzAnO1xuXG4gICAgICAgIGlmICh0aGlzLm1pZGRsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5faW5zZXR9ICR7YmFzZU1hcmdpbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VNYXJnaW59ICR7dGhpcy5faW5zZXR9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuX2luc2V0fSAke2Jhc2VNYXJnaW59IDAgJHtiYXNlTWFyZ2lufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYCR7YmFzZU1hcmdpbn0gMCAke2Jhc2VNYXJnaW59ICR7dGhpcy5faW5zZXR9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hEaXZpZGVyRGlyZWN0aXZlXSxcbiAgICBleHBvcnRzOiBbSWd4RGl2aWRlckRpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4RGl2aWRlck1vZHVsZSB7IH1cbiJdfQ==