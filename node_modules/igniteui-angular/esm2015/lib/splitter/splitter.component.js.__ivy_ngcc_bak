import { Component, Input, ContentChildren, HostBinding } from '@angular/core';
import { IgxSplitterPaneComponent } from './splitter-pane/splitter-pane.component';
/**
 * An enumeration that defines the `SplitterComponent` panes orientation.
 */
export var SplitterType;
(function (SplitterType) {
    SplitterType[SplitterType["Horizontal"] = 0] = "Horizontal";
    SplitterType[SplitterType["Vertical"] = 1] = "Vertical";
})(SplitterType || (SplitterType = {}));
/**
 * Provides a framework for a simple layout, splitting the view horizontally or vertically
 * into multiple smaller resizable and collapsible areas.
 * @igxModule IgxSplitterModule
 *
 * @igxParent Layouts
 *
 * @igxTheme igx-splitter-theme
 *
 * @igxKeywords splitter panes layout
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <igx-splitter>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 * </igx-splitter>
 * ```
 */
export class IgxSplitterComponent {
    constructor() {
        this._type = SplitterType.Horizontal;
        /**
         * @hidden @internal
         * Gets/Sets the `overflow` property of the current splitter.
         */
        this.overflow = 'hidden';
        /**
         * @hidden @internal
         * Sets/Gets the `display` property of the current splitter.
         */
        this.display = 'flex';
    }
    /**
     * Gets/Sets the splitter orientation.
     * @example
     * ```html
     * <igx-splitter [type]="type">...</igx-splitter>
     * ```
     */
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
        if (this.panes) {
            // if type is changed runtime, should reset sizes.
            this.panes.forEach(x => x.size = 'auto');
        }
    }
    /**
     * @hidden @internal
     * Gets the `flex-direction` property of the current `SplitterComponent`.
     */
    get direction() {
        return this.type === SplitterType.Horizontal ? 'row' : 'column';
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this.panes.forEach(pane => pane.owner = this);
        this.assignFlexOrder();
        this.panes.changes.subscribe(() => {
            this.panes.forEach(pane => pane.owner = this);
            this.assignFlexOrder();
        });
    }
    /**
     * @hidden @internal
     * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.
     * @param pane - the main pane associated with the currently dragged bar.
     */
    onMoveStart(pane) {
        const panes = this.panes.toArray();
        this.pane = pane;
        this.sibling = panes[panes.indexOf(this.pane) + 1];
        const paneRect = this.pane.element.getBoundingClientRect();
        this.initialPaneSize = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        if (this.pane.size === 'auto') {
            this.pane.size = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        }
        const siblingRect = this.sibling.element.getBoundingClientRect();
        this.initialSiblingSize = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        if (this.sibling.size === 'auto') {
            this.sibling.size = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        }
    }
    /**
     * @hidden @internal
     * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.
     * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.
     */
    onMoving(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        this.pane.size = paneSize + 'px';
        this.sibling.size = siblingSize + 'px';
    }
    /**
     * @hidden @internal
     * This method assigns the order of each pane.
     */
    assignFlexOrder() {
        let k = 0;
        this.panes.forEach((pane) => {
            pane.order = k;
            k += 2;
        });
    }
    /** @hidden @internal */
    getPaneSiblingsByOrder(order, barIndex) {
        const panes = this.panes.toArray();
        const prevPane = panes[order - barIndex - 1];
        const nextPane = panes[order - barIndex];
        const siblings = [prevPane, nextPane];
        return siblings;
    }
}
IgxSplitterComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-splitter',
                template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\">\n    </igx-splitter-bar>\n</ng-container>\n"
            },] }
];
IgxSplitterComponent.propDecorators = {
    type: [{ type: Input }],
    panes: [{ type: ContentChildren, args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent },] }],
    direction: [{ type: HostBinding, args: ['style.flex-direction',] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }],
    display: [{ type: HostBinding, args: ['style.display',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXR0ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3NwbGl0dGVyL3NwbGl0dGVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFhLEtBQUssRUFBRSxlQUFlLEVBQW9CLFdBQVcsRUFBd0IsTUFBTSxlQUFlLENBQUM7QUFDbEksT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0seUNBQXlDLENBQUM7QUFFbkY7O0dBRUc7QUFDSCxNQUFNLENBQU4sSUFBWSxZQUdYO0FBSEQsV0FBWSxZQUFZO0lBQ3BCLDJEQUFVLENBQUE7SUFDVix1REFBUSxDQUFBO0FBQ1osQ0FBQyxFQUhXLFlBQVksS0FBWixZQUFZLFFBR3ZCO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXdCRztBQUtILE1BQU0sT0FBTyxvQkFBb0I7SUFKakM7UUFLWSxVQUFLLEdBQWlCLFlBQVksQ0FBQyxVQUFVLENBQUM7UUF1Q3REOzs7V0FHRztRQUVJLGFBQVEsR0FBRyxRQUFRLENBQUM7UUFFM0I7OztXQUdHO1FBRUksWUFBTyxHQUFHLE1BQU0sQ0FBQztJQW9HNUIsQ0FBQztJQXRKRzs7Ozs7O09BTUc7SUFDSCxJQUNJLElBQUk7UUFDSixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDdEIsQ0FBQztJQUNELElBQUksSUFBSSxDQUFDLEtBQUs7UUFDVixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDWixrREFBa0Q7WUFDbEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxDQUFDO1NBQzVDO0lBQ0wsQ0FBQztJQVlEOzs7T0FHRztJQUNI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LFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUN0QyxPQUFPLFFBQVEsQ0FBQztJQUNwQixDQUFDOzs7WUEzSkosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxjQUFjO2dCQUN4Qix1aEJBQXdDO2FBQzNDOzs7bUJBVUksS0FBSztvQkFtQkwsZUFBZSxTQUFDLHdCQUF3QixFQUFFLEVBQUUsSUFBSSxFQUFFLHdCQUF3QixFQUFFO3dCQU81RSxXQUFXLFNBQUMsc0JBQXNCO3VCQVNsQyxXQUFXLFNBQUMsZ0JBQWdCO3NCQU81QixXQUFXLFNBQUMsZUFBZSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgUXVlcnlMaXN0LCBJbnB1dCwgQ29udGVudENoaWxkcmVuLCBBZnRlckNvbnRlbnRJbml0LCBIb3N0QmluZGluZywgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCB9IGZyb20gJy4vc3BsaXR0ZXItcGFuZS9zcGxpdHRlci1wYW5lLmNvbXBvbmVudCc7XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gdGhhdCBkZWZpbmVzIHRoZSBgU3BsaXR0ZXJDb21wb25lbnRgIHBhbmVzIG9yaWVudGF0aW9uLlxuICovXG5leHBvcnQgZW51bSBTcGxpdHRlclR5cGUge1xuICAgIEhvcml6b250YWwsXG4gICAgVmVydGljYWxcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhIGZyYW1ld29yayBmb3IgYSBzaW1wbGUgbGF5b3V0LCBzcGxpdHRpbmcgdGhlIHZpZXcgaG9yaXpvbnRhbGx5IG9yIHZlcnRpY2FsbHlcbiAqIGludG8gbXVsdGlwbGUgc21hbGxlciByZXNpemFibGUgYW5kIGNvbGxhcHNpYmxlIGFyZWFzLlxuICogQGlneE1vZHVsZSBJZ3hTcGxpdHRlck1vZHVsZVxuICpcbiAqIEBpZ3hQYXJlbnQgTGF5b3V0c1xuICpcbiAqIEBpZ3hUaGVtZSBpZ3gtc3BsaXR0ZXItdGhlbWVcbiAqXG4gKiBAaWd4S2V5d29yZHMgc3BsaXR0ZXIgcGFuZXMgbGF5b3V0XG4gKlxuICogQGlneEdyb3VwIHByZXNlbnRhdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sXG4gKiA8aWd4LXNwbGl0dGVyPlxuICogIDxpZ3gtc3BsaXR0ZXItcGFuZT5cbiAqICAgICAgLi4uXG4gKiAgPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAqICA8aWd4LXNwbGl0dGVyLXBhbmU+XG4gKiAgICAgIC4uLlxuICogIDwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gKiA8L2lneC1zcGxpdHRlcj5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1zcGxpdHRlcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NwbGl0dGVyLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hTcGxpdHRlckNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuICAgIHByaXZhdGUgX3R5cGU6IFNwbGl0dGVyVHlwZSA9IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsO1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgc3BsaXR0ZXIgb3JpZW50YXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlciBbdHlwZV09XCJ0eXBlXCI+Li4uPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuICAgIHNldCB0eXBlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMucGFuZXMpIHtcbiAgICAgICAgICAgIC8vIGlmIHR5cGUgaXMgY2hhbmdlZCBydW50aW1lLCBzaG91bGQgcmVzZXQgc2l6ZXMuXG4gICAgICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2goeCA9PiB4LnNpemUgPSAnYXV0bycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBvZiBzcGxpdHRlciBwYW5lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwYW5lcyA9IHRoaXMuc3BsaXR0ZXIucGFuZXM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQsIHsgcmVhZDogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50IH0pXG4gICAgcHVibGljIHBhbmVzITogUXVlcnlMaXN0PElneFNwbGl0dGVyUGFuZUNvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMgdGhlIGBmbGV4LWRpcmVjdGlvbmAgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgYFNwbGl0dGVyQ29tcG9uZW50YC5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmZsZXgtZGlyZWN0aW9uJylcbiAgICBwdWJsaWMgZ2V0IGRpcmVjdGlvbigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/ICdyb3cnIDogJ2NvbHVtbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzL1NldHMgdGhlIGBvdmVyZmxvd2AgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgc3BsaXR0ZXIuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5vdmVyZmxvdycpXG4gICAgcHVibGljIG92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFNldHMvR2V0cyB0aGUgYGRpc3BsYXlgIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IHNwbGl0dGVyLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuZGlzcGxheScpXG4gICAgcHVibGljIGRpc3BsYXkgPSAnZmxleCc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEEgZmllbGQgdGhhdCBob2xkcyB0aGUgaW5pdGlhbCBzaXplIG9mIHRoZSBtYWluIGBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnRgIGluIGVhY2ggcGFpciBvZiBwYW5lcyBkaXZpZGVkIGJ5IGEgc3BsaXR0ZXIgYmFyLlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdGlhbFBhbmVTaXplITogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBBIGZpZWxkIHRoYXQgaG9sZHMgdGhlIGluaXRpYWwgc2l6ZSBvZiB0aGUgc2libGluZyBwYW5lIGluIGVhY2ggcGFpciBvZiBwYW5lcyBkaXZpZGVkIGJ5IGEgZ3JpcHBlci5cbiAgICAgKiBAbWVtYmVyb2YgU3BsaXR0ZXJDb21wb25lbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRpYWxTaWJsaW5nU2l6ZSE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhlIG1haW4gcGFuZSBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIGdyaXBwZXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBwYW5lITogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNpYmxpbmcgcGFuZSBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIHNwbGl0dGVyIGJhci5cbiAgICAgKi9cbiAgICBwcml2YXRlIHNpYmxpbmchOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ7XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2gocGFuZSA9PiBwYW5lLm93bmVyID0gdGhpcyk7XG4gICAgICAgIHRoaXMuYXNzaWduRmxleE9yZGVyKCk7XG4gICAgICAgIHRoaXMucGFuZXMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKHBhbmUgPT4gcGFuZS5vd25lciA9IHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5hc3NpZ25GbGV4T3JkZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyAgaW5pdGlhbGl6YXRpb24gbG9naWMgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIHNwbGl0dGVyIGJhciBiZXR3ZWVuIGVhY2ggcGFpciBvZiBwYW5lcy5cbiAgICAgKiBAcGFyYW0gcGFuZSAtIHRoZSBtYWluIHBhbmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50bHkgZHJhZ2dlZCBiYXIuXG4gICAgICovXG4gICAgcHVibGljIG9uTW92ZVN0YXJ0KHBhbmU6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMucGFuZXMudG9BcnJheSgpO1xuICAgICAgICB0aGlzLnBhbmUgPSBwYW5lO1xuICAgICAgICB0aGlzLnNpYmxpbmcgPSBwYW5lc1twYW5lcy5pbmRleE9mKHRoaXMucGFuZSkgKyAxXTtcblxuICAgICAgICBjb25zdCBwYW5lUmVjdCA9IHRoaXMucGFuZS5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxQYW5lU2l6ZSA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyBwYW5lUmVjdC53aWR0aCA6IHBhbmVSZWN0LmhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMucGFuZS5zaXplID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMucGFuZS5zaXplID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IHBhbmVSZWN0LndpZHRoIDogcGFuZVJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2libGluZ1JlY3QgPSB0aGlzLnNpYmxpbmcuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsU2libGluZ1NpemUgPSB0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsID8gc2libGluZ1JlY3Qud2lkdGggOiBzaWJsaW5nUmVjdC5oZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLnNpYmxpbmcuc2l6ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLnNpYmxpbmcuc2l6ZSA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyBzaWJsaW5nUmVjdC53aWR0aCA6IHNpYmxpbmdSZWN0LmhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhpcyBtZXRob2QgcGVyZm9ybXMgY2FsY3VsYXRpb25zIGNvbmNlcm5pbmcgdGhlIHNpemVzIG9mIGVhY2ggcGFpciBvZiBwYW5lcyB3aGVuIHRoZSBiYXIgYmV0d2VlbiB0aGVtIGlzIGRyYWdnZWQuXG4gICAgICogQHBhcmFtIGRlbHRhIC0gVGhlIGRpZmZlcmVuY2UgYWxvbmcgdGhlIFggKG9yIFkpIGF4aXMgYmV0d2VlbiB0aGUgaW5pdGlhbCBhbmQgdGhlIGN1cnJlbnQgcG9pbnQgd2hlbiBkcmFnZ2luZyB0aGUgYmFyLlxuICAgICAqL1xuICAgIHB1YmxpYyBvbk1vdmluZyhkZWx0YTogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IHBhcnNlSW50KHRoaXMucGFuZS5taW5TaXplLCAxMCkgfHwgMDtcbiAgICAgICAgY29uc3QgbWF4ID0gcGFyc2VJbnQodGhpcy5wYW5lLm1heFNpemUsIDEwKSB8fCB0aGlzLmluaXRpYWxQYW5lU2l6ZSArIHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplO1xuICAgICAgICBjb25zdCBtaW5TaWJsaW5nID0gcGFyc2VJbnQodGhpcy5zaWJsaW5nLm1pblNpemUsIDEwKSB8fCAwO1xuICAgICAgICBjb25zdCBtYXhTaWJsaW5nID0gcGFyc2VJbnQodGhpcy5zaWJsaW5nLm1heFNpemUsIDEwKSB8fCB0aGlzLmluaXRpYWxQYW5lU2l6ZSArIHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplO1xuXG4gICAgICAgIGNvbnN0IHBhbmVTaXplID0gdGhpcy5pbml0aWFsUGFuZVNpemUgLSBkZWx0YTtcbiAgICAgICAgY29uc3Qgc2libGluZ1NpemUgPSB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZSArIGRlbHRhO1xuICAgICAgICBpZiAocGFuZVNpemUgPCBtaW4gfHwgcGFuZVNpemUgPiBtYXggfHwgc2libGluZ1NpemUgPCBtaW5TaWJsaW5nIHx8IHNpYmxpbmdTaXplID4gbWF4U2libGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYW5lLnNpemUgPSBwYW5lU2l6ZSArICdweCc7XG4gICAgICAgIHRoaXMuc2libGluZy5zaXplID0gc2libGluZ1NpemUgKyAncHgnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyB0aGUgb3JkZXIgb2YgZWFjaCBwYW5lLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXNzaWduRmxleE9yZGVyKCkge1xuICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgIHRoaXMucGFuZXMuZm9yRWFjaCgocGFuZTogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICBwYW5lLm9yZGVyID0gaztcbiAgICAgICAgICAgIGsgKz0gMjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldFBhbmVTaWJsaW5nc0J5T3JkZXIob3JkZXI6IG51bWJlciwgYmFySW5kZXg6IG51bWJlcik6IEFycmF5PElneFNwbGl0dGVyUGFuZUNvbXBvbmVudD4ge1xuICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMucGFuZXMudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBwcmV2UGFuZSA9IHBhbmVzW29yZGVyIC0gYmFySW5kZXggLSAxXTtcbiAgICAgICAgY29uc3QgbmV4dFBhbmUgPSBwYW5lc1tvcmRlciAtIGJhckluZGV4XTtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBbcHJldlBhbmUsIG5leHRQYW5lXTtcbiAgICAgICAgcmV0dXJuIHNpYmxpbmdzO1xuICAgIH1cbn1cbiJdfQ==