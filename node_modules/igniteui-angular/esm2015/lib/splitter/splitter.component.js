import { Component, Input, ContentChildren, HostBinding } from '@angular/core';
import { IgxSplitterPaneComponent } from './splitter-pane/splitter-pane.component';
/**
 * An enumeration that defines the `SplitterComponent` panes orientation.
 */
import * as ɵngcc0 from '@angular/core';

function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-splitter-bar", 2);
    ɵngcc0.ɵɵlistener("moveStart", function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template_igx_splitter_bar_moveStart_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(2); return ctx_r5.onMoveStart($event); })("moving", function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template_igx_splitter_bar_moving_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r7 = ɵngcc0.ɵɵnextContext(2); return ctx_r7.onMoving($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    const pane_r1 = ctx_r8.$implicit;
    const index_r3 = ctx_r8.index;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("order", pane_r1.order + 1)("type", ctx_r4.type)("pane", pane_r1)("siblings", ctx_r4.getPaneSiblingsByOrder(pane_r1.order + 1, index_r3));
} }
function IgxSplitterComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template, 1, 4, "igx-splitter-bar", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const last_r2 = ctx.last;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r2);
} }
const _c0 = [[["igx-splitter-pane"]]];
const _c1 = ["igx-splitter-pane"];
export var SplitterType;
(function (SplitterType) {
    SplitterType[SplitterType["Horizontal"] = 0] = "Horizontal";
    SplitterType[SplitterType["Vertical"] = 1] = "Vertical";
})(SplitterType || (SplitterType = {}));
/**
 * Provides a framework for a simple layout, splitting the view horizontally or vertically
 * into multiple smaller resizable and collapsible areas.
 * @igxModule IgxSplitterModule
 *
 * @igxParent Layouts
 *
 * @igxTheme igx-splitter-theme
 *
 * @igxKeywords splitter panes layout
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <igx-splitter>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 * </igx-splitter>
 * ```
 */
export class IgxSplitterComponent {
    constructor() {
        this._type = SplitterType.Horizontal;
        /**
         * @hidden @internal
         * Gets/Sets the `overflow` property of the current splitter.
         */
        this.overflow = 'hidden';
        /**
         * @hidden @internal
         * Sets/Gets the `display` property of the current splitter.
         */
        this.display = 'flex';
    }
    /**
     * Gets/Sets the splitter orientation.
     * @example
     * ```html
     * <igx-splitter [type]="type">...</igx-splitter>
     * ```
     */
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
        if (this.panes) {
            // if type is changed runtime, should reset sizes.
            this.panes.forEach(x => x.size = 'auto');
        }
    }
    /**
     * @hidden @internal
     * Gets the `flex-direction` property of the current `SplitterComponent`.
     */
    get direction() {
        return this.type === SplitterType.Horizontal ? 'row' : 'column';
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this.panes.forEach(pane => pane.owner = this);
        this.assignFlexOrder();
        this.panes.changes.subscribe(() => {
            this.panes.forEach(pane => pane.owner = this);
            this.assignFlexOrder();
        });
    }
    /**
     * @hidden @internal
     * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.
     * @param pane - the main pane associated with the currently dragged bar.
     */
    onMoveStart(pane) {
        const panes = this.panes.toArray();
        this.pane = pane;
        this.sibling = panes[panes.indexOf(this.pane) + 1];
        const paneRect = this.pane.element.getBoundingClientRect();
        this.initialPaneSize = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        if (this.pane.size === 'auto') {
            this.pane.size = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        }
        const siblingRect = this.sibling.element.getBoundingClientRect();
        this.initialSiblingSize = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        if (this.sibling.size === 'auto') {
            this.sibling.size = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        }
    }
    /**
     * @hidden @internal
     * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.
     * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.
     */
    onMoving(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        this.pane.size = paneSize + 'px';
        this.sibling.size = siblingSize + 'px';
    }
    /**
     * @hidden @internal
     * This method assigns the order of each pane.
     */
    assignFlexOrder() {
        let k = 0;
        this.panes.forEach((pane) => {
            pane.order = k;
            k += 2;
        });
    }
    /** @hidden @internal */
    getPaneSiblingsByOrder(order, barIndex) {
        const panes = this.panes.toArray();
        const prevPane = panes[order - barIndex - 1];
        const nextPane = panes[order - barIndex];
        const siblings = [prevPane, nextPane];
        return siblings;
    }
}
IgxSplitterComponent.ɵfac = function IgxSplitterComponent_Factory(t) { return new (t || IgxSplitterComponent)(); };
IgxSplitterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSplitterComponent, selectors: [["igx-splitter"]], contentQueries: function IgxSplitterComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSplitterPaneComponent, false, IgxSplitterPaneComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panes = _t);
    } }, hostVars: 6, hostBindings: function IgxSplitterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("overflow", ctx.overflow)("display", ctx.display)("flex-direction", ctx.direction);
    } }, inputs: { type: "type" }, ngContentSelectors: _c1, decls: 2, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["role", "separator", 3, "order", "type", "pane", "siblings", "moveStart", "moving", 4, "ngIf"], ["role", "separator", 3, "order", "type", "pane", "siblings", "moveStart", "moving"]], template: function IgxSplitterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, IgxSplitterComponent_ng_container_1_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.panes);
    } }, encapsulation: 2 });
IgxSplitterComponent.propDecorators = {
    type: [{ type: Input }],
    panes: [{ type: ContentChildren, args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent },] }],
    direction: [{ type: HostBinding, args: ['style.flex-direction',] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }],
    display: [{ type: HostBinding, args: ['style.display',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSplitterComponent, [{
        type: Component,
        args: [{
                selector: 'igx-splitter',
                template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\">\n    </igx-splitter-bar>\n</ng-container>\n"
            }]
    }], function () { return []; }, { overflow: [{
            type: HostBinding,
            args: ['style.overflow']
        }], display: [{
            type: HostBinding,
            args: ['style.display']
        }], type: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ['style.flex-direction']
        }], panes: [{
            type: ContentChildren,
            args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent }]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXR0ZXIuY29tcG9uZW50LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvc3BsaXR0ZXIvc3BsaXR0ZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQWEsS0FBSyxFQUFFLGVBQWUsRUFBb0IsV0FBVyxFQUF3QixNQUFNLGVBQWUsQ0FBQztBQUNsSSxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQztBQUVuRjtBQUNBO0FBQ0EsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDSCxNQUFNLENBQU4sSUFBWSxZQUdYO0FBSEQsV0FBWSxZQUFZO0FBQ3ZCLElBQUcsMkRBQVUsQ0FBQTtBQUFDLElBQ1gsdURBQVEsQ0FBQTtBQUNaLENBQUMsRUFIVyxZQUFZLEtBQVosWUFBWSxRQUd2QjtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFLSCxNQUFNLE9BQU8sb0JBQW9CO0FBQUcsSUFKcEM7QUFDRyxRQUlTLFVBQUssR0FBaUIsWUFBWSxDQUFDLFVBQVUsQ0FBQztBQUMxRCxRQXNDSTtBQUNKO0FBQ0k7QUFFSixXQURPO0FBQ1AsUUFDVyxhQUFRLEdBQUcsUUFBUSxDQUFDO0FBQy9CLFFBQ0k7QUFDSjtBQUNJO0FBRUosV0FETztBQUNQLFFBQ1csWUFBTyxHQUFHLE1BQU0sQ0FBQztBQUM1QixJQW1HQSxDQUFDO0FBQ0QsSUF2Skk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUksSUFDSSxJQUFJO0FBQ1osUUFBUSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7QUFDMUIsSUFBSSxD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QkFBZ0I7QUFDNUIsc0JBTUEsV0FBVyxTQUFDLGVBQWU7QUFDNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBRdWVyeUxpc3QsIElucHV0LCBDb250ZW50Q2hpbGRyZW4sIEFmdGVyQ29udGVudEluaXQsIEhvc3RCaW5kaW5nLCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50IH0gZnJvbSAnLi9zcGxpdHRlci1wYW5lL3NwbGl0dGVyLXBhbmUuY29tcG9uZW50JztcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiB0aGF0IGRlZmluZXMgdGhlIGBTcGxpdHRlckNvbXBvbmVudGAgcGFuZXMgb3JpZW50YXRpb24uXG4gKi9cbmV4cG9ydCBlbnVtIFNwbGl0dGVyVHlwZSB7XG4gICAgSG9yaXpvbnRhbCxcbiAgICBWZXJ0aWNhbFxufVxuXG4vKipcbiAqIFByb3ZpZGVzIGEgZnJhbWV3b3JrIGZvciBhIHNpbXBsZSBsYXlvdXQsIHNwbGl0dGluZyB0aGUgdmlldyBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseVxuICogaW50byBtdWx0aXBsZSBzbWFsbGVyIHJlc2l6YWJsZSBhbmQgY29sbGFwc2libGUgYXJlYXMuXG4gKiBAaWd4TW9kdWxlIElneFNwbGl0dGVyTW9kdWxlXG4gKlxuICogQGlneFBhcmVudCBMYXlvdXRzXG4gKlxuICogQGlneFRoZW1lIGlneC1zcGxpdHRlci10aGVtZVxuICpcbiAqIEBpZ3hLZXl3b3JkcyBzcGxpdHRlciBwYW5lcyBsYXlvdXRcbiAqXG4gKiBAaWd4R3JvdXAgcHJlc2VudGF0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtc3BsaXR0ZXI+XG4gKiAgPGlneC1zcGxpdHRlci1wYW5lPlxuICogICAgICAuLi5cbiAqICA8L2lneC1zcGxpdHRlci1wYW5lPlxuICogIDxpZ3gtc3BsaXR0ZXItcGFuZT5cbiAqICAgICAgLi4uXG4gKiAgPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAqIDwvaWd4LXNwbGl0dGVyPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LXNwbGl0dGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc3BsaXR0ZXIuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIElneFNwbGl0dGVyQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gICAgcHJpdmF0ZSBfdHlwZTogU3BsaXR0ZXJUeXBlID0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWw7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBzcGxpdHRlciBvcmllbnRhdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNwbGl0dGVyIFt0eXBlXT1cInR5cGVcIj4uLi48L2lneC1zcGxpdHRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG4gICAgc2V0IHR5cGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdHlwZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5wYW5lcykge1xuICAgICAgICAgICAgLy8gaWYgdHlwZSBpcyBjaGFuZ2VkIHJ1bnRpbWUsIHNob3VsZCByZXNldCBzaXplcy5cbiAgICAgICAgICAgIHRoaXMucGFuZXMuZm9yRWFjaCh4ID0+IHguc2l6ZSA9ICdhdXRvJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IG9mIHNwbGl0dGVyIHBhbmVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHBhbmVzID0gdGhpcy5zcGxpdHRlci5wYW5lcztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCwgeyByZWFkOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQgfSlcbiAgICBwdWJsaWMgcGFuZXMhOiBRdWVyeUxpc3Q8SWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0cyB0aGUgYGZsZXgtZGlyZWN0aW9uYCBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBgU3BsaXR0ZXJDb21wb25lbnRgLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuZmxleC1kaXJlY3Rpb24nKVxuICAgIHB1YmxpYyBnZXQgZGlyZWN0aW9uKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsID8gJ3JvdycgOiAnY29sdW1uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMvU2V0cyB0aGUgYG92ZXJmbG93YCBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBzcGxpdHRlci5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLm92ZXJmbG93JylcbiAgICBwdWJsaWMgb3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogU2V0cy9HZXRzIHRoZSBgZGlzcGxheWAgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgc3BsaXR0ZXIuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5kaXNwbGF5JylcbiAgICBwdWJsaWMgZGlzcGxheSA9ICdmbGV4JztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogQSBmaWVsZCB0aGF0IGhvbGRzIHRoZSBpbml0aWFsIHNpemUgb2YgdGhlIG1haW4gYElneFNwbGl0dGVyUGFuZUNvbXBvbmVudGAgaW4gZWFjaCBwYWlyIG9mIHBhbmVzIGRpdmlkZWQgYnkgYSBzcGxpdHRlciBiYXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0aWFsUGFuZVNpemUhOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEEgZmllbGQgdGhhdCBob2xkcyB0aGUgaW5pdGlhbCBzaXplIG9mIHRoZSBzaWJsaW5nIHBhbmUgaW4gZWFjaCBwYWlyIG9mIHBhbmVzIGRpdmlkZWQgYnkgYSBncmlwcGVyLlxuICAgICAqIEBtZW1iZXJvZiBTcGxpdHRlckNvbXBvbmVudFxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdGlhbFNpYmxpbmdTaXplITogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGUgbWFpbiBwYW5lIGluIGVhY2ggcGFpciBvZiBwYW5lcyBkaXZpZGVkIGJ5IGEgZ3JpcHBlci5cbiAgICAgKi9cbiAgICBwcml2YXRlIHBhbmUhOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2libGluZyBwYW5lIGluIGVhY2ggcGFpciBvZiBwYW5lcyBkaXZpZGVkIGJ5IGEgc3BsaXR0ZXIgYmFyLlxuICAgICAqL1xuICAgIHByaXZhdGUgc2libGluZyE6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudDtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGFuZXMuZm9yRWFjaChwYW5lID0+IHBhbmUub3duZXIgPSB0aGlzKTtcbiAgICAgICAgdGhpcy5hc3NpZ25GbGV4T3JkZXIoKTtcbiAgICAgICAgdGhpcy5wYW5lcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2gocGFuZSA9PiBwYW5lLm93bmVyID0gdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmFzc2lnbkZsZXhPcmRlcigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zICBpbml0aWFsaXphdGlvbiBsb2dpYyB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgc3BsaXR0ZXIgYmFyIGJldHdlZW4gZWFjaCBwYWlyIG9mIHBhbmVzLlxuICAgICAqIEBwYXJhbSBwYW5lIC0gdGhlIG1haW4gcGFuZSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnRseSBkcmFnZ2VkIGJhci5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25Nb3ZlU3RhcnQocGFuZTogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHBhbmVzID0gdGhpcy5wYW5lcy50b0FycmF5KCk7XG4gICAgICAgIHRoaXMucGFuZSA9IHBhbmU7XG4gICAgICAgIHRoaXMuc2libGluZyA9IHBhbmVzW3BhbmVzLmluZGV4T2YodGhpcy5wYW5lKSArIDFdO1xuXG4gICAgICAgIGNvbnN0IHBhbmVSZWN0ID0gdGhpcy5wYW5lLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFBhbmVTaXplID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IHBhbmVSZWN0LndpZHRoIDogcGFuZVJlY3QuaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5wYW5lLnNpemUgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgdGhpcy5wYW5lLnNpemUgPSB0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsID8gcGFuZVJlY3Qud2lkdGggOiBwYW5lUmVjdC5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaWJsaW5nUmVjdCA9IHRoaXMuc2libGluZy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZSA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyBzaWJsaW5nUmVjdC53aWR0aCA6IHNpYmxpbmdSZWN0LmhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuc2libGluZy5zaXplID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuc2libGluZy5zaXplID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IHNpYmxpbmdSZWN0LndpZHRoIDogc2libGluZ1JlY3QuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyBjYWxjdWxhdGlvbnMgY29uY2VybmluZyB0aGUgc2l6ZXMgb2YgZWFjaCBwYWlyIG9mIHBhbmVzIHdoZW4gdGhlIGJhciBiZXR3ZWVuIHRoZW0gaXMgZHJhZ2dlZC5cbiAgICAgKiBAcGFyYW0gZGVsdGEgLSBUaGUgZGlmZmVyZW5jZSBhbG9uZyB0aGUgWCAob3IgWSkgYXhpcyBiZXR3ZWVuIHRoZSBpbml0aWFsIGFuZCB0aGUgY3VycmVudCBwb2ludCB3aGVuIGRyYWdnaW5nIHRoZSBiYXIuXG4gICAgICovXG4gICAgcHVibGljIG9uTW92aW5nKGRlbHRhOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgbWluID0gcGFyc2VJbnQodGhpcy5wYW5lLm1pblNpemUsIDEwKSB8fCAwO1xuICAgICAgICBjb25zdCBtYXggPSBwYXJzZUludCh0aGlzLnBhbmUubWF4U2l6ZSwgMTApIHx8IHRoaXMuaW5pdGlhbFBhbmVTaXplICsgdGhpcy5pbml0aWFsU2libGluZ1NpemU7XG4gICAgICAgIGNvbnN0IG1pblNpYmxpbmcgPSBwYXJzZUludCh0aGlzLnNpYmxpbmcubWluU2l6ZSwgMTApIHx8IDA7XG4gICAgICAgIGNvbnN0IG1heFNpYmxpbmcgPSBwYXJzZUludCh0aGlzLnNpYmxpbmcubWF4U2l6ZSwgMTApIHx8IHRoaXMuaW5pdGlhbFBhbmVTaXplICsgdGhpcy5pbml0aWFsU2libGluZ1NpemU7XG5cbiAgICAgICAgY29uc3QgcGFuZVNpemUgPSB0aGlzLmluaXRpYWxQYW5lU2l6ZSAtIGRlbHRhO1xuICAgICAgICBjb25zdCBzaWJsaW5nU2l6ZSA9IHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplICsgZGVsdGE7XG4gICAgICAgIGlmIChwYW5lU2l6ZSA8IG1pbiB8fCBwYW5lU2l6ZSA+IG1heCB8fCBzaWJsaW5nU2l6ZSA8IG1pblNpYmxpbmcgfHwgc2libGluZ1NpemUgPiBtYXhTaWJsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhbmUuc2l6ZSA9IHBhbmVTaXplICsgJ3B4JztcbiAgICAgICAgdGhpcy5zaWJsaW5nLnNpemUgPSBzaWJsaW5nU2l6ZSArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3NpZ25zIHRoZSBvcmRlciBvZiBlYWNoIHBhbmUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3NpZ25GbGV4T3JkZXIoKSB7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKChwYW5lOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgIHBhbmUub3JkZXIgPSBrO1xuICAgICAgICAgICAgayArPSAyO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgZ2V0UGFuZVNpYmxpbmdzQnlPcmRlcihvcmRlcjogbnVtYmVyLCBiYXJJbmRleDogbnVtYmVyKTogQXJyYXk8SWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50PiB7XG4gICAgICAgIGNvbnN0IHBhbmVzID0gdGhpcy5wYW5lcy50b0FycmF5KCk7XG4gICAgICAgIGNvbnN0IHByZXZQYW5lID0gcGFuZXNbb3JkZXIgLSBiYXJJbmRleCAtIDFdO1xuICAgICAgICBjb25zdCBuZXh0UGFuZSA9IHBhbmVzW29yZGVyIC0gYmFySW5kZXhdO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IFtwcmV2UGFuZSwgbmV4dFBhbmVdO1xuICAgICAgICByZXR1cm4gc2libGluZ3M7XG4gICAgfVxufVxuIl19