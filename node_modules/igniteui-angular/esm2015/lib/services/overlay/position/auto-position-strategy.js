import { VerticalAlignment, HorizontalAlignment } from './../utilities';
import { BaseFitPositionStrategy } from './base-fit-position-strategy';
/**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
export class AutoPositionStrategy extends BaseFitPositionStrategy {
    /** @inheritdoc */
    fitInViewport(element, connectedFit) {
        const transformString = [];
        if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
            if (this.canFlipHorizontal(connectedFit)) {
                this.flipHorizontal();
            }
            else {
                const horizontalPush = this.horizontalPush(connectedFit);
                transformString.push(`translateX(${horizontalPush}px)`);
            }
        }
        if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
            if (this.canFlipVertical(connectedFit)) {
                this.flipVertical();
            }
            else {
                const verticalPush = this.verticalPush(connectedFit);
                transformString.push(`translateY(${verticalPush}px)`);
            }
        }
        element.style.transform = transformString.join(' ').trim();
    }
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    canFlipHorizontal(connectedFit) {
        //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
        //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
        //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
        //  this way:
        //  (-1) * (Left + 1) = 0 = Right
        //  (-1) * (Center + 1) = -0.5 = Center
        //  (-1) * (Right + 1) = -1 = Left
        const flippedStartPoint = (-1) * (this.settings.horizontalStartPoint + 1);
        const flippedDirection = (-1) * (this.settings.horizontalDirection + 1);
        const leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        const rightBorder = leftBorder + connectedFit.contentElementRect.width;
        return 0 < leftBorder && rightBorder < connectedFit.viewPortRect.width;
    }
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    canFlipVertical(connectedFit) {
        const flippedStartPoint = (-1) * (this.settings.verticalStartPoint + 1);
        const flippedDirection = (-1) * (this.settings.verticalDirection + 1);
        const topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        const bottomBorder = topBorder + connectedFit.contentElementRect.height;
        return 0 < topBorder && bottomBorder < connectedFit.viewPortRect.height;
    }
    /**
     * Flips direction and start point of the position settings
     */
    flipHorizontal() {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                this.settings.horizontalDirection = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalDirection = HorizontalAlignment.Left;
                break;
        }
        switch (this.settings.horizontalStartPoint) {
            case HorizontalAlignment.Left:
                this.settings.horizontalStartPoint = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalStartPoint = HorizontalAlignment.Left;
                break;
        }
    }
    /**
     * Flips direction and start point of the position settings
     */
    flipVertical() {
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                this.settings.verticalDirection = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalDirection = VerticalAlignment.Top;
                break;
        }
        switch (this.settings.verticalStartPoint) {
            case VerticalAlignment.Top:
                this.settings.verticalStartPoint = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalStartPoint = VerticalAlignment.Top;
                break;
        }
    }
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    horizontalPush(connectedFit) {
        const leftExtend = connectedFit.left;
        const rightExtend = connectedFit.right - connectedFit.viewPortRect.width;
        //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
        //  as much as it is beyond the screen.
        //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
        //  extend but with amount not bigger than what left between left border of screen and left border of
        //  overlay, e.g. leftExtend
        if (leftExtend < 0) {
            return Math.abs(leftExtend);
        }
        else if (rightExtend > 0) {
            return -Math.min(rightExtend, leftExtend);
        }
        else {
            return 0;
        }
    }
    /**
     * Calculates necessary vertical push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    verticalPush(connectedFit) {
        const topExtend = connectedFit.top;
        const bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.height;
        if (topExtend < 0) {
            return Math.abs(topExtend);
        }
        else if (bottomExtend > 0) {
            return -Math.min(bottomExtend, topExtend);
        }
        else {
            return 0;
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1wb3NpdGlvbi1zdHJhdGVneS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zZXJ2aWNlcy9vdmVybGF5L3Bvc2l0aW9uL2F1dG8tcG9zaXRpb24tc3RyYXRlZ3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGlCQUFpQixFQUFFLG1CQUFtQixFQUFnQixNQUFNLGdCQUFnQixDQUFDO0FBQ3RGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBRXZFOzs7R0FHRztBQUNILE1BQU0sT0FBTyxvQkFBcUIsU0FBUSx1QkFBdUI7SUFFN0Qsa0JBQWtCO0lBQ1IsYUFBYSxDQUFDLE9BQW9CLEVBQUUsWUFBMEI7UUFDcEUsTUFBTSxlQUFlLEdBQWEsRUFBRSxDQUFDO1FBQ3JDLElBQUksWUFBWSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLFlBQVksQ0FBQyxhQUFhLENBQUMsT0FBTyxHQUFHLENBQUMsRUFBRTtZQUMvRSxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFDdEMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO2FBQ3pCO2lCQUFNO2dCQUNILE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQ3pELGVBQWUsQ0FBQyxJQUFJLENBQUMsY0FBYyxjQUFjLEtBQUssQ0FBQyxDQUFDO2FBQzNEO1NBQ0o7UUFFRCxJQUFJLFlBQVksQ0FBQyxXQUFXLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSSxZQUFZLENBQUMsV0FBVyxDQUFDLE9BQU8sR0FBRyxDQUFDLEVBQUU7WUFDM0UsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLFlBQVksQ0FBQyxFQUFFO2dCQUNwQyxJQUFJLENBQUMsWUFBWSxFQUFFLENB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QUFFO1lBQ3hCLE9BQU8sQ0FBRSxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxVQUFVLENBQUMsQ0FBQztTQUM5QzthQUFNO1lBQ0gsT0FBTyxDQUFDLENBQUM7U0FDWjtJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssWUFBWSxDQUFDLFlBQTBCO1FBQzNDLE1BQU0sU0FBUyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUM7UUFDbkMsTUFBTSxZQUFZLEdBQUcsWUFBWSxDQUFDLE1BQU0sR0FBRyxZQUFZLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQztRQUM1RSxJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUU7WUFDZixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDOUI7YUFBTSxJQUFJLFlBQVksR0FBRyxDQUFDLEVBQUU7WUFDekIsT0FBTyxDQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1NBQzlDO2FBQU07WUFDSCxPQUFPLENBQUMsQ0FBQztTQUNaO0lBQ0wsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVydGljYWxBbGlnbm1lbnQsIEhvcml6b250YWxBbGlnbm1lbnQsIENvbm5lY3RlZEZpdCB9IGZyb20gJy4vLi4vdXRpbGl0aWVzJztcbmltcG9ydCB7IEJhc2VGaXRQb3NpdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9iYXNlLWZpdC1wb3NpdGlvbi1zdHJhdGVneSc7XG5cbi8qKlxuICogUG9zaXRpb25zIHRoZSBlbGVtZW50IGFzIGluICoqQ29ubmVjdGVkKiogcG9zaXRpb25pbmcgc3RyYXRlZ3kgYW5kIHJlLXBvc2l0aW9ucyB0aGUgZWxlbWVudCBpblxuICogdGhlIHZpZXcgcG9ydCAoY2FsY3VsYXRpbmcgYSBkaWZmZXJlbnQgc3RhcnQgcG9pbnQpIGluIGNhc2UgdGhlIGVsZW1lbnQgaXMgcGFydGlhbGx5IGdldHRpbmcgb3V0IG9mIHZpZXdcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Qb3NpdGlvblN0cmF0ZWd5IGV4dGVuZHMgQmFzZUZpdFBvc2l0aW9uU3RyYXRlZ3kge1xuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgcHJvdGVjdGVkIGZpdEluVmlld3BvcnQoZWxlbWVudDogSFRNTEVsZW1lbnQsIGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybVN0cmluZzogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgaWYgKGNvbm5lY3RlZEZpdC5maXRIb3Jpem9udGFsLmJhY2sgPCAwIHx8IGNvbm5lY3RlZEZpdC5maXRIb3Jpem9udGFsLmZvcndhcmQgPCAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5GbGlwSG9yaXpvbnRhbChjb25uZWN0ZWRGaXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGlwSG9yaXpvbnRhbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBob3Jpem9udGFsUHVzaCA9IHRoaXMuaG9yaXpvbnRhbFB1c2goY29ubmVjdGVkRml0KTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TdHJpbmcucHVzaChgdHJhbnNsYXRlWCgke2hvcml6b250YWxQdXNofXB4KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbm5lY3RlZEZpdC5maXRWZXJ0aWNhbC5iYWNrIDwgMCB8fCBjb25uZWN0ZWRGaXQuZml0VmVydGljYWwuZm9yd2FyZCA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkZsaXBWZXJ0aWNhbChjb25uZWN0ZWRGaXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGlwVmVydGljYWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVydGljYWxQdXNoID0gdGhpcy52ZXJ0aWNhbFB1c2goY29ubmVjdGVkRml0KTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TdHJpbmcucHVzaChgdHJhbnNsYXRlWSgke3ZlcnRpY2FsUHVzaH1weClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtU3RyaW5nLmpvaW4oJyAnKS50cmltKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGVsZW1lbnQgY2FuIGJlIGZsaXBwZWQgd2l0aG91dCBnZXQgb2ZmIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBjb25uZWN0ZWRGaXQgY29ubmVjdGVkRml0IG9iamVjdCBjb250YWluaW5nIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZWxlbWVudCBjYW4gYmUgZmxpcHBlZCBhbmQgc3RhaW4gaW4gdmlld3BvcnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbkZsaXBIb3Jpem9udGFsKGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KTogYm9vbGVhbiB7XG4gICAgICAgIC8vICBIb3Jpem9udGFsQWxpZ25tZW50IGNhbiBiZSBMZWZ0ID0gLTE7IENlbnRlciA9IC0wLjUgb3IgUmlnaHQgPSAwLlxuICAgICAgICAvLyAgVG8gdmlydHVhbGx5IGZsaXAgZGlyZWN0aW9uIGFuZCBzdGFydCBwb2ludCAoYm90aCBhcmUgSG9yaXpvbnRhbEFsaWdubWVudCkgd2UgY2FuIGRvIHRoaXM6XG4gICAgICAgIC8vICBmbGlwcGVkQWxpZ25tZW50ID0gKC0xKSAqIChIb3Jpem9udGFsQWxpZ25tZW50ICsgMSlcbiAgICAgICAgLy8gIHRoaXMgd2F5OlxuICAgICAgICAvLyAgKC0xKSAqIChMZWZ0ICsgMSkgPSAwID0gUmlnaHRcbiAgICAgICAgLy8gICgtMSkgKiAoQ2VudGVyICsgMSkgPSAtMC41ID0gQ2VudGVyXG4gICAgICAgIC8vICAoLTEpICogKFJpZ2h0ICsgMSkgPSAtMSA9IExlZnRcbiAgICAgICAgY29uc3QgZmxpcHBlZFN0YXJ0UG9pbnQgPSAoLTEpICogKHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbFN0YXJ0UG9pbnQgKyAxKTtcbiAgICAgICAgY29uc3QgZmxpcHBlZERpcmVjdGlvbiA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsRGlyZWN0aW9uICsgMSk7XG5cbiAgICAgICAgY29uc3QgbGVmdEJvcmRlciA9IHRoaXMuY2FsY3VsYXRlTGVmdChcbiAgICAgICAgICAgIGNvbm5lY3RlZEZpdC50YXJnZXRSZWN0LCBjb25uZWN0ZWRGaXQuY29udGVudEVsZW1lbnRSZWN0LCBmbGlwcGVkU3RhcnRQb2ludCwgZmxpcHBlZERpcmVjdGlvbiwgMCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0Qm9yZGVyID0gbGVmdEJvcmRlciArIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3Qud2lkdGg7XG4gICAgICAgIHJldHVybiAwIDwgbGVmdEJvcmRlciAmJiByaWdodEJvcmRlciA8IGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3Qud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGVsZW1lbnQgY2FuIGJlIGZsaXBwZWQgd2l0aG91dCBnZXQgb2ZmIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBjb25uZWN0ZWRGaXQgY29ubmVjdGVkRml0IG9iamVjdCBjb250YWluaW5nIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZWxlbWVudCBjYW4gYmUgZmxpcHBlZCBhbmQgc3RhaW4gaW4gdmlld3BvcnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbkZsaXBWZXJ0aWNhbChjb25uZWN0ZWRGaXQ6IENvbm5lY3RlZEZpdCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBmbGlwcGVkU3RhcnRQb2ludCA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQgKyAxKTtcbiAgICAgICAgY29uc3QgZmxpcHBlZERpcmVjdGlvbiA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbiArIDEpO1xuXG4gICAgICAgIGNvbnN0IHRvcEJvcmRlciA9IHRoaXMuY2FsY3VsYXRlVG9wKFxuICAgICAgICAgICAgY29ubmVjdGVkRml0LnRhcmdldFJlY3QsIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3QsIGZsaXBwZWRTdGFydFBvaW50LCBmbGlwcGVkRGlyZWN0aW9uLCAwKTtcbiAgICAgICAgY29uc3QgYm90dG9tQm9yZGVyID0gdG9wQm9yZGVyICsgY29ubmVjdGVkRml0LmNvbnRlbnRFbGVtZW50UmVjdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiAwIDwgdG9wQm9yZGVyICYmIGJvdHRvbUJvcmRlciA8IGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3QuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsaXBzIGRpcmVjdGlvbiBhbmQgc3RhcnQgcG9pbnQgb2YgdGhlIHBvc2l0aW9uIHNldHRpbmdzXG4gICAgICovXG4gICAgcHJpdmF0ZSBmbGlwSG9yaXpvbnRhbCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLmhvcml6b250YWxEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgSG9yaXpvbnRhbEFsaWdubWVudC5MZWZ0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbERpcmVjdGlvbiA9IEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsRGlyZWN0aW9uID0gSG9yaXpvbnRhbEFsaWdubWVudC5MZWZ0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsU3RhcnRQb2ludCkge1xuICAgICAgICAgICAgY2FzZSBIb3Jpem9udGFsQWxpZ25tZW50LkxlZnQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsU3RhcnRQb2ludCA9IEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsU3RhcnRQb2ludCA9IEhvcml6b250YWxBbGlnbm1lbnQuTGVmdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsaXBzIGRpcmVjdGlvbiBhbmQgc3RhcnQgcG9pbnQgb2YgdGhlIHBvc2l0aW9uIHNldHRpbmdzXG4gICAgICovXG4gICAgcHJpdmF0ZSBmbGlwVmVydGljYWwoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBWZXJ0aWNhbEFsaWdubWVudC5Ub3A6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbiA9IFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuQm90dG9tOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MudmVydGljYWxEaXJlY3Rpb24gPSBWZXJ0aWNhbEFsaWdubWVudC5Ub3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLnZlcnRpY2FsU3RhcnRQb2ludCkge1xuICAgICAgICAgICAgY2FzZSBWZXJ0aWNhbEFsaWdubWVudC5Ub3A6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQgPSBWZXJ0aWNhbEFsaWdubWVudC5Cb3R0b207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbTpcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnZlcnRpY2FsU3RhcnRQb2ludCA9IFZlcnRpY2FsQWxpZ25tZW50LlRvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgbmVjZXNzYXJ5IGhvcml6b250YWwgcHVzaCBhY2NvcmRpbmcgdG8gcHJvdmlkZWQgY29ubmVjdGVkRml0XG4gICAgICogQHBhcmFtIGNvbm5lY3RlZEZpdCBjb25uZWN0ZWRGaXQgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgYW1vdW50IG9mIG5lY2Vzc2FyeSB0cmFuc2xhdGlvbiB3aGljaCB3aWxsIHB1c2ggdGhlIGVsZW1lbnQgaW50byB2aWV3cG9ydFxuICAgICAqL1xuICAgIHByaXZhdGUgaG9yaXpvbnRhbFB1c2goY29ubmVjdGVkRml0OiBDb25uZWN0ZWRGaXQpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBsZWZ0RXh0ZW5kID0gY29ubmVjdGVkRml0LmxlZnQ7XG4gICAgICAgIGNvbnN0IHJpZ2h0RXh0ZW5kID0gY29ubmVjdGVkRml0LnJpZ2h0IC0gY29ubmVjdGVkRml0LnZpZXdQb3J0UmVjdC53aWR0aDtcbiAgICAgICAgLy8gIGlmIGxlZnRFeHRlbmQgPCAwIG92ZXJsYXkgZ29lcyBiZXlvbmQgbGVmdCBlbmQgb2YgdGhlIHNjcmVlbi4gV2Ugc2hvdWxkIHB1c2ggaXQgYmFjayB3aXRoIGV4YWN0bHlcbiAgICAgICAgLy8gIGFzIG11Y2ggYXMgaXQgaXMgYmV5b25kIHRoZSBzY3JlZW4uXG4gICAgICAgIC8vICBpZiByaWdodEV4dGVuZCA+IDAgb3ZlcmxheSBnb2VzIGJleW9uZCByaWdodCBlbmQgb2YgdGhlIHNjcmVlbi4gV2Ugc2hvdWxkIHB1c2ggaXQgYmFjayB3aXRoIHRoZVxuICAgICAgICAvLyAgZXh0ZW5kIGJ1dCB3aXRoIGFtb3VudCBub3QgYmlnZ2VyIHRoYW4gd2hhdCBsZWZ0IGJldHdlZW4gbGVmdCBib3JkZXIgb2Ygc2NyZWVuIGFuZCBsZWZ0IGJvcmRlciBvZlxuICAgICAgICAvLyAgb3ZlcmxheSwgZS5nLiBsZWZ0RXh0ZW5kXG4gICAgICAgIGlmIChsZWZ0RXh0ZW5kIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGxlZnRFeHRlbmQpO1xuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0RXh0ZW5kID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0gTWF0aC5taW4ocmlnaHRFeHRlbmQsIGxlZnRFeHRlbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIG5lY2Vzc2FyeSB2ZXJ0aWNhbCBwdXNoIGFjY29yZGluZyB0byBwcm92aWRlZCBjb25uZWN0ZWRGaXRcbiAgICAgKiBAcGFyYW0gY29ubmVjdGVkRml0IGNvbm5lY3RlZEZpdCBvYmplY3QgY29udGFpbmluZyBhbGwgbmVjZXNzYXJ5IHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyBhbW91bnQgb2YgbmVjZXNzYXJ5IHRyYW5zbGF0aW9uIHdoaWNoIHdpbGwgcHVzaCB0aGUgZWxlbWVudCBpbnRvIHZpZXdwb3J0XG4gICAgICovXG4gICAgcHJpdmF0ZSB2ZXJ0aWNhbFB1c2goY29ubmVjdGVkRml0OiBDb25uZWN0ZWRGaXQpOiBudW1iZXIge1xuICAgICAgICBjb25zdCB0b3BFeHRlbmQgPSBjb25uZWN0ZWRGaXQudG9wO1xuICAgICAgICBjb25zdCBib3R0b21FeHRlbmQgPSBjb25uZWN0ZWRGaXQuYm90dG9tIC0gY29ubmVjdGVkRml0LnZpZXdQb3J0UmVjdC5oZWlnaHQ7XG4gICAgICAgIGlmICh0b3BFeHRlbmQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModG9wRXh0ZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChib3R0b21FeHRlbmQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLSBNYXRoLm1pbihib3R0b21FeHRlbmQsIHRvcEV4dGVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==