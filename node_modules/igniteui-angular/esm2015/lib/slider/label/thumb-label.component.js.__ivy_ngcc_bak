import { Component, Input, HostBinding, ElementRef } from '@angular/core';
import { SliderHandle } from '../slider.common';
export class IgxThumbLabelComponent {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
    get thumbFromClass() {
        return this.type === SliderHandle.FROM;
    }
    get thumbToClass() {
        return this.type === SliderHandle.TO;
    }
    get thumbFromActiveClass() {
        return this.type === SliderHandle.FROM && this.active;
    }
    get thumbToActiveClass() {
        return this.type === SliderHandle.TO && this.active;
    }
    get nativeElement() {
        return this._elementRef.nativeElement;
    }
    get active() {
        return this._active;
    }
    set active(val) {
        if (this.continuous || this.deactiveState) {
            this._active = false;
        }
        else {
            this._active = val;
        }
    }
}
IgxThumbLabelComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-thumb-label',
                template: "<div class=\"label\">\n    <ng-container *ngTemplateOutlet=\"templateRef ? templateRef : thumbFromDefaultTemplate; context: context\"></ng-container>\n</div>\n\n<ng-template #thumbFromDefaultTemplate>\n    {{ value }}\n</ng-template>\n"
            },] }
];
IgxThumbLabelComponent.ctorParameters = () => [
    { type: ElementRef }
];
IgxThumbLabelComponent.propDecorators = {
    value: [{ type: Input }],
    templateRef: [{ type: Input }],
    context: [{ type: Input }],
    type: [{ type: Input }],
    continuous: [{ type: Input }],
    deactiveState: [{ type: Input }],
    thumbFromClass: [{ type: HostBinding, args: ['class.igx-slider__label-from',] }],
    thumbToClass: [{ type: HostBinding, args: ['class.igx-slider__label-to',] }],
    thumbFromActiveClass: [{ type: HostBinding, args: ['class.igx-slider__label-from--active',] }],
    thumbToActiveClass: [{ type: HostBinding, args: ['class.igx-slider__label-to--active',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGh1bWItbGFiZWwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3NsaWRlci9sYWJlbC90aHVtYi1sYWJlbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQWUsV0FBVyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN2RixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFNaEQsTUFBTSxPQUFPLHNCQUFzQjtJQXlDL0IsWUFBb0IsV0FBdUI7UUFBdkIsZ0JBQVcsR0FBWCxXQUFXLENBQVk7SUFBSSxDQUFDO0lBcEJoRCxJQUNXLGNBQWM7UUFDckIsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksQ0FBQyxJQUFJLENBQUM7SUFDM0MsQ0FBQztJQUVELElBQ1csWUFBWTtRQUNuQixPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssWUFBWSxDQUFDLEVBQUUsQ0FBQztJQUN6QyxDQUFDO0lBRUQsSUFDVyxvQkFBb0I7UUFDM0IsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUMxRCxDQUFDO0lBRUQsSUFDVyxrQkFBa0I7UUFDekIsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksQ0FBQyxFQUFFLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUN4RCxDQUFDO0lBSUQsSUFBVyxhQUFhO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUM7SUFDMUMsQ0FBQztJQUVELElBQVcsTUFBTTtRQUNiLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN4QixDQUFDO0lBRUQsSUFBVyxNQUFNLENBQUMsR0FBWTtRQUMxQixJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUN2QyxJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztTQUN4QjthQUFNO1lBQ0gsSUFBSSxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7U0FDdEI7SUFDTCxDQUFDOzs7WUE3REosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxpQkFBaUI7Z0JBQzNCLHVQQUF5QzthQUM1Qzs7O1lBTm9ELFVBQVU7OztvQkFVMUQsS0FBSzswQkFHTCxLQUFLO3NCQUdMLEtBQUs7bUJBR0wsS0FBSzt5QkFHTCxLQUFLOzRCQUdMLEtBQUs7NkJBR0wsV0FBVyxTQUFDLDhCQUE4QjsyQkFLMUMsV0FBVyxTQUFDLDRCQUE0QjttQ0FLeEMsV0FBVyxTQUFDLHNDQUFzQztpQ0FLbEQsV0FBVyxTQUFDLG9DQUFvQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIFRlbXBsYXRlUmVmLCBIb3N0QmluZGluZywgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2xpZGVySGFuZGxlIH0gZnJvbSAnLi4vc2xpZGVyLmNvbW1vbic7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LXRodW1iLWxhYmVsJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RodW1iLWxhYmVsLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hUaHVtYkxhYmVsQ29tcG9uZW50IHtcbiAgICBwcml2YXRlIF9hY3RpdmU6IGJvb2xlYW47XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB2YWx1ZTogbnVtYmVyO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBjb250ZXh0OiBhbnk7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0eXBlOiBTbGlkZXJIYW5kbGU7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBjb250aW51b3VzOiBib29sZWFuO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZGVhY3RpdmVTdGF0ZTogYm9vbGVhbjtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXNsaWRlcl9fbGFiZWwtZnJvbScpXG4gICAgcHVibGljIGdldCB0aHVtYkZyb21DbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gU2xpZGVySGFuZGxlLkZST007XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtc2xpZGVyX19sYWJlbC10bycpXG4gICAgcHVibGljIGdldCB0aHVtYlRvQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFNsaWRlckhhbmRsZS5UTztcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1zbGlkZXJfX2xhYmVsLWZyb20tLWFjdGl2ZScpXG4gICAgcHVibGljIGdldCB0aHVtYkZyb21BY3RpdmVDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gU2xpZGVySGFuZGxlLkZST00gJiYgdGhpcy5hY3RpdmU7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtc2xpZGVyX19sYWJlbC10by0tYWN0aXZlJylcbiAgICBwdWJsaWMgZ2V0IHRodW1iVG9BY3RpdmVDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gU2xpZGVySGFuZGxlLlRPICYmIHRoaXMuYWN0aXZlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgcHVibGljIGdldCBuYXRpdmVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgYWN0aXZlKHZhbDogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5jb250aW51b3VzIHx8IHRoaXMuZGVhY3RpdmVTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=